

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/baike.png">
  <link rel="icon" href="/img/baike.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="MrZ">
  <meta name="keywords" content="">
  
    <meta name="description" content="this绑定this绑定的三种方式 默认绑定:独立调用,this指向window  12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript高级">
<meta property="og:url" content="http://example.com/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="MrZ的个人博客">
<meta property="og:description" content="this绑定this绑定的三种方式 默认绑定:独立调用,this指向window  12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/1740029840980-ac7611b5-e2ba-41e7-be31-28ae8c61ca8e.png">
<meta property="og:image" content="http://example.com/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/1739109824352-f8b3988e-849b-4b9c-a57f-4e235b002cfb.png">
<meta property="og:image" content="http://example.com/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/1739111638539-e85b5bdb-11ca-4ee9-ab9f-fcbcd1d9680d.png">
<meta property="article:published_time" content="2025-02-25T15:32:39.000Z">
<meta property="article:modified_time" content="2025-02-28T15:34:19.660Z">
<meta property="article:author" content="MrZ">
<meta property="article:tag" content="JavaScript高级">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/1740029840980-ac7611b5-e2ba-41e7-be31-28ae8c61ca8e.png">
  
  
  
  <title>JavaScript高级 - MrZ的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MirZ Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JavaScript高级"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-25 23:32" pubdate>
          2025年2月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          33k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          274 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JavaScript高级</h1>
            
            
              <div class="markdown-body">
                
                <hr>
<h4 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h4><h5 id="this绑定的三种方式"><a href="#this绑定的三种方式" class="headerlink" title="this绑定的三种方式"></a>this绑定的三种方式</h5><ol>
<li>默认绑定:独立调用,this指向window</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// &quot;use strict&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//普通函数的独立调用,window</span></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo的this&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">foo</span>()</span><br><span class="language-javascript">        <span class="hljs-comment">//定义在对象中,独立调用,window</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> obj=&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">bar</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar的this&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> baz=obj.<span class="hljs-property">bar</span></span><br><span class="language-javascript">        <span class="hljs-title function_">baz</span>()</span><br><span class="language-javascript">        <span class="hljs-comment">//函数互相调用,window</span></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params">fn</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">fn</span>()</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">foo1</span>(baz)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//在严格模式下,独立调用函数的this,为undefined</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>隐式绑定,通过某个对象进行调用的,this指向调用对象</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//隐式绑定</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> obj=&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;obj&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bar</span>:foo</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj.<span class="hljs-title function_">bar</span>()</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>new绑定,this指向创建的空对象(函数当做一个类的构造函数来使用，也就是使用new关键字)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;script&gt;<br>    /* <br>    1.创建空对象<br>    2.将this指向空对象,将函数的显式原型赋值给对象的隐式原型<br>    3.执行函数体的代码<br>    4.无显示返回非空对象时,会默认显示这个对象<br>     */<br><br>     function foo()&#123;<br>        console.log(&#x27;foo&#x27;,this);<br>        this.name=&#x27;MirZ&#x27;<br>     &#125;<br>     new foo()<br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<ol>
<li>显式绑定,this指向要绑定的对象</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> obj=&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;MirZ&#x27;</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-comment">//将foo函数的this指向obj,使用call/apply</span></span><br><span class="language-javascript">   foo.<span class="hljs-title function_">call</span>(obj)</span><br><span class="language-javascript">   foo.<span class="hljs-title function_">apply</span>(obj)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>





<h5 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h5><p><strong>call&#x2F;apply</strong></p>
<p>如果我们不希望在对象内部包含这个函数的引用同时又希望在这个对象上进行强制调用可以使用call和apply方法</p>
<ul>
<li>第一个参数传入指定绑定的对象;</li>
<li>后面的参数，apply为数组，call为参数列表;</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo调用&#x27;</span>, <span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;参数&#x27;</span>, name, age);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> obj=&#123;&#125;</span><br><span class="language-javascript">        <span class="hljs-comment">//使用call/apply,将foo函数指向obj</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.apply(obj)</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.call(obj)</span></span><br><span class="language-javascript">        <span class="hljs-comment">//传入原始类型,会指向原始类型封装的对应包装类型对象</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.call(123)</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.apply(&#x27;Mir&#x27;)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//传参</span></span><br><span class="language-javascript">        foo.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;MirZ&#x27;</span>, <span class="hljs-number">18</span>)</span><br><span class="language-javascript">        foo.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&#x27;1&#x27;</span>,[<span class="hljs-string">&#x27;MirZ&#x27;</span>,<span class="hljs-number">18</span>])</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>bind</strong></p>
<p>如果我们希望一个函数总是显示的绑定到一个对象上，可以使用bind绑定函数</p>
<ul>
<li>使用bind方法，bind()方法创建一个新的绑定函数(bound function，BF)</li>
<li>绑定函数是一个 exotic function object(怪异函数对象，ECMAScript 2015 中的术语)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;script&gt;<br>        function foo(name, age) &#123;<br>            console.log(&#x27;foo调用&#x27;, this);<br>            console.log(&quot;参数&quot;,name,age);<br>            <br>        &#125;<br>        var obj=&#123;&#125;<br>        //需求:调用foo时，总是绑定到obj对象身上<br>        // var bar=foo.bind(obj) //yhis-&gt;obj<br>        // bar()<br>        // bar()<br>        // bar()<br>        //传参<br>        var bar=foo.bind(obj,&#x27;Mir&#x27;)<br>        bar()<br>        bar(18)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>



<h5 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h5><ul>
<li>默认规则的优先级最低,存在其他规则时，就会通过其他规则的方式绑定this</li>
<li>显示绑定优先级高于隐式绑定</li>
<li>new绑定优先级高于隐式绑定</li>
<li>new绑定优先级高于bind<ul>
<li>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</li>
<li>new绑定可以和bind一起使用，new绑定优先级更高</li>
<li>bind和apply&#x2F;call同时使用,bind优先级更高</li>
</ul>
</li>
</ul>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁:</p>
<ul>
<li>箭头函数不会绑定this、arguments属性,</li>
<li>箭头函数不能作为构造函数来使用(不能和new一起来使用，会抛出错误):</li>
</ul>
<p>箭头函数的简写</p>
<ul>
<li>优化一: 如果只有一个参数()可以省略</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>优化二: 如果函数执行体中只有一行代码,那么可以省略大括号并且这行代码的返回值会作为整个函数的返回值</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item))<br>nums.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>优化三: 如果函数执行体只有返回一个对象，那么需要给这个对象加上()</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> foo=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-keyword">return</span>&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;abc&quot;</span>&#125;<br><span class="hljs-keyword">var</span>. bar=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;abc&quot;</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>*<em>箭头函数不使用this的四种标准规则(也就是不绑定this)，而是根据*<em><strong>外层作用域</strong></em></em>来决定this.**</p>
<p><strong>this指向面试题:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><br><span class="hljs-comment">// &#123;&#125; -&gt; 对象</span><br><span class="hljs-comment">// &#123;&#125; -&gt; 代码块</span><br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,<br>  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// console.log(this) // 第一个表达式this -&gt; person1</span><br>    <span class="hljs-comment">// console.log(this) // 第二个表达式this -&gt; person2</span><br>    <span class="hljs-comment">// console.log(this) // 第三个表达式this -&gt; person1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;<br><br><br><span class="hljs-comment">// 开始题目:</span><br>person1.<span class="hljs-title function_">foo1</span>(); <span class="hljs-comment">// 隐式绑定: person1</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo2</span>(); <span class="hljs-comment">// 上层作用域: window</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// 上层作用域: window</span><br><br>person1.<span class="hljs-title function_">foo3</span>()(); <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo4</span>()(); <span class="hljs-comment">// person1</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// person2</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person1</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  1.创建一个空的对象</span><br><span class="hljs-comment">  2.将这个空的对象赋值给this</span><br><span class="hljs-comment">  3.执行函数体中代码</span><br><span class="hljs-comment">  4.将这个新的对象默认返回</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// person1/person都是对象(实例instance)</span><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br><br><span class="hljs-comment">// 面试题目:</span><br>person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// 隐式绑定: person1</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">// 上层作用域查找: person1</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 上层作用域查找: person1</span><br><br>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">// 上层作用域查找: person1(隐式绑定)</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">//  上层作用域查找: person2(显式绑定)</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 上层作用域查找: person1(隐式绑定)</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  1.创建一个空的对象</span><br><span class="hljs-comment">  2.将这个空的对象赋值给this</span><br><span class="hljs-comment">  3.执行函数体中代码</span><br><span class="hljs-comment">  4.将这个新的对象默认返回</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <span class="hljs-comment">// 上层作用域查找: obj(隐式绑定)</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// 上层作用域查找: person2(显式绑定)</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 上层作用域查找: obj(隐式绑定)</span><br></code></pre></td></tr></table></figure>



<h4 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h4><h5 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h5><p><strong>浏览器渲染页面过程:</strong> </p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/wudibawanglong-gbppc/frgahd/cet8sqz7nv0gkvda">浏览器渲染原理</a></p>
<p>在解析JS是堵塞也往往会带来新的问题，特别是现代页面开发中:</p>
<p>目前的开发模式中(比如Vue、React)，脚本往往比HTML页面更“重”处理时间需要更长所以会造成页面的解析阻塞，在脚本下载、执行完成之前，用户在界面上什么都看不到;</p>
<p>为了解决这个问题，script元素给我们提供了两个属性(attribute):defer和async。</p>
<p><strong>defer</strong></p>
<p>defer 属性告诉浏览器不要等待脚本下载，而继续解析HTML，构建DOM Tree</p>
<ul>
<li>脚本会由浏览器来进行下载，但是不会阻塞DOM Tree的构建过程;</li>
<li>如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码</li>
</ul>
<p>多个带defer的脚本是可以保持正确的顺序执行的。</p>
<p>从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中;</p>
<p>注意:defer仅适用于外部脚本，对于script默认内容会被忽略</p>
<p><strong>async</strong></p>
<p>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。</p>
<p>async是让一个脚本完全独立的:</p>
<ul>
<li>浏览器不会因 async 脚本而阻塞(与 defer 类似);</li>
<li>async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本</li>
<li>async不会能保证在DOMContentLoaded之前或者之后执行</li>
</ul>
<p>:::info defer通常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求的;</p>
<p>async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的;</p>
<p>:::</p>
<h4 id="Js原理"><a href="#Js原理" class="headerlink" title="Js原理"></a>Js原理</h4><h5 id="JS执行原理"><a href="#JS执行原理" class="headerlink" title="JS执行原理"></a>JS执行原理</h5><p><strong>初始化全局对象</strong></p>
<p>js引擎会在执行代码之前，会在堆内存中创建一个**全局对象:**GlobalObject(GO)</p>
<p>该对象所有的作用域(scope)都可以访问;里面会包含Date、Array、String、Number、setTimeout、setlnterval等等.其中还有一个window属性指向自己</p>
<p><strong>全局代码如何被执行?</strong></p>
<p>js引擎内部有一个<strong>执行上下文栈</strong>(Execution Context Stack，简称ECS)它是用于<strong>执行代码的调用栈</strong></p>
<p>那么现在它要执行谁呢?执行的是全局的代码块</p>
<ul>
<li>全局的代码块为了执行会构建一个 Global Execution Context(GEC)</li>
<li>GEC会 被放入到ECS中执行;</li>
</ul>
<p>每一个执行上下文会关联一个<strong>VO(Variable Object，变量对象)*</strong>*,**<strong>变量和函数声明</strong>会被添加到这个VO对象中</p>
<p><strong>当全局代码被执行的时候，VO就是GO对象了</strong></p>
<p>GEC被放入到ECS中里面包含两部分内容:</p>
<ul>
<li>第一部分:在代码执行前，在parser转成AST的过程中，会将全局定义的变量、函数等加入等加入到GlobalObject中，但是并不会赋值;<ul>
<li>这个过程也称之为变量的作用域提升(hoisting)</li>
</ul>
</li>
<li>第二部分:在代码执行中，对变量赋值，或者执行其他的函数;</li>
</ul>
<p><strong>函数如何被执行?</strong></p>
<p>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文(FunctionalExecutionContext，简称FEC)并且压入到<strong>EC Stack</strong>中。</p>
<p>因为每个执行上下文都会关联一个VO，那么函数执行上下文关联的VO是什么呢?</p>
<ul>
<li>当进入一个函数执行上下文时，会创建一个AO对象(Activation Object)</li>
<li>这个AO对象会使用arguments作为初始化，并且初始值是传入的参数;</li>
<li>这个AO对象会作为执行上下文的VO来存放变量的初始化;</li>
</ul>
<p><strong>作用域链</strong></p>
<p>当进入到一个执行上下文时，执行上下文也会关联一个作用域链(Scope Chain)</p>
<p>作用域链是一个对象列表，用于变量标识符的求值;当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    // 1.面试题一:<br>    // var n = 100<br>    // function foo() &#123;<br>    //   n = 200<br>    // &#125;<br>    // foo()<br><br>    // console.log(n)<br><br>    // 2.面试题二:<br>    // var n = 100<br>    // function foo() &#123;<br>    //   console.log(n)<br>    //   var n = 200<br>    //   console.log(n)<br>    // &#125;<br><br>    // foo()<br><br>    // 3.面试题三:<br>    // var n = 100<br><br>    // function foo1() &#123;<br>    //   console.log(n)<br>    // &#125;<br>    // function foo2() &#123;<br>    //   var n = 200<br>    //   console.log(n)<br>    //   foo1()<br>    // &#125;<br>    // foo2()<br><br>    // 4.面试题四:<br>    // var n = 100<br>    // function foo() &#123;<br>    //   console.log(n) <br>    //   return<br>    //   var n = 200   //var a是在编译解析阶段,已经声明,return是在执行阶段结束<br>    // &#125;<br>    // foo()<br><br>    // 5.在开发中可能会出现这样错误的写法<br>    // function foo() &#123;<br>    //   message = &quot;Hello World&quot; //没有声明,会被放到全局<br>    // &#125;<br>    // foo()<br>    // console.log(message)<br><br>    // 6.面试题五:<br>    function foo() &#123;<br>      var a = b = 100<br>    &#125;<br>    foo()<br>    console.log(b)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p><strong>词法环境是一种规范类型，用于在词法嵌套结构中定义关联的变量、函数等标识符;</strong></p>
<p>一个词法环境是由环境记录(Environment Record)和一个外部词法环境(oute;rLexicalEnvironment)组成:</p>
<p>一个词法环境经常用于关联一个函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出来;</p>
<p><strong>全局词法环境</strong></p>
<p>全局词法环境是最外层的词法环境，它在 JavaScript 程序开始执行时就被创建，并且在整个程序的生命周期内都存在。全局词法环境的外部引用为 <code>null</code>。</p>
<p><strong>函数词法环境</strong></p>
<p>每当调用一个函数时，就会为该函数创建一个新的词法环境。函数词法环境的外部引用指向创建该函数时所在的词法环境。</p>
<p><img src="1740029840980-ac7611b5-e2ba-41e7-be31-28ae8c61ca8e.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">- <span class="hljs-title class_">LexicalEnvironment</span>用于处理<span class="hljs-keyword">let</span>、<span class="hljs-keyword">const</span>声明的标识符<br>- <span class="hljs-title class_">VariableEnyionment</span>用于处理<span class="hljs-keyword">var</span>和<span class="hljs-keyword">function</span>声明的标识符:<br></code></pre></td></tr></table></figure>

<p><strong>环境记录</strong></p>
<p>在这个规范中有两种主要的环境记录值:声明式环境记录和对象环境记录。</p>
<ul>
<li>声明式环境记录:声明性环境记录用于定义ECMAScript语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定</li>
<li>对象式环境记录:对象环境记录用于定义ECMAScript元素的效果，例如WithStatement，它将标识符绑定与某些对象的属</li>
</ul>
<p>关联起来。</p>
<h5 id="JS内存管理"><a href="#JS内存管理" class="headerlink" title="JS内存管理"></a>JS内存管理</h5><p>不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要我们自己手动的管理内存,某些编程语言会可以自动帮助我们管理内存:</p>
<p>不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期:</p>
<ul>
<li>第一步:分配申请你需要的内存(申请);</li>
<li>第二步:使用分配的内存(存放一些东西，比如对象等);</li>
<li>第三步:不需要使用时，对其进行释放;</li>
</ul>
<p>不同的编程语言对于第一步和第三步会有不同的实现:</p>
<ul>
<li>手动管理内存:比如C、C++，包括早期的OC都是需要手动来管理内存的申请和释放的(malloc和free函数)</li>
<li>自动管理内存:比如Java、JavaScript、Python、Swift、Dart等，它们有自动帮助我们管理内存;</li>
</ul>
<p>对于开发者来说，JavaScript的内存管理是自动的、无形的。我们创建的原始值、对象、函数.…这一切都会占用内存,但是我们并不需要手动来对它们进行管理JavaScript引l擎会帮助我们处理好它;</p>
<p>JavaScript会在定义数据时为我们分配内存。</p>
<ul>
<li>JS对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配;</li>
<li>JS对于复杂数据类型内存分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用;</li>
</ul>
<h6 id="JS的垃圾回收机制"><a href="#JS的垃圾回收机制" class="headerlink" title="JS的垃圾回收机制"></a>JS的垃圾回收机制</h6><p>** **因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间。</p>
<p>在手动管理内存的语言中，我们需要通过一些方式自己来释放不再需要的内存，比如free函数:</p>
<ul>
<li>这种管理的方式其实非常的低效，影响我们编写逻辑的代码的效率，</li>
<li>这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露，</li>
</ul>
<p>所以大部分现代的编程语言都是有自己的垃圾回收机制:</p>
<p>垃圾回收的英文是Garbage Collection，简称GC;对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间;而我们的语言运行环境，比如java的运行环境IM，JavaScript的运行环境js引擎都会内存 垃圾回收器</p>
<p><strong>GC算法-标记-清除算法</strong></p>
<p>标记-清除是最基础的垃圾回收算法。它的工作原理如下</p>
<p>标记清除的核心思路是可达性,这个算法是设置根对象(root object)垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象</p>
<ul>
<li>标记阶段：垃圾回收器会遍历所有的对象，从根对象（如全局对象）开始，将所有可达对象标记为活动的。</li>
<li>清除阶段：对于那些没有被标记为活动的对象，垃圾回收器会将其内存释放。</li>
</ul>
<p>优点</p>
<ul>
<li>可靠性：确保所有不再需要的对象都会被正确回收。</li>
<li>简单性：实现相对简单，易于维护。</li>
</ul>
<p>缺点</p>
<ul>
<li>暂停程序执行：在垃圾回收期间需要暂停程序执行（Stop-the-world），可能会影响性能。</li>
<li>遍历整个对象图：需要遍历整个对象图，处理大对象图时效率较低。</li>
</ul>
<p><strong>GC算法-引用计数</strong></p>
<p>引用计数是一种较早的垃圾回收算法。它的工作原理如下：</p>
<p>计数：每个对象维护一个引用计数器，用于记录有多少其他对象引用它。</p>
<ul>
<li>增加引用：当有一个新的引用指向该对象时，计数器加1。</li>
<li>减少引用：当一个引用不再指向该对象时，计数器减1。</li>
</ul>
<p>释放内存：当计数器变为0时，该对象可以被回收，因为没有任何引用指向它。</p>
<p>优点</p>
<ul>
<li>即时回收：一旦对象的引用计数变为0，可以立即回收，不需要等待垃圾回收的周期。</li>
<li>简单：实现相对简单，不需要复杂的标记和清除过程。</li>
</ul>
<p>缺点</p>
<ul>
<li>循环引用问题：如果两个对象互相引用，即使它们没有其他引用指向它们，引用计数器永远不会变为0，从而导致内存泄漏。</li>
<li>性能开销：每次引用增加或减少都需要更新计数器，会带来一定的性能开销。</li>
</ul>
<p><strong>GC算法-分代收集</strong></p>
<p>分代收集基于对象的生命周期假设：大多数对象是短命的，少数对象是长命的。它将堆内存划分为两代：新生代和老年代。</p>
<ul>
<li>新生代：存放生命周期短的对象。垃圾回收器会频繁地检查并清理新生代，因为新对象的创建和销毁非常频繁。</li>
<li>老年代：存放生命周期长的对象。垃圾回收器对老年代的检查和清理频率较低，因为这些对象大多长期存在。</li>
</ul>
<p>优点</p>
<ul>
<li>效率高：新生代对象的清理操作较为快速，整体垃圾回收效率高。</li>
<li>减少暂停时间：新生代的清理操作时间较短，减少了程序暂停时间。</li>
</ul>
<p>缺点</p>
<ul>
<li>复杂性：实现和维护较为复杂，需要有效区分和管理新生代和老年代对象。</li>
<li>内存占用：需要更多的内存来维护新生代和老年代的分代结构。</li>
</ul>
<p><strong>V8 的垃圾回收机制</strong></p>
<p>V8 使用了分代垃圾回收，结合了标记-清除、标记-压缩和增量标记（Incremental Marking）等技术。</p>
<p>标记-清除：对新生代对象进行快速标记和清除。</p>
<p>标记-压缩：对老年代对象进行标记和压缩，以减少内存碎片。</p>
<p>增量标记：将垃圾回收过程拆分成多个小步骤，穿插在正常的程序执行过程中，减少程序暂停时间。</p>
<p>闲时收集: 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</p>
<h5 id="JS闭包"><a href="#JS闭包" class="headerlink" title="JS闭包"></a>JS闭包</h5><h6 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h6><p>在计算机科学中对闭包的定义(维基百科):</p>
<ul>
<li>闭包(英语:Closure)，又称<strong>词法闭包</strong>(LexicalClosure)或<strong>函数闭包</strong>(function closures);</li>
<li>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术;</li>
<li>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境((相当于一个符号查找表):</li>
<li>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行。</li>
</ul>
<p>MDN对JavaScript闭包的解释:</p>
<p>一个函数和对其周围状态(<strong>lexical environment</strong>，<strong>词法环境</strong>)的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是<strong>闭包</strong>(cosure)也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域;在JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来;</p>
<ul>
<li>一个普通函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包;</li>
<li>从广义的角度来说:Javascript中的函数都是闭包;</li>
<li>从狭义的角度来说:Javascript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包;</li>
</ul>
<h6 id="闭包的访问过程"><a href="#闭包的访问过程" class="headerlink" title="闭包的访问过程"></a>闭包的访问过程</h6><p><strong>作用域链（Scope Chain）</strong></p>
<ul>
<li><strong>定义</strong>：作用域链是 JavaScript 中变量查找的机制。每个函数在执行时都会创建一个作用域链，这个链由当前执行上下文的变量对象（Variable Object）和所有外层（父级）执行上下文的变量对象组成。</li>
<li><strong>作用</strong>：当访问一个变量时，JavaScript 引擎会沿着作用域链<strong>逐层向上查找</strong>变量，直到找到变量或到达全局作用域（若未找到则报错）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function outer() &#123;<br>  const a = 10;<br>  function inner() &#123;<br>    console.log(a); // 通过作用域链找到 outer 中的 a<br>  &#125;<br>  inner();<br>&#125;<br>outer(); // 输出 10<br></code></pre></td></tr></table></figure>

<p>在 <code>inner</code> 函数中访问 <code>a</code> 时，作用域链会依次查找 <code>inner</code> → <code>outer</code> → 全局作用域。</p>
<p><strong>2. 闭包（Closure）</strong></p>
<ul>
<li><strong>定义</strong>：闭包是函数能够访问其词法作用域外的变量的能力，即使这个函数在其词法作用域外被调用。闭包的实现依赖于作用域链。</li>
<li><strong>本质</strong>：闭包是作用域链的一种应用结果。当一个函数引用了外层作用域的变量，且该函数被传递到其他作用域执行时，闭包会保留对外层作用域的引用，从而避免变量被垃圾回收。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function outer() &#123;<br>  const a = 10;<br>  return function inner() &#123;<br>    console.log(a); // 闭包保留了对外层 a 的引用<br>  &#125;;<br>&#125;<br>const innerFunc = outer();<br>innerFunc(); // 输出 10（即使 outer 已执行完毕，仍能访问 a）<br></code></pre></td></tr></table></figure>

<p>这里，<code>inner</code> 函数通过闭包保留了 <code>outer</code> 的作用域，即使 <code>outer</code> 已经执行完毕。</p>
<p><strong>3. 区别与联系</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>作用域链</strong></th>
<th><strong>闭包</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>角色</strong></td>
<td>变量查找的规则和路径</td>
<td>基于作用域链实现的一种现象（函数保留对外层作用域的引用）</td>
</tr>
<tr>
<td><strong>存在时机</strong></td>
<td>函数执行时自动创建</td>
<td>当函数引用了外层变量，并在其他作用域被调用时形成</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>作用域链在函数执行完毕后通常会被销毁（除非有闭包）</td>
<td>闭包会导致外层作用域的变量对象无法被垃圾回收，可能引起内存泄漏</td>
</tr>
<tr>
<td><strong>核心目的</strong></td>
<td>确定变量的可访问性</td>
<td>让函数“记住”并访问其词法作用域外的变量</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>作用域链是底层机制</strong>，决定了变量如何被查找。</li>
<li><strong>闭包是上层现象</strong>，是作用域链在特定场景（函数跨作用域执行）下的表现。</li>
<li>可以说，闭包的实现依赖于作用域链，但两者不是同一个概念。</li>
</ul>
<h6 id="内存泄漏及释放内存"><a href="#内存泄漏及释放内存" class="headerlink" title="内存泄漏及释放内存"></a>内存泄漏及释放内存</h6><p><strong>内存泄漏（Memory Leak）</strong> 指的是程序运行过程中不再需要的内存没有被及时释放，导致内存占用持续增长，最终可能引发性能问题甚至程序崩溃。</p>
<p><strong>二、常见内存泄漏场景及解决方案</strong></p>
<p>以下是 JavaScript 中常见的内存泄漏场景及其解决方法：</p>
<p><strong>1. 意外的全局变量</strong></p>
<p><strong>问题</strong>：未使用 <code>var</code>&#x2F;<code>let</code>&#x2F;<code>const</code> 声明的变量会成为全局变量，无法被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">function leak() &#123;<br>  globalVar = &quot;I am a global variable!&quot;; // 意外创建全局变量<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解决</strong>：始终使用 <code>&#39;use strict&#39;</code> 严格模式，或显式声明变量。</li>
</ul>
<p><strong>2. 未清理的定时器（Timers）或回调函数</strong></p>
<p><strong>问题</strong>：<code>setInterval</code> 或事件监听未及时清除，导致回调函数及其依赖的变量无法释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const intervalId = setInterval(() =&gt; &#123;<br>  // 长期运行的定时器<br>&#125;, 1000);<br><br>// 未调用 clearInterval(intervalId) 会导致内存泄漏<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解决</strong>：在不需要时手动清除定时器或事件监听。</li>
</ul>
<p><strong>3. 闭包滥用</strong></p>
<p><strong>问题</strong>：闭包保留了对外部变量的引用，导致外部作用域的变量无法释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createClosure() &#123;<br>  const largeData = new Array(1000000).fill(&quot;data&quot;);<br>  return function() &#123;<br>    // 闭包引用了 largeData，即使不再需要，largeData 也无法被回收<br>  &#125;;<br>&#125;<br>const closure = createClosure();<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解决</strong>：在闭包中避免保留不必要的大对象，或在不需要时手动解除引用（如 <code>closure = null</code>）。</li>
</ul>
<p><strong>4. 未释放的 DOM 引用</strong></p>
<p><strong>问题</strong>：保留对已移除 DOM 元素的引用，导致 DOM 元素无法被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const elements = &#123;<br>  button: document.getElementById(&quot;myButton&quot;),<br>&#125;;<br><br>// 即使从页面移除了按钮，elements.button 仍保留引用<br>document.body.removeChild(document.getElementById(&quot;myButton&quot;));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解决</strong>：在移除 DOM 元素后，手动解除引用（如 <code>elements.button = null</code>）。</li>
</ul>
<p><strong>5. 事件监听未移除</strong></p>
<p><strong>问题</strong>：为 DOM 元素添加事件监听后未移除，导致元素无法被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const button = document.getElementById(&quot;myButton&quot;);<br>button.addEventListener(&quot;click&quot;, handleClick);<br><br>// 未调用 removeEventListener 会导致元素和事件处理函数无法释放<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解决</strong>：在移除元素前手动移除事件监听。</li>
</ul>
<h4 id="函数增强"><a href="#函数增强" class="headerlink" title="函数增强"></a>函数增强</h4><h5 id="函数的arguments和剩余参数"><a href="#函数的arguments和剩余参数" class="headerlink" title="函数的arguments和剩余参数"></a>函数的arguments和剩余参数</h5><p>在 JavaScript 中，<code>** arguments **</code> 是函数内部的一个特殊对象，用于表示函数被调用时传入的所有参数（无论是否在形参列表中声明）。</p>
<ul>
<li><strong>类数组对象</strong>：<code>arguments</code> 是一个类数组对象（Array-like Object），具有数字索引和 <code>length</code> 属性，但<strong>不支持数组方法</strong>（如 <code>push</code>、<code>map</code> 等）。</li>
<li><strong>动态绑定</strong>：<code>arguments</code> 的内容会随着函数参数的变化而动态更新（非严格模式下）。</li>
<li><strong>非箭头函数独有</strong>：箭头函数（Arrow Function）没有自己的 <code>arguments</code> 对象。</li>
</ul>
<p><strong>类数组转数组</strong></p>
<p>如果需要使用数组方法，需将 <code>arguments</code> 转换为真正的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function logArgs() &#123;<br>  //	使用 slice截取<br>  //const newArr=Array.prototype.slice.apply(arguments)<br>  // 使用 Array.from() 或扩展运算符<br>  const argsArray = Array.from(arguments);<br>  // 或者 const argsArray = [...arguments];<br><br>  argsArray.forEach(arg =&gt; console.log(arg));<br>&#125;<br>logArgs(&quot;a&quot;, &quot;b&quot;); // 输出 &quot;a&quot;, &quot;b&quot;<br></code></pre></td></tr></table></figure>

<p><strong>严格模式下的行为</strong></p>
<p>在严格模式（<code>&#39;use strict&#39;</code>）中，<code>arguments</code> 与形参<strong>解耦</strong>，修改 <code>arguments</code> 不会影响形参，反之亦然：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">function strictExample(a, b) &#123;<br>  &#x27;use strict&#x27;;<br>  arguments[0] = 100;<br>  console.log(a); // 输出原始的 a 值（非严格模式下会输出 100）<br>&#125;<br>strictExample(1, 2);<br></code></pre></td></tr></table></figure>

<p>**  **<code>** arguments **</code> <strong>与箭头函数</strong></p>
<p>箭头函数没有自己的 <code>arguments</code> 对象，但可以访问外层函数的 <code>arguments</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">function outer() &#123;<br>  const inner = () =&gt; &#123;<br>    console.log(arguments); // 输出 outer 的 arguments<br>  &#125;;<br>  inner();<br>&#125;<br>outer(1, 2); // 输出 &#123; 0: 1, 1: 2 &#125;<br></code></pre></td></tr></table></figure>

<p><strong>替代方案：剩余参数（Rest Parameters）</strong></p>
<p>ES6 引入了 <strong>剩余参数（</strong><code>** ...args **</code><strong>）</strong>，它是真正的数组，更推荐使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function sum(...args) &#123;<br>  return args.reduce((acc, val) =&gt; acc + val, 0);<br>&#125;<br>console.log(sum(1, 2, 3)); // 输出 6<br></code></pre></td></tr></table></figure>

<p><strong>优势对比：</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>**arguments**</code></th>
<th><strong>剩余参数（</strong><code>**...args**</code><br><strong>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>类数组对象</td>
<td>真正的数组</td>
</tr>
<tr>
<td><strong>与形参的绑定</strong></td>
<td>动态绑定（非严格模式）</td>
<td>独立</td>
</tr>
<tr>
<td><strong>箭头函数支持</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>可读性</strong></td>
<td>低（隐式传递参数）</td>
<td>高（显式声明参数）</td>
</tr>
</tbody></table>
<h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p><strong>纯函数的维基百科定义:</strong></p>
<p>在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数:</p>
<ul>
<li>此函数在相同的输入值时，需产生相同的输出。</li>
<li>函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I&#x2F;0设备产生的外部输出无关。</li>
<li>该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。</li>
</ul>
<p>:::tips 计算机科学中，也引用了副作用的概念，表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响,比如修改了全局变量，修改参数或者改变外部的存储;</p>
<p>:::</p>
<p><strong>纯函数作用</strong></p>
<ul>
<li>在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改;</li>
<li>输入内容不会被任意篡改，并且确定的输入，一定会有确定的输出;</li>
</ul>
<p>:::tips React中就要求我们无论是函数还是class声明一个组件，这个组件都必须像纯函数一样，保护它们的props不被修改</p>
<p>:::</p>
<h5 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h5><p><strong>函数柯里化定义</strong></p>
<p>在计算机科学中，柯里化(英语:Currying)，又译为卡瑞化或加里化:</p>
<ul>
<li>是把接收多个参数的函数变成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数，而且返回结果的新函数的技术;</li>
<li>柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数</li>
</ul>
<p>柯里化箭头函数写法:<code>var foo=x=&gt;y=&gt;z=&gt;console.log(x + y + z)</code></p>
<p><strong>自动柯里化函数</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y, z</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y + z)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> num1 + num2</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">logInfo</span>(<span class="hljs-params">date, type, message</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`时间:<span class="hljs-subst">$&#123;date&#125;</span> 类型:<span class="hljs-subst">$&#123;type&#125;</span> 内容:<span class="hljs-subst">$&#123;message&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 手动转化</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 封装函数: 自动转化柯里化过程(有一点难度)</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hyCurrying</span>(<span class="hljs-params">fn</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">curryFn</span>(<span class="hljs-params">...args</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 两类操作:</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 第一类操作: 继续返回一个新的函数, 继续接受参数</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 第二类操作: 直接执行fn的函数</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= fn.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">// 执行第二类</span></span><br><span class="language-javascript">          <span class="hljs-comment">// return fn(...args)</span></span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)</span><br><span class="language-javascript">        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 执行第一类</span></span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// return curryFn(...args.concat(newArgs))</span></span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> curryFn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(newArgs))</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> curryFn</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 对其他的函数进行柯里化</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> fooCurry = <span class="hljs-title function_">hyCurrying</span>(foo)</span><br><span class="language-javascript">    <span class="hljs-title function_">fooCurry</span>(<span class="hljs-number">10</span>)(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">fooCurry</span>(<span class="hljs-number">55</span>, <span class="hljs-number">12</span>, <span class="hljs-number">56</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> sumCurry = <span class="hljs-title function_">hyCurrying</span>(sum)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> sum5 = <span class="hljs-title function_">sumCurry</span>(<span class="hljs-number">5</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum5</span>(<span class="hljs-number">10</span>))</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum5</span>(<span class="hljs-number">15</span>))</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum5</span>(<span class="hljs-number">18</span>))</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> logInfoCurry = <span class="hljs-title function_">hyCurrying</span>(logInfo)</span><br><span class="language-javascript">    <span class="hljs-title function_">logInfoCurry</span>(<span class="hljs-string">&quot;2022-06-01&quot;</span>)(<span class="hljs-string">&quot;DEBUG&quot;</span>)(<span class="hljs-string">&quot;我发现一个bug, 哈哈哈哈&quot;</span>)</span><br><span class="language-javascript"> </span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h5 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 第一步对数字*2</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">num</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 第二步对数字**2</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">num</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> num ** <span class="hljs-number">2</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 封装的函数: 你传入多个函数, 我自动的将多个函数组合在一起挨个调用</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">composeFn</span>(<span class="hljs-params">...fns</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1.边界判断(edge case)</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> length = fns.<span class="hljs-property">length</span></span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span></span><br><span class="language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> fn = fns[i]</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`index position <span class="hljs-subst">$&#123;i&#125;</span> must be function`</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 2.返回的新函数</span></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> result = fns[<span class="hljs-number">0</span>].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">var</span> fn = fns[i]</span><br><span class="language-javascript">          result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [result])</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> result</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> newFn = <span class="hljs-title function_">composeFn</span>(double, pow, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFn</span>(<span class="hljs-number">100</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFn</span>(<span class="hljs-number">55</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFn</span>(<span class="hljs-number">22</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(newFn(100))</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(newFn(55))</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(newFn(22))</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>JavaScript 的严格模式（Strict Mode）是 ES5 引入的重要特性，通过限制某些不安全或易出错的语法，提升代码的安全性和可维护性。以下是严格模式的核心要点：</p>
<h6 id="启用方式"><a href="#启用方式" class="headerlink" title="启用方式"></a>启用方式</h6><ol>
<li><strong>全局启用</strong>：在脚本或 <code>&lt;script&gt;</code> 标签的<strong>最顶部</strong>添加 <code>&quot;use strict&quot;;</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>// 整个脚本遵循严格模式<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>函数作用域启用</strong>：在函数体的<strong>最顶部</strong>添加 <code>&quot;use strict&quot;;</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function strictFunc() &#123;<br>  &quot;use strict&quot;;<br>  // 函数内部遵循严格模式<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="核心变化与限制"><a href="#核心变化与限制" class="headerlink" title="核心变化与限制"></a>核心变化与限制</h6><p><strong>1. 变量必须声明</strong></p>
<ul>
<li>未声明的变量赋值会报错（非严格模式会隐式创建全局变量）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>x = 10; // ReferenceError: x is not defined<br></code></pre></td></tr></table></figure>

<p><strong>2. 禁止重复参数</strong></p>
<ul>
<li>函数参数名不可重复。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>function dupParam(a, a) &#123; &#125; // SyntaxError: Duplicate parameter name<br></code></pre></td></tr></table></figure>

<p><strong>3. 禁用</strong> <code>** with **</code> <strong>语句</strong></p>
<ul>
<li><code>with</code> 会导致作用域混乱，严格模式直接禁用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>with (obj) &#123; &#125; // SyntaxError: Strict mode code may not include a with statement<br></code></pre></td></tr></table></figure>

<p><strong>4. 只读属性不可修改</strong></p>
<ul>
<li>对只读属性（如 <code>Object.prototype</code>）赋值会报错。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>Object.prototype = &#123;&#125;; // TypeError: Cannot assign to read-only property<br></code></pre></td></tr></table></figure>

<p><strong>5. 不可删除不可配置的属性</strong></p>
<ul>
<li>删除变量、函数或不可配置的属性会报错。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>delete Object.prototype; // TypeError: Cannot delete property &#x27;prototype&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>6.</strong> <code>** arguments **</code> <strong>对象限制</strong></p>
<ul>
<li><code>arguments</code> 与形参解耦，修改互不影响。</li>
<li>禁用 <code>arguments.callee</code> 和 <code>arguments.caller</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>function func(a) &#123;<br>  arguments[0] = 100;<br>  console.log(a); // 非严格模式输出 100，严格模式输出原值<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>7.</strong> <code>** this **</code> <strong>的默认值为</strong> <code>** undefined **</code></p>
<ul>
<li>普通函数调用时，<code>this</code> 不再指向全局对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>function test() &#123;<br>  console.log(this); // undefined（非严格模式为 window）<br>&#125;<br>test();<br>test.apply(&#x27;123&#x27;) //&#x27;123&#x27; (非严格模式为对应的包装对象)<br>test()<br></code></pre></td></tr></table></figure>

<p><strong>8. 保留字限制</strong></p>
<ul>
<li>不可使用 <code>implements</code>, <code>interface</code>, <code>let</code>, <code>yield</code> 等作为变量名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>let interface = 10; // SyntaxError: Unexpected strict mode reserved word<br></code></pre></td></tr></table></figure>

<p><strong>9.</strong> <code>** eval **</code> <strong>独立作用域</strong></p>
<ul>
<li><code>eval</code> 内部声明的变量不会泄露到外部。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>eval(&quot;var x = 10;&quot;);<br>console.log(x); // ReferenceError: x is not defined<br></code></pre></td></tr></table></figure>

<p><strong>10. 八进制字面量语法</strong></p>
<ul>
<li>禁止使用旧式 <code>0</code> 前缀的八进制，必须用 <code>0o</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>let num = 0123; // SyntaxError: Octal literals are not allowed<br>let correct = 0o123; // 正确写法<br></code></pre></td></tr></table></figure>

<p><strong>11. 对象字面量重复属性</strong></p>
<ul>
<li>ES5 严格模式禁止重复属性（ES6 已放宽此限制）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>let obj = &#123; a: 1, a: 2 &#125;; // ES5 严格模式报错，ES6 不报错<br></code></pre></td></tr></table></figure>



<h6 id="严格模式的优势"><a href="#严格模式的优势" class="headerlink" title="严格模式的优势"></a>严格模式的优势</h6><ul>
<li><strong>减少隐藏错误</strong>：通过报错暴露潜在问题（如变量未声明）。</li>
<li><strong>优化代码</strong>：帮助引擎优化执行（如固定作用域）。</li>
<li><strong>兼容未来语法</strong>：保留关键字为 ES6+ 铺路（如 <code>class</code>, <code>let</code>）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>旧代码启用严格模式需逐步迁移，避免报错。</li>
<li>合并脚本时，若全局启用严格模式，需确保合并后的脚本开头无非严格代码。</li>
</ul>
<h4 id="对象增强"><a href="#对象增强" class="headerlink" title="对象增强"></a>对象增强</h4><h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><p>JavaScript 中的属性描述符用于定义或描述对象属性的特性，分为<strong>数据属性</strong>和<strong>访问器属性</strong>两种类型。以下是关键点总结：</p>
<p><strong>1. 属性描述符的组成</strong></p>
<ul>
<li><strong>数据属性</strong>：包含以下特性：<ul>
<li><code>value</code>：属性的值。</li>
<li><code>writable</code>：是否可修改值（默认为<code>false</code>，若通过赋值创建则默认为<code>true</code>）。</li>
<li><code>enumerable</code>：是否可被枚举（如 <code>for...in</code> 或 <code>Object.keys</code>，默认为<code>false</code>）。</li>
<li><code>configurable</code>：是否可删除属性或修改特性（默认为<code>false</code>）。</li>
</ul>
</li>
<li><strong>访问器属性</strong>：包含 <code>get</code> 和 <code>set</code> 函数：<ul>
<li><code>get()</code>：读取属性时调用。</li>
<li><code>set(value)</code>：写入属性时调用。</li>
<li>不能与 <code>value</code> 或 <code>writable</code> 共存。</li>
</ul>
</li>
</ul>
<p><strong>2. 获取属性描述符</strong></p>
<ul>
<li><code>Object.getOwnPropertyDescriptor(obj, &#39;prop&#39;)</code>：获取对象<strong>自身属性</strong>的描述符。</li>
<li><code>Object.getOwnPropertyDescriptors(obj)</code>：获取对象所有自身属性的描述符。</li>
</ul>
<p><strong>3. 定义&#x2F;修改属性</strong></p>
<ul>
<li><code>Object.defineProperty(obj, &#39;prop&#39;, descriptor)</code>：定义单个属性。</li>
<li><code>Object.defineProperties(obj, descriptors)</code>：批量定义属性。</li>
<li><strong>默认值</strong>：若未显式设置，<code>writable</code>、<code>enumerable</code>、<code>configurable</code> 默认为 <code>false</code>。</li>
</ul>
<p><strong>4. 特性规则</strong></p>
<ul>
<li><code>** configurable: false **</code>：<ul>
<li>禁止删除属性。</li>
<li>禁止修改除 <code>writable</code> 以外的特性（<code>writable</code> 仅允许从 <code>true</code> 改为 <code>false</code>）。</li>
</ul>
</li>
<li><code>** writable: false **</code>：禁止通过赋值修改值（严格模式报错）。</li>
<li><code>** enumerable: false **</code>：属性不会出现在 <code>for...in</code> 或 <code>Object.keys</code> 中。</li>
</ul>
<p><strong>5. 示例</strong></p>
<p><strong>数据属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123;&#125;;<br>Object.defineProperty(obj, &#x27;a&#x27;, &#123;<br>  value: 1,<br>  writable: true,<br>  enumerable: true,<br>  configurable: true<br>&#125;);<br><br>// 修改为不可写<br>Object.defineProperty(obj, &#x27;a&#x27;, &#123; writable: false &#125;);<br>obj.a = 2; // 静默失败（严格模式报错）<br></code></pre></td></tr></table></figure>

<p><strong>访问器属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">Object.defineProperty(obj, &#x27;fullName&#x27;, &#123;<br>  get() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;,<br>  set(value) &#123; [this.firstName, this.lastName] = value.split(&#x27; &#x27;); &#125;,<br>  enumerable: true,<br>  configurable: true<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>6. 默认行为</strong></p>
<p><strong>通过赋值创建的属性</strong>：<code>writable</code>、<code>enumerable</code>、<code>configurable</code> 默认为 <code>true</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; a: 1 &#125;;<br>const desc = Object.getOwnPropertyDescriptor(obj, &#x27;a&#x27;);<br>// &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过</strong> <code>** defineProperty **</code> <strong>创建的属性</strong>：未指定的特性默认为 <code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Object.defineProperty(obj, &#x27;b&#x27;, &#123; value: 2 &#125;);<br>const desc = Object.getOwnPropertyDescriptor(obj, &#x27;b&#x27;);<br>// &#123; value: 2, writable: false, enumerable: false, configurable: false &#125;<br></code></pre></td></tr></table></figure>

<p><strong>7. 实用方法</strong></p>
<ul>
<li><code>Object.freeze(obj)</code>：设置所有属性为 <code>writable: false</code> 且 <code>configurable: false</code>。</li>
<li><code>Object.seal(obj)</code>：设置所有属性为 <code>configurable: false</code>，但保留 <code>writable</code>。</li>
<li><code>Object.preventExtensions(obj)</code>：不允许对象添加新属性(严格模式报错)</li>
</ul>
<p><strong>总结</strong></p>
<p>属性描述符允许精确控制对象属性的行为，适用于实现不可变性、隐藏内部属性或定义动态计算的属性（如访问器）。使用时需注意特性之间的依赖关系（如 <code>configurable</code> 的限制），避免潜在错误。</p>
<h4 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h4><h5 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h5><p>JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。当我们通过引用对象的属性key来获取一个value时，它会触发[[Get]]的操作:这个操作会首先检查该对象是否有对应的属性，如果有的话就使用它;如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性</p>
<p><strong>获取原型方式:</strong></p>
<ul>
<li>方式一:通过对象的_proto 属性可以获取到(但是这个是早期浏览器自己添加的，存在一定的兼容性问题)</li>
<li>方式二:通过 Object.getPrototypeOf 方法可以获取到;</li>
</ul>
<h5 id="函数原型prototype-显式原型"><a href="#函数原型prototype-显式原型" class="headerlink" title="函数原型prototype(显式原型)"></a>函数原型prototype(显式原型)</h5><p>每个函数都有一个 <code>prototype</code> 属性，它是一个对象，用于实现基于构造函数的继承。使用 <code>new</code> 关键字调用函数创建对象时，新对象的 <code>[[Prototype]]</code> 会指向该函数的 <code>prototype</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一：使用对象字面量创建对象</span><br><span class="hljs-keyword">const</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 方式二：使用构造函数创建对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">runing</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>obj2.<span class="hljs-title function_">runing</span>()<br><br><span class="hljs-comment">// 查看对象的原型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong>函数原型上的constructor</strong></p>
<p>事实上原型对象上面是有一个属性的:constructor ,默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br>    // 非常重要的属性: constructor, 指向Person函数对象<br>    function Person() &#123;<br><br>    &#125;<br><br>    // 1.对constructor在prototype上的验证<br>    var PersonPrototype = Person.prototype<br>    console.log(PersonPrototype)<br>    console.log(PersonPrototype.constructor)<br>    console.log(PersonPrototype.constructor === Person)<br><br>    console.log(Person.name)<br>    console.log(PersonPrototype.constructor.name)<br><br>    // 2.实例对象p<br>    var p = new Person()<br>    console.log(p.__proto__.constructor)<br>    console.log(p.__proto__.constructor.name)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>



<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p> 面向对象有三大特性:<strong>封装、继承、多态</strong></p>
<ul>
<li>封装:我们前面将属性和方法封装到一个类中，可以称之为封装的过程;</li>
<li>继承:继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提(纯面向对象中);</li>
<li>多态:不同的对象在执行时表现出不同的形态;</li>
</ul>
<h6 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h6><p>首先，原型链是JavaScript实现继承的机制，对吧？每个对象都有一个原型对象，而原型对象也可能有它自己的原型，这样一层层链接起来就形成了原型链。当访问一个对象的属性时，如果对象本身没有这个属性，就会沿着原型链向上查找，直到找到或者到达原型链的末端（null）。这是原型链的基本概念。</p>
<p><strong>一、默认原型链</strong></p>
<p><strong>对象字面量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">let obj = &#123;&#125;;<br>// 原型链：obj -&gt; Object.prototype -&gt; null<br>- ` obj.__proto__ === Object.prototype `<br>- ` Object.prototype.__proto__ === null `<br></code></pre></td></tr></table></figure>

<p><strong>构造函数创建对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Person() &#123;&#125;<br>let person = new Person();<br>// 原型链：person -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br>- ` person.__proto__ === Person.prototype `<br>- ` Person.prototype.__proto__ === Object.prototype `<br></code></pre></td></tr></table></figure>

<p><strong>函数的原型链</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Foo() &#123;&#125;<br>// 原型链：Foo -&gt; Function.prototype -&gt; Object.prototype -&gt; null<br>- ` Foo.__proto__ === Function.prototype `<br>- ` Function.prototype.__proto__ === Object.prototype `<br></code></pre></td></tr></table></figure>

<p><strong>二、自定义原型链</strong></p>
<p><strong>使用</strong> <code>** Object.create **</code></p>
<p><code>Object.create()</code> 方法创建一个新对象，该对象继承自指定的原型对象。通过这种方式，<code>proto</code> 对象就拥有了 <code>Parent</code> 构造函数原型上的所有属性和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const parent = &#123; name: &quot;parent&quot; &#125;;<br>const child = Object.create(parent);<br>// 原型链：child -&gt; parent -&gt; Object.prototype -&gt; null<br>- ` child.__proto__ === parent `<br></code></pre></td></tr></table></figure>

<p><strong>手动修改原型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Parent() &#123;&#125;<br>function Child() &#123;&#125;<br>Child.prototype = new Parent(); // 不推荐（可能调用父类构造函数两次）<br>Child.prototype.constructor = Child; // 修复 constructor<br></code></pre></td></tr></table></figure>

<p><strong>推荐方式：寄生组合继承</strong></p>
<p><code>call</code> 方法允许在指定的 <code>this</code> 值和参数的情况下调用函数。通过这种方式，<code>Child</code> 对象可以继承 <code>Parent</code> 对象的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">function inheritPrototype(Child, Parent) &#123;<br>  const proto = Object.create(Parent.prototype);<br>  proto.constructor = Child;<br>  Child.prototype = proto;<br>&#125;<br>//或者使用 Object.defineProperty设置constructor<br>//function inheritPrototype(Child, Parent) &#123;<br>        //     Child.prototype=Object.create(Parent.prototype)<br>        //     Object.defineProperty(Child.prototype,&#x27;constructor&#x27;,&#123;<br>        //         enumerable:false,<br>        //         configurable:true,<br>        //         writable:true,<br>        //         value:Child<br>        //     &#125;)<br>        // &#125;<br></code></pre></td></tr></table></figure>

<p><strong>三、继承的实现</strong></p>
<p><strong>组合继承（借用构造函数 + 原型链）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Parent(name) &#123;<br>  this.name = name;<br>&#125;<br>Parent.prototype.sayName = function() &#123; console.log(this.name) &#125;;<br><br>function Child(name, age) &#123;<br>  Parent.call(this, name);  // 继承属性<br>  this.age = age;<br>&#125;<br>Child.prototype = new Parent();     // 继承方法（不推荐）<br>Child.prototype.constructor = Child;<br></code></pre></td></tr></table></figure>

<p><strong>寄生组合继承（优化版）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Child(name, age) &#123;<br>  Parent.call(this, name);<br>  this.age = age;<br>&#125;<br>inheritPrototype(Child, Parent); // 使用上述工具函数<br></code></pre></td></tr></table></figure>

<p><strong>ES6</strong> <code>** class **</code> <strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Parent &#123;<br>  constructor(name) &#123; this.name = name; &#125;<br>  sayName() &#123; console.log(this.name) &#125;<br>&#125;<br><br>class Child extends Parent &#123;<br>  constructor(name, age) &#123;<br>    super(name); // 必须先调用 super()<br>    this.age = age;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h6 id="对象原型判断方法"><a href="#对象原型判断方法" class="headerlink" title="对象原型判断方法"></a>对象原型判断方法</h6><ul>
<li>hasOwnProperty:对象是否有某一个属于自己的属性(不是在原型上的属性)</li>
<li>in&#x2F;for in 操作符:判断某个属性是否在某个对象或者对象的原型上</li>
<li>instanceof:用于检测构造函数(Person、Student类)的prototype是否出现在某个实例对象的原型链上</li>
<li>isPrototypeOf:用于检测某个对象，是否出现在某个实例对象的原型链上</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/inherit_utils.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> info = <span class="hljs-title function_">createObject</span>(obj)</span><br><span class="language-javascript">    info.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;中国&quot;</span></span><br><span class="language-javascript">    info.<span class="hljs-property">intro</span> = <span class="hljs-string">&quot;中国大好河山&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">name</span>, info.<span class="hljs-property">address</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.hasOwnProperty</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(info.hasOwnProperty(&quot;name&quot;)) // false</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(info.hasOwnProperty(&quot;address&quot;)) // true</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2.in操作符</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> info)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-keyword">in</span> info)</span><br><span class="language-javascript">    <span class="hljs-comment">// 注意: for in遍历不仅仅是自己对象上的内容, 也包括原型对象上的内容</span></span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> info) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 3.instanceof</span></span><br><span class="language-javascript">    <span class="hljs-comment">// instanceof用于判断对象和类(构造函数)之间的关系</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// stu实例(instance)对象</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>()</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Student</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 4.isPrototypeOf</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(stu))</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(stu))</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 可以用于判断对象之间的继承</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">isPrototypeOf</span>(info))</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h5 id="原型继承关系"><a href="#原型继承关系" class="headerlink" title="原型继承关系"></a>原型继承关系</h5><p><img src="1739109824352-f8b3988e-849b-4b9c-a57f-4e235b002cfb.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>构造函数</strong>（如 <code>Foo</code>、<code>Object</code>）：通过 <code>new Function()</code> 创建的函数对象。</li>
<li><strong>原型对象</strong>（<code>prototype</code>）：每个构造函数都有一个 <code>prototype</code> 属性，指向其原型对象。</li>
<li><strong>实例对象</strong>（如 <code>f1</code>、<code>o1</code>）：通过 <code>new 构造函数()</code> 创建的对象。</li>
<li><strong>原型链</strong>：通过 <code>__proto__</code> 属性连接，形成对象的继承链。</li>
</ol>
<p>关键关系</p>
<ol>
<li><strong>构造函数与原型对象</strong>：<ul>
<li><strong>构造函数的*</strong>* **<code>** prototype **</code> 属性指向其原型对象（如 <code>Foo.prototype</code>）。</li>
<li><strong>原型对象的*</strong>* **<code>** constructor **</code> 属性指回构造函数（如 <code>Foo.prototype.constructor === Foo</code>）。</li>
</ul>
</li>
<li><strong>实例对象与原型链</strong>：<ul>
<li><strong>实例的*</strong>* **<code>** __proto__ **</code> 指向其构造函数的原型对象（如 <code>f1.__proto__ === Foo.prototype</code>）。</li>
<li><strong>原型链终点</strong>：所有原型链最终指向 <code>Object.prototype</code>，其 <code>__proto__</code> 为 <code>null</code>。</li>
</ul>
</li>
<li><strong>函数对象的特殊链</strong>：<ul>
<li><strong>构造函数的*</strong>* **<code>** __proto__ **</code> 指向 <code>Function.prototype</code>（如 <code>Foo.__proto__ === Function.prototype</code>）。</li>
<li><code>** Function **</code> ****<strong>自身</strong>：<code>Function.__proto__ === Function.prototype</code>（因为 <code>Function</code> 是自身的构造函数）。</li>
<li><code>** Function.prototype **</code> ****<strong>的原型</strong>：<code>Function.prototype.__proto__ === Object.prototype</code>。</li>
</ul>
</li>
</ol>
<p><strong>图示总结</strong></p>
<p><code>** Foo **</code> <strong>的继承链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">f1（实例） → Foo.prototype → Object.prototype → null<br>↑<br>Foo（构造函数） → Function.prototype → Object.prototype → null<br></code></pre></td></tr></table></figure>

<p><code>** Object **</code> <strong>的继承链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">o1（实例） → Object.prototype → null<br>↑<br>Object（构造函数） → Function.prototype → Object.prototype → null<br></code></pre></td></tr></table></figure>

<p><code>** Function **</code> ****<strong>的继承链</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Function（构造函数） → Function.prototype → Object.prototype → null<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><strong>构造函数*</strong>* **<code>** prototype **</code>：定义原型，供实例继承。</li>
<li><strong>实例*</strong>* **<code>** __proto__ **</code>：顺着链找，继承属性和方法。</li>
<li><strong>函数皆*</strong>* <strong><code>\** Function \**</code></strong> **<strong>生</strong>：所有构造函数的 <code>__proto__</code> 指向 <code>Function.prototype</code>。</li>
<li><strong>终点</strong> <code>** Object.prototype **</code>：万物归宗，原型链尽头是 <code>null</code>。</li>
</ul>
<p><strong>通过这张图，可以清晰理解 JavaScript 中对象、构造函数、原型之间的层级关系与继承机制。</strong></p>
<p><img src="1739111638539-e85b5bdb-11ca-4ee9-ab9f-fcbcd1d9680d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="ES6新增特性"><a href="#ES6新增特性" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h4><h5 id="class定义类"><a href="#class定义类" class="headerlink" title="class定义类"></a>class定义类</h5><p>ES6 引入了 <code>class</code> 关键字，提供了更清晰的语法糖来实现面向对象编程，其底层仍基于原型继承。</p>
<h6 id="1-类定义与构造函数"><a href="#1-类定义与构造函数" class="headerlink" title="1. 类定义与构造函数"></a>1. 类定义与构造函数</h6><ul>
<li><strong>定义类</strong>：使用 <code>class</code> 关键字，后跟类名和 <code>&#123;&#125;</code>。</li>
<li><strong>构造函数</strong>：<code>constructor</code> 方法用于初始化实例，未显式定义则默认生成空构造函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Person &#123;<br>  constructor(name) &#123;<br>    this.name = name; // 实例属性<br>  &#125;<br>  sayHello() &#123;<br>    console.log(`Hello, $&#123;this.name&#125;!`);<br>  &#125;<br>&#125;<br>const alice = new Person(&quot;Alice&quot;);<br>alice.sayHello(); // Hello, Alice!<br></code></pre></td></tr></table></figure>

<p>当我们通过new关键字操作类的时候，会调用这个constructor函数，并且执行如下操作:</p>
<ul>
<li>1.在内存中创建一个新的对象(空对象);</li>
<li>2.这个对象内部的[[prototype]]属性会被赋值为该类的prototype属性;</li>
<li>3.构造函数内部的this，会指向创建出来的新对象;</li>
<li>4.执行构造函数的内部代码(函数体代码)</li>
<li>5.如果构造函数没有返回非空对象，则返回创建出来的新对象;</li>
</ul>
<h6 id="2-继承（extends-和-super）"><a href="#2-继承（extends-和-super）" class="headerlink" title="2. 继承（extends 和 super）"></a>2. 继承（extends 和 super）</h6><ul>
<li><strong>继承父类</strong>：通过 <code>extends</code> 实现继承。</li>
<li><strong>调用父类构造函数</strong>：子类构造函数必须调用 <code>super()</code> 后才能使用 <code>this</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Student extends Person &#123;<br>  constructor(name, grade) &#123;<br>    super(name);<br>    this.grade = grade;<br>  &#125;<br>  study() &#123;<br>    console.log(`$&#123;this.name&#125; is studying in grade $&#123;this.grade&#125;.`);<br>  &#125;<br>&#125;<br>const bob = new Student(&quot;Bob&quot;, 10);<br>bob.study(); // Bob is studying in grade 10.<br></code></pre></td></tr></table></figure>



<h6 id="3-静态方法与属性（static）"><a href="#3-静态方法与属性（static）" class="headerlink" title="3. 静态方法与属性（static）"></a>3. 静态方法与属性（static）</h6><ul>
<li><strong>静态成员</strong>：属于类本身，通过类名访问，实例无法调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">class MathUtils &#123;<br>  static PI = 3.14159; // 静态属性（ES2022+）<br>  static square(x) &#123;<br>    return x * x;<br>  &#125;<br>&#125;<br>console.log(MathUtils.square(5)); // 25<br></code></pre></td></tr></table></figure>



<h6 id="4-Getter-和-Setter"><a href="#4-Getter-和-Setter" class="headerlink" title="4. Getter 和 Setter"></a>4. Getter 和 Setter</h6><ul>
<li><strong>访问器属性</strong>：通过 <code>get</code> 和 <code>set</code> 定义，控制属性的读取和赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Circle &#123;<br>  constructor(radius) &#123;<br>    this._radius = radius;<br>  &#125;<br>  get area() &#123;<br>    return Math.PI * this._radius ** 2;<br>  &#125;<br>  set radius(value) &#123;<br>    if (value &gt; 0) this._radius = value;<br>  &#125;<br>&#125;<br>const c = new Circle(5);<br>console.log(c.area); // 78.54...<br>c.radius = 10; // 调用 setter<br></code></pre></td></tr></table></figure>



<h6 id="5-私有字段（ES2022-）"><a href="#5-私有字段（ES2022-）" class="headerlink" title="5. 私有字段（ES2022+）"></a>5. 私有字段（ES2022+）</h6><ul>
<li><strong>私有成员</strong>：以 <code>#</code> 开头，仅在类内部访问。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Counter &#123;<br>  #count = 0; // 私有字段<br>  increment() &#123;<br>    this.#count++;<br>  &#125;<br>  get value() &#123;<br>    return this.#count;<br>  &#125;<br>&#125;<br>const counter = new Counter();<br>counter.increment();<br>console.log(counter.value); // 1<br></code></pre></td></tr></table></figure>



<h6 id="6-类表达式"><a href="#6-类表达式" class="headerlink" title="6. 类表达式"></a>6. 类表达式</h6><ul>
<li><strong>匿名类</strong>：类可作为表达式赋值给变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Animal = class &#123;<br>  constructor(name) &#123;<br>    this.name = name;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h6 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h6><ul>
<li><strong>无函数提升</strong>：类声明不会提升，需先定义后使用。</li>
<li><strong>方法无逗号</strong>：类方法间无需逗号分隔。</li>
<li><strong>原型方法</strong>：类方法定义在原型上，实例共享方法以节省内存。</li>
</ul>
<h6 id="总结对比（ES6-vs-ES5）"><a href="#总结对比（ES6-vs-ES5）" class="headerlink" title="总结对比（ES6 vs ES5）"></a>总结对比（ES6 vs ES5）</h6><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>ES6 Class</strong></th>
<th><strong>ES5 实现方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td><code>class MyClass &#123;&#125;</code></td>
<td>构造函数 <code>function MyClass() &#123;&#125;</code></td>
</tr>
<tr>
<td>继承</td>
<td><code>extends</code><br> 和 <code>super</code></td>
<td><code>prototype</code><br> 和 <code>Object.create</code></td>
</tr>
<tr>
<td>静态方法</td>
<td><code>static</code><br> 关键字</td>
<td>直接赋值：<code>MyClass.staticMethod</code></td>
</tr>
<tr>
<td>私有性（ES2022+）</td>
<td><code>#</code><br> 前缀</td>
<td>闭包或约定（如 <code>_name</code><br>）</td>
</tr>
</tbody></table>
<p>ES6 类语法更简洁直观，但本质仍是基于原型的继承，熟悉原型链有助于深入理解类的工作机制。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态是面向对象编程中的一个概念,多态的定义应该是指同一个方法在不同对象中有不同的实现。也就是说，不同的对象可以对同一个方法调用做出不同的响应。JS中的多态可以通过两种方式实现：基于原型链继承的方法重写，以及基于类型的方法调用。这两种方式都允许不同对象对同一方法调用做出不同响应，体现了多态性。</p>
<p><strong>1. 基于原型链继承的方法重写（ES6类语法）</strong></p>
<p>通过继承父类并重写方法，子类实例调用方法时执行自身的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Animal &#123;<br>  speak() &#123;<br>    console.log(&#x27;动物叫&#x27;);<br>  &#125;<br>&#125;<br><br>class Dog extends Animal &#123;<br>  speak() &#123;<br>    console.log(&#x27;汪汪&#x27;); // 重写父类方法<br>  &#125;<br>&#125;<br><br>class Cat extends Animal &#123;<br>  speak() &#123;<br>    console.log(&#x27;喵喵&#x27;); // 重写父类方法<br>  &#125;<br>&#125;<br><br>const animals = [new Dog(), new Cat()];<br>animals.forEach(animal =&gt; animal.speak()); // 输出：汪汪 喵喵<br></code></pre></td></tr></table></figure>

<p><strong>2. 基于类型的灵活多态</strong></p>
<p>只要对象具有所需方法，无论是否继承同一父类，均可实现多态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">const duck = &#123;<br>  speak() &#123;<br>    console.log(&#x27;嘎嘎&#x27;); // 独立对象的方法<br>  &#125;<br>&#125;;<br><br>const robot = &#123;<br>  speak() &#123;<br>    console.log(&#x27;哔哔&#x27;); // 独立对象的方法<br>  &#125;<br>&#125;;<br><br>function makeSound(entity) &#123;<br>  entity.speak(); // 依赖鸭子类型<br>&#125;<br><br>makeSound(duck);  // 嘎嘎<br>makeSound(robot); // 哔哔<br></code></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><strong>继承与重写</strong>：子类覆盖父类方法，调用时根据实例类型执行对应方法。</li>
<li><strong>基于类型的灵活多态</strong>：关注对象是否具备方法而非继承关系，提升灵活性。</li>
<li><strong>动态特性</strong>：JavaScript的动态类型系统天然支持多态，无需显式接口定义。</li>
</ul>
<p><strong>优势</strong>：增强代码扩展性和复用性，新增类型时无需修改调用方代码，符合开闭原则。</p>
<h5 id="apply-call和bind的实现和封装"><a href="#apply-call和bind的实现和封装" class="headerlink" title="apply,call和bind的实现和封装"></a>apply,call和bind的实现和封装</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// new Function()</span></span><br><span class="language-javascript">    <span class="hljs-comment">// foo.__proto__ === Function.prototype</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>, name, age)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// foo函数可以通过apply/call</span></span><br><span class="language-javascript">    <span class="hljs-comment">// foo.apply(&quot;aaa&quot;, [&quot;why&quot;, 18])</span></span><br><span class="language-javascript">    <span class="hljs-comment">// foo.call(&quot;bbb&quot;, &quot;kobe&quot;, 30)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.封装思想</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.1.封装到独立的函数中</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">execFn</span>(<span class="hljs-params">thisArg, otherArgs, fn</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1.获取thisArg, 并且确保是一个对象类型</span></span><br><span class="language-javascript">      thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// thisArg.fn = this</span></span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, <span class="hljs-string">&quot;fn&quot;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: fn</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 执行代码</span></span><br><span class="language-javascript">      thisArg.<span class="hljs-title function_">fn</span>(...otherArgs)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.2. 封装原型中</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyexec</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1.获取thisArg, 并且确保是一个对象类型</span></span><br><span class="language-javascript">      thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// thisArg.fn = this</span></span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, <span class="hljs-string">&quot;fn&quot;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span></span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">      thisArg.<span class="hljs-title function_">fn</span>(...otherArgs)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.给函数对象添加方法: hyapply</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyapply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hyexec</span>(thisArg, otherArgs)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">// 2.给函数对象添加方法: hycall</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hycall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hyexec</span>(thisArg, otherArgs)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hyapply</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span> &#125;, [<span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-number">25</span>])</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hyapply</span>(<span class="hljs-number">123</span>, [<span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>])</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hyapply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>])</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hycall</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span> &#125;, <span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-number">25</span>)</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hycall</span>(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>)</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hycall</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// apply/call</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, height, address</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>, name, age, height, address)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// Function.prototype</span></span><br><span class="language-javascript">    <span class="hljs-comment">// var newFoo = foo.bind(&#123; name: &quot;why&quot; &#125;, &quot;why&quot;, 18)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// newFoo(1.88)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 实现hybind函数</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// console.log(this) // -&gt; foo函数对象</span></span><br><span class="language-javascript">      thisArg = thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span> ? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)</span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, <span class="hljs-string">&quot;fn&quot;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span></span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// var allArgs = otherArgs.concat(newArgs)</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> allArgs = [...otherArgs, ...newArgs]</span><br><span class="language-javascript">        thisArg.<span class="hljs-title function_">fn</span>(...allArgs)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> newFoo = foo.<span class="hljs-title function_">hybind</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h5 id="const和let"><a href="#const和let" class="headerlink" title="const和let"></a>const和let</h5><p>在JavaScript中，<code>const</code>和<code>let</code>是ES6引入的两种变量声明方式，提供了更清晰的变量作用域和更严格的语法规则，取代了传统的<code>var</code>。</p>
<p><strong>1. 作用域</strong></p>
<p><code>** let **</code> <strong>和</strong> <code>** const **</code> <strong>是块级作用域</strong>：   在<code>&#123;&#125;</code>（如<code>if</code>、<code>for</code>、函数等代码块）内部声明的变量，仅在块内有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (true) &#123;<br>  let a = 10;<br>  const b = 20;<br>&#125;<br>console.log(a); // 报错：a未定义<br>console.log(b); // 报错：b未定义<br></code></pre></td></tr></table></figure>

<ul>
<li><code>** var **</code> ****<strong>是函数作用域</strong>：   变量在整个函数内有效，容易导致变量泄漏到外部作用域。</li>
</ul>
<p><strong>2. 变量提升与暂时性死区（TDZ）</strong></p>
<p><strong>变量提升存在，但存在暂时性死区</strong>：   <code>let</code>和<code>const</code>声明的变量会提升到作用域顶部，但在声明前访问会触发<strong>TDZ</strong>（报错）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">console.log(a); // 报错（TDZ）<br>let a = 10;<br></code></pre></td></tr></table></figure>

<p><code>** var **</code> <strong>的变量提升</strong>：   <code>var</code>声明的变量会初始化为<code>undefined</code>，无TDZ。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">console.log(b); // 输出undefined<br>var b = 10;<br></code></pre></td></tr></table></figure>

<p><strong>3. 重复声明</strong></p>
<p><code>** let **</code> <strong>和</strong> <code>** const **</code> <strong>禁止重复声明</strong>：   同一作用域内不可重复声明同名变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">let x = 1;<br>let x = 2; // 报错：x已声明<br></code></pre></td></tr></table></figure>

<p><code>** var **</code> <strong>允许重复声明</strong>：   后续声明会覆盖前者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var y = 1;<br>var y = 2; // 合法<br></code></pre></td></tr></table></figure>

<p><strong>4.</strong> <code>** const **</code> <strong>的特殊性</strong></p>
<p><strong>声明时必须初始化</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const PI = 3.14; // 正确<br>const PI; // 报错：未初始化<br></code></pre></td></tr></table></figure>

<p><strong>不可重新赋值</strong>：   基本类型值不可变，引用类型（对象、数组）的属性可修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const arr = [1, 2, 3];<br>arr.push(4); // 允许<br>arr = [5]; // 报错：不可重新赋值<br><br>const obj = &#123; name: &quot;Alice&quot; &#125;;<br>obj.name = &quot;Bob&quot;; // 允许<br></code></pre></td></tr></table></figure>

<p><strong>5. 使用场景</strong></p>
<p><strong>优先使用*</strong>* **<code>** const **</code>：   默认用<code>const</code>声明变量，除非需要重新赋值。</p>
<ul>
<li><code>const API_KEY = &quot;abc123&quot;; // 常量</code></li>
</ul>
<p><strong>需要重新赋值时用</strong> <code>** let **</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">let count = 0;<br>count = 1; // 合法<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>避免使用*</strong>* **<code>** var **</code>：   <code>var</code>的作用域和提升行为容易导致错误。</li>
</ul>
<p><strong>6. 循环中的表现</strong></p>
<p><code>** let **</code> <strong>在循环中绑定每次迭代</strong>：   解决<code>var</code>在循环中共享变量的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (let i = 0; i &lt; 3; i++) &#123;<br>  setTimeout(() =&gt; console.log(i), 100); // 输出0,1,2<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>** const **</code> <strong>在循环中的特殊行为</strong>：   每次迭代创建一个新变量（适用于<code>for...of</code>&#x2F;<code>for...in</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (const num of [1, 2, 3]) &#123;<br>  console.log(num); // 输出1,2,3<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><code>** const **</code>：声明常量，不可重新赋值，引用类型属性可变。</li>
<li><code>** let **</code>：声明可变的块级变量。</li>
<li><strong>块级作用域</strong>、<strong>TDZ</strong>、<strong>禁止重复声明</strong>使代码更安全、可维护。</li>
<li><strong>替代</strong><code>** var **</code>：推荐始终使用<code>const</code>和<code>let</code>，避免<code>var</code>。</li>
</ul>
<h4 id="ES6-ES13"><a href="#ES6-ES13" class="headerlink" title="ES6~ES13"></a>ES6~ES13</h4><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>JavaScript 中的模板字符串和标签模板字符串是 ES6 引入的重要特性，极大提升了字符串处理的灵活性和功能性。</p>
<h6 id="模板字符串（Template-Strings）"><a href="#模板字符串（Template-Strings）" class="headerlink" title="模板字符串（Template Strings）"></a>模板字符串（Template Strings）</h6><p><strong>基本语法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-  使用反引号（ <span class="hljs-string">`   `</span> ）包裹字符串，支持多行内容和插值表达式。 <br>-  插值通过  <span class="hljs-string">` <span class="hljs-subst">$&#123;expression&#125;</span> `</span>  实现，表达式结果自动转换为字符串并嵌入。 <br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>; <span class="hljs-comment">// &quot;Hello, Alice!&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>多行字符串</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">-  直接换行编写，保留换行符和缩进。 <br>const html = `<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>`;<br></code></pre></td></tr></table></figure>

<p><strong>表达式求值</strong>：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">-  支持任意 JavaScript 表达式，包括函数调用、运算等。 <br>const <span class="hljs-built_in">sum</span> = <span class="hljs-string">`3 + 5 = <span class="hljs-subst">$&#123;<span class="hljs-number">3</span> + <span class="hljs-number">5</span>&#125;</span>`</span>; <span class="hljs-comment">// &quot;3 + 5 = 8&quot;</span><br></code></pre></td></tr></table></figure>



<h6 id="标签模板字符串（Tagged-Templates）"><a href="#标签模板字符串（Tagged-Templates）" class="headerlink" title="标签模板字符串（Tagged Templates）"></a>标签模板字符串（Tagged Templates）</h6><ol>
<li><strong>基本概念</strong>：<ul>
<li>通过标签函数处理模板字符串，语法为：<code>tagFunction</code>string text ${expression}…&#96;&#96;。</li>
<li>标签函数接收字符串数组和插值参数，返回自定义结果。</li>
</ul>
</li>
<li><strong>参数解析</strong>：<ul>
<li><strong>第一个参数</strong>：字符串数组（按插值位置分割）。</li>
<li><strong>后续参数</strong>：按顺序传入插值表达式的计算结果。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function tag(strings, ...values) &#123;<br>  console.log(strings); // [&quot;Hello &quot;, &quot;, age &quot;, &quot;&quot;]<br>  console.log(values);  // [&quot;Alice&quot;, 30]<br>&#125;<br>tag`Hello $&#123;&quot;Alice&quot;&#125;, age $&#123;30&#125;`;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>应用场景</strong>：</li>
</ol>
<p><strong>HTML 转义</strong>：防止 XSS 攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">function safeHtml(strings, ...values) &#123;<br>  let result = &quot;&quot;;<br>  for (let i = 0; i &lt; strings.length; i++) &#123;<br>    result += strings[i];<br>    if (i &lt; values.length) &#123;<br>      result += String(values[i])<br>        .replace(/&amp;/g, &quot;&amp;amp;&quot;)<br>        .replace(/&lt;/g, &quot;&amp;lt;&quot;);<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br>const userInput = &quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;<br>safeHtml`&lt;div&gt;$&#123;userInput&#125;&lt;/div&gt;`; // 转义后输出<br></code></pre></td></tr></table></figure>

<p><strong>国际化（i18n）</strong>：动态翻译。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">i18n<span class="hljs-string">`Welcome to <span class="hljs-subst">$&#123;siteName&#125;</span>. You have <span class="hljs-subst">$&#123;<span class="hljs-built_in">count</span>&#125;</span> messages.`</span>;<br></code></pre></td></tr></table></figure>

<p><strong>样式组件</strong>（如 styled-components）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Button = styled.button`<br>  color: $&#123;props =&gt; props.primary ? &#x27;white&#x27; : &#x27;black&#x27;&#125;;<br>`;<br></code></pre></td></tr></table></figure>

<p><strong>原始字符串</strong>：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">-  通过  ` strings.raw `  获取未转义的原始内容（如保留  ` \n `  而非换行）。 <br>function showRaw(strings) &#123;<br>  <span class="hljs-keyword">return</span> strings.raw[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br>&#125;<br>showRaw`Hello\nWorld`; // <span class="hljs-string">&quot;Hello\\nWorld&quot;</span>（实际输出包含两个反斜杠）<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>返回值灵活性</strong>：<ul>
<li>可返回任意类型（字符串、对象、组件等）。</li>
</ul>
</li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>模板字符串</strong></th>
<th><strong>标签模板字符串</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>语法</strong></td>
<td>反引号包裹 <code>$&#123;&#125;</code><br>插值</td>
<td>函数名后跟模板字符串</td>
</tr>
<tr>
<td><strong>多行支持</strong></td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>插值处理</strong></td>
<td>自动转换为字符串</td>
<td>由标签函数自定义处理</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>动态字符串拼接、多行文本</td>
<td>HTML 转义、国际化、DSL、样式组件等</td>
</tr>
<tr>
<td><strong>原始字符串访问</strong></td>
<td>无</td>
<td>通过 <code>strings.raw</code><br>获取</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>字符串</td>
<td>任意类型（由标签函数决定）</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：模板字符串简化了字符串拼接和多行处理，而标签模板字符串通过自定义函数扩展了其功能，适用于安全转义、国际化、DSL 等复杂场景。</p>
<h5 id="深浅拷贝理解"><a href="#深浅拷贝理解" class="headerlink" title="深浅拷贝理解"></a>深浅拷贝理解</h5><p>在JavaScript中，对象的拷贝分为<strong>浅拷贝</strong>和<strong>深拷贝</strong>，主要区别在于对引用类型数据的处理方式。</p>
<h6 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h6><p><strong>特点</strong>：仅复制对象的顶层属性，若属性是引用类型（如对象、数组），则拷贝的是内存地址（新旧对象共享嵌套的引用类型数据）。</p>
<p><strong>实现方式：</strong></p>
<ol>
<li><strong>展开运算符</strong> <code>** ... **</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;<br>const shallowCopy = &#123; ...obj &#125;;<br></code></pre></td></tr></table></figure>

<ol>
<li><code>** Object.assign() **</code></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">const shallowCopy = Object.assign(&#123;&#125;, obj);<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>数组方法</strong>（如 <code>slice()</code>、<code>concat()</code>、展开运算符）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const arr = [1, &#123; x: 2 &#125;];<br>const shallowArr = arr.slice();<br>const shallowArr2 = [...arr];<br></code></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<p>修改嵌套的引用类型数据会影响原对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">shallowCopy.b.c = 3;<br>console.log(obj.b.c); // 3（原对象被修改）<br></code></pre></td></tr></table></figure>



<h6 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h6><p><strong>特点</strong>：完全复制对象及其嵌套的引用类型数据，新旧对象完全独立。</p>
<p><strong>实现方式：</strong></p>
<ol>
<li><code>** JSON.parse(JSON.stringify(obj)) **</code>   局限：<ol>
<li>无法处理函数、<code>undefined</code>、<code>Symbol</code>。</li>
<li>日期对象会被转为字符串。</li>
<li>循环引用会报错。</li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">const deepCopy = JSON.parse(JSON.stringify(obj));<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>递归实现</strong>   基础版本（未处理特殊对象和循环引用）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs plain">function deepClone(obj) &#123;<br>      if (obj === null || typeof obj !== &quot;object&quot;) return obj;<br>      const clone = Array.isArray(obj) ? [] : &#123;&#125;<br>      for (const key in obj) &#123;<br>        if(obj.hasOwnProperty(key))&#123;<br>          clone[key] = deepClone(obj[key])<br>        &#125;<br>      &#125;<br>      return clone<br>    &#125;<br><br>    const info = &#123;<br>      name: &#x27;MirZ&#x27;,<br>      age: 18,<br>      friend: &#123;<br>        name: &#x27;LadyJ&#x27;,<br>        address: &#123;<br>          detail: &#x27;郑州&#x27;,<br>          goHome: function () &#123;<br>            console.log(&#x27;go郑州&#x27;);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    const newInfo = deepClone(info)<br>    newInfo.friend.name = &#x27;LadyY&#x27;<br>    newInfo.friend.address.detail = &#x27;安徽&#x27;<br>    //此处函数未被深拷贝,而是指向了一个新的函数,所以不影响原函数的指向<br>    newInfo.friend.address.goHome = function () &#123;<br>      console.log(&#x27;go安徽&#x27;);<br>    &#125;<br><br>    console.log(info);<br>    info.friend.address.goHome()<br>    console.log(newInfo);<br>    newInfo.friend.address.goHome()<br>    //如有set,map,symbol需进一步处理<br> function deepClone(obj) &#123;<br>      // 如果值是Symbol的类型<br>      if (typeof obj === &quot;symbol&quot;) &#123;<br>        return Symbol(obj.description)<br>      &#125;<br>      // 如果是set类型,map也进行类似处理<br>      if (obj instanceof Set) &#123;<br>        const newSet = new Set()<br>        for (const setItem of obj) &#123;<br>          newSet.add(deepCopy(setItem))<br>        &#125;<br>        return newSet<br>      &#125;<br>      if (obj === null || typeof obj !== &quot;object&quot;) return obj;<br>      const clone = Array.isArray(obj) ? [] : &#123;&#125;<br>      //此处只会遍历key,不会遍历symbol[key]<br>      for (const key in obj) &#123;<br>        if (obj.hasOwnProperty(key)) &#123;<br>          clone[key] = deepClone(obj[key])<br>        &#125;<br>      &#125;<br>      // 单独遍历symbol<br>      const symbolKeys = Object.getOwnPropertySymbols(obj)<br>      for (const symbolKey of symbolKeys) &#123;<br>        clone[Symbol(symbolKey.description)] = deepCopy(obj[symbolKey])<br>      &#125;<br><br>      return clone<br>    &#125;<br><br>    const info = &#123;<br>      name: &#x27;MirZ&#x27;,<br>      age: 18,<br>      friend: &#123;<br>        name: &#x27;LadyJ&#x27;,<br>        address: &#123;<br>          detail: &#x27;郑州&#x27;,<br>          goHome: function () &#123;<br>            console.log(&#x27;go郑州&#x27;);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    const newInfo = deepClone(info)<br>    newInfo.friend.name = &#x27;LadyY&#x27;<br>    newInfo.friend.address.detail = &#x27;安徽&#x27;<br>    //此处函数未被深拷贝,而是指向了一个新的函数,所以不影响原函数的指向<br>    newInfo.friend.address.goHome = function () &#123;<br>      console.log(&#x27;go安徽&#x27;);<br>    &#125;<br><br>    console.log(info);<br>    info.friend.address.goHome()<br>    console.log(newInfo);<br>    newInfo.friend.address.goHome()<br></code></pre></td></tr></table></figure>

<p><strong>处理循环引用和特殊对象</strong>   使用 <code>WeakMap</code> 缓存已拷贝对象，并处理 <code>Date</code>、<code>RegExp</code> 等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">function deepClone(obj, hash = new WeakMap()) &#123;<br>     if (obj === null || typeof obj !== &quot;object&quot;) return obj;<br>     //判断此次深拷贝的对象是否在hash中存在,如果存在直接返回<br>     if (hash.has(obj)) return hash.get(obj);<br><br>     let clone;<br>     if (obj instanceof Date) &#123;<br>       clone = new Date(obj.getTime());<br>     &#125; else if (obj instanceof RegExp) &#123;<br>       clone = new RegExp(obj.source, obj.flags);<br>     &#125; else &#123;<br>       clone = Array.isArray(obj) ? [] : &#123;&#125;;<br>     &#125;<br>     //根据obj存储clone<br>     hash.set(obj, clone);<br>     for (let key in obj) &#123;<br>       if (obj.hasOwnProperty(key)) &#123;<br>         clone[key] = deepClone(obj[key], hash);<br>       &#125;<br>     &#125;<br>     return clone;<br>   &#125;<br><br>   const info = &#123;<br>     name: &#x27;MirZ&#x27;,<br>     age: 18<br>   &#125;<br>   info.self = info<br>   console.log(info);<br>   const newInfo = deepClone(info)<br>   newInfo.name = &#x27;MIRZ&#x27;<br>   console.log(newInfo);<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>第三方库</strong>   使用 <code>lodash</code> 的 <code>_.cloneDeep()</code>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">import _ from &quot;lodash&quot;;<br>const deepCopy = _.cloneDeep(obj);<br></code></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ul>
<li><strong>浅拷贝</strong>：适用于对象结构简单，无嵌套引用或明确无需隔离的场景。</li>
<li><strong>深拷贝</strong>：适用于对象结构复杂，需完全隔离新旧对象的场景（如状态管理、数据持久化）。</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>循环引用</strong>：递归深拷贝需使用缓存（如 <code>WeakMap</code>）避免无限递归。</li>
<li><strong>特殊对象</strong>：如 <code>Date</code>、<code>RegExp</code>、<code>Set</code>、<code>Map</code> 等需单独处理。</li>
<li><strong>性能</strong>：深拷贝对大型对象可能有性能开销，需权衡使用。</li>
</ol>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>JavaScript 中的 <strong>Symbol</strong> 是 ES6 引入的一种新的原始数据类型，用于表示唯一的标识符。</p>
<p><strong>1. Symbol 的基本特性</strong></p>
<p><strong>唯一性</strong>：每个 Symbol 都是唯一的，即使描述相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">let sym1 = Symbol(&#x27;key&#x27;);<br>let sym2 = Symbol(&#x27;key&#x27;);<br>console.log(sym1 === sym2); // false<br></code></pre></td></tr></table></figure>

<p><strong>原始类型</strong>：不能使用 <code>new</code> 创建，直接调用 <code>Symbol()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">let sym = Symbol(); // 正确<br>let err = new Symbol(); // TypeError<br></code></pre></td></tr></table></figure>

<p><strong>描述参数</strong>：用于调试，不影响唯一性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">console.log(Symbol(&#x27;desc&#x27;).toString()); // Symbol(desc)<br></code></pre></td></tr></table></figure>

<p><strong>2. Symbol 作为对象属性</strong></p>
<p><strong>定义属性</strong>：用方括号语法 <code>[]</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const sym = Symbol(&#x27;key&#x27;);<br>const obj = &#123;<br>    [sym]: &#x27;value&#x27;<br>&#125;;<br>console.log(obj[sym]); // &#x27;value&#x27;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>不可枚举性</strong>：Symbol 属性不会被常规方法遍历（如 <code>for...in</code>、<code>Object.keys()</code>）。<ul>
<li>获取 Symbol 属性：使用 <code>Object.getOwnPropertySymbols()</code>。</li>
<li>反射方法：<code>Reflect.ownKeys()</code> 返回所有键（包括 Symbol）。</li>
</ul>
</li>
</ul>
<p><strong>3. 全局 Symbol 注册表</strong></p>
<p><strong>共享 Symbol</strong>：通过 <code>Symbol.for(key)</code> 创建或获取全局 Symbol。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const sym1 = Symbol.for(&#x27;globalKey&#x27;);<br>const sym2 = Symbol.for(&#x27;globalKey&#x27;);<br>console.log(sym1 === sym2); // true<br></code></pre></td></tr></table></figure>

<p><strong>查询全局键</strong>：<code>Symbol.keyFor(sym)</code> 返回 Symbol 的全局键。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">console.log(Symbol.keyFor(sym1)); // &#x27;globalKey&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>4. 内置 Symbol 值</strong></p>
<p>用于修改对象的默认行为，常见内置 Symbol：</p>
<p><strong>Symbol.iterator</strong>：定义对象的迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const iterable = &#123;<br>    [Symbol.iterator]: function* () &#123; yield 1; yield 2; &#125;<br>&#125;;<br>console.log([...iterable]); // [1, 2]<br></code></pre></td></tr></table></figure>

<p><strong>Symbol.toStringTag</strong>：定制 <code>toString()</code> 输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; [Symbol.toStringTag]: &#x27;MyObject&#x27; &#125;;<br>console.log(obj.toString()); // [object MyObject]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Symbol.hasInstance</strong>：自定义 <code>instanceof</code> 行为。</li>
</ul>
<p><strong>5. 应用场景</strong></p>
<p><strong>唯一属性名</strong>：避免对象属性名冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const cacheKey = Symbol(&#x27;cache&#x27;);<br>function getData(obj) &#123;<br>    if (!obj[cacheKey]) &#123;<br>        obj[cacheKey] = computeExpensiveValue();<br>    &#125;<br>    return obj[cacheKey];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>模拟私有属性</strong>：通过 Symbol 隐藏属性（非绝对私有，但需主动获取)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const _private = Symbol(&#x27;private&#x27;);<br>class MyClass &#123;<br>    constructor() &#123; this[_private] = &#x27;secret&#x27;; &#125;<br>    getSecret() &#123; return this[_private]; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>自定义语言行为</strong>：如迭代、类型转换等。</p>
<p><strong>6. 注意事项</strong></p>
<ul>
<li><strong>类型转换</strong>：<ul>
<li>Symbol 不能隐式转字符串（需显式调用 <code>.toString()</code> 或 <code>String()</code>）。</li>
<li>可转换为布尔值（始终为 <code>true</code>）。</li>
</ul>
</li>
<li><strong>序列化</strong>：Symbol 属性不会被 <code>JSON.stringify()</code> 处理。</li>
<li><strong>兼容性</strong>：ES6+ 支持，旧环境需通过 Babel 等工具转译。</li>
</ul>
<p><strong>总结</strong></p>
<p>Symbol 的主要用途是提供唯一的标识符，解决命名冲突，并允许开发者介入 JavaScript 的内部行为。合理使用 Symbol 可以提升代码的健壮性和扩展性，但需注意其不可枚举性和转换规则。</p>
<h5 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set-Map"></a>Set-Map</h5><p>Set和Map都是ES6引入的，用来处理复杂的数据集合</p>
<h6 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h6><p><strong>基本特性</strong></p>
<ul>
<li><strong>成员唯一性</strong>：自动去重，值不能重复（基于 <code>===</code>，但 <code>NaN</code> 视为相等）。</li>
<li><strong>无序性</strong>：元素无插入顺序概念，但实际迭代时按插入顺序遍历。</li>
<li><strong>键与值相同</strong>：<code>Set</code> 的键和值相等，即 <code>key === value</code>。</li>
</ul>
<p><strong>创建与操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const set = new Set();<br>set.add(1);       // 添加元素<br>set.add(2).add(3); // 链式调用<br>set.delete(1);    // 删除元素，返回布尔值表示是否成功<br>set.has(2);       // 检查存在性，返回 true/false<br>set.size;         // 获取元素数量<br>set.clear();      // 清空集合<br></code></pre></td></tr></table></figure>

<p><strong>迭代方法</strong></p>
<ul>
<li><code>keys()</code>、<code>values()</code>：返回迭代器（因为键值相同，两者等价）。</li>
<li><code>entries()</code>：返回 <code>[value, value]</code> 的迭代器。</li>
<li><code>forEach()</code>：遍历元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (const item of set) &#123; /* 直接迭代 */ &#125;<br>set.forEach(v =&gt; console.log(v));<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li><strong>数组去重</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const arr = [1, 2, 2, 3];<br>//const uniqueArr = Array.from(new Set(arr)) // [1, 2, 3]<br>const uniqueArr = [...new Set(arr)]; // [1, 2, 3]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>集合运算</strong>（交集、并集、差集）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 交集<br>const intersection = new Set([...setA].filter(x =&gt; setB.has(x)));<br>// 并集<br>const union = new Set([...setA, ...setB]);<br>// 差集（A - B）<br>const difference = new Set([...setA].filter(x =&gt; !setB.has(x)));<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>临时存储唯一值</strong>：用于快速检查元素是否存在。</li>
</ul>
<h6 id="2-Map（映射）"><a href="#2-Map（映射）" class="headerlink" title="2. Map（映射）"></a>2. Map（映射）</h6><p><strong>基本特性</strong></p>
<ul>
<li><strong>键值对结构</strong>：存储键值对的集合，键可以是任意类型（对象、函数等）。</li>
<li><strong>有序性</strong>：元素按插入顺序迭代。</li>
<li><strong>高效查找</strong>：基于哈希表实现，查找速度接近 O(1)。</li>
</ul>
<p><strong>创建与操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const map = new Map();<br>map.set(&#x27;key1&#x27;, &#x27;value1&#x27;); // 添加键值对<br>map.set(&#123;&#125;, &#x27;objectKey&#x27;);  // 对象作为键<br>map.get(&#x27;key1&#x27;);           // 获取值，若不存在返回 undefined<br>map.has(&#x27;key1&#x27;);           // 检查键是否存在<br>map.delete(&#x27;key1&#x27;);        // 删除键值对<br>map.size;                  // 获取键值对数量<br>map.clear();               // 清空映射<br></code></pre></td></tr></table></figure>

<p><strong>迭代方法</strong></p>
<ul>
<li><code>keys()</code>：返回键的迭代器。</li>
<li><code>values()</code>：返回值的迭代器。</li>
<li><code>entries()</code>：返回 <code>[key, value]</code> 的迭代器（默认迭代方式）。</li>
<li><code>forEach()</code>：遍历键值对。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (const [key, value] of map) &#123; /* 迭代键值对 */ &#125;<br>map.forEach((value, key) =&gt; &#123; /* ... */ &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li><strong>复杂键存储</strong>：当键需要是非字符串类型时（如对象、函数）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const domNode = document.getElementById(&#x27;node&#x27;);<br>const map = new Map();<br>map.set(domNode, &#123; clickCount: 0 &#125;); // DOM 节点作为键<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>数据关联</strong>：维护键值对的动态关联关系（如缓存计算结果）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const cache = new Map();<br>function computeExpensiveValue(key) &#123;<br>    if (cache.has(key)) return cache.get(key);<br>    const result = /* 复杂计算 */;<br>    cache.set(key, result);<br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>有序存储</strong>：需要保留插入顺序的键值对集合。</li>
</ul>
<h6 id="3-WeakSet-与-WeakMap"><a href="#3-WeakSet-与-WeakMap" class="headerlink" title="3. WeakSet 与 WeakMap"></a>3. WeakSet 与 WeakMap</h6><p><strong>WeakSet</strong></p>
<ul>
<li><strong>弱引用集合</strong>：元素必须是对象，且不计入引用计数（不影响垃圾回收）。</li>
<li><strong>不可迭代</strong>：没有 <code>size</code>、<code>clear()</code> 或迭代方法。</li>
</ul>
<p><strong>用途</strong>：临时存储对象，避免内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const weakSet = new WeakSet();<br>let obj = &#123;&#125;;<br>weakSet.add(obj);<br></code></pre></td></tr></table></figure>

<p><strong>WeakMap</strong></p>
<ul>
<li><strong>弱引用键</strong>：键必须是对象，值可以是任意类型。</li>
<li><strong>不可迭代</strong>：同样没有 <code>size</code>、<code>clear()</code> 或迭代方法。</li>
</ul>
<p><strong>用途</strong>：存储对象的私有数据或元数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const weakMap = new WeakMap();<br>const obj = &#123;&#125;;<br>weakMap.set(obj, &#x27;privateData&#x27;);<br></code></pre></td></tr></table></figure>



<h6 id="4-Set-和-Map-的对比"><a href="#4-Set-和-Map-的对比" class="headerlink" title="4. Set 和 Map 的对比"></a>4. Set 和 Map 的对比</h6><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Set</strong></th>
<th><strong>Map</strong></th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>唯一值</td>
<td>键值对</td>
</tr>
<tr>
<td>键类型</td>
<td>值即键（任意类型）</td>
<td>键可以是任意类型</td>
</tr>
<tr>
<td>查找方式</td>
<td>直接检查值的存在性</td>
<td>通过键查找值</td>
</tr>
<tr>
<td>典型用途</td>
<td>去重、集合运算</td>
<td>复杂键存储、有序关联</td>
</tr>
</tbody></table>
<h6 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h6><p><strong>引用类型键的陷阱</strong>：对象作为键时，引用不同则视为不同键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const map = new Map();<br>map.set(&#123;&#125;, &#x27;value&#x27;);<br>console.log(map.get(&#123;&#125;)); // undefined（两个空对象引用不同）<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>性能优化</strong>：<code>Set</code> 和 <code>Map</code> 的查找速度（<code>has()</code>、<code>get()</code>）远快于数组的 <code>includes()</code>。</li>
<li><strong>序列化限制</strong>：<code>JSON.stringify()</code> 无法序列化 <code>Set</code> 和 <code>Map</code>，需手动转换。</li>
<li><strong>兼容性</strong>：ES6+ 支持，旧环境需使用 Babel 或 Polyfill（如 <code>core-js</code>）。</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>Set</strong>：处理唯一值集合，适合去重、集合运算。</li>
<li><strong>Map</strong>：处理键值对，适合复杂键类型或需要有序的场景。</li>
<li><strong>WeakSet&#x2F;WeakMap</strong>：弱引用特性适合临时存储或避免内存泄漏。</li>
</ul>
<h5 id="padStart和padEnd"><a href="#padStart和padEnd" class="headerlink" title="padStart和padEnd"></a>padStart和padEnd</h5><p><code>padStart</code> 和 <code>padEnd</code> 是 JavaScript 中用于字符串填充的方法，允许在字符串的开头或结尾添加字符，直到达到指定长度。以下是它们的详细说明和示例：</p>
<p><strong>1.</strong> <code>** padStart(targetLength, padString) **</code></p>
<ul>
<li><strong>作用</strong>：在字符串<strong>开头</strong>填充字符，直到字符串达到目标长度。</li>
<li><strong>参数</strong>：<ul>
<li><code>targetLength</code>：填充后的目标长度。</li>
<li><code>padString</code>（可选）：用于填充的字符串，默认为空格。</li>
</ul>
</li>
<li><strong>规则</strong>：<ul>
<li>若原字符串长度 ≥ <code>targetLength</code>，直接返回原字符串。</li>
<li>填充字符串 <code>padString</code> 会被重复使用，超出部分被截断。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;5&#x27;.padStart(3, &#x27;0&#x27;);       // &#x27;005&#x27;（填充到开头）<br>&#x27;hi&#x27;.padStart(5, &#x27;ab&#x27;);     // &#x27;abahi&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;abc&#x27;.padStart(6, &#x27;123&#x27;);   // &#x27;123abc&#x27;（填充 &#x27;123&#x27;）<br>&#x27;7&#x27;.padStart(4, &#x27;ab&#x27;);      // &#x27;aba7&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;test&#x27;.padStart(6);         // &#x27;  test&#x27;（默认用空格填充）<br></code></pre></td></tr></table></figure>

<p><strong>2.</strong> <code>** padEnd(targetLength, padString) **</code></p>
<ul>
<li><strong>作用</strong>：在字符串<strong>结尾</strong>填充字符，直到字符串达到目标长度。</li>
<li><strong>参数</strong>：同 <code>padStart</code>。</li>
<li><strong>规则</strong>：与 <code>padStart</code> 类似，但填充方向相反。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;5&#x27;.padEnd(3, &#x27;0&#x27;);         // &#x27;500&#x27;（填充到结尾）<br>&#x27;hi&#x27;.padEnd(5, &#x27;ab&#x27;);       // &#x27;hiaba&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;abc&#x27;.padEnd(6, &#x27;123&#x27;);     // &#x27;abc123&#x27;（填充 &#x27;123&#x27;）<br>&#x27;7&#x27;.padEnd(4, &#x27;ab&#x27;);        // &#x27;7aba&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;test&#x27;.padEnd(6);           // &#x27;test  &#x27;（默认用空格填充）<br></code></pre></td></tr></table></figure>

<p><strong>关键注意事项：</strong></p>
<p><strong>填充字符串的重复与截断</strong>：   若 <code>padString</code> 长度不足，会重复拼接直到满足目标长度，超出部分被截断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;12&#x27;.padStart(5, &#x27;abc&#x27;);  // &#x27;abc12&#x27;（填充 &#x27;abc&#x27;）<br>&#x27;12&#x27;.padEnd(5, &#x27;abc&#x27;);    // &#x27;12abc&#x27;（填充 &#x27;abc&#x27;）<br></code></pre></td></tr></table></figure>

<p><strong>空字符串或省略参数</strong>：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-  省略    <span class="hljs-string">` padString `</span>    时，默认用空格填充。 <br>-  若  <span class="hljs-string">` padString `</span>  为空字符串，无法填充，直接返回原字符串。 <br><span class="hljs-string">&#x27;5&#x27;</span>.padStart(<span class="hljs-number">3</span>);          <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;  5&#x27;</span>（默认空格）<br><span class="hljs-string">&#x27;5&#x27;</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;&#x27;</span>);      <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;5&#x27;</span>（无填充）<br></code></pre></td></tr></table></figure>

<p><strong>目标长度小于原字符串</strong>：   直接返回原字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;hello&#x27;.padStart(3, &#x27;0&#x27;); // &#x27;hello&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p><strong>场景 1：隐藏手机号中间四位</strong></p>
<p>将手机号 <code>13812341234</code> 转换为 <code>138****1234</code>，保留前 3 位和后 4 位，中间填充 <code>****</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizePhone(phone) &#123;<br>  const visiblePrefix = 3; // 显示前 3 位<br>  const visibleSuffix = 4; // 显示后 4 位<br>  const prefix = phone.slice(0, visiblePrefix);<br>  const suffix = phone.slice(-visibleSuffix);<br>  // 中间填充 *，总长度与原手机号一致<br>  return prefix + suffix.padStart(phone.length - visiblePrefix, &#x27;*&#x27;);<br>&#125;<br><br>desensitizePhone(&#x27;13812341234&#x27;); // &#x27;138****1234&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>场景 2：隐藏身份证号前 14 位</strong></p>
<p>将身份证号 <code>110101199003077654</code> 转换为 <code>************7654</code>，只显示后 4 位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizeID(id) &#123;<br>  const visibleDigits = 4; // 显示后 4 位<br>  const suffix = id.slice(-visibleDigits);<br>  // 前部填充 *，总长度与原身份证号一致<br>  return suffix.padStart(id.length, &#x27;*&#x27;);<br>&#125;<br><br>desensitizeID(&#x27;110101199003077654&#x27;); // &#x27;************7654&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>场景 3：隐藏银行卡号中间部分</strong></p>
<p>将银行卡号 <code>6225880134567890</code> 转换为 <code>622588******7890</code>，保留前 6 位和后 4 位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizeBankCard(card) &#123;<br>  const visiblePrefix = 6; // 显示前 6 位<br>  const visibleSuffix = 4; // 显示后 4 位<br>  const prefix = card.slice(0, visiblePrefix);<br>  const suffix = card.slice(-visibleSuffix);<br>  // 中间填充 *，总长度与原卡号一致<br>  return prefix + &#x27;*&#x27;.repeat(card.length - visiblePrefix - visibleSuffix) + suffix;<br>&#125;<br><br>desensitizeBankCard(&#x27;6225880134567890&#x27;); // &#x27;622588******7890&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>场景 4：格式化短文本敏感信息</strong></p>
<p>将用户昵称 <code>Alice</code> 转换为 <code>**ice</code>，隐藏前 2 位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizeShortText(text, hideLength = 2) &#123;<br>  const visiblePart = text.slice(hideLength);<br>  return visiblePart.padStart(text.length, &#x27;*&#x27;);<br>&#125;<br><br>desensitizeShortText(&#x27;Alice&#x27;, 2); // &#x27;**ice&#x27;<br></code></pre></td></tr></table></figure>

<p><strong>关键逻辑总结</strong></p>
<ol>
<li><strong>截取保留部分</strong>：通过 <code>slice</code> 截取需要显示的头&#x2F;尾部分。</li>
<li><strong>填充敏感符号</strong>：使用 <code>padStart</code> 或 <code>padEnd</code> 填充 <code>*</code>，确保总长度与原数据一致。</li>
<li><strong>动态适配长度</strong>：根据输入数据的实际长度动态计算填充位数，避免硬编码。</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li><strong>输入合法性校验</strong>：需确保输入是字符串且长度合法（如身份证 18 位、手机号 11 位）。</li>
<li><strong>边界处理</strong>：若保留位数超过原数据长度，直接返回全隐藏（如 <code>&#39;*&#39;.repeat(text.length)</code>）。</li>
<li><strong>扩展性</strong>：可通过参数控制隐藏的位数和填充符号，适配不同场景。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><code>** padStart **</code>：向前填充，适用于左对齐或补前置字符（如日期补零）。</li>
<li><code>** padEnd **</code>：向后填充，适用于右对齐或补后缀字符（如固定格式文本）。</li>
<li>处理填充字符串时，注意重复和截断逻辑，避免结果与预期不符。</li>
</ul>
<h5 id="flat和flatMap"><a href="#flat和flatMap" class="headerlink" title="flat和flatMap"></a>flat和flatMap</h5><p><code>flat()</code> 和 <code>flatMap()</code> 是 JavaScript 中用于处理数组的两种方法，专门用于简化嵌套数组的结构或结合映射（<code>map</code>）与扁平化（<code>flat</code>）操作。</p>
<p><strong>1.</strong> <code>** flat(depth) **</code></p>
<p><strong>作用</strong>：将嵌套的数组“扁平化”，返回一个包含所有子数组元素的新数组。   <strong>参数</strong>：</p>
<ul>
<li><code>depth</code>（可选）：指定要扁平化的嵌套层数，默认值为 <code>1</code>。若需完全扁平化，可设为 <code>Infinity</code>。   <strong>返回值</strong>：新数组（原数组不会被修改）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 默认扁平化一层<br>const arr1 = [1, [2, 3], [4, [5]]];<br>console.log(arr1.flat());        // [1, 2, 3, 4, [5]]<br><br>// 完全扁平化（无限层）<br>console.log(arr1.flat(Infinity)); // [1, 2, 3, 4, 5]<br><br>// 处理空位（自动跳过空值）<br>const arr2 = [1, , 3];<br>console.log(arr2.flat());         // [1, 3]<br></code></pre></td></tr></table></figure>

<p><strong>2.</strong> <code>** flatMap(callback) **</code></p>
<p><strong>作用</strong>：先对数组的每个元素执行 <code>map</code> 操作，然后对结果扁平化一层。   <strong>参数</strong>：</p>
<ul>
<li><code>callback</code>：一个函数，用于处理每个元素，返回一个数组（或其他可迭代对象）。   <strong>返回值</strong>：新数组（原数组不会被修改）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 基本用法（等效于 map + flat(1)）<br>const arr = [1, 2, 3];<br>const result = arr.flatMap((x) =&gt; [x, x * 2]);<br>console.log(result); // [1, 2, 2, 4, 3, 6]<br><br>// 处理非数组返回值（自动包装为数组）<br>const words = [&quot;hello&quot;, &quot;world&quot;];<br>console.log(words.flatMap(word =&gt; word.split(&quot;&quot;))); <br>// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]<br><br>// 过滤并展开数据<br>const data = [<br>  &#123; id: 1, values: [10, 20] &#125;,<br>  &#123; id: 2, values: [30] &#125;,<br>];<br>console.log(data.flatMap(item =&gt; item.values)); // [10, 20, 30]<br></code></pre></td></tr></table></figure>

<p><strong>对比</strong> <code>** flatMap **</code> <strong>与</strong> <code>** map + flat **</code></p>
<p>以下两种写法等价，但 <code>flatMap</code> 更简洁高效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 使用 flatMap<br>arr.flatMap((x) =&gt; [x, x * 2]);<br><br>// 等效于 map + flat<br>arr.map((x) =&gt; [x, x * 2]).flat();<br></code></pre></td></tr></table></figure>

<p><strong>关键注意事项</strong></p>
<ol>
<li><strong>扁平化层级</strong>：<ul>
<li><code>flat()</code> 可指定层级，默认 <code>1</code>；<code>flatMap()</code> 仅扁平化一层。</li>
</ul>
</li>
</ol>
<p>若需完全扁平化 <code>flatMap</code> 的结果，需额外调用 <code>flat()</code>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-code">`arr.flatMap(fn).flat(Infinity);`</span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong>空值处理</strong>：<ul>
<li><code>flat()</code> 会自动跳过数组中的空位（如 <code>[1, , 3]</code>）。</li>
</ul>
</li>
</ol>
<p><code>flatMap()</code> 的回调函数若返回空数组 <code>[]</code>，会直接过滤该元素：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">- `[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].flatMap(<span class="hljs-variable language_">x</span> =&gt; <span class="hljs-variable language_">x</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? [] : [<span class="hljs-variable language_">x</span>]); <span class="hljs-comment">// [1, 3]`</span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong>性能优化</strong>：<ul>
<li><code>flatMap()</code> 比先 <code>map</code> 后 <code>flat</code> 更高效，因为它减少了一次完整数组遍历。</li>
</ul>
</li>
</ol>
<p><strong>使用场景</strong></p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>flat()</code></td>
<td>多层嵌套数组的扁平化（如树形结构数据、API 返回的嵌套结果）。</td>
</tr>
<tr>
<td><code>flatMap()</code></td>
<td>需要同时映射并扁平化的场景（如展开子数组、过滤后展开、拆分字符串等）。</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><code>** flat() **</code>：专为简化嵌套数组设计，支持指定层级。</li>
<li><code>** flatMap() **</code>：结合 <code>map</code> 和 <code>flat</code>，适合需要“映射后立即扁平化”的场景。</li>
<li>两者均返回新数组，不会修改原数组。</li>
</ul>
<h5 id="FinalizationRegistry"><a href="#FinalizationRegistry" class="headerlink" title="FinalizationRegistry"></a>FinalizationRegistry</h5><p>FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调。</p>
<p>FinalizationRegistry 提供了这样的一种方法:当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。(清理回调有时被称为-fnalizer);</p>
<p>你可以通过调用register方法，注册任何你想要清理回调的对象传入该对象和所含的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br>    let obj = &#123; name: &quot;why&quot;, age: 18 &#125;<br>    let info = &#123; name: &quot;kobe&quot;, age: 30 &#125;<br><br>    const finalRegistry = new FinalizationRegistry((value) =&gt; &#123;<br>      console.log(&quot;某一个对象被回收了:&quot;, value)<br>    &#125;)<br><br>    finalRegistry.register(obj, &quot;why&quot;)<br>    finalRegistry.register(info, &quot;kobe&quot;)<br><br>    // obj = null<br>    info = null<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>





<h5 id="WeakRefs"><a href="#WeakRefs" class="headerlink" title="WeakRefs"></a>WeakRefs</h5><p>如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用:</p>
<p>如果我们希望是一个弱引用的话可以使用WeakRef;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> info = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(info)</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(info)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> finalRegistry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;对象被回收~&quot;</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    finalRegistry.<span class="hljs-title function_">register</span>(info, <span class="hljs-string">&quot;info&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      info = <span class="hljs-literal">null</span></span><br><span class="language-javascript">    &#125;, <span class="hljs-number">2000</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">deref</span>().<span class="hljs-property">name</span>, obj.<span class="hljs-title function_">deref</span>().<span class="hljs-property">age</span>)</span><br><span class="language-javascript">    &#125;, <span class="hljs-number">8000</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>







<h4 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy-Reflect"></a>Proxy-Reflect</h4><p><strong>Proxy</strong> 和 <strong>Reflect</strong> 是 ES6 引入的元编程工具，允许开发者拦截和自定义对象的基本操作。</p>
<h5 id="监听对象属性操作方法"><a href="#监听对象属性操作方法" class="headerlink" title="监听对象属性操作方法"></a>监听对象属性操作方法</h5><p>使用Object.defineProperty(vue2响应式原理),存储数据描述符设计的初衷并不是为了去监听一个完整的对象</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 需求: 监听对象属性的所有操作</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 监听属性的操作</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.针对一个属性</span></span><br><span class="language-javascript">    <span class="hljs-comment">// let _name = obj.name</span></span><br><span class="language-javascript">    <span class="hljs-comment">// Object.defineProperty(obj, &quot;name&quot;, &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   set: function(newValue) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     console.log(&quot;监听: 给name设置了新的值:&quot;, newValue)</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     _name = newValue</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   get: function() &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     console.log(&quot;监听: 获取name的值&quot;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     return _name</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   &#125;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2.监听所有的属性: 遍历所有的属性, 对每一个属性使用defineProperty</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> value = obj[key]</span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 给<span class="hljs-subst">$&#123;key&#125;</span>设置了新的值:`</span>, newValue)</span><br><span class="language-javascript">          value = newValue</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 获取<span class="hljs-subst">$&#123;key&#125;</span>的值`</span>)</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> value</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(obj.name)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// obj.name = &quot;kobe&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)</span><br><span class="language-javascript">    obj.<span class="hljs-property">age</span> = <span class="hljs-number">17</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 什么是响应式?</span></span><br><span class="language-javascript">    <span class="hljs-comment">// const nameEl = document.querySelector(&quot;.name&quot;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// nameEl.textContent = obj.name</span></span><br><span class="language-javascript">    <span class="hljs-comment">// obj.name = &quot;kobe&quot;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// obj.name = &quot;james&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>创建一个代理对象(Proxy对象)之后对该对象的所有操作，都通过代理对象来完成,代理对象可以监听我们想要对原对象进行哪些操作</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.创建一个Proxy对象</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, newValue</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 监听<span class="hljs-subst">$&#123;key&#125;</span>的设置值: `</span>, newValue)</span><br><span class="language-javascript">        target[key] = newValue</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 监听<span class="hljs-subst">$&#123;key&#125;</span>的获取`</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> target[key]</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2.对obj的所有操作, 应该去操作objProxy</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(objProxy.name)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// objProxy.name = &quot;kobe&quot;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(objProxy.name)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// objProxy.name = &quot;james&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    objProxy.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;广州市&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">address</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p><strong>Proxy</strong> 用于创建一个对象的代理，拦截并重新定义对象的底层操作（如属性读取、赋值等）。</p>
<p><strong>基本语法</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> newProxy=<span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>,<span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>target</strong>：被代理的目标对象。</li>
<li><strong>handler</strong>：定义拦截行为的对象，包含一组“陷阱”（trap）方法。</li>
</ul>
<p><strong>常用拦截方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>触发场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>get(target, prop, receiver)</code></td>
<td>读取属性时（如 <code>proxy.prop</code>）</td>
</tr>
<tr>
<td><code>set(target, prop, value, receiver)</code></td>
<td>设置属性时（如 <code>proxy.prop = value</code>）</td>
</tr>
<tr>
<td><code>has(target, prop)</code></td>
<td><code>in</code>操作符（如 <code>&#39;prop&#39; in proxy</code>）</td>
</tr>
<tr>
<td><code>deleteProperty(target, prop)</code></td>
<td><code>delete</code> 操作符（如 <code>delete proxy.prop</code>）</td>
</tr>
<tr>
<td><code>apply(target, thisArg, args)</code></td>
<td>函数调用（如 <code>proxy()</code>）</td>
</tr>
<tr>
<td><code>construct(target, args, newTarget)</code></td>
<td><code>new</code>操作符（如 <code>new Proxy()</code>）</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">const target = &#123; name: &quot;Alice&quot; &#125;;<br>const handler = &#123;<br>  get(target, prop) &#123;<br>    console.log(`读取属性：$&#123;prop&#125;`);<br>    return target[prop];<br>  &#125;,<br>  set(target, prop, value) &#123;<br>    console.log(`设置属性：$&#123;prop&#125; = $&#123;value&#125;`);<br>    target[prop] = value;<br>    return true; // 表示成功<br>  &#125;<br>&#125;;<br>const proxy = new Proxy(target, handler);<br><br>proxy.name; // 输出 &quot;读取属性：name&quot;，返回 &quot;Alice&quot;<br>proxy.age = 30; // 输出 &quot;设置属性：age = 30&quot;<br></code></pre></td></tr></table></figure>



<h5 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h5><p><strong>Reflect</strong> 是一个内置对象，提供与 Proxy 方法一一对应的方法，用于执行对象的默认行为。它的设计目的是简化 Proxy 的实现，并提供更规范的底层操作。</p>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>Reflect 方法</strong></th>
<th><strong>对应 Proxy 陷阱</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.get(target, prop, receiver)</code></td>
<td><code>get</code></td>
</tr>
<tr>
<td><code>Reflect.set(target, prop, value, receiver)</code></td>
<td><code>set</code></td>
</tr>
<tr>
<td><code>Reflect.has(target, prop)</code></td>
<td><code>has</code></td>
</tr>
<tr>
<td><code>Reflect.deleteProperty(target, prop)</code></td>
<td><code>deleteProperty</code></td>
</tr>
<tr>
<td><code>Reflect.apply(func, thisArg, args)</code></td>
<td><code>apply</code></td>
</tr>
<tr>
<td><code>Reflect.construct(target, args)</code></td>
<td><code>construct</code></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; a: 1 &#125;;<br>// 通过 Reflect 操作对象<br>Reflect.set(obj, &quot;b&quot;, 2); // obj 变为 &#123; a: 1, b: 2 &#125;<br>console.log(Reflect.get(obj, &quot;a&quot;)); // 输出 1<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  &lt;script&gt;<br>    function Person(name, age) &#123;<br>      this.name = name<br>      this.age = age<br>    &#125;<br><br>    function Student(name, age) &#123;<br>      // Person.call(this, name, age)<br><br>    &#125;<br>    // 属于Student类,实现自Person<br>    const stu = Reflect.construct(Person, [&#x27;MirZ&#x27;, 18], Student)<br>    console.log(stu)<br>    console.log(stu.__proto__ === Student.prototype)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>



<h5 id="Proxy-和-Reflect-的配合"><a href="#Proxy-和-Reflect-的配合" class="headerlink" title="Proxy 和 Reflect 的配合"></a>Proxy 和 Reflect 的配合</h5><p>在 Proxy 的方法中调用 Reflect 的对应方法，可确保保留对象的默认行为，同时添加自定义逻辑。</p>
<ul>
<li>不去直接操作原对象</li>
<li>reflect会返回boolean判断操作是否成功</li>
<li>reflect可以使用<code>receiver</code>正确传递this</li>
</ul>
<p><strong>典型模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const handler = &#123;<br>  get(target, prop, receiver) &#123;<br>    console.log(`读取属性：$&#123;prop&#125;`);<br>    return Reflect.get(...arguments); // 等效于 Reflect.get(target, prop, receiver)<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h5 id="this-绑定问题"><a href="#this-绑定问题" class="headerlink" title="this 绑定问题"></a>this 绑定问题</h5><p>直接操作 <code>target[prop]</code> 可能导致 <code>this</code> 指向错误，而 <code>Reflect.get(target, prop, receiver)</code> 能正确传递 <code>receiver</code>（通常是代理对象）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">const target = &#123;<br>  name: &quot;Alice&quot;,<br>  greet() &#123;<br>    console.log(`Hello, $&#123;this.name&#125;!`);<br>  &#125;<br>&#125;;<br>const handler = &#123;<br>  get(target, prop, receiver) &#123;<br>    return Reflect.get(target, prop, receiver); // 确保 this 指向代理<br>  &#125;<br>&#125;;<br>const proxy = new Proxy(target, handler);<br>proxy.greet(); // Hello, Alice!（若 name 被代理修改，此处会反映变化）<br></code></pre></td></tr></table></figure>



<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li><strong>数据校验</strong>：拦截 <code>set</code> 操作，验证属性值。</li>
<li><strong>日志记录</strong>：跟踪对象的读写操作。</li>
<li><strong>自动填充属性</strong>：访问不存在的属性时返回默认值。</li>
<li><strong>观察者模式</strong>：属性变化时触发回调。</li>
<li><strong>函数调用劫持</strong>：统计函数执行时间。</li>
</ol>
<p><strong>数据校验示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const validator = &#123;<br>  set(target, prop, value) &#123;<br>    if (prop === &quot;age&quot; &amp;&amp; typeof value !== &quot;number&quot;) &#123;<br>      throw new TypeError(&quot;Age must be a number!&quot;);<br>    &#125;<br>    return Reflect.set(target, prop, value);<br>  &#125;<br>&#125;;<br>const proxy = new Proxy(&#123;&#125;, validator);<br>proxy.age = 30; // 成功<br>proxy.age = &quot;30&quot;; // 抛出错误<br></code></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>性能</strong>：频繁拦截可能影响性能，需谨慎使用。</li>
<li><strong>兼容性</strong>：现代浏览器支持良好，旧环境可能需要 polyfill。</li>
</ul>
<p><strong>可撤销代理</strong>：通过 <code>Proxy.revocable()</code> 创建可取消的代理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);<br>revoke(); // 后续操作 proxy 将报错<br></code></pre></td></tr></table></figure>

<p>通过结合 <strong>Proxy</strong> 和 <strong>Reflect</strong>，开发者可以实现高度灵活的对象操作，增强代码的可控性和可维护性。</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是 JavaScript 中处理异步操作的核心机制。</p>
<p><strong>1. 三种状态</strong></p>
<ul>
<li><strong>Pending（待定）</strong>：初始状态，未完成或被拒绝。</li>
<li><strong>Fulfilled（已兑现）</strong>：操作成功完成，调用 <code>resolve(value)</code>。</li>
<li><strong>Rejected（已拒绝）</strong>：操作失败，调用 <code>reject(error)</code>。</li>
<li><strong>状态不可逆</strong>：一旦状态变为 Fulfilled 或 Rejected，将不再改变。</li>
</ul>
<p><strong>基本用法</strong></p>
<p>通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor,这个回调函数会被立即执行，并且给传入另外两个回调函数(resolve、reject)当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数:当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs plain">const promise = new Promise((resolve, reject) =&gt; &#123;<br>  // 异步操作（如 API 请求、定时器等）<br>  if (/* 成功 */) &#123;<br>    resolve(value); // 状态变为 Fulfilled<br>  &#125; else &#123;<br>    reject(error);  // 状态变为 Rejected<br>  &#125;<br>&#125;);<br>&lt;script&gt;<br>    const p = new Promise((resolve) =&gt; &#123;<br>      // setTimeout(resolve, 2000)<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;p的resolve&quot;)<br>      &#125;, 2000)<br>    &#125;)<br><br>    const promise = new Promise((resolve, reject) =&gt; &#123;<br>      // 1.普通值<br>      // resolve([<br>      //   &#123;name: &quot;macbook&quot;, price: 9998, intro: &quot;有点贵&quot;&#125;,<br>      //   &#123;name: &quot;iPhone&quot;, price: 9.9, intro: &quot;有点便宜&quot;&#125;,<br>      // ])<br><br>      // 2.resolve(promise)<br>      // 如果resolve的值本身Promise对象, 那么当前的Promise的状态会有传入的Promise来决定<br>      // resolve(p)<br><br>      // 3.resolve(thenable对象)<br>      resolve(&#123;<br>        name: &quot;kobe&quot;,<br>        //由then来决定<br>        then: function(resolve) &#123;<br>          resolve(11111)<br>        &#125;<br>      &#125;)<br>    &#125;)<br><br>    promise.then(res =&gt; &#123;<br>      console.log(&quot;then中拿到结果:&quot;, res)<br>    &#125;)<br><br>  &lt;/script&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    const promise = new Promise((resolve, reject) =&gt; &#123;<br>      resolve(&quot;aaaaaaa&quot;)<br>      // reject()<br>    &#125;)<br><br>    // 1.then方法是返回一个新的Promise, 这个新Promise的决议是等到then方法传入的回调函数有返回值时, 进行决议<br>    // Promise本身就是支持链式调用<br>    // then方法是返回一个新的Promise, 链式中的then是在等待这个新的Promise有决议之后执行的<br>    // promise.then(res =&gt; &#123;<br>    //   console.log(&quot;第一个then方法:&quot;, res)<br>    //   return &quot;bbbbbbbb&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;第二个then方法:&quot;, res)<br>    //   return &quot;cccccccc&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;第三个then方法:&quot;, res)<br>    // &#125;)<br><br>    // promise.then(res =&gt; &#123;<br>    //   console.log(&quot;添加第二个then方法:&quot;, res)<br>    // &#125;)<br><br>    // 2.then方法传入回调函数的返回值类型<br>    const newPromise = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;why&quot;)<br>      &#125;, 3000)<br>    &#125;)<br><br>    promise.then(res =&gt; &#123;<br>      console.log(&quot;第一个Promise的then方法:&quot;, res)<br>      // 1.普通值<br>      // return &quot;bbbbbbb&quot;<br>      // 2.新的Promise<br>      // return newPromise<br>      // 3.thenable的对象<br>      return &#123;<br>        then: function(resolve) &#123;<br>          resolve(&quot;thenable&quot;)<br>        &#125;<br>      &#125;<br>    &#125;).then(res =&gt; &#123;<br>      console.log(&quot;第二个Promise的then方法:&quot;, res) <br>    &#125;)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    const promise = new Promise((resolve, reject) =&gt; &#123;<br>      // reject(&quot;error: aaaaa&quot;)<br>      resolve(&quot;aaaaaa&quot;)<br>    &#125;)<br><br>    // 1.catch方法也会返回一个新的Promise<br>    // promise.catch(err =&gt; &#123;<br>    //   console.log(&quot;catch回调:&quot;, err)<br>    //   return &quot;bbbbb&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;then第一个回调:&quot;, res)<br>    //   return &quot;ccccc&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;then第二个回调:&quot;, res)<br>    // &#125;)<br><br>    // 2.catch方法的执行时机<br>    promise.then(res =&gt; &#123;<br>      console.log(&quot;then第一次回调:&quot;, res)<br>      // throw new Error(&quot;第二个Promise的异常error&quot;) <br>      return &quot;bbbbbb&quot;<br>    &#125;).then(res =&gt; &#123;<br>      console.log(&quot;then第二次回调:&quot;, res)<br>      throw new Error(&quot;第三个Promise的异常error&quot;)<br>    &#125;).then(res =&gt; &#123;<br>      console.log(&quot;then第三次回调:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;catch回调被执行:&quot;, err)<br>    &#125;)<br><br>    // 中断函数继续执行:<br>    // 方式一: return<br>    // 方式二: throw new Error()<br>    // 方式三: yield 暂停(暂时性的中断)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p><strong>2. 链式调用</strong></p>
<ul>
<li><code>** .then() **</code>：处理成功结果，可返回新值或 Promise。</li>
<li><code>** .catch() **</code>：捕获链中所有错误。</li>
<li><code>** .finally() **</code>：无论成功或失败都会执行，通常用于清理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">doSomething()<br>  .then(result =&gt; doSomethingElse(result))<br>  .then(newResult =&gt; doThirdThing(newResult))<br>  .catch(error =&gt; console.error(error))<br>  .finally(() =&gt; stopLoading());<br></code></pre></td></tr></table></figure>

<p><strong>3. 静态方法</strong></p>
<ul>
<li><code>** Promise.resolve(value) **</code>：返回一个已解决的 Promise。</li>
<li><code>** Promise.reject(error) **</code>：返回一个已拒绝的 Promise。</li>
<li><code>** Promise.all([p1, p2, ...]) **</code>：所有成功时返回结果数组；任一失败立即拒绝。</li>
<li><code>** Promise.race([p1, p2, ...]) **</code>：采用第一个完成（成功或失败）的 Promise 结果。</li>
<li><code>** Promise.allSettled([p1, p2, ...]) **</code>：等待所有完成，返回状态和结果数组。</li>
<li><code>** Promise.any([p1, p2, ...]) **</code>：任一成功则返回其值，全部失败则抛出 <code>AggregateError</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    // 创建三个Promise<br>    const p1 = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        // resolve(&quot;p1 resolve&quot;)<br>        reject(&quot;p1 reject error&quot;)<br>      &#125;, 3000)<br>    &#125;)<br><br>    const p2 = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;p2 resolve&quot;)<br>      &#125;, 2000)<br>    &#125;)<br>    <br>    const p3 = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;p3 resolve&quot;)<br>      &#125;, 5000)<br>    &#125;)<br><br>    // all:全部/所有 所有成功时返回结果数组；任一失败立即拒绝。<br>    Promise.all([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;all promise res:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;all promise err:&quot;, err)<br>    &#125;)<br><br>    <br>    //allSettled 等待所有完成，返回状态和结果数组。<br>    Promise.allSettled([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;all settled:&quot;, res)<br>    &#125;)<br><br>    // 类方法: race方法<br>    // 特点: 会等到一个Promise有结果(无论这个结果是fulfilled还是rejected)<br>    Promise.race([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;race promise:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;race promise err:&quot;, err)<br>    &#125;)<br><br>    <br>   // 类方法: any方法 任一成功则返回其值，全部失败则抛出 AggregateError。<br>    Promise.any([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;any promise res:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;any promise err:&quot;, err)<br>    &#125;)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p><strong>4. 错误处理</strong></p>
<ul>
<li><strong>隐式冒泡</strong>：链中未处理的错误会传递到最近的 <code>.catch()</code>。</li>
<li><strong>同步错误捕获</strong>：执行器函数中的同步错误自动触发拒绝。</li>
<li><strong>异步错误需显式拒绝</strong>：在异步回调（如 <code>setTimeout</code>）中需手动调用 <code>reject()</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 正确捕获异步错误<br>new Promise((resolve, reject) =&gt; &#123;<br>  setTimeout(() =&gt; &#123;<br>    reject(new Error(&quot;Async error&quot;));<br>  &#125;, 1000);<br>&#125;).catch(error =&gt; console.log(error));<br></code></pre></td></tr></table></figure>

<p><strong>5. 常见陷阱</strong></p>
<ul>
<li><strong>返回值缺失</strong>：<code>.then()</code> 中未 <code>return</code> 将导致后续接收 <code>undefined</code>。</li>
<li><strong>嵌套 Promise</strong>：避免嵌套，改用链式调用。</li>
<li><strong>未处理的拒绝</strong>：始终添加 <code>.catch()</code> 防止未捕获错误。</li>
</ul>
<p><strong>6. 与 async&#x2F;await 结合</strong></p>
<ul>
<li><code>** async **</code> ****<strong>函数</strong>：返回 Promise，可用 <code>await</code> 等待异步操作。</li>
<li><strong>错误处理</strong>：结合 <code>try/catch</code> 捕获异常。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function fetchData() &#123;<br>  try &#123;<br>    const data = await apiCall();<br>    const processed = await processData(data);<br>    console.log(processed);<br>  &#125; catch (error) &#123;<br>    console.error(&quot;Fetch failed:&quot;, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>7. 应用场景</strong></p>
<ul>
<li><strong>并行任务</strong>：<code>Promise.all</code> 处理多个独立异步操作。</li>
<li><strong>竞速请求</strong>：<code>Promise.race</code> 实现超时控制。</li>
<li><strong>顺序执行</strong>：链式调用逐个处理依赖任务的结果。</li>
</ul>
<p>掌握 Promise 的关键在于理解状态流转、链式调用机制及错误处理策略。结合 <code>async/await</code> 可进一步提升代码可读性，有效管理异步流程。</p>
<h4 id="Iterator-Generator-迭代器-生成器"><a href="#Iterator-Generator-迭代器-生成器" class="headerlink" title="Iterator-Generator(迭代器-生成器)"></a>Iterator-Generator(迭代器-生成器)</h4><p>在 JavaScript 中，<strong>迭代器（Iterator）</strong>、<strong>生成器</strong>（Generator）<strong>和可迭代对象</strong>（Iterable）是处理数据集合和异步编程的重要概念。</p>
<h5 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h5><p>迭代器_(iteratbr)，使用户在容器对象(container，例如链表或数组)上遍访的对象，使用该接口无需关心对象的内部实现细节。</p>
<ol>
<li><strong>定义</strong>   一个对象，必须实现 <code>** next() **</code> 方法，返回 <code>&#123; value: any, done: boolean &#125;</code>。</li>
</ol>
<p><strong>手动创建迭代器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createCounter(max) &#123;<br>  let count = 0;<br>  return &#123;<br>    next() &#123;<br>      return count &lt; max <br>        ? &#123; value: count++, done: false &#125; <br>        : &#123; done: true &#125;;<br>    &#125;<br>  &#125;;<br>&#125;<br><br>const counter = createCounter(3);<br>console.log(counter.next().value); // 0<br>console.log(counter.next().value); // 1<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>迭代器协议</strong>   任何对象只要实现了 <code>next()</code> 方法，符合返回 <code>&#123;value, done&#125;</code> 的规则，就是一个迭代器。</li>
</ol>
<h5 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象(Iterable)"></a>可迭代对象(Iterable)</h5><p><strong>定义</strong>   实现了 <code>** [Symbol.iterator]() **</code> 方法的对象，该方法返回一个<strong>迭代器</strong>。可被 <code>for...of</code> 遍历。</p>
<p><strong>常见内置可迭代对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>, <span class="hljs-title class_">String</span>, <span class="hljs-title class_">Map</span>, <span class="hljs-title class_">Set</span>, <span class="hljs-title class_">TypedArray</span>, <span class="hljs-variable language_">arguments</span>, <span class="hljs-title class_">NodeList</span> 等 <br></code></pre></td></tr></table></figure>

<p><strong>手动实现可迭代对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123;<br>      fri: [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;],<br>      [Symbol.iterator]() &#123;<br>        let num = 0;<br>        return &#123;<br>          next: () =&gt; &#123;<br>          //使用箭头函数,无this,上层作用域找this,找到顶层<br>            return num &lt;= this.fri.length ? &#123; done: false, value: this.fri[num++] &#125; : &#123; done: true &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    for (const o of obj) &#123;<br>      console.log(o);<br>    &#125;<br>    console.log(obj[Symbol.iterator]);<br>    console.log(obj[Symbol.iterator]());<br><br>    const iterFun = obj[Symbol.iterator]()<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>  const obj=&#123;<br>    name:&#x27;MirZ&#x27;,<br>    age:&#x27;18&#x27;,<br>    address:&#x27;河南&#x27;,<br>    [Symbol.iterator]()&#123;<br>      // const keys=Object.keys(this)<br>      // const values=Object.values(this)<br>      const entries=Object.entries(this)<br>      let count=0<br>      return&#123;<br>        next:()=&gt;&#123;<br>          return count&lt;entries.length?&#123;done:false,value:entries[count++]&#125;:&#123;done:true&#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  for (const element of obj) &#123;<br>    console.log(element);<br>    <br>  &#125;<br>class Person &#123;<br>      constructor(name, age, height, friends) &#123;<br>        this.name = name<br>        this.age = age<br>        this.height = height<br>        this.friends = friends<br>      &#125;<br><br>      // 实例方法<br>      running() &#123;&#125;<br>      [Symbol.iterator]() &#123;<br>        let index = 0<br>        const iterator = &#123;<br>          next: () =&gt; &#123;<br>            if (index &lt; this.friends.length) &#123;<br>              return &#123; done: false, value: this.friends[index++] &#125;<br>            &#125; else &#123;<br>              return &#123; done: true &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>        return iterator<br>      &#125;<br>    &#125;<br><br>    const p1 = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])<br>    const p2 = new Person(&quot;kobe&quot;, 30, 1.98, [&quot;curry&quot;, &quot;james&quot;, &quot;aonier&quot;, &quot;weide&quot;])<br><br>    for (const item of p2) &#123;<br>      console.log(item)<br>    &#125;<br>class Person &#123;<br>      constructor(name, age, height, friends) &#123;<br>        this.name = name<br>        this.age = age<br>        this.height = height<br>        this.friends = friends<br>      &#125;<br><br>      // 实例方法<br>      running() &#123;&#125;<br>      [Symbol.iterator]() &#123;<br>        let index = 0<br>        const iterator = &#123;<br>          next: () =&gt; &#123;<br>            if (index &lt; this.friends.length) &#123;<br>              return &#123; done: false, value: this.friends[index++] &#125;<br>            &#125; else &#123;<br>              return &#123; done: true &#125;<br>            &#125;<br>          &#125;,<br>          return: () =&gt; &#123;<br>            console.log(&quot;监听到迭代器中断了&quot;)<br>            return &#123; done: true &#125;<br>          &#125;<br>        &#125;<br>        return iterator<br>      &#125;<br>    &#125;<br><br>    <br>    const p1 = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])<br><br>    for (const item of p1) &#123;<br>      console.log(item)<br>      if (item === &quot;kobe&quot;) &#123;<br>        break<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p><strong>定义</strong></p>
<p>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等   通过 <code>** function* **</code> 定义的函数，返回一个<strong>生成器对象</strong>（既是迭代器又是可迭代对象）。</p>
<p><strong>生成器和普通的函数区别:</strong></p>
<ul>
<li>首先，生成器函数需要在function的后面加一个符号:*</li>
<li>其次，生成器函数可以通过yield关键字来控制函数的执行流程</li>
<li>最后，生成器函数的返回值是一个Generator(生成器)</li>
<li>生成器是一种特殊的迭代器</li>
</ul>
<p><code>** yield **</code> ****<strong>关键字</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">-  暂停函数执行并返回一个值。 <br>-  通过  ` <span class="hljs-built_in">next</span>() `  恢复执行，可传递参数给生成器。 <br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>const generator = gen();<br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>()); // &#123; value: <span class="hljs-number">1</span>, done: <span class="hljs-literal">false</span> &#125;<br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>()); <br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>());<br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>());<br></code></pre></td></tr></table></figure>

<p><strong>生成器的惰性求值</strong>   生成器按需生成值，适合处理大数据或无限序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">function* fibonacci() &#123;<br>  let a = 0, b = 1;<br>  while (true) &#123;<br>    yield a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>生成器的高级用法</strong></p>
<ul>
<li><strong>传参给</strong> <code>** next() **</code>：向生成器内部传递值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain"> function* fibonacci() &#123;<br>  let a = 0, b = 1;<br>  while (true) &#123;<br>    yield a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br>const gen=fibonacci()<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>// console.log(gen.return());<br>// console.log(gen.throw(new Error(&#x27;结束&#x27;)));<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>- ** 错误处理 ** ：使用    ` generator.throw(err) `    抛出错误。 <br>- ** 提前终止 ** ：使用  ` generator.return() `  结束生成器。 <br></code></pre></td></tr></table></figure>



<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><strong>迭代器和生成器的关系</strong></p>
<ol>
<li><strong>生成器是迭代器的语法糖</strong>   生成器自动实现 <code>[Symbol.iterator]()</code> 和 <code>next()</code>，简化迭代器创建。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs plain"> const obj=&#123;<br>      names:[&#x27;李卓&#x27;,&#x27;叶茂华&#x27;,&#x27;MirZ&#x27;]<br>    &#125;<br>    function* creatItera(obj)&#123;<br>      for (let index = 0; index &lt; obj.names.length; index++) &#123;<br>        yield obj.names[index]        <br>      &#125;<br>    &#125;<br>    const objItera=creatItera(obj)<br>    console.log(objItera.next());<br>    console.log(objItera.next());<br>    console.log(objItera.next());<br>    console.log(objItera.next());<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  &lt;script&gt;<br>   class Person &#123;<br>      constructor(name, age, height, friends) &#123;<br>        this.name = name<br>        this.age = age<br>        this.height = height<br>        this.friends = friends<br>      &#125;<br><br>      // 实例方法<br>      *[Symbol.iterator]() &#123;<br>        //yield* 用于委托给另一个可迭代对象。它会遍历这个可迭代对象，并逐个 yield 其中的元素，而不是将整个可迭代对象作为一个元素返回。<br>      yield* this.friends<br>      &#125;<br>    &#125;<br><br>    const p = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])<br><br>    for (const item of p) &#123;<br>      console.log(item)<br>    &#125;<br>    // const pItera=p[Symbol.iterator]()<br>    // console.log(pItera.next());<br>    // console.log(pItera.next());<br>    // console.log(pItera.next());<br>    // console.log(pItera.next());<br>    <br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>生成器对象的特性</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const genObj = gen();<br>console.log(genObj[Symbol.iterator]() === genObj); // true<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ol>
<li><code>** for...of **</code> <strong>循环</strong>   遍历可迭代对象：</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> of <span class="hljs-string">&#x27;Hello&#x27;</span>) console.log(<span class="hljs-keyword">char</span>); <span class="hljs-comment">// H, e, l, l, o</span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong>解构赋值与扩展运算符</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const [a, b] = [10, 20];      // 解构<br>const arr = [...&#x27;abc&#x27;];       // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>异步迭代器（Async Iterators）</strong>   与 <code>for await...of</code> 配合处理异步数据流：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function* asyncGen() &#123;<br>  yield await Promise.resolve(1);<br>  yield await Promise.resolve(2);<br>&#125;<br><br>(async () =&gt; &#123;<br>  for await (const num of asyncGen()) console.log(num); // 1, 2<br>&#125;)();<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>关键点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>可迭代对象</strong></td>
<td>必须实现 <code>[Symbol.iterator]()</code>，返回迭代器。</td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td>必须实现 <code>next()</code>，返回 <code>&#123; value, done &#125;</code>。</td>
</tr>
<tr>
<td><strong>生成器</strong></td>
<td>通过 <code>function*</code>定义，简化迭代器创建，支持暂停&#x2F;恢复执行和双向通信。</td>
</tr>
</tbody></table>
<h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><h5 id="异步处理方式"><a href="#异步处理方式" class="headerlink" title="异步处理方式"></a>异步处理方式</h5><p>最早的异步处理方式可能是回调函数，比如在setTimeout或者事件监听中使用回调。但回调的问题在于容易导致回调地狱，代码难以维护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    // 封装请求的方法: url -&gt; promise(result)<br>    function requestData(url) &#123;<br>      return new Promise((resolve, reject) =&gt; &#123;<br>        setTimeout(() =&gt; &#123;<br>          resolve(url)<br>        &#125;, 2000)<br>      &#125;)<br>    &#125;<br><br>    // 1.发送一次网络请求<br>    // requestData(&quot;http://why&quot;).then(res =&gt; &#123;<br>    //   console.log(&quot;res:&quot;, res)<br>    // &#125;)<br><br>    /*<br>      需求: <br>        1.发送一次网络请求, 等到这次网络请求的结果<br>        2.发送第二次网络请求, 等待这次网络请求的结果<br>        3.发送第三次网络请求, 等待这次网络请求的结果<br>    */<br>    // 方式一: 层层嵌套(回调地狱 callback hell)<br>    // function getData() &#123;<br>    //   // 1.第一次请求<br>    //   requestData(&quot;why&quot;).then(res1 =&gt; &#123;<br>    //     console.log(&quot;第一次结果:&quot;, res1)<br><br>    //     // 2.第二次请求<br>    //     requestData(res1 + &quot;kobe&quot;).then(res2 =&gt; &#123;<br>    //       console.log(&quot;第二次结果:&quot;, res2)<br><br>    //       // 3.第三次请求<br>    //       requestData(res2 + &quot;james&quot;).then(res3 =&gt; &#123;<br>    //         console.log(&quot;第三次结果:&quot;, res3)<br>    //       &#125;)<br>    //     &#125;)<br>    //   &#125;)<br>    // &#125;<br><br>    // 方式二: 使用Promise进行重构(解决回调地狱)<br>    // 链式调用<br>    // function getData() &#123;<br>    //   requestData(&quot;why&quot;).then(res1 =&gt; &#123;<br>    //     console.log(&quot;第一次结果:&quot;, res1)<br>    //     return requestData(res1 + &quot;kobe&quot;)<br>    //   &#125;).then(res2 =&gt; &#123;<br>    //     console.log(&quot;第二次结果:&quot;, res2)<br>    //     return requestData(res2 + &quot;james&quot;)<br>    //   &#125;).then(res3 =&gt; &#123;<br>    //     console.log(&quot;第三次结果:&quot;, res3)<br>    //   &#125;)<br>    // &#125;<br><br>    // 方式三: 最终代码<br>    // function* getData() &#123;<br>    //   const res1 = yield requestData(&quot;why&quot;)<br>    //   console.log(&quot;res1:&quot;, res1)<br><br>    //   const res2 = yield requestData(res1 + &quot;kobe&quot;)<br>    //   console.log(&quot;res2:&quot;, res2)<br><br>    //   const res3 = yield requestData(res2 + &quot;james&quot;)<br>    //   console.log(&quot;res3:&quot;, res3)<br>    // &#125;<br><br>    // const generator = getData()<br>    // generator.next().value.then(res1 =&gt; &#123;<br>    //   generator.next(res1).value.then(res2 =&gt; &#123;<br>    //     generator.next(res2).value.then(res3 =&gt; &#123;<br>    //       generator.next(res3)<br>    //     &#125;)<br>    //   &#125;)<br>    // &#125;)<br><br>    // 方式四: async/await的解决方案<br>    async function getData() &#123;<br>      const res1 = await requestData(&quot;why&quot;)<br>      console.log(&quot;res1:&quot;, res1)<br><br>      const res2 = await requestData(res1 + &quot;kobe&quot;)<br>      console.log(&quot;res2:&quot;, res2)<br><br>      const res3 = await requestData(res2 + &quot;james&quot;)<br>      console.log(&quot;res3:&quot;, res3)<br>    &#125;<br><br>    const generator = getData()<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br>    // 封装请求的方法: url -&gt; promise(result)<br>    function requestData(url) &#123;<br>      return new Promise((resolve, reject) =&gt; &#123;<br>        setTimeout(() =&gt; &#123;<br>          resolve(url)<br>        &#125;, 2000)<br>      &#125;)<br>    &#125;<br><br>    // 生成器的处理方案<br>    function* getData() &#123;<br>      const res1 = yield requestData(&quot;why&quot;)<br>      console.log(&quot;res1:&quot;, res1)<br><br>      const res2 = yield requestData(res1 + &quot;kobe&quot;)<br>      console.log(&quot;res2:&quot;, res2)<br><br>      const res3 = yield requestData(res2 + &quot;james&quot;)<br>      console.log(&quot;res3:&quot;, res3)<br><br>      const res4 = yield requestData(res3 + &quot;curry&quot;)<br>      console.log(&quot;res4:&quot;, res4)<br><br>      const res5 = yield requestData(res4 + &quot;tatumu&quot;)<br>      console.log(&quot;res5:&quot;, res5)<br>    &#125;<br><br>    // const generator = getData()<br>    // generator.next().value.then(res1 =&gt; &#123;<br>    //   generator.next(res1).value.then(res2 =&gt; &#123;<br>    //     generator.next(res2).value.then(res3 =&gt; &#123;<br>    //       generator.next(res3).value.then(res4 =&gt; &#123;<br>    //         generator.next(res4)<br>    //       &#125;)<br>    //     &#125;)<br>    //   &#125;)<br>    // &#125;)<br><br>    // 自动化执行生成器函数(了解)<br>    function execGenFn(genFn) &#123;<br>      // 1.获取对应函数的generator<br>      const generator = genFn()<br>      // 2.定义一个递归函数<br>      function exec(res) &#123;<br>        // result -&gt; &#123; done: true/false, value: 值/undefined &#125;<br>        const result = generator.next(res)<br>        if (result.done) return<br>        result.value.then(res =&gt; &#123;<br>          exec(res)<br>        &#125;)<br>      &#125;<br>      // 3.执行递归函数<br>      exec()<br>    &#125;<br><br>    execGenFn(getData)<br></code></pre></td></tr></table></figure>



<h5 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h5><p><strong>异步函数基础</strong></p>
<ul>
<li><strong>定义</strong>：通过 <code>async</code> 关键字声明的函数，内部可使用 <code>await</code> 等待 Promise 完成。</li>
<li><strong>返回值</strong>：<code>async</code> 函数<strong>始终返回一个 Promise</strong>：<ul>
<li>若函数返回非 Promise 值，会被隐式转换为 <code>Promise.resolve(值)</code>。</li>
<li>若抛出错误（<code>throw</code>），返回 <code>Promise.reject(错误)</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function getData() &#123;<br>  return 42; // 等价于 Promise.resolve(42)<br>&#125;<br>getData().then(console.log); // 输出 42<br></code></pre></td></tr></table></figure>

<p>**  **<code>** await **</code> <strong>关键字的核心规则</strong></p>
<ul>
<li><strong>作用</strong>：暂停 <code>async</code> 函数执行，等待右侧的 Promise 完成。<ul>
<li>若 Promise 成功，<code>await</code> 返回解析后的值。</li>
<li>若 Promise 失败，<code>await</code> 抛出拒绝原因（可用 <code>try/catch</code> 捕获）。</li>
</ul>
</li>
<li><strong>限制</strong>：<code>await</code> <strong>只能在</strong> <code>** async **</code> <strong>函数内部使用</strong>，否则报语法错误。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function fetchUser() &#123;<br>  const response = await fetch(&#x27;/api/user&#x27;); // 等待网络请求完成<br>  const user = await response.json();        // 等待 JSON 解析<br>  return user;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>错误处理</strong></p>
<ul>
<li><code>** try/catch **</code> ****<strong>捕获错误</strong>：同步风格处理异步错误。</li>
<li><code>** .catch() **</code> <strong>兜底</strong>：<code>async</code> 函数返回的 Promise 可链式调用 <code>.catch()</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 方式 1: try/catch<br>async function loadData() &#123;<br>  try &#123;<br>    const data = await fetchApi();<br>  &#125; catch (error) &#123;<br>    console.error(&#x27;加载失败:&#x27;, error);<br>  &#125;<br>&#125;<br><br>// 方式 2: .catch()<br>loadData().catch(error =&gt; console.error(&#x27;兜底捕获:&#x27;, error));<br></code></pre></td></tr></table></figure>



<h5 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h5><h6 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h6><p><strong>线程和进程是操作系统中的两个概念:</strong></p>
<p>进程(process):计算机已经运行的程序，是操作系统管理程序的一种方式:</p>
<p>线程(thread):操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中;</p>
<p>:::tips 听起来很抽象，这里还是给出我的解释:</p>
<ul>
<li>进程:我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程):</li>
<li>线程:每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称之为主线程</li>
</ul>
<p>所以我们也可以说进程是线程的容器</p>
<p>:::</p>
<h6 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h6><p>JavaScript是单线程(可以开启workers)的，但是JavaScript的线程有自己的容器进程:浏览器或者Node.</p>
<p>目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出,每个进程中又有很多的线程，其中包括执行JavaScript代码的线程</p>
<p>JavaScript的代码执行是在一个单独的线程中执行的,这就意味着JavaScript的代码在同一个时刻只能做一件事,如果这件事是非常耗时的，就意味着当前的线程就会被阻塞</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/wudibawanglong-gbppc/frgahd/rkcthgb5bpuwyui3">事件循环</a></p>
<p><strong>宏任务和微任务</strong></p>
<p>但是事件循环中并非只维护着一个队列，事实上是有两个队列:</p>
<ul>
<li>宏任务队列(macrotask queue):ajax、setTimeout、setlnterval、DOM监听、Ul Rendering等</li>
<li>微任务队列(microtask queue):Promise的then回调、Mutation Observer APl、queueMicrotask()等</li>
</ul>
<p><strong>那么事件循环对于两个队列的优先级是怎么样的呢?</strong></p>
<ul>
<li>1.main script中的代码优先执行(编写的顶层script代码);</li>
<li>2.在执行任何一个宏任务之前(不是队列，是一个宏任务)，都会先查看微任务队列中是否有任务需要执行, 也就是宏任务执行之前，必须保证微任务队列是空的;如果不为空，那么就优先执行微任务队列中的任务(回调):</li>
</ul>
<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>)          <span class="hljs-comment">//1</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout1&quot;</span>);  <span class="hljs-comment">//8</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>();<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then4&quot;</span>);  <span class="hljs-comment">//10</span><br>    &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then2&quot;</span>);  <span class="hljs-comment">//9</span><br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);  <span class="hljs-comment">//2</span><br>  <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then1&quot;</span>);  <span class="hljs-comment">//5</span><br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout2&quot;</span>);  <span class="hljs-comment">//11</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">//3</span><br><span class="hljs-comment">//直接将一个函数加入微队列</span><br><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;queueMicrotask1&quot;</span>)  <span class="hljs-comment">//6</span><br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then3&quot;</span>);  <span class="hljs-comment">//7</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script end&quot;</span>)  <span class="hljs-comment">//4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;requestData&quot;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>)<br>      <span class="hljs-title function_">resolve</span>(url)<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 2.await/async</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getData start&quot;</span>)<br>  <span class="hljs-comment">//await只有等到promise的结果返回才会执行后续代码</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-string">&quot;why&quot;</span>)<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then1-res:&quot;</span>, res)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getData end&quot;</span>)<br>&#125;<br><br><span class="hljs-title function_">getData</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script end&quot;</span>)<br><br><span class="hljs-comment">// script start</span><br><span class="hljs-comment">// getData start</span><br><span class="hljs-comment">// requestData</span><br><span class="hljs-comment">// script end</span><br><br><span class="hljs-comment">// setTimeout</span><br><br><span class="hljs-comment">// then1-res: why</span><br><span class="hljs-comment">// getData end</span><br> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>)  <span class="hljs-comment">//2</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>      <span class="hljs-comment">// async2()执行完后会return undefined ==&gt; Promise.resolve(undefined) ,下面代码放入微任务队列</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)   <span class="hljs-comment">// 6</span><br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)  <span class="hljs-comment">//3</span><br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)  <span class="hljs-comment">//1</span><br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)   <span class="hljs-comment">//8</span><br>    &#125;, <span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-title function_">async1</span>(); <br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)  <span class="hljs-comment">//4</span><br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-property">then</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)  <span class="hljs-comment">//7</span><br>    &#125;)<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)   <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure>



<h4 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h4><p>Storage 用于在客户端存储数据，主要包括 <code>localStorage</code> 和 <code>sessionStorage</code>，属于 Web Storage API。</p>
<p><strong>1. 类型与区别</strong></p>
<ul>
<li><strong>localStorage</strong><ul>
<li><strong>生命周期</strong>：永久存储，需手动删除（代码或浏览器清除）。</li>
<li><strong>作用域</strong>：同源（协议、域名、端口相同）的所有标签页和窗口共享。</li>
</ul>
</li>
<li><strong>sessionStorage</strong><ul>
<li><strong>生命周期</strong>：仅限当前会话，关闭标签页或浏览器后清除。</li>
<li><strong>作用域</strong>：仅在当前标签页有效，同源其他标签页无法访问。</li>
</ul>
</li>
</ul>
<p><strong>2. 常用方法</strong></p>
<p><strong>存储数据</strong>：<code>setItem(key, value)</code></p>
<ul>
<li><code>localStorage.setItem(&#39;username&#39;, &#39;Alice&#39;);</code></li>
</ul>
<p><strong>读取数据</strong>：<code>getItem(key)</code></p>
<ul>
<li><code>const user = localStorage.getItem(&#39;username&#39;); // &#39;Alice&#39;</code></li>
</ul>
<p><strong>删除数据</strong>：<code>removeItem(key)</code></p>
<ul>
<li><code>localStorage.removeItem(&#39;username&#39;);</code></li>
</ul>
<p><strong>清空所有数据</strong>：<code>clear()</code></p>
<ul>
<li><code>localStorage.clear();</code></li>
</ul>
<p><strong>3. 数据格式</strong></p>
<p><strong>仅支持字符串</strong>：存储对象需序列化，读取时反序列化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br><span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>4. 存储事件（storage Event）</strong></p>
<ul>
<li><strong>触发条件</strong>：同源其他标签页修改 Storage 时触发。</li>
<li><strong>事件对象属性</strong>：<code>key</code>、<code>oldValue</code>、<code>newValue</code>、<code>url</code> 等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">window.addEventListener(&#x27;storage&#x27;, (e) =&gt; &#123;<br>  console.log(`$&#123;e.key&#125; 值从 $&#123;e.oldValue&#125; 变为 $&#123;e.newValue&#125;`);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>5. 容量限制</strong></p>
<ul>
<li><strong>大小</strong>：约 5MB（不同浏览器可能不同）。</li>
<li><strong>错误处理</strong>：超出限制会抛出 <code>QuotaExceededError</code>，需使用 <code>try...catch</code>处理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">try &#123;<br>  localStorage.setItem(&#x27;bigData&#x27;, new Array(5 * 1024 * 1024).join(&#x27;a&#x27;));<br>&#125; catch (e) &#123;<br>  console.error(&#x27;存储失败：&#x27;, e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>6. 安全性与兼容性</strong></p>
<ul>
<li><strong>明文存储</strong>：避免保存敏感信息（如密码）。</li>
<li><strong>XSS 风险</strong>：若网站存在 XSS 漏洞，攻击者可读取 Storage 数据。</li>
<li><strong>兼容性</strong>：现代浏览器均支持，IE8+ 支持，但隐私模式可能受限。</li>
</ul>
<p><strong>检测支持</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function isStorageSupported() &#123;<br>  try &#123;<br>    const testKey = &#x27;__test__&#x27;;<br>    localStorage.setItem(testKey, testKey);<br>    localStorage.removeItem(testKey);<br>    return true;<br>  &#125; catch (e) &#123;<br>    return false;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>7. 注意事项</strong></p>
<ul>
<li><strong>类型转换</strong>：非字符串数据会被自动转换（如 <code>true</code> 转为 <code>&quot;true&quot;</code>）。</li>
<li><strong>遍历键值</strong>：通过 <code>length</code> 和 <code>key(index)</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (let i = 0; i &lt; localStorage.length; i++) &#123;<br>  const key = localStorage.key(i);<br>  console.log(key, localStorage.getItem(key));<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>隐私模式</strong>：部分浏览器在隐身模式下禁用 Storage，需异常处理。</li>
</ul>
<p><strong>8. 与 Cookie 对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Cookie</strong></th>
<th><strong>Web Storage</strong></th>
</tr>
</thead>
<tbody><tr>
<td>容量</td>
<td>~4KB</td>
<td>~5MB</td>
</tr>
<tr>
<td>请求是否携带</td>
<td>每次 HTTP 请求自动携带</td>
<td>不参与通信</td>
</tr>
<tr>
<td>生命周期</td>
<td>可设置过期时间</td>
<td>永久或会话级</td>
</tr>
</tbody></table>
<p><strong>9. 封装工具函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">const storage = &#123;<br>  set(key, value) &#123;<br>    localStorage.setItem(key, JSON.stringify(value));<br>  &#125;,<br>  get(key) &#123;<br>    const data = localStorage.getItem(key);<br>    return data ? JSON.parse(data) : null;<br>  &#125;,<br>  remove(key) &#123;<br>    localStorage.removeItem(key);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p>
<h5 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h5><p>在 JavaScript 中有两种方式创建正则表达式：</p>
<ul>
<li>字面量方式</li>
</ul>
<p>使用斜杠（<code>/</code>）来界定正则表达式模式。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const pattern <span class="hljs-operator">=</span> /abc/<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>构造函数方式</li>
</ul>
<p>使用 <code>RegExp</code> 构造函数，传入模式字符串作为参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;abc&#x27;</span>); <br></code></pre></td></tr></table></figure>



<h5 id="正则表达式标志"><a href="#正则表达式标志" class="headerlink" title="正则表达式标志"></a>正则表达式标志</h5><p>标志可以改变正则表达式的匹配行为，标志可以单个使用，也可以组合使用。常用标志如下：</p>
<ul>
<li><code>i</code>：忽略大小写。(global)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/i</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>g</code>：全局匹配，找到所有匹配项，而不是在找到第一个匹配项后停止。(ignore)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-keyword">const</span> matches = str.<span class="hljs-title function_">match</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matches); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>m</code>：多行匹配，使 <code>^</code> 和 <code>$</code> 可以匹配每行的开头和结尾。(multiple)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc\nabc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/^abc/m</span>;<br><span class="hljs-keyword">const</span> matches = str.<span class="hljs-title function_">match</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matches); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br></code></pre></td></tr></table></figure>



<h5 id="常用的正则表达式元字符"><a href="#常用的正则表达式元字符" class="headerlink" title="常用的正则表达式元字符"></a>常用的正则表达式元字符</h5><h6 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h6><p><strong>元字符</strong></p>
<ul>
<li>基础：<code>^</code>（开头）、<code>$</code>（结尾）、<code>.</code>（任意字符，除换行符）、<code>|</code>（或）。</li>
<li>转义字符：<code>\d</code>（数字）、<code>\D</code>（非数字）、<code>\w</code>（单词字符）、<code>\W</code>（非单词字符）、<code>\s</code>（空白符）、<code>\S</code>（非空白符）。<code>**\. \* \? **</code> (转义特殊字符,如 . * ? [ ] \ &#x2F; ^ $ | + ( ))</li>
<li>边界：<code>\b</code>（单词边界）、<code>\B</code>（非单词边界）。</li>
</ul>
<p><strong>量词</strong></p>
<ul>
<li><code>*</code>（0次或多次）、<code>+</code>（1次或多次）、<code>?</code>（0或1次）。</li>
<li><code>&#123;n&#125;</code>（n次）、<code>&#123;n,&#125;</code>（至少n次）、<code>&#123;n,m&#125;</code>（n到m次）。</li>
<li><strong>非贪婪模式</strong>：在量词后加 <code>?</code>（如 <code>*?</code>、<code>+?</code>）。</li>
</ul>
<p><strong>字符集合</strong></p>
<ul>
<li><code>[abc]</code>：匹配 a、b、c 中的任意一个。</li>
<li><code>[^abc]</code>：匹配不在集合中的字符。</li>
<li><code>[a-z]</code>：匹配范围（如小写字母）。</li>
</ul>
<p><strong>分组与捕获</strong></p>
<ul>
<li><code>(abc)</code>：捕获组，通过 <code>\1</code> 或 <code>$1</code> 引用。</li>
<li><code>(?:abc)</code>：非捕获组，不保存匹配项。</li>
<li>前瞻：<code>(?=...)</code>（正向肯定）、<code>(?!=...)</code>（正向否定）。</li>
</ul>
<h6 id="元字符示例"><a href="#元字符示例" class="headerlink" title="元字符示例"></a>元字符示例</h6><ul>
<li><code>.</code>：匹配除换行符之外的任意单个字符。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/a.c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>^</code>：匹配字符串的开头。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/^abc/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcdef&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>$</code>：匹配字符串的结尾。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc$/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;defabc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>*</code>：匹配前面的元素零次或多次。<code>&#123;0,&#125;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab*c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abbbc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>+</code>：匹配前面的元素一次或多次。<code>&#123;1,&#125;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab+c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abbbc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>?</code>：匹配前面的元素零次或一次。<code>&#123;0,1&#125;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab?c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abbbc&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>&#123;n,m&#125;</code>：匹配前面的元素至少 <code>n</code> 次，最多 <code>m</code> 次。<code>&#123;n&#125;</code>：匹配前面的元素恰好 <code>n</code> 次。<code>&#123;n,&#125;</code>：匹配前面的元素至少 <code>n</code> 次。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 匹配 2 到 4 个连续的数字</span><br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\d&#123;2,4&#125;/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>[]</code>：匹配方括号内的任意一个字符。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/[abc]/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;d&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>()</code>：用于分组，将多个元素视为一个整体。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/(ab)+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>|</code> :  用于表示or ,  或者</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &quot;1239891238732136321&quot;<br>const pattern=/(123|321)/ig<br>const res=message.match(pattern)<br>console.log(res);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>\d</code>：匹配任意一个数字，等价于 <code>[0-9]</code>。(digit)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;cca2bc4af5cab12b&#x27;</span>;<br><span class="hljs-comment">//\d+匹配数字,将多个连续的数字也视为一个整体</span><br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\d+/ig</span>;<br><span class="hljs-keyword">const</span> newArr = str.<span class="hljs-title function_">match</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [&#x27;2&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;12&#x27;]</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>\D</code>：匹配任意非数字字符，等价于 <code>[^0-9]</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const str = &#x27;cca2bc4af5cab12b&#x27;;<br>const pattern = /\D+/ig;<br>const newArr = str.match(pattern);<br>console.log(newArr); //[&#x27;cca&#x27;, &#x27;bc&#x27;, &#x27;af&#x27;, &#x27;cab&#x27;, &#x27;b&#x27;]<br></code></pre></td></tr></table></figure>

<ul>
<li><code>\s</code>：匹配任意空白字符，包括空格、制表符、换行符等。(space)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\s/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27; &#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>\S</code>：匹配任意非空白字符。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\S/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>\w</code>：匹配任意字母、数字或下划线，等价于 <code>[a-zA-Z0-9_]</code>。(word)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\w/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;x&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>\W</code>：匹配任意非字母、数字或下划线的字符，等价于 <code>[^a-zA-Z0-9_]</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\W/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;!&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>\b</code>: 单词边界 , 匹配的单词两边必须是边界(不匹配\w)</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &#x27;My name is MirZ&#x27;<br>    const pattern = /\bis\b/<br>    if (pattern.test(message)) &#123;<br>      console.log(&#x27;is 有边界&#x27;);<br>    &#125; else &#123;<br>      console.log(&#x27;is 无边界&#x27;);<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>\B</code>: 单词边界 , 匹配的单词两边必须非边界</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &#x27;My name is MirZ&#x27;<br>    const pattern = /\Bis\B/<br>    if (pattern.test(message)) &#123;<br>      console.log(&#x27;is 有边界&#x27;);<br>    &#125; else &#123;<br>      console.log(&#x27;is 无边界&#x27;);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h5 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法"></a>正则表达式方法</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">test</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>用于测试字符串中是否存在匹配的模式，返回 <code>true</code> 或 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdef&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// true</span><br>**<span class="hljs-title function_">exec</span>()**<br></code></pre></td></tr></table></figure>

<p>用于字符串中执行匹配操作，返回一个数组，包含匹配的结果和相关信息。没有匹配到，则返回 <code>null</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdef&#x27;</span>;<br><span class="hljs-keyword">const</span> result = pattern.<span class="hljs-title function_">exec</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// [&#x27;abc&#x27;, index: 0, input: &#x27;abcdef&#x27;, groups: undefined]</span><br>**<span class="hljs-title function_">match</span>()**<br></code></pre></td></tr></table></figure>

<p>在字符串中查找匹配的模式，返回一个数组，包含所有匹配的结果。如果没有使用 <code>g</code> 标志，则只返回第一个匹配结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern1 = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> pattern2 = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern1)); <span class="hljs-comment">// [&#x27;abc&#x27;, index: 0, input: &#x27;abc abc&#x27;, groups: undefined]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern2)); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br>**<span class="hljs-title function_">matchAll</span>()**<br></code></pre></td></tr></table></figure>

<p>在字符串中查找匹配的模式，返回一个迭代器。必须使用 <code>g</code> 标志</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern1 = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> pattern2 = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern1)); <span class="hljs-comment">// [&#x27;abc&#x27;, index: 0, input: &#x27;abc abc&#x27;, groups: undefined]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern2)); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br>**<span class="hljs-title function_">replace</span>()**<br></code></pre></td></tr></table></figure>

<p>用于替换字符串中匹配的模式，返回一个新的字符串。如果不加<code>g</code>标识符,则只替换搜索到的第一个符合的字符串,加<code>g</code>替换结果等同于<code>**replaceAll()**</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-keyword">const</span> newStr = str.<span class="hljs-title function_">replace</span>(pattern, <span class="hljs-string">&#x27;def&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr); <span class="hljs-comment">// &#x27;def def&#x27;</span><br>**<span class="hljs-title function_">split</span>()**<br></code></pre></td></tr></table></figure>

<p>用于使用字符串中匹配的字符串进行分割字符串，返回一个新的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;ccabcabacafbcab12b&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab/</span>;<br><span class="hljs-keyword">const</span> newArr = str.<span class="hljs-title function_">split</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [&#x27;cc&#x27;,&#x27;c&#x27;,&#x27;acefhc&#x27;,&#x27;12b&#x27;]</span><br>**<span class="hljs-title function_">search</span>()**<br></code></pre></td></tr></table></figure>

<p>用于查找字符串中第一个匹配的模式的索引，如果没有找到，则返回 -1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc def&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">search</span>(pattern)); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>



<h5 id="贪婪模式和惰性模式"><a href="#贪婪模式和惰性模式" class="headerlink" title="贪婪模式和惰性模式"></a>贪婪模式和惰性模式</h5><ul>
<li>贪婪匹配，它会从第一个匹配项开始，尽可能多地匹配字符，直到遇到最后一个匹配项 ，所以最终匹配的是整个字符串</li>
<li>惰性模式也称为非贪婪模式，通过在量词后面加上问号 <code>? </code> 来开启。在惰性模式下，量词会尽可能少地匹配符合条件的字符，一旦找到第一个匹配项就会停止匹配。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">// 1.贪婪模式/惰性模式<br>    const message = &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;<br><br>    // 默认.+采用贪婪模式<br>    // const nameRe = /《.+》/ig<br>    <br>    // const result1 = message.match(nameRe)<br>    // console.log(result1)<br><br>    // 使用惰性模式<br>    const nameRe = /《.+?》/ig<br>    <br>    const result1 = message.match(nameRe)<br>    console.log(result1)<br></code></pre></td></tr></table></figure>



<h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p><code>() </code> 不单单可以当作一个整体 , 也可以定义捕获组。每一对括号就定义了一个捕获组，从左到右，括号的顺序决定了捕获组的编号，编号从 1 开始。第 0 个捕获组始终代表整个正则表达式匹配的内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">const str = &#x27;John Smith&#x27;;<br>const pattern = /(\w+) (\w+)/;<br>const result = str.match(pattern);<br><br>console.log(result[0]); // 输出整个匹配结果：John Smith<br>console.log(result[1]); // 输出第一个捕获组：John<br>console.log(result[2]); // 输出第二个捕获组：Smith<br>const str = &#x27;Doe, John&#x27;;<br>const pattern = /(\w+), (\w+)/;<br>const newStr = str.replace(pattern, &#x27;$2 $1&#x27;);<br><br>console.log(newStr); // 输出：John Doe<br>//这里，$1 和 $2 分别代表第一个和第二个捕获组的内容，通过 replace 方法将它们的顺序进行了交换。<br>const str = &#x27;2023-10-15&#x27;;<br>const pattern = /(?<span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>\d&#123;4&#125;)-(?<span class="hljs-tag">&lt;<span class="hljs-name">month</span>&gt;</span>\d&#123;2&#125;)-(?<span class="hljs-tag">&lt;<span class="hljs-name">day</span>&gt;</span>\d&#123;2&#125;)/;<br>const result = str.match(pattern);<br><br>console.log(result.groups.year); // 输出：2023<br>console.log(result.groups.month); // 输出：10<br>console.log(result.groups.day); // 输出：15<br></code></pre></td></tr></table></figure>

<p><strong>非捕获组</strong></p>
<p>有时候，你可能只想使用括号来对正则表达式的一部分进行分组，但不想捕获匹配的内容，这时可以使用非捕获组，语法是 <code>(?:pattern)</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;<br><br>  //捕获组<br>// const nameRe = /(《)(?<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>.+?)(》)/ig<br>  //非捕获组<br>const nameRe = /(?:《)(?<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>.+?)(?:》)/ig<br>const iterator = message.matchAll(nameRe)<br>for (const item of iterator) &#123;<br>  console.log(item)<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h5><ul>
<li>手机号码验证</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">const phone = &#x27;13800138000&#x27;;<br>const phonePattern = /^1[3-9]\d&#123;9&#125;$/;<br>console.log(phonePattern.test(phone)); // true<br></code></pre></td></tr></table></figure>

<ul>
<li>HTML标签匹配</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const htmlEle=&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#x27;<br>    const pattern=/&lt;\/?[a-z][a-z0-9]*&gt;/ig<br>    const res=htmlEle.match(pattern)<br>    console.log(res);<br></code></pre></td></tr></table></figure>

<ul>
<li>HTML标签内容匹配</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">const html = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#x27;;<br>const pattern = /&lt;[^&gt;]+&gt;([^&lt;]+)&lt;\/[^&gt;]+&gt;/;<br>const result = html.match(pattern);<br>if (result) &#123;<br>    console.log(result[1]); // &#x27;Hello, World!&#x27;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>格式化日期</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const dateStr = &#x27;2023-10-15&#x27;;<br>const pattern = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;<br>const newDateStr = dateStr.replace(pattern, &#x27;$2/$3/$1&#x27;);<br>console.log(newDateStr); // &#x27;10/15/2023&#x27;<br></code></pre></td></tr></table></figure>

<ul>
<li>时间戳格式化时间</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html">// yyyy/MM/dd hh:mm:ss<br>// yyyy*MM*dd hh-mm-ss<br>// dayjs/moment<br>function formatTime(timestamp, fmtString) &#123;<br>  // 1.将时间戳转成Date<br>  const date = new Date(timestamp)<br><br>  // // 2.获取到值<br>  // const year = date.getFullYear()<br>  // const month = date.getMonth() + 1<br>  // const day = date.getDate()<br>  // const hour = date.getHours()<br>  // const minute = date.getMinutes()<br>  // const second = date.getSeconds()<br><br>  // 2.正则和值匹配起来<br>  const dateO = &#123;<br>    &quot;y+&quot;: date.getFullYear(),<br>    &quot;M+&quot;: date.getMonth() + 1,<br>    &quot;d+&quot;: date.getDate(),<br>    &quot;h+&quot;: date.getHours(),<br>    &quot;m+&quot;: date.getMinutes(),<br>    &quot;s+&quot;: date.getSeconds()<br>  &#125;<br><br>  // 3.for循环进行替换<br>  for (const key in dateO) &#123;<br>    const keyRe = new RegExp(key)<br>    if (keyRe.test(fmtString)) &#123;<br>      const value = (dateO[key] + &quot;&quot;).padStart(2, &quot;0&quot;)<br>      fmtString = fmtString.replace(keyRe, value)<br>    &#125;<br>  &#125;<br><br>  return fmtString<br>&#125;<br><br>// 某一个商品上架时间, 活动的结束时间<br>const timeEl = document.querySelector(&quot;.time&quot;)<br>const productJSON = &#123;<br>  name: &quot;iPhone16e&quot;,<br>  newPrice: 4999,<br>  oldPrice: 5999,<br>  endTime: Date.now()<br>&#125;<br><br>timeEl.textContent = formatTime(productJSON.endTime, &quot;hh:mm:ss yyyy:MM:dd&quot;)<br></code></pre></td></tr></table></figure>



<h4 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h4><p>在 JavaScript 中，<strong>防抖（Debounce）</strong> 和 <strong>节流（Throttle）</strong> 是两种常用的性能优化技术，用于控制高频事件的触发频率，避免过多的资源消耗（如频繁的 DOM 操作、网络请求等）。</p>
<h5 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h5><p>当事件被频繁触发时，<strong>只有在事件停止触发一段时间后</strong>，才会执行目标函数。如果在此期间再次触发事件，则重新计时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs plain">    function MyDebounce(fn, delay) &#123;<br>      //定义timer记录定时器<br>      let timer = null<br>      //返回一个防抖处理后新的函数,不能使用箭头函数(箭头函数无this,this会指向window)<br>      return function (...arg) &#123;<br>        //每次触发清除上一次定时器<br>        clearTimeout(timer)<br>        //延迟执行函数,...args事件触发时传递的参数        <br>        timer = setTimeout(() =&gt; &#123;<br>          //找到被防抖处理的函数应该绑定的this,进行绑定<br>          fn.apply(this, args)<br>        &#125;, delay)<br>      &#125;<br>    &#125;<br> function MyDebounce(fn, delay) &#123;<br>      let timer = null<br>      const _debounce=function(...args)&#123;<br>        clearTimeout(timer)<br>        timer = setTimeout(() =&gt; &#123;<br>          fn.apply(this, args)<br>        &#125;, delay)<br>      &#125;<br>      //在返回的_debounce函数上绑定一个取消函数<br>      _debounce.cancel=function()&#123;<br>        if(timer) clearTimeout(timer)<br>      &#125;<br>      return _debounce<br>      &#125;<br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    const buttonEle=document.querySelector(&#x27;button&#x27;)<br>    const MyDebounceFn = MyDebounce(function () &#123;<br>      console.log(this.value);<br>    &#125;, 5000)<br>    inputEle.oninput=MyDebounceFn<br>    buttonEle.onclick=function()&#123;<br>      MyDebounceFn.cancel()<br>    &#125;<br>    //immediate判断是否立即执行一次<br>    function MyDebounce(fn, delay, immediate = false) &#123;<br>      let timer = null<br>      //定义变量记录是否已经立即执行过<br>      let isInvoke = false<br>      const _debounce = function (...args) &#123;<br>        clearTimeout(timer)<br>        if (immediate &amp;&amp; !isInvoke)&#123;<br>          fn.apply(this,args)<br>          isInvoke=true<br>          return<br>        &#125; <br>        timer = setTimeout(() =&gt; &#123;<br>          fn.apply(this, args)<br>        &#125;, delay)<br>      &#125;<br>      //在返回的_debounce函数上绑定一个取消函数<br>      _debounce.cancel = function () &#123;<br>        if (timer) clearTimeout(timer)<br>      &#125;<br>      return _debounce<br>    &#125;<br><br><br><br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    const buttonEle = document.querySelector(&#x27;button&#x27;)<br>    const MyDebounceFn = MyDebounce(function () &#123;<br>      console.log(this.value);<br>    &#125;, 2000,true)<br>    inputEle.oninput = MyDebounceFn<br>    buttonEle.onclick = function () &#123;<br>      MyDebounceFn.cancel()<br>    &#125;<br>//immediate判断是否立即执行一次<br>    function MyDebounce(fn, delay, immediate = false) &#123;<br>      let timer = null<br>      //定义变量记录是否已经立即执行过<br>      let isInvoke = false<br>      //记录返回的结果<br>      let res = undefined<br>      const _debounce = function (...args) &#123;<br>        return new Promise((resolve, reject) =&gt; &#123;<br>          clearTimeout(timer)<br>          if (immediate &amp;&amp; !isInvoke) &#123;<br>            //获取返回的值,通过回调函数回调出去<br>            res = fn.apply(this, args)<br>            resolve(res)<br>            isInvoke = true<br>            return<br>          &#125;<br>          timer = setTimeout(() =&gt; &#123;<br>            //获取返回的值,通过回调函数回调出去<br>            res = fn.apply(this, args)<br>            resolve(res)<br>          &#125;, delay)<br>        &#125;)<br><br>      &#125;<br>      //在返回的_debounce函数上绑定一个取消函数<br>      _debounce.cancel = function () &#123;<br>        if (timer) clearTimeout(timer)<br>      &#125;<br>      return _debounce<br>    &#125;<br><br>    const MyFn = MyDebounce(function (name) &#123;<br>      console.log(name);<br>      return &#x27;promise返回值&#x27;<br>    &#125;, 2000, false)<br>    MyFn(&#x27;Mir&#x27;).then((res)=&gt;&#123;<br>      console.log(res);<br>    &#125;)<br></code></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ol>
<li>搜索框输入联想（用户停止输入后再发送请求）。</li>
<li>窗口大小调整（停止调整后再计算布局）。</li>
<li>表单验证（输入完成后验证一次）。</li>
</ol>
<h5 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h5><p>当事件被频繁触发时，<strong>每隔固定的时间间隔</strong>，执行一次目标函数。无论事件触发多频繁，函数的执行频率都会被限制。</p>
<ul>
<li>时间戳实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs plain">function throttle(func, delay) &#123;<br>  let lastTime = 0;<br>  return function (...args) &#123;<br>    const now = Date.now();<br>    //第一次立即执行,后续lastTime = now,等待每次间隔达到delay执行<br>    if (now - lastTime &gt;= delay) &#123;<br>      func.apply(this, args);<br>      lastTime = now;<br>    &#125;<br>  &#125;;<br>&#125;<br> function MyThrottle(fn, delay, immediate = true) &#123;<br>      let startTime = 0<br>      const _throttle = function (...arys) &#123;<br>        const nowTime = Date.now();<br>        //第一次startTime和now相等,不立即执行<br>        if (!immediate &amp;&amp; startTime === 0) startTime = nowTime<br>        if (nowTime - startTime &gt;= delay) &#123;<br>          fn.apply(this, arys)<br>          startTime = nowTime<br>        &#125;<br>      &#125;<br>      return _throttle<br>    &#125;<br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    inputEle.oninput = MyThrottle(function () &#123;<br>      console.log(this.value);<br>    &#125;, 1000, false)<br>    function MyThrottle(fn, delay, leading = true, trailing = false) &#123;<br>      let startTime = 0<br>      let timer = null<br>      const _throttle = function (...arys) &#123;<br>        const nowTime = Date.now();<br>        //定时器判断是否尾部执行<br>        //第一次startTime和now相等,不立即执行<br>        if (!leading &amp;&amp; startTime === 0) startTime = nowTime<br>        if (nowTime - startTime &gt;= delay) &#123;<br>          //极限情况,在这里执行完,清除定时器,防止下面重复执行<br>          if (timer) &#123;<br>            clearTimeout(timer)<br>            timer = null<br>          &#125;<br>          fn.apply(this, arys)<br>          startTime = nowTime<br>          //满足条件结束本次函数,nowTime - startTime不能达到delay,进入trailing的定时器判断<br>          return<br>        &#125;<br>        //存在误差,大多执行下面函数<br>        if (trailing &amp;&amp; !timer) &#123;<br>          //在下次该执行函数的时间执行函数<br>          timer = setTimeout(() =&gt; &#123;<br>            fn.apply(this, arys)<br>            // startTime = nowTime 不能使用nowTime作为下次开始,保存的为上次定义的nowTime,不是最新时间<br>            startTime=Date.now()<br>            timer = null<br>          &#125;, delay-(nowTime-startTime))<br>        &#125;<br>      &#125;<br>      return _throttle<br>    &#125;<br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    inputEle.oninput = MyThrottle(function () &#123;<br>      console.log(this.value);<br>    &#125;, 3000, false, true)<br>function MyThrottle(fn, delay, leading = true, trailing = false) &#123;<br>      let startTime = 0<br>      let timer = null<br>      //如果想获取返回值,使用回调函数,或者返回promise对象<br>      const _throttle = function (...arys) &#123;<br>        const nowTime = Date.now();<br>        //定时器判断是否尾部执行<br>        //第一次startTime和now相等,不立即执行<br>        if (!leading &amp;&amp; startTime === 0) startTime = nowTime<br>        if (nowTime - startTime &gt;= delay) &#123;<br>          //极限情况,在这里执行完,清除定时器,防止下面重复执行<br>          if (timer) &#123;<br>            clearTimeout(timer)<br>            timer = null<br>          &#125;<br>          fn.apply(this, arys)<br>          startTime = nowTime<br>          //满足条件结束本次函数,nowTime - startTime不能达到delay,进入trailing的定时器判断<br>          return<br>        &#125;<br>        //存在误差,大多执行下面函数<br>        if (trailing &amp;&amp; !timer) &#123;<br>          //在下次该执行函数的时间执行函数<br>          timer = setTimeout(() =&gt; &#123;<br>            fn.apply(this, arys)<br>            // startTime = nowTime 不能使用nowTime作为下次开始,保存的为上次定义的nowTime,不是最新时间<br>            startTime=Date.now()<br>            timer = null<br>          &#125;, delay-(nowTime-startTime))<br>        &#125;<br>      &#125;<br>      _throttle.cancel = function() &#123;<br>        if (timer) clearTimeout(timer)<br>        startTime = 0<br>        timer = null<br>      &#125;<br>      return _throttle<br>    &#125;<br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    const buttonEle=document.querySelector(&#x27;button&#x27;)<br>    const MyThrottleFn=MyThrottle(function () &#123;<br>      console.log(this.value);<br>    &#125;, 3000, false, true)<br>    inputEle.oninput = MyThrottleFn<br>    buttonEle.onclick=function()&#123;<br>      MyThrottleFn.cancel()<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>定时器实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">function throttle(func, delay) &#123;<br>  let timer = null;<br>  return function (...args) &#123;<br>  //定时器状态为null重新注册定时器<br>    if (!timer) &#123;<br>      timer = setTimeout(() =&gt; &#123;<br>        func.apply(this, args);<br>        //当到达节流时间将timer赋值为null,才能开启下次定时<br>        timer = null;<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>两种实现的区别</strong></p>
<ul>
<li><strong>时间戳版</strong>：立即执行，停止触发后不再执行最后一次。</li>
<li><strong>定时器版</strong>：延迟执行，停止触发后会执行最后一次。</li>
</ul>
<p><strong>应用场景</strong></p>
<ol>
<li>页面滚动事件（如无限加载）。</li>
<li>鼠标移动事件（如拖拽）。</li>
<li>高频点击按钮（如提交表单）。</li>
</ol>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>防抖（Debounce）</strong></th>
<th><strong>节流（Throttle）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行时机</strong></td>
<td>事件停止触发后执行</td>
<td>固定时间间隔执行</td>
</tr>
<tr>
<td><strong>是否保留最后一次</strong></td>
<td>是（重新计时）</td>
<td>取决于实现方式</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>输入联想、窗口调整</td>
<td>滚动事件、高频点击</td>
</tr>
</tbody></table>
<h4 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h4><p>事件总线是一种基于<strong>发布-订阅模式</strong>的通信机制，用于组件或模块间的解耦</p>
<p><strong>核心概念</strong></p>
<ul>
<li><strong>发布-订阅模型</strong>：发布者（Publisher）触发事件，订阅者（Subscriber）监听并响应事件，二者通过事件总线通信，无需直接依赖。</li>
<li><strong>事件中心</strong>：统一管理事件与回调函数，提供注册、触发、销毁等能力。</li>
</ul>
<p><strong>核心 API</strong></p>
<ul>
<li>**on(event, callback)**：订阅事件。</li>
<li>**once(event, callback)**：订阅事件（仅触发一次）。</li>
<li>**emit(event, …args)**：触发事件，传递参数。</li>
<li>**off(event, callback)**：取消事件订阅。</li>
</ul>
<p><strong>实现原理</strong></p>
<p><strong>事件存储</strong>：使用对象或 <code>Map</code> 存储事件名与回调函数列表的映射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">class EventBus &#123;<br>  constructor() &#123;<br>    this.events = new Map(); // &#123; eventName: [callback1, callback2] &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>订阅事件</strong>：将回调添加到对应事件的数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">on(event, callback) &#123;<br>  if (!this.events.has(event)) &#123;<br>    this.events.set(event, []);<br>  &#125;<br>  this.events.get(event).push(callback);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>触发事件</strong>：遍历执行事件对应的所有回调。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">emit(event, ...args) &#123;<br>  const callbacks = this.events.get(event) || [];<br>  callbacks.forEach(cb =&gt; cb(...args)); // 注意复制数组避免循环时修改<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>一次性订阅</strong>：包装回调，执行后自动取消。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">once(event, callback) &#123;<br>  const wrapper = (...args) =&gt; &#123;<br>    callback(...args);<br>    this.off(event, wrapper);<br>  &#125;;<br>  this.on(event, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>取消订阅</strong>：从回调数组中移除指定函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">off(event, callback) &#123;<br>  const callbacks = this.events.get(event) || [];<br>  const filtered = callbacks.filter(cb =&gt; cb !== callback);<br>  this.events.set(event, filtered);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>内存泄漏</strong>：未及时调用 <code>off</code> 可能导致回调堆积。</li>
<li><strong>命名冲突</strong>：全局事件名需统一管理（如使用前缀）。</li>
<li><strong>执行顺序</strong>：多个回调按注册顺序执行，但不应依赖此顺序。</li>
<li><strong>错误处理</strong>：使用 <code>try-catch</code> 避免单个回调崩溃影响整体。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><strong>组件通信</strong>：Vue&#x2F;React 中非父子组件通信。</li>
<li><strong>模块解耦</strong>：插件间通信或异步任务完成通知。</li>
<li><strong>简易状态管理</strong>：小型项目中替代 Redux&#x2F;Vuex。</li>
</ul>
<p><strong>常见库与框架</strong></p>
<ul>
<li><strong>Node.js</strong>：内置 <code>EventEmitter</code> 模块。</li>
<li><strong>Vue</strong>：利用 <code>Vue.prototype.$bus = new Vue()</code> 实现。</li>
<li><strong>第三方库</strong>：<code>mitt</code>（轻量）、<code>PubSubJS</code>（跨平台）。</li>
</ul>
<p><strong>封装简易事件总线</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs plain">class MyEventBus &#123;<br>     constructor() &#123;<br>       this.events = new Map()<br>     &#125;<br>     //订阅函数<br>     on(event, callback) &#123;<br>       //第一次执行,初始化为&#123;event,[]&#125;的Map结构<br>       if (!this.events.has(event)) &#123;<br>         this.events.set(event, []);<br>       &#125;<br>       //每次订阅,添加到对应保存事件的[]中<br>       this.events.get(event).push(callback);<br>     &#125;<br>     //触发函数<br>     emit(event, ...args) &#123;<br>       //取出事件总线中对应的[],依次执行<br>       const callbacks = this.events.get(event) || [];<br>       callbacks.forEach(cb =&gt; cb(...args)); // 注意复制数组避免循环时修改<br>     &#125;<br>     //仅订阅一次<br>     once(event, callback) &#123;<br>       //创建包装函数,执行代码体,执行完后,执行off函数,取消订阅<br>       const wrapper = (...args) =&gt; &#123;<br>         callback(...args);<br>         this.off(event, wrapper);<br>       &#125;;<br>       //进行订阅<br>       this.on(event, wrapper);<br>     &#125;<br>     //取消订阅<br>     off(event, callback) &#123;<br>       const callbacks = this.events.get(event) || [];<br>       //filter过滤出要取消订阅的callback函数,将得到的数组重新设置set(event, filtered)<br>       const filtered = callbacks.filter(cb =&gt; cb !== callback);<br>       this.events.set(event, filtered);<br>     &#125;<br>   &#125;<br><br><br>   const myEventBus = new MyEventBus()<br>   myEventBus.on(&#x27;myClick&#x27;, () =&gt; &#123;<br>     console.log(&#x27;myClick,001&#x27;);<br>   &#125;)<br>   myEventBus.on(&#x27;myClick&#x27;, () =&gt; &#123;<br>     console.log(&#x27;myClick,002&#x27;);<br>   &#125;)<br>   myEventBus.on(&#x27;youClick&#x27;, () =&gt; &#123;<br>     console.log(&#x27;youClick,001&#x27;);<br>   &#125;)<br>   const buttonEle = document.querySelector(&#x27;button&#x27;)<br>   buttonEle.onclick = () =&gt; &#123;<br>     console.log(&#x27;自己监听&#x27;);<br>     myEventBus.emit(&#x27;myClick&#x27;)<br>   &#125;<br></code></pre></td></tr></table></figure>





<h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p><a target="_blank" rel="noopener" href="https://www.yuque.com/wudibawanglong-gbppc/gbvyr0">前端网络</a></p>
<h5 id="一、HTTP-基础"><a href="#一、HTTP-基础" class="headerlink" title="一、HTTP 基础"></a>一、HTTP 基础</h5><ol>
<li><strong>请求方法</strong><ul>
<li><code>GET</code>：获取资源（幂等，参数在 URL 中）</li>
<li><code>POST</code>：提交数据（非幂等，参数在请求体）</li>
<li><code>PUT</code>：更新资源（幂等）</li>
<li><code>DELETE</code>：删除资源（幂等）</li>
<li><code>PATCH</code>：部分更新资源</li>
</ul>
</li>
<li><strong>状态码</strong><ul>
<li><code>200 OK</code>：请求成功</li>
<li><code>301/302</code>：重定向</li>
<li><code>400 Bad Request</code>：客户端错误</li>
<li><code>401 Unauthorized</code>：未认证</li>
<li><code>403 Forbidden</code>：无权限</li>
<li><code>404 Not Found</code>：资源不存在</li>
<li><code>500 Internal Server Error</code>：服务端错误</li>
</ul>
</li>
<li><strong>Header 常见字段</strong><ul>
<li><code>Content-Type</code>：数据类型（如 <code>application/json</code>）</li>
<li><code>Authorization</code>：身份验证（如 <code>Bearer Token</code>）</li>
<li><code>Cache-Control</code>：缓存策略（如 <code>max-age=3600</code>）</li>
<li><code>Accept-Encoding</code>：压缩方式（如 <code>gzip</code>）</li>
</ul>
</li>
</ol>
<h5 id="二、AJAX（Asynchronous-JavaScript-and-XML）"><a href="#二、AJAX（Asynchronous-JavaScript-and-XML）" class="headerlink" title="二、AJAX（Asynchronous JavaScript and XML）"></a>二、AJAX（Asynchronous JavaScript and XML）</h5><p><strong>核心对象</strong> <code>** XMLHttpRequest **</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs plain">const xhr = new XMLHttpRequest();<br>xhr.open(&#x27;GET&#x27;, &#x27;https://api.example.com/data&#x27;);<br>//监听状态的改变<br>xhr.onreadystatechange = function() &#123;<br>  if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;<br>    console.log(JSON.parse(xhr.responseText));<br>  &#125;<br>&#125;;<br>xhr.send();<br>// function myAjax(&#123;<br>    //   url,<br>    //   method = &#x27;get&#x27;,<br>    //   timeout = 5000,<br>    //   headers = &#123;&#125;,<br>    //   data = &#123;&#125;,<br>    //   success,<br>    //   failure<br>    // &#125; = &#123;&#125;) &#123;<br>    //   const xhr = new XMLHttpRequest()<br>    //   xhr.onload = function () &#123;<br>    //     //使用回调函数获取响应结果<br>    //     if (xhr.status == 200) &#123;<br>    //       success &amp;&amp; success(xhr.response)<br>    //     &#125; else &#123;<br>    //       failure &amp;&amp; failure(&#123; status: xhr.status, message: xhr.statusText &#125;)<br>    //     &#125;<br>    //   &#125;<br>    //   xhr.responseType = &#x27;json&#x27;<br>    //   if (method.toUpperCase() === &#x27;GET&#x27;) &#123;<br>    //     const queryStrings = []<br>    //     for (const key in data) &#123;<br>    //       queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)<br>    //     &#125;<br>    //     url = url + &#x27;?&#x27; + queryStrings.join(&#x27;&amp;&#x27;)<br>    //     xhr.open(method, url)<br>    //     xhr.send()<br>    //   &#125; else &#123;<br>    //     xhr.open(method, url)<br>    //     xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/json&#x27;)<br>    //     xhr.send(JSON.stringify(data))<br>    //   &#125;<br>    // &#125;<br><br><br>    function myAjax(&#123;<br>      url,<br>      method = &#x27;get&#x27;,<br>      timeout = 5000,<br>      headers = &#123;&#125;,<br>      data = &#123;&#125;,<br>    &#125; = &#123;&#125;) &#123;<br>      return new Promise((resolve, reject) =&gt; &#123;<br>        //使用Promise获取响应结果<br>        const xhr = new XMLHttpRequest()<br>        xhr.onload = function () &#123;<br>          if (xhr.status == 200) &#123;<br>            resolve(xhr.response)<br>          &#125; else &#123;<br>            reject(&#123; status: xhr.status, message: xhr.statusText &#125;)<br>          &#125;<br>        &#125;<br>        xhr.responseType = &#x27;json&#x27;<br>        xhr.timeout = timeout<br>        if (method.toUpperCase() === &#x27;GET&#x27;) &#123;<br>          const queryStrings = []<br>          for (const key in data) &#123;<br>            queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)<br>          &#125;<br>          url = url + &#x27;?&#x27; + queryStrings.join(&#x27;&amp;&#x27;)<br>          xhr.open(method, url)<br>          xhr.send()<br>        &#125; else &#123;<br>          xhr.open(method, url)<br>          xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/json&#x27;)<br>          xhr.send(JSON.stringify(data))<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    myAjax(&#123;<br>      url: &#x27;your url&#x27;,<br>      method: &#x27;get&#x27;,<br>      data: &#123;<br>        name: &#x27;Mir&#x27;,<br>        age: 18<br>      &#125;<br>    &#125;)<br>const uploadBtn = document.querySelector(&quot;.upload&quot;)<br>    uploadBtn.onclick = function() &#123;<br>      // 1.创建对象<br>      const xhr = new XMLHttpRequest()<br><br>      // 2.监听结果<br>      xhr.onload = function() &#123;<br>        console.log(xhr.response)<br>      &#125;<br><br>      xhr.onprogress = function(event) &#123;<br>        console.log(event)<br>      &#125;<br>      <br><br>      xhr.responseType = &quot;json&quot;<br>      xhr.open(&quot;post&quot;, &quot;http://123.207.32.32:1888/02_param/upload&quot;)<br><br>      const fileEl = document.querySelector(&quot;.file&quot;)<br>      const file = fileEl.files[0]<br><br>      const formData = new FormData()<br>      formData.append(&quot;avatar&quot;, file)<br><br>      xhr.send(formData)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>优缺点</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">-  </span>优点：兼容性好，支持老浏览器。 <br><span class="hljs-bullet">-  </span>缺点：回调地狱，API 设计繁琐。 <br></code></pre></td></tr></table></figure>

<p><strong>1. 基本用法</strong></p>
<ul>
<li><strong>创建对象</strong>：<code>const xhr = new XMLHttpRequest();</code></li>
<li><strong>初始化请求</strong>：<code>xhr.open(method, url, async);</code><ul>
<li><code>method</code>：请求方法（<code>GET</code>、<code>POST</code> 等）。</li>
<li><code>url</code>：请求地址。</li>
<li><code>async</code>：是否异步（默认 <code>true</code>）。</li>
</ul>
</li>
<li><strong>发送请求</strong>：<code>xhr.send(body);</code><ul>
<li><code>body</code>：POST 请求的数据（如 <code>FormData</code> 或字符串）。</li>
</ul>
</li>
</ul>
<p><strong>2. 事件监听</strong></p>
<ul>
<li><strong>响应完成</strong>：<code>xhr.onload = () =&gt; &#123; ... &#125;</code></li>
<li><strong>错误处理</strong>：<code>xhr.onerror = () =&gt; &#123; ... &#125;</code></li>
<li><strong>进度监控</strong>：<code>xhr.onprogress = (event) =&gt; &#123; ... &#125;</code>（上传&#x2F;下载进度）。</li>
<li><strong>状态变化</strong>：<code>xhr.onreadystatechange</code>（通过 <code>xhr.readyState</code> 跟踪状态）。</li>
</ul>
<p><strong>3. 状态与响应</strong></p>
<ul>
<li><code>** readyState **</code> ****<strong>值</strong>：<ul>
<li><code>0</code>：未初始化(代理被创建,未调用open())</li>
<li><code>1</code>：已打开连接(open被调用)</li>
<li><code>2</code>：已接收请求头(send被调用)</li>
<li><code>3</code>：正在接收响应体(loading)</li>
<li><code>4</code>：请求完成</li>
</ul>
</li>
<li><strong>状态码</strong>：<code>xhr.status</code>（如 200、404）。</li>
<li><strong>响应数据</strong>：<ul>
<li><code>xhr.responseText</code>：文本格式。</li>
<li><code>xhr.response</code>：根据 <code>responseType</code> 解析（如 <code>json</code>、<code>blob</code>）。</li>
</ul>
</li>
</ul>
<p><strong>4. 其他特性</strong></p>
<ul>
<li><strong>设置请求头</strong>：<code>xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);</code></li>
<li><strong>超时设置</strong>：<code>xhr.timeout = 5000;</code>，通过 <code>xhr.ontimeout</code> 处理。</li>
<li><strong>中止请求</strong>：<code>xhr.abort();</code></li>
</ul>
<h5 id="三、Fetch-API"><a href="#三、Fetch-API" class="headerlink" title="三、Fetch API"></a>三、Fetch API</h5><p><strong>基于 Promise 的现代方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">fetch(&#x27;https://api.example.com/data&#x27;)<br>  .then(response =&gt; &#123;<br>    if (!response.ok) throw new Error(&#x27;Network error&#x27;);<br>    return response.json();<br>  &#125;) <br>  .then(data =&gt; console.log(data))<br>  .catch(error =&gt; console.error(error));<br>const uploadBtn = document.querySelector(&quot;.upload&quot;)<br>    uploadBtn.onclick = async function() &#123;<br>      const fileEl = document.querySelector(&quot;.file&quot;)<br>      const file = fileEl.files[0]<br><br>      const formData = new FormData()<br>      formData.append(&quot;avatar&quot;, file)<br><br>      // 发送fetch请求<br>      const response = await fetch(&quot;http://123.207.32.32:1888/02_param/upload&quot;, &#123;<br>        method: &quot;post&quot;,<br>        body: formData<br>      &#125;)<br>      const res = await response.json()<br>      console.log(&quot;res:&quot;, res)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>关键特性</strong></p>
<ul>
<li>默认不携带 Cookie（需设置    <code>credentials: &#39;include&#39;</code> ） </li>
<li>支持流式数据处理（如    <code>response.body</code> ） </li>
<li>可通过    <code>AbortController</code>    中止请求。</li>
</ul>
<p><strong>1. 基本用法</strong></p>
<p><strong>发起请求</strong>：<code>fetch(url, options)</code></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">- <span class="hljs-string">` options `</span> ：配置对象（方法、头、体等）。 <br>fetch(url, &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">method</span>: &#x27;<span class="hljs-title">POST</span>&#x27;,</span><br><span class="hljs-function">  <span class="hljs-title">headers</span>: </span>&#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>  body: JSON.stringify(data),<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>返回 Promise</strong>：处理响应或错误。</li>
</ul>
<p><strong>2. 响应处理</strong></p>
<ul>
<li><strong>解析数据</strong>：<ul>
<li><code>response.json()</code>：解析为 JS ON。</li>
<li><code>response.text()</code>：解析为文本。</li>
<li><code>response.blob()</code>：解析为二进制数据。</li>
</ul>
</li>
</ul>
<p><strong>状态检查</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (response.ok) &#123; // 状态码 200-299<br>  // 处理成功<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3. 错误处理</strong></p>
<ul>
<li><strong>网络错误</strong>：自动触发 <code>catch</code>。</li>
<li><strong>HTTP 错误（如 404）</strong>：需手动检查 <code>response.ok</code>。</li>
</ul>
<p><strong>4. 高级功能</strong></p>
<p><strong>中止请求</strong>：使用 <code>AbortController</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const controller = new AbortController();<br>fetch(url, &#123; signal: controller.signal &#125;);<br>controller.abort(); // 中止请求<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>跨域请求</strong>：默认不携带凭据，需设置 <code>credentials: &#39;include&#39;</code>。</li>
</ul>
<h5 id="四、Axios（第三方库）"><a href="#四、Axios（第三方库）" class="headerlink" title="四、Axios（第三方库）"></a>四、Axios（第三方库）</h5><p><strong>功能丰富的 HTTP 客户端</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.get(&#x27;https://api.example.com/data&#x27;)<br>  .then(response =&gt; console.log(response.data))<br>  .catch(error =&gt; console.error(error));<br><br>// POST 请求示例<br>axios.post(&#x27;/api/post&#x27;, &#123; data: &#x27;value&#x27; &#125;, &#123;<br>  headers: &#123; &#x27;X-Custom-Header&#x27;: &#x27;value&#x27; &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>核心优势</strong><ul>
<li>自动转换 JSON 数据。</li>
<li>拦截器（请求&#x2F;响应拦截）。</li>
<li>客户端防御 XSRF。</li>
<li>取消请求（通过 <code>CancelToken</code> 或 <code>AbortController</code>）。</li>
</ul>
</li>
</ol>
<h5 id="五、跨域问题（CORS）"><a href="#五、跨域问题（CORS）" class="headerlink" title="五、跨域问题（CORS）"></a>五、跨域问题（CORS）</h5><ol>
<li><strong>同源策略</strong>   协议、域名、端口一致才允许请求。</li>
<li><strong>解决方案</strong><ul>
<li><strong>CORS（跨域资源共享）</strong>   服务端设置响应头（如 <code>Access-Control-Allow-Origin: *</code>）。</li>
</ul>
</li>
</ol>
<p><strong>JSONP</strong>   利用 <code>&lt;script&gt;</code> 标签跨域（仅支持 GET）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function handleResponse(data) &#123; console.log(data); &#125;<br>const script = document.createElement(&#x27;script&#x27;);<br>script.src = &#x27;https://api.example.com/data?callback=handleResponse&#x27;;<br>document.body.appendChild(script);<br>- ** 代理服务器 **   <br></code></pre></td></tr></table></figure>

<p> 通过后端或工具（如 Webpack DevServer）转发请求。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><strong>XHR vs Fetch 对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>XHR</strong></th>
<th><strong>Fetch</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>语法</strong></td>
<td>回调&#x2F;事件驱动，较冗长</td>
<td>Promise 链式调用，更简洁</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>需监听 <code>onerror</code><br>和状态码</td>
<td>网络错误触发 <code>catch</code><br>，HTTP 错误需手动检查</td>
</tr>
<tr>
<td><strong>中止请求</strong></td>
<td><code>xhr.abort()</code></td>
<td><code>AbortController</code></td>
</tr>
<tr>
<td><strong>进度监控</strong></td>
<td>支持（<code>onprogress</code><br>）</td>
<td>不直接支持，需通过 Stream 处理</td>
</tr>
<tr>
<td><strong>默认携带 Cookie</strong></td>
<td>是</td>
<td>需设置 <code>credentials: &#39;include&#39;</code></td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>广泛支持（包括旧浏览器）</td>
<td>不支持 IE，需 polyfill</td>
</tr>
</tbody></table>
<ul>
<li><strong>传统 AJAX</strong> 适合兼容性要求高的场景。</li>
<li><strong>Fetch API</strong> 是现代化、轻量的选择。</li>
<li><strong>Axios</strong> 提供更全面的功能和企业级支持。</li>
<li><strong>跨域问题</strong> 需服务端配合或使用代理。</li>
<li><strong>WebSocket</strong> 实现实时双向通信。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JS/" class="category-chain-item">JS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JavaScript%E9%AB%98%E7%BA%A7/" class="print-no-link">#JavaScript高级</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JavaScript高级</div>
      <div>http://example.com/2025/02/25/JavaScript高级/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>MrZ</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/24/JavaScript%E5%9F%BA%E7%A1%80/" title="JavaScript基础">
                        <span class="hidden-mobile">JavaScript基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
