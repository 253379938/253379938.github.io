<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript高级</title>
    <link href="/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/"/>
    <url>/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>this 绑定<br>this 绑定的三种方式</p><p>默认绑定:独立调用,this 指向 window</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>        // "use strict"<pre><code class="hljs">    //普通函数的独立调用,window    function foo() &#123;        console.log(&#39;foo的this&#39;,this);    &#125;    foo()    //定义在对象中,独立调用,window    var obj=&#123;        bar:function()&#123;            console.log(&#39;bar的this&#39;,this);        &#125;    &#125;    var baz=obj.bar    baz()    //函数互相调用,window    function foo1(fn)&#123;        fn()    &#125;    foo1(baz)    //在严格模式下,独立调用函数的this,为undefined&lt;/script&gt;</code></pre></body></html>隐式绑定,通过某个对象进行调用的,this指向调用对象<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>        //隐式绑定      function foo(){        console.log('foo',this);      }      var obj={        name:"obj",        bar:foo      }      obj.bar()    </script></body></html>new绑定,this指向创建的空对象(函数当做一个类的构造函数来使用，也就是使用new关键字)<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>    /*     1.创建空对象    2.将this指向空对象,将函数的显式原型赋值给对象的隐式原型    3.执行函数体的代码    4.无显示返回非空对象时,会默认显示这个对象     */<pre><code class="hljs"> function foo()&#123;    console.log(&#39;foo&#39;,this);    this.name=&#39;MirZ&#39; &#125; new foo()&lt;/script&gt;</code></pre></body></html>显式绑定,this指向要绑定的对象<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>   function foo(){    console.log('foo',this);   }   var obj={    name:'MirZ'   }   //将foo函数的this指向obj,使用call/apply   foo.call(obj)   foo.apply(obj)    </script></body></html><p>显式绑定</p><p>call&#x2F;apply</p><p>如果我们不希望在对象内部包含这个函数的引用同时又希望在这个对象上进行强制调用可以使用 call 和 apply 方法</p><p>第一个参数传入指定绑定的对象;</p><p>后面的参数，apply 为数组，call 为参数列表;</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>        function foo(name, age) {            console.log('foo调用', this);            console.log('参数', name, age);        }        var obj={}        //使用call/apply,将foo函数指向obj        // foo.apply(obj)        // foo.call(obj)        //传入原始类型,会指向原始类型封装的对应包装类型对象        // foo.call(123)        // foo.apply('Mir')<pre><code class="hljs">    //传参    foo.call(&#39;1&#39;, &#39;MirZ&#39;, 18)    foo.apply(&#39;1&#39;,[&#39;MirZ&#39;,18])&lt;/script&gt;</code></pre></body></html>bind<p>如果我们希望一个函数总是显示的绑定到一个对象上，可以使用 bind 绑定函数</p><p>使用 bind 方法，bind()方法创建一个新的绑定函数(bound function，BF)</p><p>绑定函数是一个 exotic function object(怪异函数对象，ECMAScript 2015 中的术语)</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><body>    <script>        function foo(name, age) {            console.log('foo调用', this);            console.log("参数",name,age);            <pre><code class="hljs">    &#125;    var obj=&#123;&#125;    //需求:调用foo时，总是绑定到obj对象身上    // var bar=foo.bind(obj) //yhis-&gt;obj    // bar()    // bar()    // bar()    //传参    var bar=foo.bind(obj,&#39;Mir&#39;)    bar()    bar(18)&lt;/script&gt;</code></pre></body></html><p>this 绑定优先级</p><p>默认规则的优先级最低,存在其他规则时，就会通过其他规则的方式绑定 this</p><p>显示绑定优先级高于隐式绑定</p><p>new 绑定优先级高于隐式绑定</p><p>new 绑定优先级高于 bind</p><p>new 绑定和 call、apply 是不允许同时使用的，所以不存在谁的优先级更高</p><p>new 绑定可以和 bind 一起使用，new 绑定优先级更高</p><p>bind 和 apply&#x2F;call 同时使用,bind 优先级更高</p><p>箭头函数</p><p>箭头函数是 ES6 之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁:</p><p>箭头函数不会绑定 this、arguments 属性,</p><p>箭头函数不能作为构造函数来使用(不能和 new 一起来使用，会抛出错误):</p><p>箭头函数的简写</p><p>优化一: 如果只有一个参数()可以省略</p><p>nums.forEach(item&#x3D;&gt;{})</p><p>优化二: 如果函数执行体中只有一行代码,那么可以省略大括号并且这行代码的返回值会作为整个函数的返回值</p><p>nums.forEach(item &#x3D;&gt;console.log(item))</p><p>nums.filter(item &#x3D;&gt; true)</p><p>优化三: 如果函数执行体只有返回一个对象，那么需要给这个对象加上()</p><p>var foo&#x3D;()&#x3D;&gt;return{ name:”abc”}</p><p>var. bar&#x3D;()&#x3D;&gt;({name:”abc”})</p><p>箭头函数不使用 this 的四种标准规则(也就是不绑定 this)，而是根据**外层作用域****来决定 this.**</p><p>this 指向面试题:</p><p>var name &#x3D; ‘window’</p><p>&#x2F;&#x2F; {} -&gt; 对象<br>&#x2F;&#x2F; {} -&gt; 代码块<br>var person1 &#x3D; {<br>name: ‘person1’,<br>foo1: function () {<br>console.log(this.name)<br>},<br>foo2: () &#x3D;&gt; console.log(this.name),<br>foo3: function () {<br>return function () {<br>console.log(this.name)<br>}<br>},<br>foo4: function () {<br>&#x2F;&#x2F; console.log(this) &#x2F;&#x2F; 第一个表达式 this -&gt; person1<br>&#x2F;&#x2F; console.log(this) &#x2F;&#x2F; 第二个表达式 this -&gt; person2<br>&#x2F;&#x2F; console.log(this) &#x2F;&#x2F; 第三个表达式 this -&gt; person1</p><pre><code class="hljs">return () =&gt; &#123;  console.log(this.name)&#125;</code></pre><p>}<br>}</p><p>var person2 &#x3D; { name: ‘person2’ }</p><p>&#x2F;&#x2F; 开始题目:<br>person1.foo1(); &#x2F;&#x2F; 隐式绑定: person1<br>person1.foo1.call(person2); &#x2F;&#x2F; 显式绑定: person2</p><p>person1.foo2(); &#x2F;&#x2F; 上层作用域: window<br>person1.foo2.call(person2); &#x2F;&#x2F; 上层作用域: window</p><p>person1.foo3()(); &#x2F;&#x2F; 默认绑定: window<br>person1.foo3.call(person2)(); &#x2F;&#x2F; 默认绑定: window<br>person1.foo3().call(person2); &#x2F;&#x2F; 显式绑定: person2</p><p>person1.foo4()(); &#x2F;&#x2F; person1<br>person1.foo4.call(person2)(); &#x2F;&#x2F; person2<br>person1.foo4().call(person2); &#x2F;&#x2F; person1<br>var name &#x3D; ‘window’</p><p>&#x2F;_ 1.创建一个空的对象 2.将这个空的对象赋值给 this 3.执行函数体中代码 4.将这个新的对象默认返回<br>_&#x2F;<br>function Person(name) {<br>this.name &#x3D; name<br>this.foo1 &#x3D; function () {<br>console.log(this.name)<br>},<br>this.foo2 &#x3D; () &#x3D;&gt; console.log(this.name),<br>this.foo3 &#x3D; function () {<br>return function () {<br>console.log(this.name)<br>}<br>},<br>this.foo4 &#x3D; function () {<br>return () &#x3D;&gt; {<br>console.log(this.name)<br>}<br>}<br>}</p><p>&#x2F;&#x2F; person1&#x2F;person 都是对象(实例 instance)<br>var person1 &#x3D; new Person(‘person1’)<br>var person2 &#x3D; new Person(‘person2’)</p><p>&#x2F;&#x2F; 面试题目:<br>person1.foo1() &#x2F;&#x2F; 隐式绑定: person1<br>person1.foo1.call(person2) &#x2F;&#x2F; 显式绑定: person2</p><p>person1.foo2() &#x2F;&#x2F; 上层作用域查找: person1<br>person1.foo2.call(person2) &#x2F;&#x2F; 上层作用域查找: person1</p><p>person1.foo3()() &#x2F;&#x2F; 默认绑定: window<br>person1.foo3.call(person2)() &#x2F;&#x2F; 默认绑定: window<br>person1.foo3().call(person2) &#x2F;&#x2F; 显式绑定: person2</p><p>person1.foo4()() &#x2F;&#x2F; 上层作用域查找: person1(隐式绑定)<br>person1.foo4.call(person2)() &#x2F;&#x2F; 上层作用域查找: person2(显式绑定)<br>person1.foo4().call(person2) &#x2F;&#x2F; 上层作用域查找: person1(隐式绑定)<br>var name &#x3D; ‘window’</p><p>&#x2F;_ 1.创建一个空的对象 2.将这个空的对象赋值给 this 3.执行函数体中代码 4.将这个新的对象默认返回<br>_&#x2F;<br>function Person(name) {<br>this.name &#x3D; name<br>this.obj &#x3D; {<br>name: ‘obj’,<br>foo1: function () {<br>return function () {<br>console.log(this.name)<br>}<br>},<br>foo2: function () {<br>return () &#x3D;&gt; {<br>console.log(this.name)<br>}<br>}<br>}<br>}</p><p>var person1 &#x3D; new Person(‘person1’)<br>var person2 &#x3D; new Person(‘person2’)</p><p>person1.obj.foo1()() &#x2F;&#x2F; 默认绑定: window<br>person1.obj.foo1.call(person2)() &#x2F;&#x2F; 默认绑定: window<br>person1.obj.foo1().call(person2) &#x2F;&#x2F; 显式绑定: person2</p><p>person1.obj.foo2()() &#x2F;&#x2F; 上层作用域查找: obj(隐式绑定)<br>person1.obj.foo2.call(person2)() &#x2F;&#x2F; 上层作用域查找: person2(显式绑定)<br>person1.obj.foo2().call(person2) &#x2F;&#x2F; 上层作用域查找: obj(隐式绑定)</p><p>浏览器原理<br>浏览器渲染页面的过程</p><p>浏览器渲染页面过程:</p><p>浏览器渲染原理</p><p>在解析 JS 是堵塞也往往会带来新的问题，特别是现代页面开发中:</p><p>目前的开发模式中(比如 Vue、React)，脚本往往比 HTML 页面更“重”处理时间需要更长所以会造成页面的解析阻塞，在脚本下载、执行完成之前，用户在界面上什么都看不到;</p><p>为了解决这个问题，script 元素给我们提供了两个属性(attribute):defer 和 async。</p><p>defer</p><p>defer 属性告诉浏览器不要等待脚本下载，而继续解析 HTML，构建 DOM Tree</p><p>脚本会由浏览器来进行下载，但是不会阻塞 DOM Tree 的构建过程;</p><p>如果脚本提前下载好了，它会等待 DOM Tree 构建完成，在 DOMContentLoaded 事件之前先执行 defer 中的代码</p><p>多个带 defer 的脚本是可以保持正确的顺序执行的。</p><p>从某种角度来说，defer 可以提高页面的性能，并且推荐放到 head 元素中;</p><p>注意:defer 仅适用于外部脚本，对于 script 默认内容会被忽略</p><p>async</p><p>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。</p><p>async 是让一个脚本完全独立的:</p><p>浏览器不会因 async 脚本而阻塞(与 defer 类似);</p><p>async 脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本</p><p>async 不会能保证在 DOMContentLoaded 之前或者之后执行</p><p>:::info<br>defer 通常用于需要在文档解析后操作 DOM 的 JavaScript 代码，并且对多个 script 文件有顺序要求的;</p><p>async 通常用于独立的脚本，对其他脚本，甚至 DOM 没有依赖的;</p><p>:::</p><p>Js 原理<br>JS 执行原理</p><p>初始化全局对象</p><p>js 引擎会在执行代码之前，会在堆内存中创建一个全局对象:GlobalObject(GO)</p><p>该对象所有的作用域(scope)都可以访问;里面会包含 Date、Array、String、Number、setTimeout、setlnterval 等等.其中还有一个 window 属性指向自己</p><p>全局代码如何被执行?</p><p>js 引擎内部有一个执行上下文栈(Execution Context Stack，简称 ECS)它是用于执行代码的调用栈</p><p>那么现在它要执行谁呢?执行的是全局的代码块</p><p>全局的代码块为了执行会构建一个 Global Execution Context(GEC)</p><p>GEC 会 被放入到 ECS 中执行;</p><p>每一个执行上下文会关联一个 VO(Variable Object，变量对象)**,****变量和函数声明**会被添加到这个 VO 对象中</p><p>当全局代码被执行的时候，VO 就是 GO 对象了</p><p>GEC 被放入到 ECS 中里面包含两部分内容:</p><p>第一部分:在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入等加入到 GlobalObject 中，但是并不会赋值;</p><p>这个过程也称之为变量的作用域提升(hoisting)</p><p>第二部分:在代码执行中，对变量赋值，或者执行其他的函数;</p><p>函数如何被执行?</p><p>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文(FunctionalExecutionContext，简称 FEC)并且压入到 EC Stack 中。</p><p>因为每个执行上下文都会关联一个 VO，那么函数执行上下文关联的 VO 是什么呢?</p><p>当进入一个函数执行上下文时，会创建一个 AO 对象(Activation Object)</p><p>这个 AO 对象会使用 arguments 作为初始化，并且初始值是传入的参数;</p><p>这个 AO 对象会作为执行上下文的 VO 来存放变量的初始化;</p><p>作用域链</p><p>当进入到一个执行上下文时，执行上下文也会关联一个作用域链(Scope Chain)</p><p>作用域链是一个对象列表，用于变量标识符的求值;当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // 1.面试题一:    // var n = 100    // function foo() {    //   n = 200    // }    // foo()        // console.log(n)        // 2.面试题二:    // var n = 100    // function foo() {    //   console.log(n)    //   var n = 200    //   console.log(n)    // }        // foo()        // 3.面试题三:    // var n = 100        // function foo1() {    //   console.log(n)    // }    // function foo2() {    //   var n = 200    //   console.log(n)    //   foo1()    // }    // foo2()        // 4.面试题四:    // var n = 100    // function foo() {    //   console.log(n)     //   return    //   var n = 200   //var a是在编译解析阶段,已经声明,return是在执行阶段结束    // }    // foo()        // 5.在开发中可能会出现这样错误的写法    // function foo() {    //   message = "Hello World" //没有声明,会被放到全局    // }    // foo()    // console.log(message)        // 6.面试题五:    function foo() {      var a = b = 100    }    foo()    console.log(b)  </script></body></html>词法环境是一种规范类型，用于在词法嵌套结构中定义关联的变量、函数等标识符;<p>一个词法环境是由环境记录(Environment Record)和一个外部词法环境(oute;rLexicalEnvironment)组成:</p><p>一个词法环境经常用于关联一个函数声明、代码块语句、try-catch 语句，当它们的代码被执行时，词法环境被创建出来;</p><p>全局词法环境</p><p>全局词法环境是最外层的词法环境，它在 JavaScript 程序开始执行时就被创建，并且在整个程序的生命周期内都存在。全局词法环境的外部引用为 null。</p><p>函数词法环境</p><p>每当调用一个函数时，就会为该函数创建一个新的词法环境。函数词法环境的外部引用指向创建该函数时所在的词法环境。</p><ul><li>LexicalEnvironment 用于处理 let、const 声明的标识符</li><li>VariableEnyionment 用于处理 var 和 function 声明的标识符:<br>环境记录</li></ul><p>在这个规范中有两种主要的环境记录值:声明式环境记录和对象环境记录。</p><p>声明式环境记录:声明性环境记录用于定义 ECMAScript 语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定</p><p>对象式环境记录:对象环境记录用于定义 ECMAScript 元素的效果，例如 WithStatement，它将标识符绑定与某些对象的属</p><p>关联起来。</p><p>JS 内存管理</p><p>不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要我们自己手动的管理内存,某些编程语言会可以自动帮助我们管理内存:</p><p>不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期:</p><p>第一步:分配申请你需要的内存(申请);</p><p>第二步:使用分配的内存(存放一些东西，比如对象等);</p><p>第三步:不需要使用时，对其进行释放;</p><p>不同的编程语言对于第一步和第三步会有不同的实现:</p><p>手动管理内存:比如 C、C++，包括早期的 OC 都是需要手动来管理内存的申请和释放的(malloc 和 free 函数)</p><p>自动管理内存:比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存;</p><p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数.…这一切都会占用内存,但是我们并不需要手动来对它们进行管理 JavaScript 引 l 擎会帮助我们处理好它;</p><p>JavaScript 会在定义数据时为我们分配内存。</p><p>JS 对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配;</p><p>JS 对于复杂数据类型内存分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用;</p><p>JS 的垃圾回收机制</p><p>** **因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间。</p><p>在手动管理内存的语言中，我们需要通过一些方式自己来释放不再需要的内存，比如 free 函数:</p><p>这种管理的方式其实非常的低效，影响我们编写逻辑的代码的效率，</p><p>这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露，</p><p>所以大部分现代的编程语言都是有自己的垃圾回收机制:</p><p>垃圾回收的英文是 Garbage Collection，简称 GC;对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间;而我们的语言运行环境，比如 java 的运行环境 IM，JavaScript 的运行环境 js 引擎都会内存 垃圾回收器</p><p>GC 算法-标记-清除算法</p><p>标记-清除是最基础的垃圾回收算法。它的工作原理如下</p><p>标记清除的核心思路是可达性,这个算法是设置根对象(root object)垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象</p><p>标记阶段：垃圾回收器会遍历所有的对象，从根对象（如全局对象）开始，将所有可达对象标记为活动的。</p><p>清除阶段：对于那些没有被标记为活动的对象，垃圾回收器会将其内存释放。</p><p>优点</p><p>可靠性：确保所有不再需要的对象都会被正确回收。</p><p>简单性：实现相对简单，易于维护。</p><p>缺点</p><p>暂停程序执行：在垃圾回收期间需要暂停程序执行（Stop-the-world），可能会影响性能。</p><p>遍历整个对象图：需要遍历整个对象图，处理大对象图时效率较低。</p><p>GC 算法-引用计数</p><p>引用计数是一种较早的垃圾回收算法。它的工作原理如下：</p><p>计数：每个对象维护一个引用计数器，用于记录有多少其他对象引用它。</p><p>增加引用：当有一个新的引用指向该对象时，计数器加 1。</p><p>减少引用：当一个引用不再指向该对象时，计数器减 1。</p><p>释放内存：当计数器变为 0 时，该对象可以被回收，因为没有任何引用指向它。</p><p>优点</p><p>即时回收：一旦对象的引用计数变为 0，可以立即回收，不需要等待垃圾回收的周期。</p><p>简单：实现相对简单，不需要复杂的标记和清除过程。</p><p>缺点</p><p>循环引用问题：如果两个对象互相引用，即使它们没有其他引用指向它们，引用计数器永远不会变为 0，从而导致内存泄漏。</p><p>性能开销：每次引用增加或减少都需要更新计数器，会带来一定的性能开销。</p><p>GC 算法-分代收集</p><p>分代收集基于对象的生命周期假设：大多数对象是短命的，少数对象是长命的。它将堆内存划分为两代：新生代和老年代。</p><p>新生代：存放生命周期短的对象。垃圾回收器会频繁地检查并清理新生代，因为新对象的创建和销毁非常频繁。</p><p>老年代：存放生命周期长的对象。垃圾回收器对老年代的检查和清理频率较低，因为这些对象大多长期存在。</p><p>优点</p><p>效率高：新生代对象的清理操作较为快速，整体垃圾回收效率高。</p><p>减少暂停时间：新生代的清理操作时间较短，减少了程序暂停时间。</p><p>缺点</p><p>复杂性：实现和维护较为复杂，需要有效区分和管理新生代和老年代对象。</p><p>内存占用：需要更多的内存来维护新生代和老年代的分代结构。</p><p>V8 的垃圾回收机制</p><p>V8 使用了分代垃圾回收，结合了标记-清除、标记-压缩和增量标记（Incremental Marking）等技术。</p><p>标记-清除：对新生代对象进行快速标记和清除。</p><p>标记-压缩：对老年代对象进行标记和压缩，以减少内存碎片。</p><p>增量标记：将垃圾回收过程拆分成多个小步骤，穿插在正常的程序执行过程中，减少程序暂停时间。</p><p>闲时收集: 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</p><p>JS 闭包<br>闭包的定义</p><p>在计算机科学中对闭包的定义(维基百科):</p><p>闭包(英语:Closure)，又称词法闭包(LexicalClosure)或函数闭包(function closures);</p><p>是在支持 头等函数 的编程语言中，实现词法绑定的一种技术;</p><p>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境((相当于一个符号查找表):</p><p>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 自由变量 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行。</p><p>MDN 对 JavaScript 闭包的解释:</p><p>一个函数和对其周围状态(lexical environment，词法环境)的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是闭包(cosure)也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域;在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来;</p><p>一个普通函数 function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包;</p><p>从广义的角度来说:Javascript 中的函数都是闭包;</p><p>从狭义的角度来说:Javascript 中一个函数，如果访问了外层作用域的变量，那么它是一个闭包;</p><p>闭包的访问过程</p><p>作用域链（Scope Chain）</p><p>定义：作用域链是 JavaScript 中变量查找的机制。每个函数在执行时都会创建一个作用域链，这个链由当前执行上下文的变量对象（Variable Object）和所有外层（父级）执行上下文的变量对象组成。</p><p>作用：当访问一个变量时，JavaScript 引擎会沿着作用域链逐层向上查找变量，直到找到变量或到达全局作用域（若未找到则报错）。</p><p>示例：</p><p>function outer() {<br>const a &#x3D; 10;<br>function inner() {<br>console.log(a); &#x2F;&#x2F; 通过作用域链找到 outer 中的 a<br>}<br>inner();<br>}<br>outer(); &#x2F;&#x2F; 输出 10<br>在 <font style="color:rgb(64, 64, 64);">inner</font> 函数中访问 <font style="color:rgb(64, 64, 64);">a</font> 时，作用域链会依次查找 <font style="color:rgb(64, 64, 64);">inner</font> → <font style="color:rgb(64, 64, 64);">outer</font> → 全局作用域。</p><ol start="2"><li>闭包（Closure）</li></ol><p>定义：闭包是函数能够访问其词法作用域外的变量的能力，即使这个函数在其词法作用域外被调用。闭包的实现依赖于作用域链。</p><p>本质：闭包是作用域链的一种应用结果。当一个函数引用了外层作用域的变量，且该函数被传递到其他作用域执行时，闭包会保留对外层作用域的引用，从而避免变量被垃圾回收。</p><p>示例：</p><p>function outer() {<br>const a &#x3D; 10;<br>return function inner() {<br>console.log(a); &#x2F;&#x2F; 闭包保留了对外层 a 的引用<br>};<br>}<br>const innerFunc &#x3D; outer();<br>innerFunc(); &#x2F;&#x2F; 输出 10（即使 outer 已执行完毕，仍能访问 a）<br>这里，<font style="color:rgb(64, 64, 64);">inner</font> 函数通过闭包保留了 <font style="color:rgb(64, 64, 64);">outer</font> 的作用域，即使 <font style="color:rgb(64, 64, 64);">outer</font> 已经执行完毕。</p><ol start="3"><li>区别与联系</li></ol><p>特性 作用域链 闭包<br>角色 变量查找的规则和路径 基于作用域链实现的一种现象（函数保留对外层作用域的引用）<br>存在时机 函数执行时自动创建 当函数引用了外层变量，并在其他作用域被调用时形成<br>内存管理 作用域链在函数执行完毕后通常会被销毁（除非有闭包） 闭包会导致外层作用域的变量对象无法被垃圾回收，可能引起内存泄漏<br>核心目的 确定变量的可访问性 让函数“记住”并访问其词法作用域外的变量<br>总结</p><p>作用域链是底层机制，决定了变量如何被查找。</p><p>闭包是上层现象，是作用域链在特定场景（函数跨作用域执行）下的表现。</p><p>可以说，闭包的实现依赖于作用域链，但两者不是同一个概念。</p><p>内存泄漏及释放内存</p><p>内存泄漏（Memory Leak） 指的是程序运行过程中不再需要的内存没有被及时释放，导致内存占用持续增长，最终可能引发性能问题甚至程序崩溃。</p><p>二、常见内存泄漏场景及解决方案</p><p>以下是 JavaScript 中常见的内存泄漏场景及其解决方法：</p><ol><li>意外的全局变量</li></ol><p>问题：未使用 <font style="color:rgb(64, 64, 64);">var</font>&#x2F;<font style="color:rgb(64, 64, 64);">let</font>&#x2F;<font style="color:rgb(64, 64, 64);">const</font> 声明的变量会成为全局变量，无法被回收。</p><p>function leak() {<br>globalVar &#x3D; “I am a global variable!”; &#x2F;&#x2F; 意外创建全局变量<br>}<br>解决：始终使用 <font style="color:rgb(64, 64, 64);">‘use strict’</font> 严格模式，或显式声明变量。</p><ol start="2"><li>未清理的定时器（Timers）或回调函数</li></ol><p>问题：<font style="color:rgb(64, 64, 64);">setInterval</font> 或事件监听未及时清除，导致回调函数及其依赖的变量无法释放。</p><p>const intervalId &#x3D; setInterval(() &#x3D;&gt; {<br>&#x2F;&#x2F; 长期运行的定时器<br>}, 1000);</p><p>&#x2F;&#x2F; 未调用 clearInterval(intervalId) 会导致内存泄漏<br>解决：在不需要时手动清除定时器或事件监听。</p><ol start="3"><li>闭包滥用</li></ol><p>问题：闭包保留了对外部变量的引用，导致外部作用域的变量无法释放。</p><p>function createClosure() {<br>const largeData &#x3D; new Array(1000000).fill(“data”);<br>return function() {<br>&#x2F;&#x2F; 闭包引用了 largeData，即使不再需要，largeData 也无法被回收<br>};<br>}<br>const closure &#x3D; createClosure();<br>解决：在闭包中避免保留不必要的大对象，或在不需要时手动解除引用（如 <font style="color:rgb(64, 64, 64);">closure &#x3D; null</font>）。</p><ol start="4"><li>未释放的 DOM 引用</li></ol><p>问题：保留对已移除 DOM 元素的引用，导致 DOM 元素无法被回收。</p><p>const elements &#x3D; {<br>button: document.getElementById(“myButton”),<br>};</p><p>&#x2F;&#x2F; 即使从页面移除了按钮，elements.button 仍保留引用<br>document.body.removeChild(document.getElementById(“myButton”));<br>解决：在移除 DOM 元素后，手动解除引用（如 <font style="color:rgb(64, 64, 64);">elements.button &#x3D; null</font>）。</p><ol start="5"><li>事件监听未移除</li></ol><p>问题：为 DOM 元素添加事件监听后未移除，导致元素无法被回收。</p><p>const button &#x3D; document.getElementById(“myButton”);<br>button.addEventListener(“click”, handleClick);</p><p>&#x2F;&#x2F; 未调用 removeEventListener 会导致元素和事件处理函数无法释放<br>解决：在移除元素前手动移除事件监听。</p><p>函数增强<br>函数的 arguments 和剩余参数</p><p>在 JavaScript 中，**<font style="color:rgb(64, 64, 64);">arguments</font>** 是函数内部的一个特殊对象，用于表示函数被调用时传入的所有参数（无论是否在形参列表中声明）。</p><p>类数组对象：<font style="color:rgb(64, 64, 64);">arguments</font> 是一个类数组对象（Array-like Object），具有数字索引和 <font style="color:rgb(64, 64, 64);">length</font> 属性，但不支持数组方法（如 <font style="color:rgb(64, 64, 64);">push</font>、<font style="color:rgb(64, 64, 64);">map</font> 等）。</p><p>动态绑定：<font style="color:rgb(64, 64, 64);">arguments</font> 的内容会随着函数参数的变化而动态更新（非严格模式下）。</p><p>非箭头函数独有：箭头函数（Arrow Function）没有自己的 <font style="color:rgb(64, 64, 64);">arguments</font> 对象。</p><p>类数组转数组</p><p>如果需要使用数组方法，需将 <font style="color:rgb(64, 64, 64);">arguments</font> 转换为真正的数组：</p><p>function logArgs() {<br>&#x2F;&#x2F; 使用 slice 截取<br>&#x2F;&#x2F;const newArr&#x3D;Array.prototype.slice.apply(arguments)<br>&#x2F;&#x2F; 使用 Array.from() 或扩展运算符<br>const argsArray &#x3D; Array.from(arguments);<br>&#x2F;&#x2F; 或者 const argsArray &#x3D; […arguments];</p><p>argsArray.forEach(arg &#x3D;&gt; console.log(arg));<br>}<br>logArgs(“a”, “b”); &#x2F;&#x2F; 输出 “a”, “b”<br>严格模式下的行为</p><p>在严格模式（<font style="color:rgb(64, 64, 64);">‘use strict’</font>）中，<font style="color:rgb(64, 64, 64);">arguments</font> 与形参解耦，修改 <font style="color:rgb(64, 64, 64);">arguments</font> 不会影响形参，反之亦然：</p><p>function strictExample(a, b) {<br>‘use strict’;<br>arguments[0] &#x3D; 100;<br>console.log(a); &#x2F;&#x2F; 输出原始的 a 值（非严格模式下会输出 100）<br>}<br>strictExample(1, 2);<br><font style="color:rgb(64, 64, 64);"></font><strong><font style="color:rgb(64, 64, 64);">arguments</font></strong> 与箭头函数</p><p>箭头函数没有自己的 <font style="color:rgb(64, 64, 64);">arguments</font> 对象，但可以访问外层函数的 <font style="color:rgb(64, 64, 64);">arguments</font>：</p><p>function outer() {<br>const inner &#x3D; () &#x3D;&gt; {<br>console.log(arguments); &#x2F;&#x2F; 输出 outer 的 arguments<br>};<br>inner();<br>}<br>outer(1, 2); &#x2F;&#x2F; 输出 { 0: 1, 1: 2 }<br>替代方案：剩余参数（Rest Parameters）</p><p>ES6 引入了 剩余参数（**<font style="color:rgb(64, 64, 64);">…args</font>**），它是真正的数组，更推荐使用：</p><p>function sum(…args) {<br>return args.reduce((acc, val) &#x3D;&gt; acc + val, 0);<br>}<br>console.log(sum(1, 2, 3)); &#x2F;&#x2F; 输出 6<br>优势对比：</p><p>特性 <strong>arguments</strong> 剩余参数（**…args**<br>）<br>类型 类数组对象 真正的数组<br>与形参的绑定 动态绑定（非严格模式） 独立<br>箭头函数支持 不支持 支持<br>可读性 低（隐式传递参数） 高（显式声明参数）</p><p>纯函数</p><p>纯函数的维基百科定义:</p><p>在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数:</p><p>此函数在相同的输入值时，需产生相同的输出。</p><p>函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 I&#x2F;0 设备产生的外部输出无关。</p><p>该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。</p><p>:::tips<br>计算机科学中，也引用了副作用的概念，表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响,比如修改了全局变量，修改参数或者改变外部的存储;</p><p>:::</p><p>纯函数作用</p><p>在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改;</p><p>输入内容不会被任意篡改，并且确定的输入，一定会有确定的输出;</p><p>:::tips<br>React 中就要求我们无论是函数还是 class 声明一个组件，这个组件都必须像纯函数一样，保护它们的 props 不被修改</p><p>:::</p><p>函数柯里化</p><p>函数柯里化定义</p><p>在计算机科学中，柯里化(英语:Currying)，又译为卡瑞化或加里化:</p><p>是把接收多个参数的函数变成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数，而且返回结果的新函数的技术;</p><p>柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数</p><p>柯里化箭头函数写法:var foo&#x3D;x&#x3D;&gt;y&#x3D;&gt;z&#x3D;&gt;console.log(x + y + z)</p><p>自动柯里化函数</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    function foo(x, y, z) {      console.log(x + y + z)    }        function sum(num1, num2) {      return num1 + num2    }        function logInfo(date, type, message) {      console.log(`时间:${date} 类型:${type} 内容:${message}`)    }        // 手动转化        // 封装函数: 自动转化柯里化过程(有一点难度)    function hyCurrying(fn) {      function curryFn(...args) {        // 两类操作:        // 第一类操作: 继续返回一个新的函数, 继续接受参数        // 第二类操作: 直接执行fn的函数        if (args.length >= fn.length) { // 执行第二类          // return fn(...args)          return fn.apply(this, args)        } else { // 执行第一类          return function(...newArgs) {            // return curryFn(...args.concat(newArgs))            return curryFn.apply(this, args.concat(newArgs))          }        }      }          return curryFn    }        // 对其他的函数进行柯里化    var fooCurry = hyCurrying(foo)    fooCurry(10)(20)(30)    fooCurry(55, 12, 56)        var sumCurry = hyCurrying(sum)    var sum5 = sumCurry(5)    console.log(sum5(10))    console.log(sum5(15))    console.log(sum5(18))        var logInfoCurry = hyCurrying(logInfo)    logInfoCurry("2022-06-01")("DEBUG")("我发现一个bug, 哈哈哈哈")  </script></body></html><p>组合函数</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // 第一步对数字*2    function double(num) {      return num * 2    }    // 第二步对数字**2    function pow(num) {      return num ** 2    }        // 封装的函数: 你传入多个函数, 我自动的将多个函数组合在一起挨个调用    function composeFn(...fns) {      // 1.边界判断(edge case)      var length = fns.length      if (length <= 0) return      for (var i = 0; i < length; i++) {        var fn = fns[i]        if (typeof fn !== "function") {          throw new Error(`index position ${i} must be function`)        }      }          // 2.返回的新函数      return function(...args) {        var result = fns[0].apply(this, args)        for (var i = 1; i < length; i++) {          var fn = fns[i]          result = fn.apply(this, [result])        }        return result      }    }        var newFn = composeFn(double, pow, console.log)    newFn(100)    newFn(55)    newFn(22)    // console.log(newFn(100))    // console.log(newFn(55))    // console.log(newFn(22))  </script></body></html><p>严格模式</p><p>JavaScript 的严格模式（Strict Mode）是 ES5 引入的重要特性，通过限制某些不安全或易出错的语法，提升代码的安全性和可维护性。以下是严格模式的核心要点：</p><p>启用方式</p><p>全局启用：在脚本或 <font style="color:rgb(64, 64, 64);"><script></font> 标签的最顶部添加 <font style="color:rgb(64, 64, 64);">"use strict";</font>。</p><p>"use strict";<br>// 整个脚本遵循严格模式<br>函数作用域启用：在函数体的最顶部添加 <font style="color:rgb(64, 64, 64);">"use strict";</font>。</p><p>function strictFunc() {<br>"use strict";<br>// 函数内部遵循严格模式<br>}</p><p>核心变化与限制</p><ol><li>变量必须声明</li></ol><p>未声明的变量赋值会报错（非严格模式会隐式创建全局变量）。</p><p>"use strict";<br>x = 10; // ReferenceError: x is not defined 2. 禁止重复参数</p><p>函数参数名不可重复。</p><p>"use strict";<br>function dupParam(a, a) { } // SyntaxError: Duplicate parameter name 3. 禁用 <strong><font style="color:rgb(64, 64, 64);">with</font></strong> 语句</p><p><font style="color:rgb(64, 64, 64);">with</font> 会导致作用域混乱，严格模式直接禁用。</p><p>"use strict";<br>with (obj) { } // SyntaxError: Strict mode code may not include a with statement 4. 只读属性不可修改</p><p>对只读属性（如 <font style="color:rgb(64, 64, 64);">Object.prototype</font>）赋值会报错。</p><p>"use strict";<br>Object.prototype = {}; // TypeError: Cannot assign to read-only property 5. 不可删除不可配置的属性</p><p>删除变量、函数或不可配置的属性会报错。</p><p>"use strict";<br>delete Object.prototype; // TypeError: Cannot delete property 'prototype' 6. <strong><font style="color:rgb(64, 64, 64);">arguments</font></strong> 对象限制</p><p><font style="color:rgb(64, 64, 64);">arguments</font> 与形参解耦，修改互不影响。</p><p>禁用 <font style="color:rgb(64, 64, 64);">arguments.callee</font> 和 <font style="color:rgb(64, 64, 64);">arguments.caller</font>。</p><p>"use strict";<br>function func(a) {<br>arguments[0] = 100;<br>console.log(a); // 非严格模式输出 100，严格模式输出原值<br>} 7. <strong><font style="color:rgb(64, 64, 64);">this</font></strong> 的默认值为 <strong><font style="color:rgb(64, 64, 64);">undefined</font></strong></p><p>普通函数调用时，<font style="color:rgb(64, 64, 64);">this</font> 不再指向全局对象。</p><p>"use strict";<br>function test() {<br>console.log(this); // undefined（非严格模式为 window）<br>}<br>test();<br>test.apply('123') //'123' (非严格模式为对应的包装对象)<br>test() 8. 保留字限制</p><p>不可使用 <font style="color:rgb(64, 64, 64);">implements</font>, <font style="color:rgb(64, 64, 64);">interface</font>, <font style="color:rgb(64, 64, 64);">let</font>, <font style="color:rgb(64, 64, 64);">yield</font> 等作为变量名。</p><p>"use strict";<br>let interface = 10; // SyntaxError: Unexpected strict mode reserved word 9. <strong><font style="color:rgb(64, 64, 64);">eval</font></strong> 独立作用域</p><p><font style="color:rgb(64, 64, 64);">eval</font> 内部声明的变量不会泄露到外部。</p><p>"use strict";<br>eval("var x = 10;");<br>console.log(x); // ReferenceError: x is not defined 10. 八进制字面量语法</p><p>禁止使用旧式 <font style="color:rgb(64, 64, 64);">0</font> 前缀的八进制，必须用 <font style="color:rgb(64, 64, 64);">0o</font>。</p><p>"use strict";<br>let num = 0123; // SyntaxError: Octal literals are not allowed<br>let correct = 0o123; // 正确写法 11. 对象字面量重复属性</p><p>ES5 严格模式禁止重复属性（ES6 已放宽此限制）。</p><p>"use strict";<br>let obj = { a: 1, a: 2 }; // ES5 严格模式报错，ES6 不报错</p><p>严格模式的优势</p><p>减少隐藏错误：通过报错暴露潜在问题（如变量未声明）。</p><p>优化代码：帮助引擎优化执行（如固定作用域）。</p><p>兼容未来语法：保留关键字为 ES6+ 铺路（如 <font style="color:rgb(64, 64, 64);">class</font>, <font style="color:rgb(64, 64, 64);">let</font>）。</p><p>注意事项</p><p>旧代码启用严格模式需逐步迁移，避免报错。</p><p>合并脚本时，若全局启用严格模式，需确保合并后的脚本开头无非严格代码。</p><p>对象增强<br>属性描述符</p><p>JavaScript 中的属性描述符用于定义或描述对象属性的特性，分为数据属性和访问器属性两种类型。以下是关键点总结：</p><ol><li>属性描述符的组成</li></ol><p>数据属性：包含以下特性：</p><p><font style="color:rgb(64, 64, 64);">value</font>：属性的值。</p><p><font style="color:rgb(64, 64, 64);">writable</font>：是否可修改值（默认为<font style="color:rgb(64, 64, 64);">false</font>，若通过赋值创建则默认为<font style="color:rgb(64, 64, 64);">true</font>）。</p><p><font style="color:rgb(64, 64, 64);">enumerable</font>：是否可被枚举（如 <font style="color:rgb(64, 64, 64);">for...in</font> 或 <font style="color:rgb(64, 64, 64);">Object.keys</font>，默认为<font style="color:rgb(64, 64, 64);">false</font>）。</p><p><font style="color:rgb(64, 64, 64);">configurable</font>：是否可删除属性或修改特性（默认为<font style="color:rgb(64, 64, 64);">false</font>）。</p><p>访问器属性：包含 <font style="color:rgb(64, 64, 64);">get</font> 和 <font style="color:rgb(64, 64, 64);">set</font> 函数：</p><p><font style="color:rgb(64, 64, 64);">get()</font>：读取属性时调用。</p><p><font style="color:rgb(64, 64, 64);">set(value)</font>：写入属性时调用。</p><p>不能与 <font style="color:rgb(64, 64, 64);">value</font> 或 <font style="color:rgb(64, 64, 64);">writable</font> 共存。</p><ol start="2"><li>获取属性描述符</li></ol><p><font style="color:rgb(64, 64, 64);">Object.getOwnPropertyDescriptor(obj, 'prop')</font>：获取对象自身属性的描述符。</p><p><font style="color:rgb(64, 64, 64);">Object.getOwnPropertyDescriptors(obj)</font>：获取对象所有自身属性的描述符。</p><ol start="3"><li>定义/修改属性</li></ol><p><font style="color:rgb(64, 64, 64);">Object.defineProperty(obj, 'prop', descriptor)</font>：定义单个属性。</p><p><font style="color:rgb(64, 64, 64);">Object.defineProperties(obj, descriptors)</font>：批量定义属性。</p><p>默认值：若未显式设置，<font style="color:rgb(64, 64, 64);">writable</font>、<font style="color:rgb(64, 64, 64);">enumerable</font>、<font style="color:rgb(64, 64, 64);">configurable</font> 默认为 <font style="color:rgb(64, 64, 64);">false</font>。</p><ol start="4"><li>特性规则</li></ol><p>**<font style="color:rgb(64, 64, 64);">configurable: false</font>**：</p><p>禁止删除属性。</p><p>禁止修改除 <font style="color:rgb(64, 64, 64);">writable</font> 以外的特性（<font style="color:rgb(64, 64, 64);">writable</font> 仅允许从 <font style="color:rgb(64, 64, 64);">true</font> 改为 <font style="color:rgb(64, 64, 64);">false</font>）。</p><p>**<font style="color:rgb(64, 64, 64);">writable: false</font>**：禁止通过赋值修改值（严格模式报错）。</p><p>**<font style="color:rgb(64, 64, 64);">enumerable: false</font>**：属性不会出现在 <font style="color:rgb(64, 64, 64);">for...in</font> 或 <font style="color:rgb(64, 64, 64);">Object.keys</font> 中。</p><ol start="5"><li>示例</li></ol><p>数据属性</p><p>const obj = {};<br>Object.defineProperty(obj, 'a', {<br>value: 1,<br>writable: true,<br>enumerable: true,<br>configurable: true<br>});</p><p>// 修改为不可写<br>Object.defineProperty(obj, 'a', { writable: false });<br>obj.a = 2; // 静默失败（严格模式报错）<br>访问器属性</p><p>Object.defineProperty(obj, 'fullName', {<br>get() { return <code>$&#123;this.firstName&#125; $&#123;this.lastName&#125;</code>; },<br>set(value) { [this.firstName, this.lastName] = value.split(' '); },<br>enumerable: true,<br>configurable: true<br>}); 6. 默认行为</p><p>通过赋值创建的属性：<font style="color:rgb(64, 64, 64);">writable</font>、<font style="color:rgb(64, 64, 64);">enumerable</font>、<font style="color:rgb(64, 64, 64);">configurable</font> 默认为 <font style="color:rgb(64, 64, 64);">true</font>。</p><p>const obj = { a: 1 };<br>const desc = Object.getOwnPropertyDescriptor(obj, 'a');<br>// { value: 1, writable: true, enumerable: true, configurable: true }<br>通过 <strong><font style="color:rgb(64, 64, 64);">defineProperty</font></strong> 创建的属性：未指定的特性默认为 <font style="color:rgb(64, 64, 64);">false</font>。</p><p>Object.defineProperty(obj, 'b', { value: 2 });<br>const desc = Object.getOwnPropertyDescriptor(obj, 'b');<br>// { value: 2, writable: false, enumerable: false, configurable: false } 7. 实用方法</p><p><font style="color:rgb(64, 64, 64);">Object.freeze(obj)</font>：设置所有属性为 <font style="color:rgb(64, 64, 64);">writable: false</font> 且 <font style="color:rgb(64, 64, 64);">configurable: false</font>。</p><p><font style="color:rgb(64, 64, 64);">Object.seal(obj)</font>：设置所有属性为 <font style="color:rgb(64, 64, 64);">configurable: false</font>，但保留 <font style="color:rgb(64, 64, 64);">writable</font>。</p><p><font style="color:rgb(64, 64, 64);">Object.preventExtensions(obj)</font>：不允许对象添加新属性(严格模式报错)</p><p>总结</p><p>属性描述符允许精确控制对象属性的行为，适用于实现不可变性、隐藏内部属性或定义动态计算的属性（如访问器）。使用时需注意特性之间的依赖关系（如 <font style="color:rgb(64, 64, 64);">configurable</font> 的限制），避免潜在错误。</p><p>ES5<br>对象原型</p><p>JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。当我们通过引用对象的属性 key 来获取一个 value 时，它会触发[[Get]]的操作:这个操作会首先检查该对象是否有对应的属性，如果有的话就使用它;如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性</p><p>获取原型方式:</p><p>方式一:通过对象的_proto 属性可以获取到(但是这个是早期浏览器自己添加的，存在一定的兼容性问题)</p><p>方式二:通过 Object.getPrototypeOf 方法可以获取到;</p><p>函数原型 prototype(显式原型)</p><p>每个函数都有一个 prototype 属性，它是一个对象，用于实现基于构造函数的继承。使用 <font style="color:rgba(0, 0, 0, 0.85);">new</font> 关键字调用函数创建对象时，新对象的 <font style="color:rgba(0, 0, 0, 0.85);">[[Prototype]]</font> 会指向该函数的 <font style="color:rgba(0, 0, 0, 0.85);">prototype</font> 对象。</p><p>// 方式一：使用对象字面量创建对象<br>const obj1 = {<br>name: 'John'<br>};</p><p>// 方式二：使用构造函数创建对象<br>function Person() {<br>this.age = 30;<br>}<br>Person.prototype.runing=function(){}<br>const obj2 = new Person();<br>obj2.runing()</p><p>// 查看对象的原型<br>console.log(obj1.<strong>proto</strong> === Object.prototype); // true<br>console.log(obj2.<strong>proto</strong> === Person.prototype); // true<br>函数原型上的 constructor</p><p>事实上原型对象上面是有一个属性的:constructor ,默认情况下原型上都会添加一个属性叫做 constructor，这个 constructor 指向当前的函数对象;</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // 非常重要的属性: constructor, 指向Person函数对象    function Person() {    }        // 1.对constructor在prototype上的验证    var PersonPrototype = Person.prototype    console.log(PersonPrototype)    console.log(PersonPrototype.constructor)    console.log(PersonPrototype.constructor === Person)        console.log(Person.name)    console.log(PersonPrototype.constructor.name)        // 2.实例对象p    var p = new Person()    console.log(p.__proto__.constructor)    console.log(p.__proto__.constructor.name)  </script><p>原型链<br>继承</p><p>面向对象有三大特性:封装、继承、多态</p><p>封装:我们前面将属性和方法封装到一个类中，可以称之为封装的过程;</p><p>继承:继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提(纯面向对象中);</p><p>多态:不同的对象在执行时表现出不同的形态;</p><p>原型链</p><p>首先，原型链是 JavaScript 实现继承的机制，对吧？每个对象都有一个原型对象，而原型对象也可能有它自己的原型，这样一层层链接起来就形成了原型链。当访问一个对象的属性时，如果对象本身没有这个属性，就会沿着原型链向上查找，直到找到或者到达原型链的末端（null）。这是原型链的基本概念。</p><p>一、默认原型链</p><p>对象字面量</p><p>let obj = {};<br>// 原型链：obj -> Object.prototype -> null</p><ul><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;obj.__proto__ === Object.prototype&lt;/font&gt;</code></li><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;Object.prototype.__proto__ === null&lt;/font&gt;</code><br>构造函数创建对象</li></ul><p>function Person() {}<br>let person = new Person();<br>// 原型链：person -> Person.prototype -> Object.prototype -> null</p><ul><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;person.__proto__ === Person.prototype&lt;/font&gt;</code></li><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;Person.prototype.__proto__ === Object.prototype&lt;/font&gt;</code><br>函数的原型链</li></ul><p>function Foo() {}<br>// 原型链：Foo -> Function.prototype -> Object.prototype -> null</p><ul><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;Foo.__proto__ === Function.prototype&lt;/font&gt;</code></li><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;Function.prototype.__proto__ === Object.prototype&lt;/font&gt;</code><br>二、自定义原型链</li></ul><p>使用 <strong><font style="color:rgb(64, 64, 64);">Object.create</font></strong></p><p>Object.create() 方法创建一个新对象，该对象继承自指定的原型对象。通过这种方式，proto 对象就拥有了 Parent 构造函数原型上的所有属性和方法。</p><p>const parent = { name: "parent" };<br>const child = Object.create(parent);<br>// 原型链：child -> parent -> Object.prototype -> null</p><ul><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;child.__proto__ === parent&lt;/font&gt;</code><br>手动修改原型</li></ul><p>function Parent() {}<br>function Child() {}<br>Child.prototype = new Parent(); // 不推荐（可能调用父类构造函数两次）<br>Child.prototype.constructor = Child; // 修复 constructor<br>推荐方式：寄生组合继承</p><p>call 方法允许在指定的 this 值和参数的情况下调用函数。通过这种方式，Child 对象可以继承 Parent 对象的属性。</p><p>function inheritPrototype(Child, Parent) {<br>const proto = Object.create(Parent.prototype);<br>proto.constructor = Child;<br>Child.prototype = proto;<br>}<br>//或者使用 Object.defineProperty 设置 constructor<br>//function inheritPrototype(Child, Parent) {<br>// Child.prototype=Object.create(Parent.prototype)<br>// Object.defineProperty(Child.prototype,'constructor',{<br>// enumerable:false,<br>// configurable:true,<br>// writable:true,<br>// value:Child<br>// })<br>// }<br>三、继承的实现</p><p>组合继承（借用构造函数 + 原型链）</p><p>function Parent(name) {<br>this.name = name;<br>}<br>Parent.prototype.sayName = function() { console.log(this.name) };</p><p>function Child(name, age) {<br>Parent.call(this, name); // 继承属性<br>this.age = age;<br>}<br>Child.prototype = new Parent(); // 继承方法（不推荐）<br>Child.prototype.constructor = Child;<br>寄生组合继承（优化版）</p><p>function Child(name, age) {<br>Parent.call(this, name);<br>this.age = age;<br>}<br>inheritPrototype(Child, Parent); // 使用上述工具函数<br>ES6 <strong><font style="color:rgb(64, 64, 64);">class</font></strong> 语法</p><p>class Parent {<br>constructor(name) { this.name = name; }<br>sayName() { console.log(this.name) }<br>}</p><p>class Child extends Parent {<br>constructor(name, age) {<br>super(name); // 必须先调用 super()<br>this.age = age;<br>}<br>}</p><hr><p>对象原型判断方法</p><p>hasOwnProperty:对象是否有某一个属于自己的属性(不是在原型上的属性)</p><p>in/for in 操作符:判断某个属性是否在某个对象或者对象的原型上</p><p>instanceof:用于检测构造函数(Person、Student 类)的 prototype 是否出现在某个实例对象的原型链上</p><p>isPrototypeOf:用于检测某个对象，是否出现在某个实例对象的原型链上</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script src="./js/inherit_utils.js"></script>  <script>    var obj = {      name: "why",      age: 18    }        var info = createObject(obj)    info.address = "中国"    info.intro = "中国大好河山"        console.log(info.name, info.address)    console.log(info)        // 1.hasOwnProperty    // console.log(info.hasOwnProperty("name")) // false    // console.log(info.hasOwnProperty("address")) // true        // 2.in操作符    console.log("name" in info)    console.log("address" in info)    // 注意: for in遍历不仅仅是自己对象上的内容, 也包括原型对象上的内容    for (var key in info) {      console.log(key)    }        // 3.instanceof    // instanceof用于判断对象和类(构造函数)之间的关系    function Person() {}    function Student() {}    inherit(Student, Person)        // stu实例(instance)对象    var stu = new Student()    console.log(stu instanceof Student)    console.log(stu instanceof Person)    console.log(stu instanceof Object)    console.log(stu instanceof Array)        // 4.isPrototypeOf    console.log(Student.prototype.isPrototypeOf(stu))    console.log(Person.prototype.isPrototypeOf(stu))        // 可以用于判断对象之间的继承    console.log(obj.isPrototypeOf(info))  </script></body></html><p>原型继承关系</p><p>核心概念</p><p>构造函数（如 <font style="color:rgb(64, 64, 64);">Foo</font>、<font style="color:rgb(64, 64, 64);">Object</font>）：通过 <font style="color:rgb(64, 64, 64);">new Function()</font> 创建的函数对象。</p><p>原型对象（<font style="color:rgb(64, 64, 64);">prototype</font>）：每个构造函数都有一个 <font style="color:rgb(64, 64, 64);">prototype</font> 属性，指向其原型对象。</p><p>实例对象（如 <font style="color:rgb(64, 64, 64);">f1</font>、<font style="color:rgb(64, 64, 64);">o1</font>）：通过 <font style="color:rgb(64, 64, 64);">new 构造函数()</font> 创建的对象。</p><p>原型链：通过 <font style="color:rgb(64, 64, 64);"><strong>proto</strong></font> 属性连接，形成对象的继承链。</p><p>关键关系</p><p>构造函数与原型对象：</p><p>构造函数的** ****<font style="color:rgb(64, 64, 64);">prototype</font>** 属性指向其原型对象（如 <font style="color:rgb(64, 64, 64);">Foo.prototype</font>）。</p><p>原型对象的** ****<font style="color:rgb(64, 64, 64);">constructor</font>** 属性指回构造函数（如 <font style="color:rgb(64, 64, 64);">Foo.prototype.constructor === Foo</font>）。</p><p>实例对象与原型链：</p><p>实例的** ****<font style="color:rgb(64, 64, 64);"><strong>proto</strong></font>** 指向其构造函数的原型对象（如 <font style="color:rgb(64, 64, 64);">f1.<strong>proto</strong> === Foo.prototype</font>）。</p><p>原型链终点：所有原型链最终指向 <font style="color:rgb(64, 64, 64);">Object.prototype</font>，其 <font style="color:rgb(64, 64, 64);"><strong>proto</strong></font> 为 <font style="color:rgb(64, 64, 64);">null</font>。</p><p>函数对象的特殊链：</p><p>构造函数的** ****<font style="color:rgb(64, 64, 64);"><strong>proto</strong></font>** 指向 <font style="color:rgb(64, 64, 64);">Function.prototype</font>（如 <font style="color:rgb(64, 64, 64);">Foo.<strong>proto</strong> === Function.prototype</font>）。</p><p><strong><font style="color:rgb(64, 64, 64);">Function</font></strong> <strong>自身</strong>：<font style="color:rgb(64, 64, 64);">Function.<strong>proto</strong> === Function.prototype</font>（因为 <font style="color:rgb(64, 64, 64);">Function</font> 是自身的构造函数）。</p><p><strong><font style="color:rgb(64, 64, 64);">Function.prototype</font></strong> <strong>的原型</strong>：<font style="color:rgb(64, 64, 64);">Function.prototype.<strong>proto</strong> === Object.prototype</font>。</p><p>图示总结</p><p><strong><font style="color:rgb(64, 64, 64);">Foo</font></strong> 的继承链：</p><p>f1（实例） → Foo.prototype → Object.prototype → null<br>↑<br>Foo（构造函数） → Function.prototype → Object.prototype → null<br><strong><font style="color:rgb(64, 64, 64);">Object</font></strong> 的继承链：</p><p>o1（实例） → Object.prototype → null<br>↑<br>Object（构造函数） → Function.prototype → Object.prototype → null<br><strong><font style="color:rgb(64, 64, 64);">Function</font></strong> <strong>的继承链</strong>：</p><p>Function（构造函数） → Function.prototype → Object.prototype → null<br>总结</p><p>构造函数** ****<font style="color:rgb(64, 64, 64);">prototype</font>**：定义原型，供实例继承。</p><p>实例** ****<font style="color:rgb(64, 64, 64);"><strong>proto</strong></font>**：顺着链找，继承属性和方法。</p><p>函数皆** <strong><font style="color:rgb(64, 64, 64);">Function</font></strong> *<strong>*生</strong>：所有构造函数的 <font style="color:rgb(64, 64, 64);"><strong>proto</strong></font> 指向 <font style="color:rgb(64, 64, 64);">Function.prototype</font>。</p><p>终点 **<font style="color:rgb(64, 64, 64);">Object.prototype</font>**：万物归宗，原型链尽头是 <font style="color:rgb(64, 64, 64);">null</font>。</p><p>通过这张图，可以清晰理解 JavaScript 中对象、构造函数、原型之间的层级关系与继承机制。</p><p>ES6 新增特性<br>class 定义类</p><p>ES6 引入了 <font style="color:rgb(64, 64, 64);">class</font> 关键字，提供了更清晰的语法糖来实现面向对象编程，其底层仍基于原型继承。</p><ol><li>类定义与构造函数</li></ol><p>定义类：使用 class 关键字，后跟类名和 {}。</p><p>构造函数：constructor 方法用于初始化实例，未显式定义则默认生成空构造函数。</p><p>class Person {<br>constructor(name) {<br>this.name = name; // 实例属性<br>}<br>sayHello() {<br>console.log(<code>Hello, $&#123;this.name&#125;!</code>);<br>}<br>}<br>const alice = new Person("Alice");<br>alice.sayHello(); // Hello, Alice!<br>当我们通过 new 关键字操作类的时候，会调用这个 constructor 函数，并且执行如下操作:</p><p>1.在内存中创建一个新的对象(空对象);</p><p>2.这个对象内部的[[prototype]]属性会被赋值为该类的 prototype 属性;</p><p>3.构造函数内部的 this，会指向创建出来的新对象;</p><p>4.执行构造函数的内部代码(函数体代码)</p><p>5.如果构造函数没有返回非空对象，则返回创建出来的新对象;</p><ol start="2"><li>继承（extends 和 super）</li></ol><p>继承父类：通过 extends 实现继承。</p><p>调用父类构造函数：子类构造函数必须调用 super() 后才能使用 this。</p><p>class Student extends Person {<br>constructor(name, grade) {<br>super(name);<br>this.grade = grade;<br>}<br>study() {<br>console.log(<code>$&#123;this.name&#125; is studying in grade $&#123;this.grade&#125;.</code>);<br>}<br>}<br>const bob = new Student("Bob", 10);<br>bob.study(); // Bob is studying in grade 10.</p><ol start="3"><li>静态方法与属性（static）</li></ol><p>静态成员：属于类本身，通过类名访问，实例无法调用。</p><p>class MathUtils {<br>static PI = 3.14159; // 静态属性（ES2022+）<br>static square(x) {<br>return x * x;<br>}<br>}<br>console.log(MathUtils.square(5)); // 25</p><ol start="4"><li>Getter 和 Setter</li></ol><p>访问器属性：通过 get 和 set 定义，控制属性的读取和赋值。</p><p>class Circle {<br>constructor(radius) {<br>this._radius = radius;<br>}<br>get area() {<br>return Math.PI * this._radius ** 2;<br>}<br>set radius(value) {<br>if (value > 0) this._radius = value;<br>}<br>}<br>const c = new Circle(5);<br>console.log(c.area); // 78.54...<br>c.radius = 10; // 调用 setter</p><ol start="5"><li>私有字段（ES2022+）</li></ol><p>私有成员：以 # 开头，仅在类内部访问。</p><p>class Counter {<br>#count = 0; // 私有字段<br>increment() {<br>this.#count++;<br>}<br>get value() {<br>return this.#count;<br>}<br>}<br>const counter = new Counter();<br>counter.increment();<br>console.log(counter.value); // 1</p><ol start="6"><li>类表达式</li></ol><p>匿名类：类可作为表达式赋值给变量。</p><p>const Animal = class {<br>constructor(name) {<br>this.name = name;<br>}<br>};</p><ol start="7"><li>注意事项</li></ol><p>无函数提升：类声明不会提升，需先定义后使用。</p><p>方法无逗号：类方法间无需逗号分隔。</p><p>原型方法：类方法定义在原型上，实例共享方法以节省内存。</p><p>总结对比（ES6 vs ES5）</p><p>特性 ES6 Class ES5 实现方式<br>定义 class MyClass {} 构造函数 function MyClass() {}<br>继承 extends<br> 和 super prototype<br> 和 Object.create<br>静态方法 static<br> 关键字 直接赋值：MyClass.staticMethod<br>私有性（ES2022+） #<br> 前缀 闭包或约定（如 _name<br>）<br>ES6 类语法更简洁直观，但本质仍是基于原型的继承，熟悉原型链有助于深入理解类的工作机制。</p><p>多态</p><p>多态是面向对象编程中的一个概念,多态的定义应该是指同一个方法在不同对象中有不同的实现。也就是说，不同的对象可以对同一个方法调用做出不同的响应。JS 中的多态可以通过两种方式实现：基于原型链继承的方法重写，以及基于类型的方法调用。这两种方式都允许不同对象对同一方法调用做出不同响应，体现了多态性。</p><ol><li>基于原型链继承的方法重写（ES6 类语法）</li></ol><p>通过继承父类并重写方法，子类实例调用方法时执行自身的实现。</p><p>class Animal {<br>speak() {<br>console.log('动物叫');<br>}<br>}</p><p>class Dog extends Animal {<br>speak() {<br>console.log('汪汪'); // 重写父类方法<br>}<br>}</p><p>class Cat extends Animal {<br>speak() {<br>console.log('喵喵'); // 重写父类方法<br>}<br>}</p><p>const animals = [new Dog(), new Cat()];<br>animals.forEach(animal => animal.speak()); // 输出：汪汪 喵喵 2. 基于类型的灵活多态</p><p>只要对象具有所需方法，无论是否继承同一父类，均可实现多态。</p><p>const duck = {<br>speak() {<br>console.log('嘎嘎'); // 独立对象的方法<br>}<br>};</p><p>const robot = {<br>speak() {<br>console.log('哔哔'); // 独立对象的方法<br>}<br>};</p><p>function makeSound(entity) {<br>entity.speak(); // 依赖鸭子类型<br>}</p><p>makeSound(duck); // 嘎嘎<br>makeSound(robot); // 哔哔<br>总结：</p><p>继承与重写：子类覆盖父类方法，调用时根据实例类型执行对应方法。</p><p>基于类型的灵活多态：关注对象是否具备方法而非继承关系，提升灵活性。</p><p>动态特性：JavaScript 的动态类型系统天然支持多态，无需显式接口定义。</p><p>优势：增强代码扩展性和复用性，新增类型时无需修改调用方代码，符合开闭原则。</p><p>apply,call 和 bind 的实现和封装</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // new Function()    // foo.__proto__ === Function.prototype    function foo(name, age) {      console.log(this, name, age)    }        // foo函数可以通过apply/call    // foo.apply("aaa", ["why", 18])    // foo.call("bbb", "kobe", 30)        // 1.封装思想    // 1.1.封装到独立的函数中    function execFn(thisArg, otherArgs, fn) {      // 1.获取thisArg, 并且确保是一个对象类型      thisArg = (thisArg === null || thisArg === undefined)? window: Object(thisArg)          // thisArg.fn = this      Object.defineProperty(thisArg, "fn", {        enumerable: false,        configurable: true,        value: fn      })          // 执行代码      thisArg.fn(...otherArgs)          delete thisArg.fn    }        // 1.2. 封装原型中    Function.prototype.hyexec = function(thisArg, otherArgs) {      // 1.获取thisArg, 并且确保是一个对象类型      thisArg = (thisArg === null || thisArg === undefined)? window: Object(thisArg)          // thisArg.fn = this      Object.defineProperty(thisArg, "fn", {        enumerable: false,        configurable: true,        value: this      })      thisArg.fn(...otherArgs)          delete thisArg.fn    }    // 1.给函数对象添加方法: hyapply    Function.prototype.hyapply = function(thisArg, otherArgs) {      this.hyexec(thisArg, otherArgs)    }    // 2.给函数对象添加方法: hycall    Function.prototype.hycall = function(thisArg, ...otherArgs) {      this.hyexec(thisArg, otherArgs)    }        foo.hyapply({ name: "why" }, ["james", 25])    foo.hyapply(123, ["why", 18])    foo.hyapply(null, ["kobe", 30])        foo.hycall({ name: "why" }, "james", 25)    foo.hycall(123, "why", 18)    foo.hycall(null, "kobe", 30)  </script></body></html><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // apply/call    function foo(name, age, height, address) {      console.log(this, name, age, height, address)    }        // Function.prototype    // var newFoo = foo.bind({ name: "why" }, "why", 18)    // newFoo(1.88)        // 实现hybind函数    Function.prototype.hybind = function(thisArg, ...otherArgs) {      // console.log(this) // -> foo函数对象      thisArg = thisArg === null || thisArg === undefined ? window: Object(thisArg)      Object.defineProperty(thisArg, "fn", {        enumerable: false,        configurable: true,        writable: false,        value: this      })          return (...newArgs) => {        // var allArgs = otherArgs.concat(newArgs)        var allArgs = [...otherArgs, ...newArgs]        thisArg.fn(...allArgs)      }    }        var newFoo = foo.hybind("abc", "kobe", 30)    newFoo(1.88, "广州市")    newFoo(1.88, "广州市")    newFoo(1.88, "广州市")    newFoo(1.88, "广州市")  </script></body></html><p>const 和 let</p><p>在 JavaScript 中，<font style="color:rgb(64, 64, 64);">const</font>和<font style="color:rgb(64, 64, 64);">let</font>是 ES6 引入的两种变量声明方式，提供了更清晰的变量作用域和更严格的语法规则，取代了传统的<font style="color:rgb(64, 64, 64);">var</font>。</p><ol><li>作用域</li></ol><p><strong><font style="color:rgb(64, 64, 64);">let</font></strong> 和 <strong><font style="color:rgb(64, 64, 64);">const</font></strong> 是块级作用域：<br>在<font style="color:rgb(64, 64, 64);">{}</font>（如<font style="color:rgb(64, 64, 64);">if</font>、<font style="color:rgb(64, 64, 64);">for</font>、函数等代码块）内部声明的变量，仅在块内有效。</p><p>if (true) {<br>let a = 10;<br>const b = 20;<br>}<br>console.log(a); // 报错：a 未定义<br>console.log(b); // 报错：b 未定义<br><strong><font style="color:rgb(64, 64, 64);">var</font></strong> <strong>是函数作用域</strong>：<br>变量在整个函数内有效，容易导致变量泄漏到外部作用域。</p><ol start="2"><li>变量提升与暂时性死区（TDZ）</li></ol><p>变量提升存在，但存在暂时性死区：<br><font style="color:rgb(64, 64, 64);">let</font>和<font style="color:rgb(64, 64, 64);">const</font>声明的变量会提升到作用域顶部，但在声明前访问会触发 TDZ（报错）。</p><p>console.log(a); // 报错（TDZ）<br>let a = 10;<br><strong><font style="color:rgb(64, 64, 64);">var</font></strong> 的变量提升：<br><font style="color:rgb(64, 64, 64);">var</font>声明的变量会初始化为<font style="color:rgb(64, 64, 64);">undefined</font>，无 TDZ。</p><p>console.log(b); // 输出 undefined<br>var b = 10; 3. 重复声明</p><p><strong><font style="color:rgb(64, 64, 64);">let</font></strong> 和 <strong><font style="color:rgb(64, 64, 64);">const</font></strong> 禁止重复声明：<br>同一作用域内不可重复声明同名变量。</p><p>let x = 1;<br>let x = 2; // 报错：x 已声明<br><strong><font style="color:rgb(64, 64, 64);">var</font></strong> 允许重复声明：<br>后续声明会覆盖前者。</p><p>var y = 1;<br>var y = 2; // 合法 4. <strong><font style="color:rgb(64, 64, 64);">const</font></strong> 的特殊性</p><p>声明时必须初始化：</p><p>const PI = 3.14; // 正确<br>const PI; // 报错：未初始化<br>不可重新赋值：<br>基本类型值不可变，引用类型（对象、数组）的属性可修改。</p><p>const arr = [1, 2, 3];<br>arr.push(4); // 允许<br>arr = [5]; // 报错：不可重新赋值</p><p>const obj = { name: "Alice" };<br>obj.name = "Bob"; // 允许 5. 使用场景</p><p>优先使用** ****<font style="color:rgb(64, 64, 64);">const</font>**：<br>默认用<font style="color:rgb(64, 64, 64);">const</font>声明变量，除非需要重新赋值。</p><p>const API_KEY = "abc123"; // 常量</p><p>需要重新赋值时用 **<font style="color:rgb(64, 64, 64);">let</font>**：</p><p>let count = 0;<br>count = 1; // 合法<br>避免使用** ****<font style="color:rgb(64, 64, 64);">var</font>**：<br><font style="color:rgb(64, 64, 64);">var</font>的作用域和提升行为容易导致错误。</p><ol start="6"><li>循环中的表现</li></ol><p><strong><font style="color:rgb(64, 64, 64);">let</font></strong> 在循环中绑定每次迭代：<br>解决<font style="color:rgb(64, 64, 64);">var</font>在循环中共享变量的问题。</p><p>for (let i = 0; i < 3; i++) {<br>setTimeout(() => console.log(i), 100); // 输出 0,1,2<br>}<br><strong><font style="color:rgb(64, 64, 64);">const</font></strong> 在循环中的特殊行为：<br>每次迭代创建一个新变量（适用于<font style="color:rgb(64, 64, 64);">for...of</font>/<font style="color:rgb(64, 64, 64);">for...in</font>）。</p><p>for (const num of [1, 2, 3]) {<br>console.log(num); // 输出 1,2,3<br>}<br>总结</p><p>**<font style="color:rgb(64, 64, 64);">const</font>**：声明常量，不可重新赋值，引用类型属性可变。</p><p>**<font style="color:rgb(64, 64, 64);">let</font>**：声明可变的块级变量。</p><p>块级作用域、TDZ、禁止重复声明使代码更安全、可维护。</p><p>替代**<font style="color:rgb(64, 64, 64);">var</font>**：推荐始终使用<font style="color:rgb(64, 64, 64);">const</font>和<font style="color:rgb(64, 64, 64);">let</font>，避免<font style="color:rgb(64, 64, 64);">var</font>。</p><p>ES6~ES13<br>模板字符串</p><p>JavaScript 中的模板字符串和标签模板字符串是 ES6 引入的重要特性，极大提升了字符串处理的灵活性和功能性。</p><p>模板字符串（Template Strings）</p><p>基本语法：</p><ul><li><p><font style="color:rgb(64, 64, 64);">使用反引号（</font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt; &lt;/font&gt;</code><font style="color:rgb(64, 64, 64);">）包裹字符串，支持多行内容和插值表达式。</font></p></li><li><p><font style="color:rgb(64, 64, 64);">插值通过 </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;$&#123;expression&#125;&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> 实现，表达式结果自动转换为字符串并嵌入。</font><br>const name = "Alice";<br>const greeting = <code>Hello, $&#123;name&#125;!</code>; // "Hello, Alice!"<br>多行字符串：</p></li><li><p><font style="color:rgb(64, 64, 64);">直接换行编写，保留换行符和缩进。</font><br>const html = `</p><div>  <p>Welcome</p></div>`;表达式求值：</li><li><p><font style="color:rgb(64, 64, 64);">支持任意 JavaScript 表达式，包括函数调用、运算等。</font><br>const sum = 3 + 5 = ${3 + 5}; // "3 + 5 = 8"</p></li></ul><p>标签模板字符串（Tagged Templates）</p><p>基本概念：</p><p>通过标签函数处理模板字符串，语法为：<font style="color:rgb(64, 64, 64);">tagFunction</font>string text ${expression}...``。</p><p>标签函数接收字符串数组和插值参数，返回自定义结果。</p><p>参数解析：</p><p>第一个参数：字符串数组（按插值位置分割）。</p><p>后续参数：按顺序传入插值表达式的计算结果。</p><p>示例：</p><p>function tag(strings, ...values) {<br>console.log(strings); // ["Hello ", ", age ", ""]<br>console.log(values); // ["Alice", 30]<br>}<br>tag<code>Hello $&#123;&quot;Alice&quot;&#125;, age $&#123;30&#125;</code>;<br>应用场景：</p><p>HTML 转义：防止 XSS 攻击。</p><p>function safeHtml(strings, ...values) {<br>let result = "";<br>for (let i = 0; i < strings.length; i++) {<br>result += strings[i];<br>if (i < values.length) {<br>result += String(values[i])<br>.replace(/&/g, "&amp;")<br>.replace(/}<br>}<br>return result;<br>}<br>const userInput = "<script>alert('xss')</script>“;<br>safeHtml<code>&lt;div&gt;$&#123;userInput&#125;&lt;/div&gt;</code>; &#x2F;&#x2F; 转义后输出<br>国际化（i18n）：动态翻译。</p><p>i18nWelcome to ${siteName}. You have ${count} messages.;</p><p>样式组件（如 styled-components）：</p><p>const Button &#x3D; styled.button<code>  color: $&#123;props =&gt; props.primary ? &#39;white&#39; : &#39;black&#39;&#125;;</code>;<br>原始字符串：</p><ul><li><font style="color:rgb(64, 64, 64);">通过 </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;strings.raw&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> 获取未转义的原始内容（如保留 </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;\n&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> 而非换行）。</font><br>function showRaw(strings) {<br>return strings.raw[0];<br>}<br>showRaw<code>Hello\nWorld</code>; &#x2F;&#x2F; “Hello\nWorld”（实际输出包含两个反斜杠）<br>返回值灵活性：</li></ul><p>可返回任意类型（字符串、对象、组件等）。</p><p>总结</p><p>特性 模板字符串 标签模板字符串<br>语法 反引号包裹 <font style="color:rgb(64, 64, 64);">${}</font><br>插值 函数名后跟模板字符串<br>多行支持 是 是<br>插值处理 自动转换为字符串 由标签函数自定义处理<br>应用场景 动态字符串拼接、多行文本 HTML 转义、国际化、DSL、样式组件等<br>原始字符串访问 无 通过 <font style="color:rgb(64, 64, 64);">strings.raw</font><br>获取<br>返回值 字符串 任意类型（由标签函数决定）<br>总结：模板字符串简化了字符串拼接和多行处理，而标签模板字符串通过自定义函数扩展了其功能，适用于安全转义、国际化、DSL 等复杂场景。</p><p>深浅拷贝理解</p><p>在 JavaScript 中，对象的拷贝分为浅拷贝和深拷贝，主要区别在于对引用类型数据的处理方式。</p><p>浅拷贝（Shallow Copy）</p><p>特点：仅复制对象的顶层属性，若属性是引用类型（如对象、数组），则拷贝的是内存地址（新旧对象共享嵌套的引用类型数据）。</p><p>实现方式：</p><p>展开运算符 <strong><font style="color:rgb(64, 64, 64);">…</font></strong></p><p>const obj &#x3D; { a: 1, b: { c: 2 } };<br>const shallowCopy &#x3D; { …obj };<br><strong><font style="color:rgb(64, 64, 64);">Object.assign()</font></strong></p><p>const shallowCopy &#x3D; Object.assign({}, obj);<br>数组方法（如 <font style="color:rgb(64, 64, 64);">slice()</font>、<font style="color:rgb(64, 64, 64);">concat()</font>、展开运算符）：</p><p>const arr &#x3D; [1, { x: 2 }];<br>const shallowArr &#x3D; arr.slice();<br>const shallowArr2 &#x3D; […arr];<br>注意事项：</p><p>修改嵌套的引用类型数据会影响原对象：</p><p>shallowCopy.b.c &#x3D; 3;<br>console.log(obj.b.c); &#x2F;&#x2F; 3（原对象被修改）</p><p>深拷贝（Deep Copy）</p><p>特点：完全复制对象及其嵌套的引用类型数据，新旧对象完全独立。</p><p>实现方式：</p><p><strong><font style="color:rgb(64, 64, 64);">JSON.parse(JSON.stringify(obj))</font></strong><br>局限：</p><p>无法处理函数、<font style="color:rgb(64, 64, 64);">undefined</font>、<font style="color:rgb(64, 64, 64);">Symbol</font>。</p><p>日期对象会被转为字符串。</p><p>循环引用会报错。</p><p>const deepCopy &#x3D; JSON.parse(JSON.stringify(obj));<br>递归实现<br>基础版本（未处理特殊对象和循环引用）：</p><p>function deepClone(obj) {<br>if (obj &#x3D;&#x3D;&#x3D; null || typeof obj !&#x3D;&#x3D; “object”) return obj;<br>const clone &#x3D; Array.isArray(obj) ? [] : {}<br>for (const key in obj) {<br>if(obj.hasOwnProperty(key)){<br>clone[key] &#x3D; deepClone(obj[key])<br>}<br>}<br>return clone<br>}</p><pre><code class="hljs">const info = &#123;  name: &#39;MirZ&#39;,  age: 18,  friend: &#123;    name: &#39;LadyJ&#39;,    address: &#123;      detail: &#39;郑州&#39;,      goHome: function () &#123;        console.log(&#39;go郑州&#39;);      &#125;    &#125;  &#125;&#125;const newInfo = deepClone(info)newInfo.friend.name = &#39;LadyY&#39;newInfo.friend.address.detail = &#39;安徽&#39;//此处函数未被深拷贝,而是指向了一个新的函数,所以不影响原函数的指向newInfo.friend.address.goHome = function () &#123;  console.log(&#39;go安徽&#39;);&#125;console.log(info);info.friend.address.goHome()console.log(newInfo);newInfo.friend.address.goHome()//如有set,map,symbol需进一步处理</code></pre><p>function deepClone(obj) {<br>&#x2F;&#x2F; 如果值是 Symbol 的类型<br>if (typeof obj &#x3D;&#x3D;&#x3D; “symbol”) {<br>return Symbol(obj.description)<br>}<br>&#x2F;&#x2F; 如果是 set 类型,map 也进行类似处理<br>if (obj instanceof Set) {<br>const newSet &#x3D; new Set()<br>for (const setItem of obj) {<br>newSet.add(deepCopy(setItem))<br>}<br>return newSet<br>}<br>if (obj &#x3D;&#x3D;&#x3D; null || typeof obj !&#x3D;&#x3D; “object”) return obj;<br>const clone &#x3D; Array.isArray(obj) ? [] : {}<br>&#x2F;&#x2F;此处只会遍历 key,不会遍历 symbol[key]<br>for (const key in obj) {<br>if (obj.hasOwnProperty(key)) {<br>clone[key] &#x3D; deepClone(obj[key])<br>}<br>}<br>&#x2F;&#x2F; 单独遍历 symbol<br>const symbolKeys &#x3D; Object.getOwnPropertySymbols(obj)<br>for (const symbolKey of symbolKeys) {<br>clone[Symbol(symbolKey.description)] &#x3D; deepCopy(obj[symbolKey])<br>}</p><pre><code class="hljs">  return clone&#125;const info = &#123;  name: &#39;MirZ&#39;,  age: 18,  friend: &#123;    name: &#39;LadyJ&#39;,    address: &#123;      detail: &#39;郑州&#39;,      goHome: function () &#123;        console.log(&#39;go郑州&#39;);      &#125;    &#125;  &#125;&#125;const newInfo = deepClone(info)newInfo.friend.name = &#39;LadyY&#39;newInfo.friend.address.detail = &#39;安徽&#39;//此处函数未被深拷贝,而是指向了一个新的函数,所以不影响原函数的指向newInfo.friend.address.goHome = function () &#123;  console.log(&#39;go安徽&#39;);&#125;console.log(info);info.friend.address.goHome()console.log(newInfo);newInfo.friend.address.goHome()</code></pre><p>处理循环引用和特殊对象<br>使用 <font style="color:rgb(64, 64, 64);">WeakMap</font> 缓存已拷贝对象，并处理 <font style="color:rgb(64, 64, 64);">Date</font>、<font style="color:rgb(64, 64, 64);">RegExp</font> 等：</p><p>function deepClone(obj, hash &#x3D; new WeakMap()) {<br>if (obj &#x3D;&#x3D;&#x3D; null || typeof obj !&#x3D;&#x3D; “object”) return obj;<br>&#x2F;&#x2F;判断此次深拷贝的对象是否在 hash 中存在,如果存在直接返回<br>if (hash.has(obj)) return hash.get(obj);</p><pre><code class="hljs">  let clone;  if (obj instanceof Date) &#123;    clone = new Date(obj.getTime());  &#125; else if (obj instanceof RegExp) &#123;    clone = new RegExp(obj.source, obj.flags);  &#125; else &#123;    clone = Array.isArray(obj) ? [] : &#123;&#125;;  &#125;  //根据obj存储clone  hash.set(obj, clone);  for (let key in obj) &#123;    if (obj.hasOwnProperty(key)) &#123;      clone[key] = deepClone(obj[key], hash);    &#125;  &#125;  return clone;&#125;const info = &#123;  name: &#39;MirZ&#39;,  age: 18&#125;info.self = infoconsole.log(info);const newInfo = deepClone(info)newInfo.name = &#39;MIRZ&#39;console.log(newInfo);</code></pre><p>第三方库<br>使用 <font style="color:rgb(64, 64, 64);">lodash</font> 的 <font style="color:rgb(64, 64, 64);">_.cloneDeep()</font>：</p><p>import _ from “lodash”;<br>const deepCopy &#x3D; _.cloneDeep(obj);<br>使用场景</p><p>浅拷贝：适用于对象结构简单，无嵌套引用或明确无需隔离的场景。</p><p>深拷贝：适用于对象结构复杂，需完全隔离新旧对象的场景（如状态管理、数据持久化）。</p><p>注意事项</p><p>循环引用：递归深拷贝需使用缓存（如 <font style="color:rgb(64, 64, 64);">WeakMap</font>）避免无限递归。</p><p>特殊对象：如 <font style="color:rgb(64, 64, 64);">Date</font>、<font style="color:rgb(64, 64, 64);">RegExp</font>、<font style="color:rgb(64, 64, 64);">Set</font>、<font style="color:rgb(64, 64, 64);">Map</font> 等需单独处理。</p><p>性能：深拷贝对大型对象可能有性能开销，需权衡使用。</p><p>Symbol</p><p>JavaScript 中的 Symbol 是 ES6 引入的一种新的原始数据类型，用于表示唯一的标识符。</p><ol><li>Symbol 的基本特性</li></ol><p>唯一性：每个 Symbol 都是唯一的，即使描述相同。</p><p>let sym1 &#x3D; Symbol(‘key’);<br>let sym2 &#x3D; Symbol(‘key’);<br>console.log(sym1 &#x3D;&#x3D;&#x3D; sym2); &#x2F;&#x2F; false<br>原始类型：不能使用 <font style="color:rgb(64, 64, 64);">new</font> 创建，直接调用 <font style="color:rgb(64, 64, 64);">Symbol()</font>。</p><p>let sym &#x3D; Symbol(); &#x2F;&#x2F; 正确<br>let err &#x3D; new Symbol(); &#x2F;&#x2F; TypeError<br>描述参数：用于调试，不影响唯一性。</p><p>console.log(Symbol(‘desc’).toString()); &#x2F;&#x2F; Symbol(desc) 2. Symbol 作为对象属性</p><p>定义属性：用方括号语法 <font style="color:rgb(64, 64, 64);">[]</font>。</p><p>const sym &#x3D; Symbol(‘key’);<br>const obj &#x3D; {<br>[sym]: ‘value’<br>};<br>console.log(obj[sym]); &#x2F;&#x2F; ‘value’<br>不可枚举性：Symbol 属性不会被常规方法遍历（如 <font style="color:rgb(64, 64, 64);">for…in</font>、<font style="color:rgb(64, 64, 64);">Object.keys()</font>）。</p><p>获取 Symbol 属性：使用 <font style="color:rgb(64, 64, 64);">Object.getOwnPropertySymbols()</font>。</p><p>反射方法：<font style="color:rgb(64, 64, 64);">Reflect.ownKeys()</font> 返回所有键（包括 Symbol）。</p><ol start="3"><li>全局 Symbol 注册表</li></ol><p>共享 Symbol：通过 <font style="color:rgb(64, 64, 64);">Symbol.for(key)</font> 创建或获取全局 Symbol。</p><p>const sym1 &#x3D; Symbol.for(‘globalKey’);<br>const sym2 &#x3D; Symbol.for(‘globalKey’);<br>console.log(sym1 &#x3D;&#x3D;&#x3D; sym2); &#x2F;&#x2F; true<br>查询全局键：<font style="color:rgb(64, 64, 64);">Symbol.keyFor(sym)</font> 返回 Symbol 的全局键。</p><p>console.log(Symbol.keyFor(sym1)); &#x2F;&#x2F; ‘globalKey’ 4. 内置 Symbol 值</p><p>用于修改对象的默认行为，常见内置 Symbol：</p><p>Symbol.iterator：定义对象的迭代器。</p><p>const iterable &#x3D; {<br>[Symbol.iterator]: function* () { yield 1; yield 2; }<br>};<br>console.log([…iterable]); &#x2F;&#x2F; [1, 2]<br>Symbol.toStringTag：定制 <font style="color:rgb(64, 64, 64);">toString()</font> 输出。</p><p>const obj &#x3D; { [Symbol.toStringTag]: ‘MyObject’ };<br>console.log(obj.toString()); &#x2F;&#x2F; [object MyObject]<br>Symbol.hasInstance：自定义 <font style="color:rgb(64, 64, 64);">instanceof</font> 行为。</p><ol start="5"><li>应用场景</li></ol><p>唯一属性名：避免对象属性名冲突。</p><p>const cacheKey &#x3D; Symbol(‘cache’);<br>function getData(obj) {<br>if (!obj[cacheKey]) {<br>obj[cacheKey] &#x3D; computeExpensiveValue();<br>}<br>return obj[cacheKey];<br>}<br>模拟私有属性：通过 Symbol 隐藏属性（非绝对私有，但需主动获取)</p><p>const _private &#x3D; Symbol(‘private’);<br>class MyClass {<br>constructor() { this[_private] &#x3D; ‘secret’; }<br>getSecret() { return this[_private]; }<br>}<br>自定义语言行为：如迭代、类型转换等。</p><ol start="6"><li>注意事项</li></ol><p>类型转换：</p><p>Symbol 不能隐式转字符串（需显式调用 <font style="color:rgb(64, 64, 64);">.toString()</font> 或 <font style="color:rgb(64, 64, 64);">String()</font>）。</p><p>可转换为布尔值（始终为 <font style="color:rgb(64, 64, 64);">true</font>）。</p><p>序列化：Symbol 属性不会被 <font style="color:rgb(64, 64, 64);">JSON.stringify()</font> 处理。</p><p>兼容性：ES6+ 支持，旧环境需通过 Babel 等工具转译。</p><p>总结</p><p>Symbol 的主要用途是提供唯一的标识符，解决命名冲突，并允许开发者介入 JavaScript 的内部行为。合理使用 Symbol 可以提升代码的健壮性和扩展性，但需注意其不可枚举性和转换规则。</p><p>Set-Map</p><p>Set 和 Map 都是 ES6 引入的，用来处理复杂的数据集合</p><p>Set（集合）</p><p>基本特性</p><p>成员唯一性：自动去重，值不能重复（基于 <font style="color:rgb(64, 64, 64);">&#x3D;&#x3D;&#x3D;</font>，但 <font style="color:rgb(64, 64, 64);">NaN</font> 视为相等）。</p><p>无序性：元素无插入顺序概念，但实际迭代时按插入顺序遍历。</p><p>键与值相同：<font style="color:rgb(64, 64, 64);">Set</font> 的键和值相等，即 <font style="color:rgb(64, 64, 64);">key &#x3D;&#x3D;&#x3D; value</font>。</p><p>创建与操作</p><p>const set &#x3D; new Set();<br>set.add(1); &#x2F;&#x2F; 添加元素<br>set.add(2).add(3); &#x2F;&#x2F; 链式调用<br>set.delete(1); &#x2F;&#x2F; 删除元素，返回布尔值表示是否成功<br>set.has(2); &#x2F;&#x2F; 检查存在性，返回 true&#x2F;false<br>set.size; &#x2F;&#x2F; 获取元素数量<br>set.clear(); &#x2F;&#x2F; 清空集合<br>迭代方法</p><p><font style="color:rgb(64, 64, 64);">keys()</font>、<font style="color:rgb(64, 64, 64);">values()</font>：返回迭代器（因为键值相同，两者等价）。</p><p><font style="color:rgb(64, 64, 64);">entries()</font>：返回 <font style="color:rgb(64, 64, 64);">[value, value]</font> 的迭代器。</p><p><font style="color:rgb(64, 64, 64);">forEach()</font>：遍历元素。</p><p>for (const item of set) { &#x2F;_ 直接迭代 _&#x2F; }<br>set.forEach(v &#x3D;&gt; console.log(v));<br>应用场景</p><p>数组去重：</p><p>const arr &#x3D; [1, 2, 2, 3];<br>&#x2F;&#x2F;const uniqueArr &#x3D; Array.from(new Set(arr)) &#x2F;&#x2F; [1, 2, 3]<br>const uniqueArr &#x3D; […new Set(arr)]; &#x2F;&#x2F; [1, 2, 3]<br>集合运算（交集、并集、差集）：</p><p>&#x2F;&#x2F; 交集<br>const intersection &#x3D; new Set([…setA].filter(x &#x3D;&gt; setB.has(x)));<br>&#x2F;&#x2F; 并集<br>const union &#x3D; new Set([…setA, …setB]);<br>&#x2F;&#x2F; 差集（A - B）<br>const difference &#x3D; new Set([…setA].filter(x &#x3D;&gt; !setB.has(x)));<br>临时存储唯一值：用于快速检查元素是否存在。</p><ol start="2"><li>Map（映射）</li></ol><p>基本特性</p><p>键值对结构：存储键值对的集合，键可以是任意类型（对象、函数等）。</p><p>有序性：元素按插入顺序迭代。</p><p>高效查找：基于哈希表实现，查找速度接近 O(1)。</p><p>创建与操作</p><p>const map &#x3D; new Map();<br>map.set(‘key1’, ‘value1’); &#x2F;&#x2F; 添加键值对<br>map.set({}, ‘objectKey’); &#x2F;&#x2F; 对象作为键<br>map.get(‘key1’); &#x2F;&#x2F; 获取值，若不存在返回 undefined<br>map.has(‘key1’); &#x2F;&#x2F; 检查键是否存在<br>map.delete(‘key1’); &#x2F;&#x2F; 删除键值对<br>map.size; &#x2F;&#x2F; 获取键值对数量<br>map.clear(); &#x2F;&#x2F; 清空映射<br>迭代方法</p><p><font style="color:rgb(64, 64, 64);">keys()</font>：返回键的迭代器。</p><p><font style="color:rgb(64, 64, 64);">values()</font>：返回值的迭代器。</p><p><font style="color:rgb(64, 64, 64);">entries()</font>：返回 <font style="color:rgb(64, 64, 64);">[key, value]</font> 的迭代器（默认迭代方式）。</p><p><font style="color:rgb(64, 64, 64);">forEach()</font>：遍历键值对。</p><p>for (const [key, value] of map) { &#x2F;_ 迭代键值对 <em>&#x2F; }<br>map.forEach((value, key) &#x3D;&gt; { &#x2F;</em> … _&#x2F; });<br>应用场景</p><p>复杂键存储：当键需要是非字符串类型时（如对象、函数）。</p><p>const domNode &#x3D; document.getElementById(‘node’);<br>const map &#x3D; new Map();<br>map.set(domNode, { clickCount: 0 }); &#x2F;&#x2F; DOM 节点作为键<br>数据关联：维护键值对的动态关联关系（如缓存计算结果）。</p><p>const cache &#x3D; new Map();<br>function computeExpensiveValue(key) {<br>if (cache.has(key)) return cache.get(key);<br>const result &#x3D; &#x2F;_ 复杂计算 _&#x2F;;<br>cache.set(key, result);<br>return result;<br>}<br>有序存储：需要保留插入顺序的键值对集合。</p><ol start="3"><li>WeakSet 与 WeakMap</li></ol><p>WeakSet</p><p>弱引用集合：元素必须是对象，且不计入引用计数（不影响垃圾回收）。</p><p>不可迭代：没有 <font style="color:rgb(64, 64, 64);">size</font>、<font style="color:rgb(64, 64, 64);">clear()</font> 或迭代方法。</p><p>用途：临时存储对象，避免内存泄漏。</p><p>const weakSet &#x3D; new WeakSet();<br>let obj &#x3D; {};<br>weakSet.add(obj);<br>WeakMap</p><p>弱引用键：键必须是对象，值可以是任意类型。</p><p>不可迭代：同样没有 <font style="color:rgb(64, 64, 64);">size</font>、<font style="color:rgb(64, 64, 64);">clear()</font> 或迭代方法。</p><p>用途：存储对象的私有数据或元数据。</p><p>const weakMap &#x3D; new WeakMap();<br>const obj &#x3D; {};<br>weakMap.set(obj, ‘privateData’);</p><ol start="4"><li>Set 和 Map 的对比</li></ol><p>特性 Set Map<br>存储内容 唯一值 键值对<br>键类型 值即键（任意类型） 键可以是任意类型<br>查找方式 直接检查值的存在性 通过键查找值<br>典型用途 去重、集合运算 复杂键存储、有序关联</p><ol start="5"><li>注意事项</li></ol><p>引用类型键的陷阱：对象作为键时，引用不同则视为不同键。</p><p>const map &#x3D; new Map();<br>map.set({}, ‘value’);<br>console.log(map.get({})); &#x2F;&#x2F; undefined（两个空对象引用不同）<br>性能优化：<font style="color:rgb(64, 64, 64);">Set</font> 和 <font style="color:rgb(64, 64, 64);">Map</font> 的查找速度（<font style="color:rgb(64, 64, 64);">has()</font>、<font style="color:rgb(64, 64, 64);">get()</font>）远快于数组的 <font style="color:rgb(64, 64, 64);">includes()</font>。</p><p>序列化限制：<font style="color:rgb(64, 64, 64);">JSON.stringify()</font> 无法序列化 <font style="color:rgb(64, 64, 64);">Set</font> 和 <font style="color:rgb(64, 64, 64);">Map</font>，需手动转换。</p><p>兼容性：ES6+ 支持，旧环境需使用 Babel 或 Polyfill（如 <font style="color:rgb(64, 64, 64);">core-js</font>）。</p><p>总结</p><p>Set：处理唯一值集合，适合去重、集合运算。</p><p>Map：处理键值对，适合复杂键类型或需要有序的场景。</p><p>WeakSet&#x2F;WeakMap：弱引用特性适合临时存储或避免内存泄漏。</p><p>padStart 和 padEnd</p><p><font style="color:rgb(64, 64, 64);">padStart</font> 和 <font style="color:rgb(64, 64, 64);">padEnd</font> 是 JavaScript 中用于字符串填充的方法，允许在字符串的开头或结尾添加字符，直到达到指定长度。以下是它们的详细说明和示例：</p><ol><li><strong><font style="color:rgb(64, 64, 64);">padStart(targetLength, padString)</font></strong></li></ol><p>作用：在字符串开头填充字符，直到字符串达到目标长度。</p><p>参数：</p><p><font style="color:rgb(64, 64, 64);">targetLength</font>：填充后的目标长度。</p><p><font style="color:rgb(64, 64, 64);">padString</font>（可选）：用于填充的字符串，默认为空格。</p><p>规则：</p><p>若原字符串长度 ≥ <font style="color:rgb(64, 64, 64);">targetLength</font>，直接返回原字符串。</p><p>填充字符串 <font style="color:rgb(64, 64, 64);">padString</font> 会被重复使用，超出部分被截断。</p><p>示例：</p><p>‘5’.padStart(3, ‘0’); &#x2F;&#x2F; ‘005’（填充到开头）<br>‘hi’.padStart(5, ‘ab’); &#x2F;&#x2F; ‘abahi’（填充 ‘aba’）<br>‘abc’.padStart(6, ‘123’); &#x2F;&#x2F; ‘123abc’（填充 ‘123’）<br>‘7’.padStart(4, ‘ab’); &#x2F;&#x2F; ‘aba7’（填充 ‘aba’）<br>‘test’.padStart(6); &#x2F;&#x2F; ‘ test’（默认用空格填充） 2. <strong><font style="color:rgb(64, 64, 64);">padEnd(targetLength, padString)</font></strong></p><p>作用：在字符串结尾填充字符，直到字符串达到目标长度。</p><p>参数：同 <font style="color:rgb(64, 64, 64);">padStart</font>。</p><p>规则：与 <font style="color:rgb(64, 64, 64);">padStart</font> 类似，但填充方向相反。</p><p>示例：</p><p>‘5’.padEnd(3, ‘0’); &#x2F;&#x2F; ‘500’（填充到结尾）<br>‘hi’.padEnd(5, ‘ab’); &#x2F;&#x2F; ‘hiaba’（填充 ‘aba’）<br>‘abc’.padEnd(6, ‘123’); &#x2F;&#x2F; ‘abc123’（填充 ‘123’）<br>‘7’.padEnd(4, ‘ab’); &#x2F;&#x2F; ‘7aba’（填充 ‘aba’）<br>‘test’.padEnd(6); &#x2F;&#x2F; ‘test ‘（默认用空格填充）<br>关键注意事项：</p><p>填充字符串的重复与截断：<br>若 <font style="color:rgb(64, 64, 64);">padString</font> 长度不足，会重复拼接直到满足目标长度，超出部分被截断。</p><p>‘12’.padStart(5, ‘abc’); &#x2F;&#x2F; ‘abc12’（填充 ‘abc’）<br>‘12’.padEnd(5, ‘abc’); &#x2F;&#x2F; ‘12abc’（填充 ‘abc’）<br>空字符串或省略参数：</p><ul><li><font style="color:rgb(64, 64, 64);">省略</font><font style="color:rgb(64, 64, 64);"> </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;padString&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">时，默认用空格填充。</font></li><li><font style="color:rgb(64, 64, 64);">若 </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;padString&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> 为空字符串，无法填充，直接返回原字符串。</font><br>‘5’.padStart(3); &#x2F;&#x2F; ‘ 5’（默认空格）<br>‘5’.padStart(3, ‘’); &#x2F;&#x2F; ‘5’（无填充）<br>目标长度小于原字符串：<br>直接返回原字符串。</li></ul><p>‘hello’.padStart(3, ‘0’); &#x2F;&#x2F; ‘hello’<br>应用场景</p><p>场景 1：隐藏手机号中间四位</p><p>将手机号 <font style="color:rgb(64, 64, 64);">13812341234</font> 转换为 <font style="color:rgb(64, 64, 64);">138*<strong>*1234</strong></font>，保留前 3 位和后 4 位，中间填充 <font style="color:rgb(64, 64, 64);">**</font>。</p><p>function desensitizePhone(phone) {<br>const visiblePrefix &#x3D; 3; &#x2F;&#x2F; 显示前 3 位<br>const visibleSuffix &#x3D; 4; &#x2F;&#x2F; 显示后 4 位<br>const prefix &#x3D; phone.slice(0, visiblePrefix);<br>const suffix &#x3D; phone.slice(-visibleSuffix);<br>&#x2F;&#x2F; 中间填充 <em>，总长度与原手机号一致<br>return prefix + suffix.padStart(phone.length - visiblePrefix, ‘</em>‘);<br>}</p><p>desensitizePhone(‘13812341234’); &#x2F;&#x2F; ‘138****1234’<br>场景 2：隐藏身份证号前 14 位</p><p>将身份证号 <font style="color:rgb(64, 64, 64);">110101199003077654</font> 转换为 <font style="color:rgb(64, 64, 64);">************7654</font>，只显示后 4 位。</p><p>function desensitizeID(id) {<br>const visibleDigits &#x3D; 4; &#x2F;&#x2F; 显示后 4 位<br>const suffix &#x3D; id.slice(-visibleDigits);<br>&#x2F;&#x2F; 前部填充 <em>，总长度与原身份证号一致<br>return suffix.padStart(id.length, ‘</em>‘);<br>}</p><p>desensitizeID(‘110101199003077654’); &#x2F;&#x2F; ‘************7654’<br>场景 3：隐藏银行卡号中间部分</p><p>将银行卡号 <font style="color:rgb(64, 64, 64);">6225880134567890</font> 转换为 <font style="color:rgb(64, 64, 64);">622588******7890</font>，保留前 6 位和后 4 位。</p><p>function desensitizeBankCard(card) {<br>const visiblePrefix &#x3D; 6; &#x2F;&#x2F; 显示前 6 位<br>const visibleSuffix &#x3D; 4; &#x2F;&#x2F; 显示后 4 位<br>const prefix &#x3D; card.slice(0, visiblePrefix);<br>const suffix &#x3D; card.slice(-visibleSuffix);<br>&#x2F;&#x2F; 中间填充 <em>，总长度与原卡号一致<br>return prefix + ‘</em>‘.repeat(card.length - visiblePrefix - visibleSuffix) + suffix;<br>}</p><p>desensitizeBankCard(‘6225880134567890’); &#x2F;&#x2F; ‘622588******7890’<br>场景 4：格式化短文本敏感信息</p><p>将用户昵称 <font style="color:rgb(64, 64, 64);">Alice</font> 转换为 <font style="color:rgb(64, 64, 64);">**ice</font>，隐藏前 2 位。</p><p>function desensitizeShortText(text, hideLength &#x3D; 2) {<br>const visiblePart &#x3D; text.slice(hideLength);<br>return visiblePart.padStart(text.length, ‘*‘);<br>}</p><p>desensitizeShortText(‘Alice’, 2); &#x2F;&#x2F; ‘**ice’<br>关键逻辑总结</p><p>截取保留部分：通过 <font style="color:rgb(64, 64, 64);">slice</font> 截取需要显示的头&#x2F;尾部分。</p><p>填充敏感符号：使用 <font style="color:rgb(64, 64, 64);">padStart</font> 或 <font style="color:rgb(64, 64, 64);">padEnd</font> 填充 <font style="color:rgb(64, 64, 64);">*</font>，确保总长度与原数据一致。</p><p>动态适配长度：根据输入数据的实际长度动态计算填充位数，避免硬编码。</p><p>注意事项</p><p>输入合法性校验：需确保输入是字符串且长度合法（如身份证 18 位、手机号 11 位）。</p><p>边界处理：若保留位数超过原数据长度，直接返回全隐藏（如 <font style="color:rgb(64, 64, 64);">‘*‘.repeat(text.length)</font>）。</p><p>扩展性：可通过参数控制隐藏的位数和填充符号，适配不同场景。</p><p>总结</p><p>**<font style="color:rgb(64, 64, 64);">padStart</font>**：向前填充，适用于左对齐或补前置字符（如日期补零）。</p><p>**<font style="color:rgb(64, 64, 64);">padEnd</font>**：向后填充，适用于右对齐或补后缀字符（如固定格式文本）。</p><p>处理填充字符串时，注意重复和截断逻辑，避免结果与预期不符。</p><p>flat 和 flatMap</p><p><font style="color:rgb(64, 64, 64);">flat()</font> 和 <font style="color:rgb(64, 64, 64);">flatMap()</font> 是 JavaScript 中用于处理数组的两种方法，专门用于简化嵌套数组的结构或结合映射（<font style="color:rgb(64, 64, 64);">map</font>）与扁平化（<font style="color:rgb(64, 64, 64);">flat</font>）操作。</p><ol><li><strong><font style="color:rgb(64, 64, 64);">flat(depth)</font></strong></li></ol><p>作用：将嵌套的数组“扁平化”，返回一个包含所有子数组元素的新数组。<br>参数：</p><p><font style="color:rgb(64, 64, 64);">depth</font>（可选）：指定要扁平化的嵌套层数，默认值为 <font style="color:rgb(64, 64, 64);">1</font>。若需完全扁平化，可设为 <font style="color:rgb(64, 64, 64);">Infinity</font>。<br>返回值：新数组（原数组不会被修改）。</p><p>示例：</p><p>&#x2F;&#x2F; 默认扁平化一层<br>const arr1 &#x3D; [1, [2, 3], [4, [5]]];<br>console.log(arr1.flat()); &#x2F;&#x2F; [1, 2, 3, 4, [5]]</p><p>&#x2F;&#x2F; 完全扁平化（无限层）<br>console.log(arr1.flat(Infinity)); &#x2F;&#x2F; [1, 2, 3, 4, 5]</p><p>&#x2F;&#x2F; 处理空位（自动跳过空值）<br>const arr2 &#x3D; [1, , 3];<br>console.log(arr2.flat()); &#x2F;&#x2F; [1, 3] 2. <strong><font style="color:rgb(64, 64, 64);">flatMap(callback)</font></strong></p><p>作用：先对数组的每个元素执行 <font style="color:rgb(64, 64, 64);">map</font> 操作，然后对结果扁平化一层。<br>参数：</p><p><font style="color:rgb(64, 64, 64);">callback</font>：一个函数，用于处理每个元素，返回一个数组（或其他可迭代对象）。<br>返回值：新数组（原数组不会被修改）。</p><p>示例：</p><p>&#x2F;&#x2F; 基本用法（等效于 map + flat(1)）<br>const arr &#x3D; [1, 2, 3];<br>const result &#x3D; arr.flatMap((x) &#x3D;&gt; [x, x * 2]);<br>console.log(result); &#x2F;&#x2F; [1, 2, 2, 4, 3, 6]</p><p>&#x2F;&#x2F; 处理非数组返回值（自动包装为数组）<br>const words &#x3D; [“hello”, “world”];<br>console.log(words.flatMap(word &#x3D;&gt; word.split(“”)));<br>&#x2F;&#x2F; [‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘w’, ‘o’, ‘r’, ‘l’, ‘d’]</p><p>&#x2F;&#x2F; 过滤并展开数据<br>const data &#x3D; [<br>{ id: 1, values: [10, 20] },<br>{ id: 2, values: [30] },<br>];<br>console.log(data.flatMap(item &#x3D;&gt; item.values)); &#x2F;&#x2F; [10, 20, 30]<br>对比 <strong><font style="color:rgb(64, 64, 64);">flatMap</font></strong> 与 <strong><font style="color:rgb(64, 64, 64);">map + flat</font></strong></p><p>以下两种写法等价，但 <font style="color:rgb(64, 64, 64);">flatMap</font> 更简洁高效：</p><p>&#x2F;&#x2F; 使用 flatMap<br>arr.flatMap((x) &#x3D;&gt; [x, x * 2]);</p><p>&#x2F;&#x2F; 等效于 map + flat<br>arr.map((x) &#x3D;&gt; [x, x * 2]).flat();<br>关键注意事项</p><p>扁平化层级：</p><p><font style="color:rgb(64, 64, 64);">flat()</font> 可指定层级，默认 <font style="color:rgb(64, 64, 64);">1</font>；<font style="color:rgb(64, 64, 64);">flatMap()</font> 仅扁平化一层。</p><p>若需完全扁平化 <font style="color:rgb(64, 64, 64);">flatMap</font> 的结果，需额外调用 <font style="color:rgb(64, 64, 64);">flat()</font>：</p><ul><li><code>arr.flatMap(fn).flat(Infinity);</code><br>空值处理：</li></ul><p><font style="color:rgb(64, 64, 64);">flat()</font> 会自动跳过数组中的空位（如 <font style="color:rgb(64, 64, 64);">[1, , 3]</font>）。</p><p><font style="color:rgb(64, 64, 64);">flatMap()</font> 的回调函数若返回空数组 <font style="color:rgb(64, 64, 64);">[]</font>，会直接过滤该元素：</p><ul><li><code>[1, 2, 3].flatMap(x =&gt; x % 2 === 0 ? [] : [x]); // [1, 3]</code><br>性能优化：</li></ul><p><font style="color:rgb(64, 64, 64);">flatMap()</font> 比先 <font style="color:rgb(64, 64, 64);">map</font> 后 <font style="color:rgb(64, 64, 64);">flat</font> 更高效，因为它减少了一次完整数组遍历。</p><p>使用场景</p><p>方法 适用场景<br><font style="color:rgb(64, 64, 64);">flat()</font> 多层嵌套数组的扁平化（如树形结构数据、API 返回的嵌套结果）。<br><font style="color:rgb(64, 64, 64);">flatMap()</font> 需要同时映射并扁平化的场景（如展开子数组、过滤后展开、拆分字符串等）。<br>总结</p><p>**<font style="color:rgb(64, 64, 64);">flat()</font>**：专为简化嵌套数组设计，支持指定层级。</p><p>**<font style="color:rgb(64, 64, 64);">flatMap()</font>**：结合 <font style="color:rgb(64, 64, 64);">map</font> 和 <font style="color:rgb(64, 64, 64);">flat</font>，适合需要“映射后立即扁平化”的场景。</p><p>两者均返回新数组，不会修改原数组。</p><p>FinalizationRegistry</p><p>FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调。</p><p>FinalizationRegistry 提供了这样的一种方法:当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。(清理回调有时被称为-fnalizer);</p><p>你可以通过调用 register 方法，注册任何你想要清理回调的对象传入该对象和所含的值</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    let obj = { name: "why", age: 18 }    let info = { name: "kobe", age: 30 }    const finalRegistry = new FinalizationRegistry((value) => {      console.log("某一个对象被回收了:", value)    })        finalRegistry.register(obj, "why")    finalRegistry.register(info, "kobe")        // obj = null    info = null  </script></body></html><p>WeakRefs</p><p>如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用:</p><p>如果我们希望是一个弱引用的话可以使用 WeakRef;</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    let info = { name: "why", age: 18 }    let obj = new WeakRef(info)    let obj2 = new WeakRef(info)        const finalRegistry = new FinalizationRegistry(() => {      console.log("对象被回收~")    })        finalRegistry.register(info, "info")        setTimeout(() => {      info = null    }, 2000)        setTimeout(() => {      console.log(obj.deref().name, obj.deref().age)    }, 8000)  </script></body></html><p>Proxy-Reflect</p><p>Proxy 和 Reflect 是 ES6 引入的元编程工具，允许开发者拦截和自定义对象的基本操作。</p><p>监听对象属性操作方法</p><p>使用 Object.defineProperty(vue2 响应式原理),存储数据描述符设计的初衷并不是为了去监听一个完整的对象</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <h2 class="name"></h2>  <script>    const obj = {      name: "why",      age: 18,      height: 1.88    }        // 需求: 监听对象属性的所有操作    // 监听属性的操作    // 1.针对一个属性    // let _name = obj.name    // Object.defineProperty(obj, "name", {    //   set: function(newValue) {    //     console.log("监听: 给name设置了新的值:", newValue)    //     _name = newValue    //   },    //   get: function() {    //     console.log("监听: 获取name的值")    //     return _name    //   }    // })        // 2.监听所有的属性: 遍历所有的属性, 对每一个属性使用defineProperty    const keys = Object.keys(obj)    for (const key of keys) {      let value = obj[key]      Object.defineProperty(obj, key, {        set: function(newValue) {          console.log(`监听: 给${key}设置了新的值:`, newValue)          value = newValue        },        get: function() {          console.log(`监听: 获取${key}的值`)          return value        }      })    }        // console.log(obj.name)    // obj.name = "kobe"    console.log(obj.age)    obj.age = 17    console.log(obj.age)    // 什么是响应式?    // const nameEl = document.querySelector(".name")    // nameEl.textContent = obj.name    // obj.name = "kobe"    // obj.name = "james"  </script></body></html>创建一个代理对象(Proxy对象)之后对该对象的所有操作，都通过代理对象来完成,代理对象可以监听我们想要对原对象进行哪些操作<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    const obj = {      name: "why",      age: 18,      height: 1.88    }    // 1.创建一个Proxy对象    const objProxy = new Proxy(obj, {      set: function(target, key, newValue) {        console.log(`监听: 监听${key}的设置值: `, newValue)        target[key] = newValue      },      get: function(target, key) {        console.log(`监听: 监听${key}的获取`)        return target[key]      }    })        // 2.对obj的所有操作, 应该去操作objProxy    // console.log(objProxy.name)    // objProxy.name = "kobe"    // console.log(objProxy.name)    // objProxy.name = "james"        objProxy.address = "广州市"    console.log(objProxy.address)  </script></body></html><p>Proxy</p><p>Proxy 用于创建一个对象的代理，拦截并重新定义对象的底层操作（如属性读取、赋值等）。</p><p>基本语法</p><p>const newProxy&#x3D;new Proxy(target,handler)</p><p>target：被代理的目标对象。</p><p>handler：定义拦截行为的对象，包含一组“陷阱”（trap）方法。</p><p>常用拦截方法</p><p>方法 触发场景<br><font style="color:rgb(64, 64, 64);">get(target, prop, receiver)</font> 读取属性时（如 <font style="color:rgb(64, 64, 64);">proxy.prop</font>）<br><font style="color:rgb(64, 64, 64);">set(target, prop, value, receiver)</font> 设置属性时（如 <font style="color:rgb(64, 64, 64);">proxy.prop &#x3D; value</font>）<br><font style="color:rgb(64, 64, 64);">has(target, prop)</font> <font style="color:rgb(64, 64, 64);">in</font>操作符（如 <font style="color:rgb(64, 64, 64);">‘prop’ in proxy</font>）<br><font style="color:rgb(64, 64, 64);">deleteProperty(target, prop)</font> <font style="color:rgb(64, 64, 64);">delete</font> 操作符（如 <font style="color:rgb(64, 64, 64);">delete proxy.prop</font>）<br><font style="color:rgb(64, 64, 64);">apply(target, thisArg, args)</font> 函数调用（如 <font style="color:rgb(64, 64, 64);">proxy()</font>）<br><font style="color:rgb(64, 64, 64);">construct(target, args, newTarget)</font> <font style="color:rgb(64, 64, 64);">new</font>操作符（如 <font style="color:rgb(64, 64, 64);">new Proxy()</font>）<br>示例</p><p>const target &#x3D; { name: “Alice” };<br>const handler &#x3D; {<br>get(target, prop) {<br>console.log(<code>读取属性：$&#123;prop&#125;</code>);<br>return target[prop];<br>},<br>set(target, prop, value) {<br>console.log(<code>设置属性：$&#123;prop&#125; = $&#123;value&#125;</code>);<br>target[prop] &#x3D; value;<br>return true; &#x2F;&#x2F; 表示成功<br>}<br>};<br>const proxy &#x3D; new Proxy(target, handler);</p><p>proxy.name; &#x2F;&#x2F; 输出 “读取属性：name”，返回 “Alice”<br>proxy.age &#x3D; 30; &#x2F;&#x2F; 输出 “设置属性：age &#x3D; 30”</p><p>Reflect</p><p>Reflect 是一个内置对象，提供与 Proxy 方法一一对应的方法，用于执行对象的默认行为。它的设计目的是简化 Proxy 的实现，并提供更规范的底层操作。</p><p>常用方法</p><p>Reflect 方法 对应 Proxy 陷阱<br><font style="color:rgb(64, 64, 64);">Reflect.get(target, prop, receiver)</font> <font style="color:rgb(64, 64, 64);">get</font><br><font style="color:rgb(64, 64, 64);">Reflect.set(target, prop, value, receiver)</font> <font style="color:rgb(64, 64, 64);">set</font><br><font style="color:rgb(64, 64, 64);">Reflect.has(target, prop)</font> <font style="color:rgb(64, 64, 64);">has</font><br><font style="color:rgb(64, 64, 64);">Reflect.deleteProperty(target, prop)</font> <font style="color:rgb(64, 64, 64);">deleteProperty</font><br><font style="color:rgb(64, 64, 64);">Reflect.apply(func, thisArg, args)</font> <font style="color:rgb(64, 64, 64);">apply</font><br><font style="color:rgb(64, 64, 64);">Reflect.construct(target, args)</font> <font style="color:rgb(64, 64, 64);">construct</font><br>示例</p><p>const obj &#x3D; { a: 1 };<br>&#x2F;&#x2F; 通过 Reflect 操作对象<br>Reflect.set(obj, “b”, 2); &#x2F;&#x2F; obj 变为 { a: 1, b: 2 }<br>console.log(Reflect.get(obj, “a”)); &#x2F;&#x2F; 输出 1</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    function Person(name, age) {      this.name = name      this.age = age    }    function Student(name, age) {      // Person.call(this, name, age)        }    // 属于Student类,实现自Person    const stu = Reflect.construct(Person, ['MirZ', 18], Student)    console.log(stu)    console.log(stu.__proto__ === Student.prototype)  </script></body></html><p>Proxy 和 Reflect 的配合</p><p>在 Proxy 的方法中调用 Reflect 的对应方法，可确保保留对象的默认行为，同时添加自定义逻辑。</p><p>不去直接操作原对象</p><p>reflect 会返回 boolean 判断操作是否成功</p><p>reflect 可以使用<font style="color:rgb(64, 64, 64);">receiver</font>正确传递 this</p><p>典型模式</p><p>const handler &#x3D; {<br>get(target, prop, receiver) {<br>console.log(<code>读取属性：$&#123;prop&#125;</code>);<br>return Reflect.get(…arguments); &#x2F;&#x2F; 等效于 Reflect.get(target, prop, receiver)<br>}<br>};</p><p>this 绑定问题</p><p>直接操作 <font style="color:rgb(64, 64, 64);">target[prop]</font> 可能导致 <font style="color:rgb(64, 64, 64);">this</font> 指向错误，而 <font style="color:rgb(64, 64, 64);">Reflect.get(target, prop, receiver)</font> 能正确传递 <font style="color:rgb(64, 64, 64);">receiver</font>（通常是代理对象）。</p><p>const target &#x3D; {<br>name: “Alice”,<br>greet() {<br>console.log(<code>Hello, $&#123;this.name&#125;!</code>);<br>}<br>};<br>const handler &#x3D; {<br>get(target, prop, receiver) {<br>return Reflect.get(target, prop, receiver); &#x2F;&#x2F; 确保 this 指向代理<br>}<br>};<br>const proxy &#x3D; new Proxy(target, handler);<br>proxy.greet(); &#x2F;&#x2F; Hello, Alice!（若 name 被代理修改，此处会反映变化）</p><p>应用场景</p><p>数据校验：拦截 <font style="color:rgb(64, 64, 64);">set</font> 操作，验证属性值。</p><p>日志记录：跟踪对象的读写操作。</p><p>自动填充属性：访问不存在的属性时返回默认值。</p><p>观察者模式：属性变化时触发回调。</p><p>函数调用劫持：统计函数执行时间。</p><p>数据校验示例</p><p>const validator &#x3D; {<br>set(target, prop, value) {<br>if (prop &#x3D;&#x3D;&#x3D; “age” &amp;&amp; typeof value !&#x3D;&#x3D; “number”) {<br>throw new TypeError(“Age must be a number!”);<br>}<br>return Reflect.set(target, prop, value);<br>}<br>};<br>const proxy &#x3D; new Proxy({}, validator);<br>proxy.age &#x3D; 30; &#x2F;&#x2F; 成功<br>proxy.age &#x3D; “30”; &#x2F;&#x2F; 抛出错误<br>注意事项</p><p>性能：频繁拦截可能影响性能，需谨慎使用。</p><p>兼容性：现代浏览器支持良好，旧环境可能需要 polyfill。</p><p>可撤销代理：通过 <font style="color:rgb(64, 64, 64);">Proxy.revocable()</font> 创建可取消的代理。</p><p>const { proxy, revoke } &#x3D; Proxy.revocable(target, handler);<br>revoke(); &#x2F;&#x2F; 后续操作 proxy 将报错<br>通过结合 Proxy 和 Reflect，开发者可以实现高度灵活的对象操作，增强代码的可控性和可维护性。</p><p>Promise</p><p>Promise 是 JavaScript 中处理异步操作的核心机制。</p><ol><li>三种状态</li></ol><p>Pending（待定）：初始状态，未完成或被拒绝。</p><p>Fulfilled（已兑现）：操作成功完成，调用 <font style="color:rgb(64, 64, 64);">resolve(value)</font>。</p><p>Rejected（已拒绝）：操作失败，调用 <font style="color:rgb(64, 64, 64);">reject(error)</font>。</p><p>状态不可逆：一旦状态变为 Fulfilled 或 Rejected，将不再改变。</p><p>基本用法</p><p>通过 new 创建 Promise 对象时，我们需要传入一个回调函数，我们称之为 executor,这个回调函数会被立即执行，并且给传入另外两个回调函数(resolve、reject)当我们调用 resolve 回调函数时，会执行 Promise 对象的 then 方法传入的回调函数:当我们调用 reject 回调函数时，会执行 Promise 对象的 catch 方法传入的回调函数;</p><p>const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; {<br>&#x2F;&#x2F; 异步操作（如 API 请求、定时器等）<br>if (&#x2F;_ 成功 _&#x2F;) {<br>resolve(value); &#x2F;&#x2F; 状态变为 Fulfilled<br>} else {<br>reject(error); &#x2F;&#x2F; 状态变为 Rejected<br>}<br>});</p><script>    const p = new Promise((resolve) => {      // setTimeout(resolve, 2000)      setTimeout(() => {        resolve("p的resolve")      }, 2000)    })    const promise = new Promise((resolve, reject) => {      // 1.普通值      // resolve([      //   {name: "macbook", price: 9998, intro: "有点贵"},      //   {name: "iPhone", price: 9.9, intro: "有点便宜"},      // ])          // 2.resolve(promise)      // 如果resolve的值本身Promise对象, 那么当前的Promise的状态会有传入的Promise来决定      // resolve(p)          // 3.resolve(thenable对象)      resolve({        name: "kobe",        //由then来决定        then: function(resolve) {          resolve(11111)        }      })    })        promise.then(res => {      console.log("then中拿到结果:", res)    })  </script><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    const promise = new Promise((resolve, reject) => {      resolve("aaaaaaa")      // reject()    })        // 1.then方法是返回一个新的Promise, 这个新Promise的决议是等到then方法传入的回调函数有返回值时, 进行决议    // Promise本身就是支持链式调用    // then方法是返回一个新的Promise, 链式中的then是在等待这个新的Promise有决议之后执行的    // promise.then(res => {    //   console.log("第一个then方法:", res)    //   return "bbbbbbbb"    // }).then(res => {    //   console.log("第二个then方法:", res)    //   return "cccccccc"    // }).then(res => {    //   console.log("第三个then方法:", res)    // })        // promise.then(res => {    //   console.log("添加第二个then方法:", res)    // })        // 2.then方法传入回调函数的返回值类型    const newPromise = new Promise((resolve, reject) => {      setTimeout(() => {        resolve("why")      }, 3000)    })        promise.then(res => {      console.log("第一个Promise的then方法:", res)      // 1.普通值      // return "bbbbbbb"      // 2.新的Promise      // return newPromise      // 3.thenable的对象      return {        then: function(resolve) {          resolve("thenable")        }      }    }).then(res => {      console.log("第二个Promise的then方法:", res)     })  </script></body></html><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    const promise = new Promise((resolve, reject) => {      // reject("error: aaaaa")      resolve("aaaaaa")    })        // 1.catch方法也会返回一个新的Promise    // promise.catch(err => {    //   console.log("catch回调:", err)    //   return "bbbbb"    // }).then(res => {    //   console.log("then第一个回调:", res)    //   return "ccccc"    // }).then(res => {    //   console.log("then第二个回调:", res)    // })        // 2.catch方法的执行时机    promise.then(res => {      console.log("then第一次回调:", res)      // throw new Error("第二个Promise的异常error")       return "bbbbbb"    }).then(res => {      console.log("then第二次回调:", res)      throw new Error("第三个Promise的异常error")    }).then(res => {      console.log("then第三次回调:", res)    }).catch(err => {      console.log("catch回调被执行:", err)    })        // 中断函数继续执行:    // 方式一: return    // 方式二: throw new Error()    // 方式三: yield 暂停(暂时性的中断)  </script></body></html>2. 链式调用<p>**<font style="color:rgb(64, 64, 64);">.then()</font>**：处理成功结果，可返回新值或 Promise。</p><p>**<font style="color:rgb(64, 64, 64);">.catch()</font>**：捕获链中所有错误。</p><p>**<font style="color:rgb(64, 64, 64);">.finally()</font>**：无论成功或失败都会执行，通常用于清理。</p><p>doSomething()<br>.then(result &#x3D;&gt; doSomethingElse(result))<br>.then(newResult &#x3D;&gt; doThirdThing(newResult))<br>.catch(error &#x3D;&gt; console.error(error))<br>.finally(() &#x3D;&gt; stopLoading()); 3. 静态方法</p><p>**<font style="color:rgb(64, 64, 64);">Promise.resolve(value)</font>**：返回一个已解决的 Promise。</p><p>**<font style="color:rgb(64, 64, 64);">Promise.reject(error)</font>**：返回一个已拒绝的 Promise。</p><p>**<font style="color:rgb(64, 64, 64);">Promise.all([p1, p2, …])</font>**：所有成功时返回结果数组；任一失败立即拒绝。</p><p>**<font style="color:rgb(64, 64, 64);">Promise.race([p1, p2, …])</font>**：采用第一个完成（成功或失败）的 Promise 结果。</p><p>**<font style="color:rgb(64, 64, 64);">Promise.allSettled([p1, p2, …])</font>**：等待所有完成，返回状态和结果数组。</p><p>**<font style="color:rgb(64, 64, 64);">Promise.any([p1, p2, …])</font>**：任一成功则返回其值，全部失败则抛出 <font style="color:rgb(64, 64, 64);">AggregateError</font>。</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // 创建三个Promise    const p1 = new Promise((resolve, reject) => {      setTimeout(() => {        // resolve("p1 resolve")        reject("p1 reject error")      }, 3000)    })        const p2 = new Promise((resolve, reject) => {      setTimeout(() => {        resolve("p2 resolve")      }, 2000)    })        const p3 = new Promise((resolve, reject) => {      setTimeout(() => {        resolve("p3 resolve")      }, 5000)    })        // all:全部/所有 所有成功时返回结果数组；任一失败立即拒绝。    Promise.all([p1, p2, p3]).then(res => {      console.log("all promise res:", res)    }).catch(err => {      console.log("all promise err:", err)    })​        //allSettled 等待所有完成，返回状态和结果数组。    Promise.allSettled([p1, p2, p3]).then(res => {      console.log("all settled:", res)    })        // 类方法: race方法    // 特点: 会等到一个Promise有结果(无论这个结果是fulfilled还是rejected)    Promise.race([p1, p2, p3]).then(res => {      console.log("race promise:", res)    }).catch(err => {      console.log("race promise err:", err)    })​       // 类方法: any方法 任一成功则返回其值，全部失败则抛出 AggregateError。​    Promise.any([p1, p2, p3]).then(res => {​      console.log("any promise res:", res)​    }).catch(err => {​      console.log("any promise err:", err)​    })  </script></body></html>4. 错误处理<p>隐式冒泡：链中未处理的错误会传递到最近的 <font style="color:rgb(64, 64, 64);">.catch()</font>。</p><p>同步错误捕获：执行器函数中的同步错误自动触发拒绝。</p><p>异步错误需显式拒绝：在异步回调（如 <font style="color:rgb(64, 64, 64);">setTimeout</font>）中需手动调用 <font style="color:rgb(64, 64, 64);">reject()</font>。</p><p>&#x2F;&#x2F; 正确捕获异步错误<br>new Promise((resolve, reject) &#x3D;&gt; {<br>setTimeout(() &#x3D;&gt; {<br>reject(new Error(“Async error”));<br>}, 1000);<br>}).catch(error &#x3D;&gt; console.log(error)); 5. 常见陷阱</p><p>返回值缺失：<font style="color:rgb(64, 64, 64);">.then()</font> 中未 <font style="color:rgb(64, 64, 64);">return</font> 将导致后续接收 <font style="color:rgb(64, 64, 64);">undefined</font>。</p><p>嵌套 Promise：避免嵌套，改用链式调用。</p><p>未处理的拒绝：始终添加 <font style="color:rgb(64, 64, 64);">.catch()</font> 防止未捕获错误。</p><ol start="6"><li>与 async&#x2F;await 结合</li></ol><p><strong><font style="color:rgb(64, 64, 64);">async</font></strong> <strong>函数</strong>：返回 Promise，可用 <font style="color:rgb(64, 64, 64);">await</font> 等待异步操作。</p><p>错误处理：结合 <font style="color:rgb(64, 64, 64);">try&#x2F;catch</font> 捕获异常。</p><p>async function fetchData() {<br>try {<br>const data &#x3D; await apiCall();<br>const processed &#x3D; await processData(data);<br>console.log(processed);<br>} catch (error) {<br>console.error(“Fetch failed:”, error);<br>}<br>} 7. 应用场景</p><p>并行任务：<font style="color:rgb(64, 64, 64);">Promise.all</font> 处理多个独立异步操作。</p><p>竞速请求：<font style="color:rgb(64, 64, 64);">Promise.race</font> 实现超时控制。</p><p>顺序执行：链式调用逐个处理依赖任务的结果。</p><p>掌握 Promise 的关键在于理解状态流转、链式调用机制及错误处理策略。结合 <font style="color:rgb(64, 64, 64);">async&#x2F;await</font> 可进一步提升代码可读性，有效管理异步流程。</p><p><font style="color:rgb(64, 64, 64);"></font></p><p>Iterator-Generator(迭代器-生成器)</p><p>在 JavaScript 中，迭代器（Iterator）、生成器（Generator）和可迭代对象（Iterable）是处理数据集合和异步编程的重要概念。</p><p>迭代器(Iterator)</p><p>迭代器_(iteratbr)，使用户在容器对象(container，例如链表或数组)上遍访的对象，使用该接口无需关心对象的内部实现细节。</p><p>定义<br>一个对象，必须实现 <strong><font style="color:rgb(64, 64, 64);">next()</font></strong> 方法，返回 <font style="color:rgb(64, 64, 64);">{ value: any, done: boolean }</font>。</p><p>手动创建迭代器</p><dl><dt>function createCounter(max) {<br>let count &#x3D; 0;<br>return {<br>next() {<br>return count &lt; max<br>? { value: count++, done: false }</dt><dd>{ done: true };<br>}<br>};<br>}</dd></dl><p>const counter &#x3D; createCounter(3);<br>console.log(counter.next().value); &#x2F;&#x2F; 0<br>console.log(counter.next().value); &#x2F;&#x2F; 1<br>迭代器协议<br>任何对象只要实现了 <font style="color:rgb(64, 64, 64);">next()</font> 方法，符合返回 <font style="color:rgb(64, 64, 64);">{value, done}</font> 的规则，就是一个迭代器。</p><p>可迭代对象(Iterable)</p><p>定义<br>实现了 <strong><font style="color:rgb(64, 64, 64);"><a href>Symbol.iterator</a></font></strong> 方法的对象，该方法返回一个迭代器。可被 <font style="color:rgb(64, 64, 64);">for…of</font> 遍历。</p><p>常见内置可迭代对象</p><p><font style="color:rgb(64, 64, 64);">Array, String, Map, Set, TypedArray, arguments, NodeList 等</font></p><p>手动实现可迭代对象</p><p>const obj &#x3D; {<br>fri: [‘1’, ‘2’, ‘3’, ‘4’],<br><a href>Symbol.iterator</a> {<br>let num &#x3D; 0;<br>return {<br>next: () &#x3D;&gt; {<br>&#x2F;&#x2F;使用箭头函数,无 this,上层作用域找 this,找到顶层<br>return num &lt;&#x3D; this.fri.length ? { done: false, value: this.fri[num++] } : { done: true }<br>}<br>}<br>}<br>}<br>for (const o of obj) {<br>console.log(o);<br>}<br>console.log(obj[Symbol.iterator]);<br>console.log(obj<a href>Symbol.iterator</a>);</p><pre><code class="hljs">const iterFun = obj[Symbol.iterator]()console.log(iterFun.next());console.log(iterFun.next());console.log(iterFun.next());console.log(iterFun.next());console.log(iterFun.next());console.log(iterFun.next());</code></pre><p>const obj&#x3D;{<br>name:’MirZ’,<br>age:’18’,<br>address:’河南’,<br><a href>Symbol.iterator</a>{<br>&#x2F;&#x2F; const keys&#x3D;Object.keys(this)<br>&#x2F;&#x2F; const values&#x3D;Object.values(this)<br>const entries&#x3D;Object.entries(this)<br>let count&#x3D;0<br>return{<br>next:()&#x3D;&gt;{<br>return count&lt;entries.length?{done:false,value:entries[count++]}:{done:true}<br>}<br>}<br>}<br>}<br>for (const element of obj) {<br>console.log(element);</p><p>}<br>class Person {<br>constructor(name, age, height, friends) {<br>this.name &#x3D; name<br>this.age &#x3D; age<br>this.height &#x3D; height<br>this.friends &#x3D; friends<br>}</p><pre><code class="hljs">  // 实例方法  running() &#123;&#125;  [Symbol.iterator]() &#123;    let index = 0    const iterator = &#123;      next: () =&gt; &#123;        if (index &lt; this.friends.length) &#123;          return &#123; done: false, value: this.friends[index++] &#125;        &#125; else &#123;          return &#123; done: true &#125;        &#125;      &#125;    &#125;    return iterator  &#125;&#125;const p1 = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])const p2 = new Person(&quot;kobe&quot;, 30, 1.98, [&quot;curry&quot;, &quot;james&quot;, &quot;aonier&quot;, &quot;weide&quot;])for (const item of p2) &#123;  console.log(item)&#125;</code></pre><p>class Person {<br>constructor(name, age, height, friends) {<br>this.name &#x3D; name<br>this.age &#x3D; age<br>this.height &#x3D; height<br>this.friends &#x3D; friends<br>}</p><pre><code class="hljs">  // 实例方法  running() &#123;&#125;  [Symbol.iterator]() &#123;    let index = 0    const iterator = &#123;      next: () =&gt; &#123;        if (index &lt; this.friends.length) &#123;          return &#123; done: false, value: this.friends[index++] &#125;        &#125; else &#123;          return &#123; done: true &#125;        &#125;      &#125;,      return: () =&gt; &#123;        console.log(&quot;监听到迭代器中断了&quot;)        return &#123; done: true &#125;      &#125;    &#125;    return iterator  &#125;&#125;</code></pre><p>​<br> const p1 &#x3D; new Person(“why”, 18, 1.88, [“curry”, “kobe”, “james”, “tatumu”])</p><pre><code class="hljs">for (const item of p1) &#123;  console.log(item)  if (item === &quot;kobe&quot;) &#123;    break  &#125;&#125;</code></pre><p>生成器</p><p>定义</p><p>生成器是 ES6 中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等<br> 通过 <strong><font style="color:rgb(64, 64, 64);">function*</font></strong> 定义的函数，返回一个生成器对象（既是迭代器又是可迭代对象）。</p><p>生成器和普通的函数区别:</p><p>首先，生成器函数需要在 function 的后面加一个符号:*</p><p>其次，生成器函数可以通过 yield 关键字来控制函数的执行流程</p><p>最后，生成器函数的返回值是一个 Generator(生成器)</p><p>生成器是一种特殊的迭代器</p><p><strong><font style="color:rgb(64, 64, 64);">yield</font></strong> <strong>关键字</strong></p><ul><li><font style="color:rgb(64, 64, 64);">暂停函数执行并返回一个值。</font></li><li><font style="color:rgb(64, 64, 64);">通过 </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;next()&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> 恢复执行，可传递参数给生成器。</font><br>function* gen() {<br>yield 1;<br>yield 2;<br>return 3;<br>}</li></ul><p>const generator &#x3D; gen();<br>console.log(generator.next()); &#x2F;&#x2F; { value: 1, done: false }<br>console.log(generator.next());<br>console.log(generator.next());<br>console.log(generator.next());<br>生成器的惰性求值<br>生成器按需生成值，适合处理大数据或无限序列：</p><p>function* fibonacci() {<br>let a &#x3D; 0, b &#x3D; 1;<br>while (true) {<br>yield a;<br>[a, b] &#x3D; [b, a + b];<br>}<br>}<br>生成器的高级用法</p><p>传参给 **<font style="color:rgb(64, 64, 64);">next()</font>**：向生成器内部传递值。</p><p>function* fibonacci() {<br>let a &#x3D; 0, b &#x3D; 1;<br>while (true) {<br>yield a;<br>[a, b] &#x3D; [b, a + b];<br>}<br>}<br>const gen&#x3D;fibonacci()<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>&#x2F;&#x2F; console.log(gen.return());<br>&#x2F;&#x2F; console.log(gen.throw(new Error(‘结束’)));<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());</p><ul><li><strong><font style="color:rgb(64, 64, 64);">错误处理</font></strong><font style="color:rgb(64, 64, 64);">：使用</font><font style="color:rgb(64, 64, 64);"> </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;generator.throw(err)&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">抛出错误。</font></li><li><strong><font style="color:rgb(64, 64, 64);">提前终止</font></strong><font style="color:rgb(64, 64, 64);">：使用 </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;generator.return()&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> 结束生成器。</font></li></ul><p>总结</p><p>迭代器和生成器的关系</p><p>生成器是迭代器的语法糖<br>生成器自动实现 <font style="color:rgb(64, 64, 64);"><a href>Symbol.iterator</a></font> 和 <font style="color:rgb(64, 64, 64);">next()</font>，简化迭代器创建。</p><p>const obj&#x3D;{<br>names:[‘李卓’,’叶茂华’,’MirZ’]<br>}<br>function* creatItera(obj){<br>for (let index &#x3D; 0; index &lt; obj.names.length; index++) {<br>yield obj.names[index]<br> }<br>}<br>const objItera&#x3D;creatItera(obj)<br>console.log(objItera.next());<br>console.log(objItera.next());<br>console.log(objItera.next());<br>console.log(objItera.next());</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>   class Person {      constructor(name, age, height, friends) {        this.name = name        this.age = age        this.height = height        this.friends = friends      }      // 实例方法      *[Symbol.iterator]() {        //yield* 用于委托给另一个可迭代对象。它会遍历这个可迭代对象，并逐个 yield 其中的元素，而不是将整个可迭代对象作为一个元素返回。      yield* this.friends      }    }        const p = new Person("why", 18, 1.88, ["curry", "kobe", "james", "tatumu"])        for (const item of p) {      console.log(item)    }    // const pItera=p[Symbol.iterator]()    // console.log(pItera.next());    // console.log(pItera.next());    // console.log(pItera.next());    // console.log(pItera.next());  </script></body></html>生成器对象的特性<p>const genObj &#x3D; gen();<br>console.log(genObj<a href>Symbol.iterator</a> &#x3D;&#x3D;&#x3D; genObj); &#x2F;&#x2F; true<br>应用场景</p><p><strong><font style="color:rgb(64, 64, 64);">for…of</font></strong> 循环<br>遍历可迭代对象：</p><p>for (const char of ‘Hello’) console.log(char); &#x2F;&#x2F; H, e, l, l, o</p><p>解构赋值与扩展运算符</p><p>const [a, b] &#x3D; [10, 20]; &#x2F;&#x2F; 解构<br>const arr &#x3D; […’abc’]; &#x2F;&#x2F; [‘a’, ‘b’, ‘c’]<br>异步迭代器（Async Iterators）<br>与 <font style="color:rgb(64, 64, 64);">for await…of</font> 配合处理异步数据流：</p><p>async function* asyncGen() {<br>yield await Promise.resolve(1);<br>yield await Promise.resolve(2);<br>}</p><p>(async () &#x3D;&gt; {<br>for await (const num of asyncGen()) console.log(num); &#x2F;&#x2F; 1, 2<br>})();<br>概念 关键点<br>可迭代对象 必须实现 <font style="color:rgb(64, 64, 64);"><a href>Symbol.iterator</a></font>，返回迭代器。<br>迭代器 必须实现 <font style="color:rgb(64, 64, 64);">next()</font>，返回 <font style="color:rgb(64, 64, 64);">{ value, done }</font>。<br>生成器 通过 <font style="color:rgb(64, 64, 64);">function*</font>定义，简化迭代器创建，支持暂停&#x2F;恢复执行和双向通信。</p><p>异步处理<br>异步处理方式</p><p>最早的异步处理方式可能是回调函数，比如在 setTimeout 或者事件监听中使用回调。但回调的问题在于容易导致回调地狱，代码难以维护。</p><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title></head><body>  <script>    // 封装请求的方法: url -> promise(result)    function requestData(url) {      return new Promise((resolve, reject) => {        setTimeout(() => {          resolve(url)        }, 2000)      })    }        // 1.发送一次网络请求    // requestData("http://why").then(res => {    //   console.log("res:", res)    // })        /*      需求:         1.发送一次网络请求, 等到这次网络请求的结果        2.发送第二次网络请求, 等待这次网络请求的结果        3.发送第三次网络请求, 等待这次网络请求的结果    */    // 方式一: 层层嵌套(回调地狱 callback hell)    // function getData() {    //   // 1.第一次请求    //   requestData("why").then(res1 => {    //     console.log("第一次结果:", res1)        //     // 2.第二次请求    //     requestData(res1 + "kobe").then(res2 => {    //       console.log("第二次结果:", res2)        //       // 3.第三次请求    //       requestData(res2 + "james").then(res3 => {    //         console.log("第三次结果:", res3)    //       })    //     })    //   })    // }        // 方式二: 使用Promise进行重构(解决回调地狱)    // 链式调用    // function getData() {    //   requestData("why").then(res1 => {    //     console.log("第一次结果:", res1)    //     return requestData(res1 + "kobe")    //   }).then(res2 => {    //     console.log("第二次结果:", res2)    //     return requestData(res2 + "james")    //   }).then(res3 => {    //     console.log("第三次结果:", res3)    //   })    // }        // 方式三: 最终代码    // function* getData() {    //   const res1 = yield requestData("why")    //   console.log("res1:", res1)        //   const res2 = yield requestData(res1 + "kobe")    //   console.log("res2:", res2)        //   const res3 = yield requestData(res2 + "james")    //   console.log("res3:", res3)    // }        // const generator = getData()    // generator.next().value.then(res1 => {    //   generator.next(res1).value.then(res2 => {    //     generator.next(res2).value.then(res3 => {    //       generator.next(res3)    //     })    //   })    // })        // 方式四: async/await的解决方案    async function getData() {      const res1 = await requestData("why")      console.log("res1:", res1)          const res2 = await requestData(res1 + "kobe")      console.log("res2:", res2)          const res3 = await requestData(res2 + "james")      console.log("res3:", res3)    }        const generator = getData()  </script></body></html><pre><code class="hljs">// 封装请求的方法: url -&gt; promise(result)function requestData(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(url)    &#125;, 2000)  &#125;)&#125;// 生成器的处理方案function* getData() &#123;  const res1 = yield requestData(&quot;why&quot;)  console.log(&quot;res1:&quot;, res1)  const res2 = yield requestData(res1 + &quot;kobe&quot;)  console.log(&quot;res2:&quot;, res2)  const res3 = yield requestData(res2 + &quot;james&quot;)  console.log(&quot;res3:&quot;, res3)  const res4 = yield requestData(res3 + &quot;curry&quot;)  console.log(&quot;res4:&quot;, res4)  const res5 = yield requestData(res4 + &quot;tatumu&quot;)  console.log(&quot;res5:&quot;, res5)&#125;// const generator = getData()// generator.next().value.then(res1 =&gt; &#123;//   generator.next(res1).value.then(res2 =&gt; &#123;//     generator.next(res2).value.then(res3 =&gt; &#123;//       generator.next(res3).value.then(res4 =&gt; &#123;//         generator.next(res4)//       &#125;)//     &#125;)//   &#125;)// &#125;)// 自动化执行生成器函数(了解)function execGenFn(genFn) &#123;  // 1.获取对应函数的generator  const generator = genFn()  // 2.定义一个递归函数  function exec(res) &#123;    // result -&gt; &#123; done: true/false, value: 值/undefined &#125;    const result = generator.next(res)    if (result.done) return    result.value.then(res =&gt; &#123;      exec(res)    &#125;)  &#125;  // 3.执行递归函数  exec()&#125;execGenFn(getData)</code></pre><p>异步函数</p><p>异步函数基础</p><p>定义：通过 <font style="color:rgb(64, 64, 64);">async</font> 关键字声明的函数，内部可使用 <font style="color:rgb(64, 64, 64);">await</font> 等待 Promise 完成。</p><p>返回值：<font style="color:rgb(64, 64, 64);">async</font> 函数始终返回一个 Promise：</p><p>若函数返回非 Promise 值，会被隐式转换为 <font style="color:rgb(64, 64, 64);">Promise.resolve(值)</font>。</p><p>若抛出错误（<font style="color:rgb(64, 64, 64);">throw</font>），返回 <font style="color:rgb(64, 64, 64);">Promise.reject(错误)</font>。</p><p>async function getData() {<br>return 42; &#x2F;&#x2F; 等价于 Promise.resolve(42)<br>}<br>getData().then(console.log); &#x2F;&#x2F; 输出 42<br><font style="color:rgb(64, 64, 64);"></font><strong><font style="color:rgb(64, 64, 64);">await</font></strong> 关键字的核心规则</p><p>作用：暂停 <font style="color:rgb(64, 64, 64);">async</font> 函数执行，等待右侧的 Promise 完成。</p><p>若 Promise 成功，<font style="color:rgb(64, 64, 64);">await</font> 返回解析后的值。</p><p>若 Promise 失败，<font style="color:rgb(64, 64, 64);">await</font> 抛出拒绝原因（可用 <font style="color:rgb(64, 64, 64);">try&#x2F;catch</font> 捕获）。</p><p>限制：<font style="color:rgb(64, 64, 64);">await</font> 只能在 <strong><font style="color:rgb(64, 64, 64);">async</font></strong> 函数内部使用，否则报语法错误。</p><p>async function fetchUser() {<br>const response &#x3D; await fetch(‘&#x2F;api&#x2F;user’); &#x2F;&#x2F; 等待网络请求完成<br>const user &#x3D; await response.json(); &#x2F;&#x2F; 等待 JSON 解析<br>return user;<br>}<br>错误处理</p><p><strong><font style="color:rgb(64, 64, 64);">try&#x2F;catch</font></strong> <strong>捕获错误</strong>：同步风格处理异步错误。</p><p><strong><font style="color:rgb(64, 64, 64);">.catch()</font></strong> 兜底：<font style="color:rgb(64, 64, 64);">async</font> 函数返回的 Promise 可链式调用 <font style="color:rgb(64, 64, 64);">.catch()</font>。</p><p>&#x2F;&#x2F; 方式 1: try&#x2F;catch<br>async function loadData() {<br>try {<br>const data &#x3D; await fetchApi();<br>} catch (error) {<br>console.error(‘加载失败:’, error);<br>}<br>}</p><p>&#x2F;&#x2F; 方式 2: .catch()<br>loadData().catch(error &#x3D;&gt; console.error(‘兜底捕获:’, error));</p><p>事件循环<br>线程和进程</p><p>线程和进程是操作系统中的两个概念:</p><p>进程(process):计算机已经运行的程序，是操作系统管理程序的一种方式:</p><p>线程(thread):操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中;</p><p>:::tips<br>听起来很抽象，这里还是给出我的解释:</p><p>进程:我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程):</p><p>线程:每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称之为主线程</p><p>所以我们也可以说进程是线程的容器</p><p>:::</p><p>事件队列</p><p>JavaScript 是单线程(可以开启 workers)的，但是 JavaScript 的线程有自己的容器进程:浏览器或者 Node.</p><p>目前多数的浏览器其实都是多进程的，当我们打开一个 tab 页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出,每个进程中又有很多的线程，其中包括执行 JavaScript 代码的线程</p><p>JavaScript 的代码执行是在一个单独的线程中执行的,这就意味着 JavaScript 的代码在同一个时刻只能做一件事,如果这件事是非常耗时的，就意味着当前的线程就会被阻塞</p><p>事件循环</p><p>宏任务和微任务</p><p>但是事件循环中并非只维护着一个队列，事实上是有两个队列:</p><p>宏任务队列(macrotask queue):ajax、setTimeout、setlnterval、DOM 监听、Ul Rendering 等</p><p>微任务队列(microtask queue):Promise 的 then 回调、Mutation Observer APl、queueMicrotask()等</p><p>那么事件循环对于两个队列的优先级是怎么样的呢?</p><p>1.main script 中的代码优先执行(编写的顶层 script 代码);</p><p>2.在执行任何一个宏任务之前(不是队列，是一个宏任务)，都会先查看微任务队列中是否有任务需要执行, 也就是宏任务执行之前，必须保证微任务队列是空的;如果不为空，那么就优先执行微任务队列中的任务(回调):</p><p>面试题</p><p>console.log(“script start”) &#x2F;&#x2F;1</p><p>setTimeout(function () {<br>console.log(“setTimeout1”); &#x2F;&#x2F;8<br>new Promise(function (resolve) {<br>resolve();<br>}).then(function () {<br>new Promise(function (resolve) {<br>resolve();<br>}).then(function () {<br>console.log(“then4”); &#x2F;&#x2F;10<br>});<br>console.log(“then2”); &#x2F;&#x2F;9<br>});<br>});</p><p>new Promise(function (resolve) {<br>console.log(“promise1”); &#x2F;&#x2F;2<br>resolve();<br>}).then(function () {<br>console.log(“then1”); &#x2F;&#x2F;5<br>});</p><p>setTimeout(function () {<br>console.log(“setTimeout2”); &#x2F;&#x2F;11<br>});</p><p>console.log(2); &#x2F;&#x2F;3<br>&#x2F;&#x2F;直接将一个函数加入微队列<br>queueMicrotask(() &#x3D;&gt; {<br>console.log(“queueMicrotask1”) &#x2F;&#x2F;6<br>});</p><p>new Promise(function (resolve) {<br>resolve();<br>}).then(function () {<br>console.log(“then3”); &#x2F;&#x2F;7<br>});</p><p>console.log(“script end”) &#x2F;&#x2F;4</p><p>console.log(“script start”)</p><p>function requestData(url) {<br>console.log(“requestData”)<br>return new Promise((resolve) &#x3D;&gt; {<br>setTimeout(() &#x3D;&gt; {<br>console.log(“setTimeout”)<br>resolve(url)<br>}, 2000);<br>})<br>}</p><p>&#x2F;&#x2F; 2.await&#x2F;async<br>async function getData() {<br>console.log(“getData start”)<br>&#x2F;&#x2F;await 只有等到 promise 的结果返回才会执行后续代码<br>const res &#x3D; await requestData(“why”)</p><p>console.log(“then1-res:”, res)<br>console.log(“getData end”)<br>}</p><p>getData()</p><p>console.log(“script end”)</p><p>&#x2F;&#x2F; script start<br>&#x2F;&#x2F; getData start<br>&#x2F;&#x2F; requestData<br>&#x2F;&#x2F; script end</p><p>&#x2F;&#x2F; setTimeout</p><p>&#x2F;&#x2F; then1-res: why<br>&#x2F;&#x2F; getData end</p><p>async function async1 () {<br>console.log(‘async1 start’) &#x2F;&#x2F;2<br>await async2();<br>&#x2F;&#x2F; async2()执行完后会 return undefined &#x3D;&#x3D;&gt; Promise.resolve(undefined) ,下面代码放入微任务队列<br>console.log(‘async1 end’) &#x2F;&#x2F; 6<br>}</p><pre><code class="hljs">async function async2 () &#123;  console.log(&#39;async2&#39;)  //3&#125;console.log(&#39;script start&#39;)  //1setTimeout(function () &#123;  console.log(&#39;setTimeout&#39;)   //8&#125;, 0)async1();new Promise (function (resolve) &#123;  console.log(&#39;promise1&#39;)  //4  resolve();&#125;).then (function () &#123;  console.log(&#39;promise2&#39;)  //7&#125;)console.log(&#39;script end&#39;)   //5</code></pre><p>Storage</p><p>Storage 用于在客户端存储数据，主要包括 <font style="color:rgb(64, 64, 64);">localStorage</font> 和 <font style="color:rgb(64, 64, 64);">sessionStorage</font>，属于 Web Storage API。</p><ol><li>类型与区别</li></ol><p>localStorage</p><p>生命周期：永久存储，需手动删除（代码或浏览器清除）。</p><p>作用域：同源（协议、域名、端口相同）的所有标签页和窗口共享。</p><p>sessionStorage</p><p>生命周期：仅限当前会话，关闭标签页或浏览器后清除。</p><p>作用域：仅在当前标签页有效，同源其他标签页无法访问。</p><ol start="2"><li>常用方法</li></ol><p>存储数据：<font style="color:rgb(64, 64, 64);">setItem(key, value)</font></p><p>localStorage.setItem(‘username’, ‘Alice’);</p><p>读取数据：<font style="color:rgb(64, 64, 64);">getItem(key)</font></p><p>const user &#x3D; localStorage.getItem(‘username’); &#x2F;&#x2F; ‘Alice’</p><p>删除数据：<font style="color:rgb(64, 64, 64);">removeItem(key)</font></p><p>localStorage.removeItem(‘username’);</p><p>清空所有数据：<font style="color:rgb(64, 64, 64);">clear()</font></p><p>localStorage.clear();</p><ol start="3"><li>数据格式</li></ol><p>仅支持字符串：存储对象需序列化，读取时反序列化。</p><p>const obj &#x3D; { name: ‘Bob’ };<br>localStorage.setItem(‘user’, JSON.stringify(obj));<br>const data &#x3D; JSON.parse(localStorage.getItem(‘user’)); 4. 存储事件（storage Event）</p><p>触发条件：同源其他标签页修改 Storage 时触发。</p><p>事件对象属性：<font style="color:rgb(64, 64, 64);">key</font>、<font style="color:rgb(64, 64, 64);">oldValue</font>、<font style="color:rgb(64, 64, 64);">newValue</font>、<font style="color:rgb(64, 64, 64);">url</font> 等。</p><p>window.addEventListener(‘storage’, (e) &#x3D;&gt; {<br>console.log(<code>$&#123;e.key&#125; 值从 $&#123;e.oldValue&#125; 变为 $&#123;e.newValue&#125;</code>);<br>}); 5. 容量限制</p><p>大小：约 5MB（不同浏览器可能不同）。</p><p>错误处理：超出限制会抛出 <font style="color:rgb(64, 64, 64);">QuotaExceededError</font>，需使用 <font style="color:rgb(64, 64, 64);">try…catch</font>处理。</p><p>try {<br>localStorage.setItem(‘bigData’, new Array(5 _ 1024 _ 1024).join(‘a’));<br>} catch (e) {<br>console.error(‘存储失败：’, e);<br>} 6. 安全性与兼容性</p><p>明文存储：避免保存敏感信息（如密码）。</p><p>XSS 风险：若网站存在 XSS 漏洞，攻击者可读取 Storage 数据。</p><p>兼容性：现代浏览器均支持，IE8+ 支持，但隐私模式可能受限。</p><p>检测支持：</p><p>function isStorageSupported() {<br>try {<br>const testKey &#x3D; ‘<strong>test</strong>‘;<br>localStorage.setItem(testKey, testKey);<br>localStorage.removeItem(testKey);<br>return true;<br>} catch (e) {<br>return false;<br>}<br>} 7. 注意事项</p><p>类型转换：非字符串数据会被自动转换（如 <font style="color:rgb(64, 64, 64);">true</font> 转为 <font style="color:rgb(64, 64, 64);">“true”</font>）。</p><p>遍历键值：通过 <font style="color:rgb(64, 64, 64);">length</font> 和 <font style="color:rgb(64, 64, 64);">key(index)</font>。</p><p>for (let i &#x3D; 0; i &lt; localStorage.length; i++) {<br>const key &#x3D; localStorage.key(i);<br>console.log(key, localStorage.getItem(key));<br>}<br>隐私模式：部分浏览器在隐身模式下禁用 Storage，需异常处理。</p><ol start="8"><li>与 Cookie 对比</li></ol><p>特性 Cookie Web Storage<br>容量 ~4KB ~5MB<br>请求是否携带 每次 HTTP 请求自动携带 不参与通信<br>生命周期 可设置过期时间 永久或会话级 9. 封装工具函数</p><p>const storage &#x3D; {<br>set(key, value) {<br>localStorage.setItem(key, JSON.stringify(value));<br>},<br>get(key) {<br>const data &#x3D; localStorage.getItem(key);<br>return data ? JSON.parse(data) : null;<br>},<br>remove(key) {<br>localStorage.removeItem(key);<br>}<br>};</p><p>正则表达式</p><p>正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p><p>正则表达式的创建</p><p>在 JavaScript 中有两种方式创建正则表达式：</p><p>字面量方式</p><p>使用斜杠（&#x2F;）来界定正则表达式模式。</p><p>const pattern &#x3D; &#x2F;abc&#x2F;;</p><p>构造函数方式</p><p>使用 RegExp 构造函数，传入模式字符串作为参数。</p><p><font style="color:rgb(28, 31, 35);">const pattern &#x3D; new RegExp(‘abc’);</font></p><p>正则表达式标志</p><p>标志可以改变正则表达式的匹配行为，标志可以单个使用，也可以组合使用。常用标志如下：</p><p>i：忽略大小写。(global)</p><p>const pattern &#x3D; &#x2F;abc&#x2F;i;<br>console.log(pattern.test(‘ABC’)); &#x2F;&#x2F; true<br>g：全局匹配，找到所有匹配项，而不是在找到第一个匹配项后停止。(ignore)</p><p>const str &#x3D; ‘abc abc’;<br>const pattern &#x3D; &#x2F;abc&#x2F;g;<br>const matches &#x3D; str.match(pattern);<br>console.log(matches); &#x2F;&#x2F; [‘abc’, ‘abc’]<br>m：多行匹配，使 ^ 和 $ 可以匹配每行的开头和结尾。(multiple)</p><p>const str &#x3D; ‘abc\nabc’;<br>const pattern &#x3D; &#x2F;^abc&#x2F;m;<br>const matches &#x3D; str.match(pattern);<br>console.log(matches); &#x2F;&#x2F; [‘abc’, ‘abc’]</p><p>常用的正则表达式元字符<br>概览</p><p>元字符</p><p>基础：<font style="color:rgb(64, 64, 64);">^</font>（开头）、<font style="color:rgb(64, 64, 64);">$</font>（结尾）、<font style="color:rgb(64, 64, 64);">.</font>（任意字符，除换行符）、<font style="color:rgb(64, 64, 64);">|</font>（或）。</p><p>转义字符：<font style="color:rgb(64, 64, 64);">\d</font>（数字）、<font style="color:rgb(64, 64, 64);">\D</font>（非数字）、<font style="color:rgb(64, 64, 64);">\w</font>（单词字符）、<font style="color:rgb(64, 64, 64);">\W</font>（非单词字符）、<font style="color:rgb(64, 64, 64);">\s</font>（空白符）、<font style="color:rgb(64, 64, 64);">\S</font>（非空白符）。**<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">. * ?</font>** (转义特殊字符,如 . * ? [ ] \ &#x2F; ^ $ | + ( ))</p><p>边界：<font style="color:rgb(64, 64, 64);">\b</font>（单词边界）、<font style="color:rgb(64, 64, 64);">\B</font>（非单词边界）。</p><p>量词</p><p><font style="color:rgb(64, 64, 64);">*</font>（0 次或多次）、<font style="color:rgb(64, 64, 64);">+</font>（1 次或多次）、<font style="color:rgb(64, 64, 64);">?</font>（0 或 1 次）。</p><p><font style="color:rgb(64, 64, 64);">{n}</font>（n 次）、<font style="color:rgb(64, 64, 64);">{n,}</font>（至少 n 次）、<font style="color:rgb(64, 64, 64);">{n,m}</font>（n 到 m 次）。</p><p>非贪婪模式：在量词后加 <font style="color:rgb(64, 64, 64);">?</font>（如 <font style="color:rgb(64, 64, 64);">*?</font>、<font style="color:rgb(64, 64, 64);">+?</font>）。</p><p>字符集合</p><p><font style="color:rgb(64, 64, 64);">[abc]</font>：匹配 a、b、c 中的任意一个。</p><p><font style="color:rgb(64, 64, 64);">[^abc]</font>：匹配不在集合中的字符。</p><p><font style="color:rgb(64, 64, 64);">[a-z]</font>：匹配范围（如小写字母）。</p><p>分组与捕获</p><p><font style="color:rgb(64, 64, 64);">(abc)</font>：捕获组，通过 <font style="color:rgb(64, 64, 64);">\1</font> 或 <font style="color:rgb(64, 64, 64);">$1</font> 引用。</p><p><font style="color:rgb(64, 64, 64);">(?:abc)</font>：非捕获组，不保存匹配项。</p><p>前瞻：<font style="color:rgb(64, 64, 64);">(?&#x3D;…)</font>（正向肯定）、<font style="color:rgb(64, 64, 64);">(?!&#x3D;…)</font>（正向否定）。</p><p>元字符示例</p><p>.：匹配除换行符之外的任意单个字符。</p><p>const pattern &#x3D; &#x2F;a.c&#x2F;;<br>console.log(pattern.test(‘abc’)); &#x2F;&#x2F; true<br>^：匹配字符串的开头。</p><p>const pattern &#x3D; &#x2F;^abc&#x2F;;<br>console.log(pattern.test(‘abcdef’)); &#x2F;&#x2F; true<br>$：匹配字符串的结尾。</p><p>const pattern &#x3D; &#x2F;abc$&#x2F;;<br>console.log(pattern.test(‘defabc’)); &#x2F;&#x2F; true *：匹配前面的元素零次或多次。{0,}</p><p>const pattern &#x3D; &#x2F;ab*c&#x2F;;<br>console.log(pattern.test(‘ac’)); &#x2F;&#x2F; true<br>console.log(pattern.test(‘abc’)); &#x2F;&#x2F; true<br>console.log(pattern.test(‘abbbc’)); &#x2F;&#x2F; true +：匹配前面的元素一次或多次。{1,}</p><p>const pattern &#x3D; &#x2F;ab+c&#x2F;;<br>console.log(pattern.test(‘ac’)); &#x2F;&#x2F; false<br>console.log(pattern.test(‘abc’)); &#x2F;&#x2F; true<br>console.log(pattern.test(‘abbbc’)); &#x2F;&#x2F; true<br>?：匹配前面的元素零次或一次。{0,1}</p><p>const pattern &#x3D; &#x2F;ab?c&#x2F;;<br>console.log(pattern.test(‘ac’)); &#x2F;&#x2F; true<br>console.log(pattern.test(‘abc’)); &#x2F;&#x2F; true<br>console.log(pattern.test(‘abbbc’)); &#x2F;&#x2F; false<br>{n,m}：匹配前面的元素至少 n 次，最多 m 次。{n}：匹配前面的元素恰好 n 次。{n,}：匹配前面的元素至少 n 次。</p><p>&#x2F;&#x2F; 匹配 2 到 4 个连续的数字<br>const pattern &#x3D; &#x2F;\d{2,4}&#x2F;;<br>console.log(pattern.test(‘123’)); &#x2F;&#x2F; true<br>[]：匹配方括号内的任意一个字符。</p><p>const pattern &#x3D; &#x2F;[abc]&#x2F;;<br>console.log(pattern.test(‘a’)); &#x2F;&#x2F; true<br>console.log(pattern.test(‘d’)); &#x2F;&#x2F; false<br>()：用于分组，将多个元素视为一个整体。</p><p>const pattern &#x3D; &#x2F;(ab)+&#x2F;;<br>console.log(pattern.test(‘abab’)); &#x2F;&#x2F; true<br>| : 用于表示 or , 或者</p><p>const message &#x3D; “1239891238732136321”<br>const pattern&#x3D;&#x2F;(123|321)&#x2F;ig<br>const res&#x3D;message.match(pattern)<br>console.log(res);<br>\d：匹配任意一个数字，等价于 [0-9]。(digit)</p><p>const str &#x3D; ‘cca2bc4af5cab12b’;<br>&#x2F;&#x2F;\d+匹配数字,将多个连续的数字也视为一个整体<br>const pattern &#x3D; &#x2F;\d+&#x2F;ig;<br>const newArr &#x3D; str.match(pattern);<br>console.log(newArr); &#x2F;&#x2F; [‘2’,’4’,’5’,’12’]<br>\D：匹配任意非数字字符，等价于 [^0-9]</p><p>const str &#x3D; ‘cca2bc4af5cab12b’;<br>const pattern &#x3D; &#x2F;\D+&#x2F;ig;<br>const newArr &#x3D; str.match(pattern);<br>console.log(newArr); &#x2F;&#x2F;[‘cca’, ‘bc’, ‘af’, ‘cab’, ‘b’]<br>\s：匹配任意空白字符，包括空格、制表符、换行符等。(space)</p><p>const pattern &#x3D; &#x2F;\s&#x2F;;<br>console.log(pattern.test(‘ ‘)); &#x2F;&#x2F; true<br>\S：匹配任意非空白字符。</p><p>const pattern &#x3D; &#x2F;\S&#x2F;;<br>console.log(pattern.test(‘a’)); &#x2F;&#x2F; true<br>\w：匹配任意字母、数字或下划线，等价于 [a-zA-Z0-9_]。(word)</p><p>const pattern &#x3D; &#x2F;\w&#x2F;;<br>console.log(pattern.test(‘x’)); &#x2F;&#x2F; true<br>\W：匹配任意非字母、数字或下划线的字符，等价于 [^a-zA-Z0-9_]。</p><p>const pattern &#x3D; &#x2F;\W&#x2F;;<br>console.log(pattern.test(‘!’)); &#x2F;&#x2F; true<br><font style="color:rgb(64, 64, 64);">\b</font>: 单词边界 , 匹配的单词两边必须是边界(不匹配\w)</p><p>const message &#x3D; ‘My name is MirZ’<br>const pattern &#x3D; &#x2F;\bis\b&#x2F;<br>if (pattern.test(message)) {<br>console.log(‘is 有边界’);<br>} else {<br>console.log(‘is 无边界’);<br>}<br><font style="color:rgb(64, 64, 64);">\B</font>: 单词边界 , 匹配的单词两边必须非边界</p><p>const message &#x3D; ‘My name is MirZ’<br>const pattern &#x3D; &#x2F;\Bis\B&#x2F;<br>if (pattern.test(message)) {<br>console.log(‘is 有边界’);<br>} else {<br>console.log(‘is 无边界’);<br>}</p><p>正则表达式方法</p><p>test()</p><p>用于测试字符串中是否存在匹配的模式，返回 true 或 false。</p><p>const pattern &#x3D; &#x2F;abc&#x2F;;<br>const str &#x3D; ‘abcdef’;<br>console.log(pattern.test(str)); &#x2F;&#x2F; true<br><strong>exec()</strong></p><p>用于字符串中执行匹配操作，返回一个数组，包含匹配的结果和相关信息。没有匹配到，则返回 null</p><p>const pattern &#x3D; &#x2F;abc&#x2F;;<br>const str &#x3D; ‘abcdef’;<br>const result &#x3D; pattern.exec(str);<br>console.log(result); &#x2F;&#x2F; [‘abc’, index: 0, input: ‘abcdef’, groups: undefined]<br><strong>match()</strong></p><p>在字符串中查找匹配的模式，返回一个数组，包含所有匹配的结果。如果没有使用 g 标志，则只返回第一个匹配结果。</p><p>const str &#x3D; ‘abc abc’;<br>const pattern1 &#x3D; &#x2F;abc&#x2F;;<br>const pattern2 &#x3D; &#x2F;abc&#x2F;g;<br>console.log(str.match(pattern1)); &#x2F;&#x2F; [‘abc’, index: 0, input: ‘abc abc’, groups: undefined]<br>console.log(str.match(pattern2)); &#x2F;&#x2F; [‘abc’, ‘abc’]<br><strong>matchAll()</strong></p><p>在字符串中查找匹配的模式，返回一个迭代器。必须使用 g 标志</p><p>const str &#x3D; ‘abc abc’;<br>const pattern1 &#x3D; &#x2F;abc&#x2F;;<br>const pattern2 &#x3D; &#x2F;abc&#x2F;g;<br>console.log(str.match(pattern1)); &#x2F;&#x2F; [‘abc’, index: 0, input: ‘abc abc’, groups: undefined]<br>console.log(str.match(pattern2)); &#x2F;&#x2F; [‘abc’, ‘abc’]<br><strong>replace()</strong></p><p>用于替换字符串中匹配的模式，返回一个新的字符串。如果不加 g 标识符,则只替换搜索到的第一个符合的字符串,加 g 替换结果等同于<strong>replaceAll()</strong></p><p>const str &#x3D; ‘abc abc’;<br>const pattern &#x3D; &#x2F;abc&#x2F;g;<br>const newStr &#x3D; str.replace(pattern, ‘def’);<br>console.log(newStr); &#x2F;&#x2F; ‘def def’<br><strong>split()</strong></p><p>用于使用字符串中匹配的字符串进行分割字符串，返回一个新的数组。</p><p>const str &#x3D; ‘ccabcabacafbcab12b’;<br>const pattern &#x3D; &#x2F;ab&#x2F;;<br>const newArr &#x3D; str.split(pattern);<br>console.log(newArr); &#x2F;&#x2F; [‘cc’,’c’,’acefhc’,’12b’]<br><strong>search()</strong></p><p>用于查找字符串中第一个匹配的模式的索引，如果没有找到，则返回 -1。</p><p>const str &#x3D; ‘abc def’;<br>const pattern &#x3D; &#x2F;abc&#x2F;;<br>console.log(str.search(pattern)); &#x2F;&#x2F; 0</p><p>贪婪模式和惰性模式</p><p>贪婪匹配，它会从第一个匹配项开始，尽可能多地匹配字符，直到遇到最后一个匹配项 ，所以最终匹配的是整个字符串</p><p>惰性模式也称为非贪婪模式，通过在量词后面加上问号 <font style="color:rgba(0, 0, 0, 0.85);">?</font> 来开启。在惰性模式下，量词会尽可能少地匹配符合条件的字符，一旦找到第一个匹配项就会停止匹配。</p><p>&#x2F;&#x2F; 1.贪婪模式&#x2F;惰性模式<br>const message &#x3D; “我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》”</p><pre><code class="hljs">// 默认.+采用贪婪模式// const nameRe = /《.+》/ig// const result1 = message.match(nameRe)// console.log(result1)// 使用惰性模式const nameRe = /《.+?》/igconst result1 = message.match(nameRe)console.log(result1)</code></pre><p>捕获组</p><p><font style="color:rgba(0, 0, 0, 0.85);">()</font> 不单单可以当作一个整体 , 也可以定义捕获组。每一对括号就定义了一个捕获组，从左到右，括号的顺序决定了捕获组的编号，编号从 1 开始。第 0 个捕获组始终代表整个正则表达式匹配的内容。</p><p>const str &#x3D; ‘John Smith’;<br>const pattern &#x3D; &#x2F;(\w+) (\w+)&#x2F;;<br>const result &#x3D; str.match(pattern);</p><p>console.log(result[0]); &#x2F;&#x2F; 输出整个匹配结果：John Smith<br>console.log(result[1]); &#x2F;&#x2F; 输出第一个捕获组：John<br>console.log(result[2]); &#x2F;&#x2F; 输出第二个捕获组：Smith<br>const str &#x3D; ‘Doe, John’;<br>const pattern &#x3D; &#x2F;(\w+), (\w+)&#x2F;;<br>const newStr &#x3D; str.replace(pattern, ‘$2 $1’);</p><p>console.log(newStr); &#x2F;&#x2F; 输出：John Doe<br>&#x2F;&#x2F;这里，$1 和 $2 分别代表第一个和第二个捕获组的内容，通过 replace 方法将它们的顺序进行了交换。<br>const str &#x3D; ‘2023-10-15’;<br>const pattern &#x3D; &#x2F;(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})&#x2F;;<br>const result &#x3D; str.match(pattern);</day></month></year></p><p>console.log(result.groups.year); &#x2F;&#x2F; 输出：2023<br>console.log(result.groups.month); &#x2F;&#x2F; 输出：10<br>console.log(result.groups.day); &#x2F;&#x2F; 输出：15<br>非捕获组</p><p>有时候，你可能只想使用括号来对正则表达式的一部分进行分组，但不想捕获匹配的内容，这时可以使用非捕获组，语法是 (?:pattern)。</p><pre><code class="hljs">const message = &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;  //捕获组// const nameRe = /(《)(?&lt;group&gt;.+?)(》)/ig  //非捕获组const nameRe = /(?:《)(?&lt;group&gt;.+?)(?:》)/igconst iterator = message.matchAll(nameRe)for (const item of iterator) &#123;  console.log(item)&#125;</code></pre><p>应用场景举例</p><p>手机号码验证</p><p>const phone &#x3D; ‘13800138000’;<br>const phonePattern &#x3D; &#x2F;^1[3-9]\d{9}$&#x2F;;<br>console.log(phonePattern.test(phone)); &#x2F;&#x2F; true<br>HTML 标签匹配</p><p>const htmlEle&#x3D;’<div><span></span><h1></h1></div>‘<br>const pattern&#x3D;&#x2F;&lt;/?[a-z][a-z0-9]*&gt;&#x2F;ig<br>const res&#x3D;htmlEle.match(pattern)<br>console.log(res);<br>HTML 标签内容匹配</p><p>const html &#x3D; ‘</p><p>Hello, World!</p>‘;<br>const pattern &#x3D; &#x2F;&lt;[^&gt;]+&gt;([^&lt;]+)&lt;/[^&gt;]+&gt;&#x2F;;<br>const result &#x3D; html.match(pattern);<br>if (result) {<br>console.log(result[1]); &#x2F;&#x2F; ‘Hello, World!’<br>}<br>格式化日期</font></p><p>const dateStr &#x3D; ‘2023-10-15’;<br>const pattern &#x3D; &#x2F;(\d{4})-(\d{2})-(\d{2})&#x2F;;<br>const newDateStr &#x3D; dateStr.replace(pattern, ‘$2&#x2F;$3&#x2F;$1’);<br>console.log(newDateStr); &#x2F;&#x2F; ‘10&#x2F;15&#x2F;2023’<br>时间戳格式化时间</p><pre><code class="hljs">// yyyy/MM/dd hh:mm:ss// yyyy*MM*dd hh-mm-ss// dayjs/momentfunction formatTime(timestamp, fmtString) &#123;  // 1.将时间戳转成Date  const date = new Date(timestamp)  // // 2.获取到值  // const year = date.getFullYear()  // const month = date.getMonth() + 1  // const day = date.getDate()  // const hour = date.getHours()  // const minute = date.getMinutes()  // const second = date.getSeconds()  // 2.正则和值匹配起来  const dateO = &#123;    &quot;y+&quot;: date.getFullYear(),    &quot;M+&quot;: date.getMonth() + 1,    &quot;d+&quot;: date.getDate(),    &quot;h+&quot;: date.getHours(),    &quot;m+&quot;: date.getMinutes(),    &quot;s+&quot;: date.getSeconds()  &#125;  // 3.for循环进行替换  for (const key in dateO) &#123;    const keyRe = new RegExp(key)    if (keyRe.test(fmtString)) &#123;      const value = (dateO[key] + &quot;&quot;).padStart(2, &quot;0&quot;)      fmtString = fmtString.replace(keyRe, value)    &#125;  &#125;  return fmtString&#125;// 某一个商品上架时间, 活动的结束时间const timeEl = document.querySelector(&quot;.time&quot;)const productJSON = &#123;  name: &quot;iPhone16e&quot;,  newPrice: 4999,  oldPrice: 5999,  endTime: Date.now()&#125;timeEl.textContent = formatTime(productJSON.endTime, &quot;hh:mm:ss yyyy:MM:dd&quot;)</code></pre><p>防抖节流</p><p>在 JavaScript 中，防抖（Debounce） 和 节流（Throttle） 是两种常用的性能优化技术，用于控制高频事件的触发频率，避免过多的资源消耗（如频繁的 DOM 操作、网络请求等）。</p><p>防抖（Debounce）</p><p>当事件被频繁触发时，只有在事件停止触发一段时间后，才会执行目标函数。如果在此期间再次触发事件，则重新计时。</p><pre><code class="hljs">function MyDebounce(fn, delay) &#123;  //定义timer记录定时器  let timer = null  //返回一个防抖处理后新的函数,不能使用箭头函数(箭头函数无this,this会指向window)  return function (...arg) &#123;    //每次触发清除上一次定时器    clearTimeout(timer)    //延迟执行函数,...args事件触发时传递的参数    timer = setTimeout(() =&gt; &#123;      //找到被防抖处理的函数应该绑定的this,进行绑定      fn.apply(this, args)    &#125;, delay)  &#125;&#125;</code></pre><p>function MyDebounce(fn, delay) {<br>let timer &#x3D; null<br>const _debounce&#x3D;function(…args){<br>clearTimeout(timer)<br>timer &#x3D; setTimeout(() &#x3D;&gt; {<br>fn.apply(this, args)<br>}, delay)<br>}<br>&#x2F;&#x2F;在返回的_debounce 函数上绑定一个取消函数<br>_debounce.cancel&#x3D;function(){<br>if(timer) clearTimeout(timer)<br>}<br>return _debounce<br>}<br>const inputEle &#x3D; document.querySelector(‘input’)<br>const buttonEle&#x3D;document.querySelector(‘button’)<br>const MyDebounceFn &#x3D; MyDebounce(function () {<br>console.log(this.value);<br>}, 5000)<br>inputEle.oninput&#x3D;MyDebounceFn<br>buttonEle.onclick&#x3D;function(){<br>MyDebounceFn.cancel()<br>}<br>&#x2F;&#x2F;immediate 判断是否立即执行一次<br>function MyDebounce(fn, delay, immediate &#x3D; false) {<br>let timer &#x3D; null<br>&#x2F;&#x2F;定义变量记录是否已经立即执行过<br>let isInvoke &#x3D; false<br>const _debounce &#x3D; function (…args) {<br>clearTimeout(timer)<br>if (immediate &amp;&amp; !isInvoke){<br>fn.apply(this,args)<br>isInvoke&#x3D;true<br>return<br>}<br>timer &#x3D; setTimeout(() &#x3D;&gt; {<br>fn.apply(this, args)<br>}, delay)<br>}<br>&#x2F;&#x2F;在返回的_debounce 函数上绑定一个取消函数<br>_debounce.cancel &#x3D; function () {<br>if (timer) clearTimeout(timer)<br>}<br>return _debounce<br>}</p><pre><code class="hljs">const inputEle = document.querySelector(&#39;input&#39;)const buttonEle = document.querySelector(&#39;button&#39;)const MyDebounceFn = MyDebounce(function () &#123;  console.log(this.value);&#125;, 2000,true)inputEle.oninput = MyDebounceFnbuttonEle.onclick = function () &#123;  MyDebounceFn.cancel()&#125;</code></pre><p>&#x2F;&#x2F;immediate 判断是否立即执行一次<br>function MyDebounce(fn, delay, immediate &#x3D; false) {<br>let timer &#x3D; null<br>&#x2F;&#x2F;定义变量记录是否已经立即执行过<br>let isInvoke &#x3D; false<br>&#x2F;&#x2F;记录返回的结果<br>let res &#x3D; undefined<br>const _debounce &#x3D; function (…args) {<br>return new Promise((resolve, reject) &#x3D;&gt; {<br>clearTimeout(timer)<br>if (immediate &amp;&amp; !isInvoke) {<br>&#x2F;&#x2F;获取返回的值,通过回调函数回调出去<br>res &#x3D; fn.apply(this, args)<br>resolve(res)<br>isInvoke &#x3D; true<br>return<br>}<br>timer &#x3D; setTimeout(() &#x3D;&gt; {<br>&#x2F;&#x2F;获取返回的值,通过回调函数回调出去<br>res &#x3D; fn.apply(this, args)<br>resolve(res)<br>}, delay)<br>})</p><pre><code class="hljs">  &#125;  //在返回的_debounce函数上绑定一个取消函数  _debounce.cancel = function () &#123;    if (timer) clearTimeout(timer)  &#125;  return _debounce&#125;const MyFn = MyDebounce(function (name) &#123;  console.log(name);  return &#39;promise返回值&#39;&#125;, 2000, false)MyFn(&#39;Mir&#39;).then((res)=&gt;&#123;  console.log(res);&#125;)</code></pre><p>应用场景</p><p>搜索框输入联想（用户停止输入后再发送请求）。</p><p>窗口大小调整（停止调整后再计算布局）。</p><p>表单验证（输入完成后验证一次）。</p><p>节流（Throttle）</p><p>当事件被频繁触发时，每隔固定的时间间隔，执行一次目标函数。无论事件触发多频繁，函数的执行频率都会被限制。</p><p>时间戳实现</p><p>function throttle(func, delay) {<br>let lastTime &#x3D; 0;<br>return function (…args) {<br>const now &#x3D; Date.now();<br>&#x2F;&#x2F;第一次立即执行,后续 lastTime &#x3D; now,等待每次间隔达到 delay 执行<br>if (now - lastTime &gt;&#x3D; delay) {<br>func.apply(this, args);<br>lastTime &#x3D; now;<br>}<br>};<br>}<br>function MyThrottle(fn, delay, immediate &#x3D; true) {<br>let startTime &#x3D; 0<br>const _throttle &#x3D; function (…arys) {<br>const nowTime &#x3D; Date.now();<br>&#x2F;&#x2F;第一次 startTime 和 now 相等,不立即执行<br>if (!immediate &amp;&amp; startTime &#x3D;&#x3D;&#x3D; 0) startTime &#x3D; nowTime<br>if (nowTime - startTime &gt;&#x3D; delay) {<br>fn.apply(this, arys)<br>startTime &#x3D; nowTime<br>}<br>}<br>return _throttle<br>}</p><pre><code class="hljs">const inputEle = document.querySelector(&#39;input&#39;)inputEle.oninput = MyThrottle(function () &#123;  console.log(this.value);&#125;, 1000, false)function MyThrottle(fn, delay, leading = true, trailing = false) &#123;  let startTime = 0  let timer = null  const _throttle = function (...arys) &#123;    const nowTime = Date.now();    //定时器判断是否尾部执行    //第一次startTime和now相等,不立即执行    if (!leading &amp;&amp; startTime === 0) startTime = nowTime    if (nowTime - startTime &gt;= delay) &#123;      //极限情况,在这里执行完,清除定时器,防止下面重复执行      if (timer) &#123;        clearTimeout(timer)        timer = null      &#125;      fn.apply(this, arys)      startTime = nowTime      //满足条件结束本次函数,nowTime - startTime不能达到delay,进入trailing的定时器判断      return    &#125;    //存在误差,大多执行下面函数    if (trailing &amp;&amp; !timer) &#123;      //在下次该执行函数的时间执行函数      timer = setTimeout(() =&gt; &#123;        fn.apply(this, arys)        // startTime = nowTime 不能使用nowTime作为下次开始,保存的为上次定义的nowTime,不是最新时间        startTime=Date.now()        timer = null      &#125;, delay-(nowTime-startTime))    &#125;  &#125;  return _throttle&#125;const inputEle = document.querySelector(&#39;input&#39;)inputEle.oninput = MyThrottle(function () &#123;  console.log(this.value);&#125;, 3000, false, true)</code></pre><p>function MyThrottle(fn, delay, leading &#x3D; true, trailing &#x3D; false) {<br>let startTime &#x3D; 0<br>let timer &#x3D; null<br>&#x2F;&#x2F;如果想获取返回值,使用回调函数,或者返回 promise 对象<br>const _throttle &#x3D; function (…arys) {<br>const nowTime &#x3D; Date.now();<br>&#x2F;&#x2F;定时器判断是否尾部执行<br>&#x2F;&#x2F;第一次 startTime 和 now 相等,不立即执行<br>if (!leading &amp;&amp; startTime &#x3D;&#x3D;&#x3D; 0) startTime &#x3D; nowTime<br>if (nowTime - startTime &gt;&#x3D; delay) {<br>&#x2F;&#x2F;极限情况,在这里执行完,清除定时器,防止下面重复执行<br>if (timer) {<br>clearTimeout(timer)<br>timer &#x3D; null<br>}<br>fn.apply(this, arys)<br>startTime &#x3D; nowTime<br>&#x2F;&#x2F;满足条件结束本次函数,nowTime - startTime 不能达到 delay,进入 trailing 的定时器判断<br>return<br>}<br>&#x2F;&#x2F;存在误差,大多执行下面函数<br>if (trailing &amp;&amp; !timer) {<br>&#x2F;&#x2F;在下次该执行函数的时间执行函数<br>timer &#x3D; setTimeout(() &#x3D;&gt; {<br>fn.apply(this, arys)<br>&#x2F;&#x2F; startTime &#x3D; nowTime 不能使用 nowTime 作为下次开始,保存的为上次定义的 nowTime,不是最新时间<br>startTime&#x3D;Date.now()<br>timer &#x3D; null<br>}, delay-(nowTime-startTime))<br>}<br>}<br>_throttle.cancel &#x3D; function() {<br>if (timer) clearTimeout(timer)<br>startTime &#x3D; 0<br>timer &#x3D; null<br>}<br>return _throttle<br>}</p><pre><code class="hljs">const inputEle = document.querySelector(&#39;input&#39;)const buttonEle=document.querySelector(&#39;button&#39;)const MyThrottleFn=MyThrottle(function () &#123;  console.log(this.value);&#125;, 3000, false, true)inputEle.oninput = MyThrottleFnbuttonEle.onclick=function()&#123;  MyThrottleFn.cancel()&#125;</code></pre><p>定时器实现</p><p>function throttle(func, delay) {<br>let timer &#x3D; null;<br>return function (…args) {<br>&#x2F;&#x2F;定时器状态为 null 重新注册定时器<br>if (!timer) {<br>timer &#x3D; setTimeout(() &#x3D;&gt; {<br>func.apply(this, args);<br>&#x2F;&#x2F;当到达节流时间将 timer 赋值为 null,才能开启下次定时<br>timer &#x3D; null;<br>}, delay);<br>}<br>};<br>}<br>两种实现的区别</p><p>时间戳版：立即执行，停止触发后不再执行最后一次。</p><p>定时器版：延迟执行，停止触发后会执行最后一次。</p><p>应用场景</p><p>页面滚动事件（如无限加载）。</p><p>鼠标移动事件（如拖拽）。</p><p>高频点击按钮（如提交表单）。</p><p>对比</p><p>特性 防抖（Debounce） 节流（Throttle）<br>执行时机 事件停止触发后执行 固定时间间隔执行<br>是否保留最后一次 是（重新计时） 取决于实现方式<br>适用场景 输入联想、窗口调整 滚动事件、高频点击</p><p>事件总线</p><p>事件总线是一种基于发布-订阅模式的通信机制，用于组件或模块间的解耦</p><p>核心概念</p><p>发布-订阅模型：发布者（Publisher）触发事件，订阅者（Subscriber）监听并响应事件，二者通过事件总线通信，无需直接依赖。</p><p>事件中心：统一管理事件与回调函数，提供注册、触发、销毁等能力。</p><p>核心 API</p><p>on(event, callback)：订阅事件。</p><p>once(event, callback)：订阅事件（仅触发一次）。</p><p>emit(event, …args)：触发事件，传递参数。</p><p>off(event, callback)：取消事件订阅。</p><p>实现原理</p><p>事件存储：使用对象或 <font style="color:rgb(64, 64, 64);">Map</font> 存储事件名与回调函数列表的映射。</p><p>class EventBus {<br>constructor() {<br>this.events &#x3D; new Map(); &#x2F;&#x2F; { eventName: [callback1, callback2] }<br>}<br>}<br>订阅事件：将回调添加到对应事件的数组中。</p><p>on(event, callback) {<br>if (!this.events.has(event)) {<br>this.events.set(event, []);<br>}<br>this.events.get(event).push(callback);<br>}<br>触发事件：遍历执行事件对应的所有回调。</p><p>emit(event, …args) {<br>const callbacks &#x3D; this.events.get(event) || [];<br>callbacks.forEach(cb &#x3D;&gt; cb(…args)); &#x2F;&#x2F; 注意复制数组避免循环时修改<br>}<br>一次性订阅：包装回调，执行后自动取消。</p><p>once(event, callback) {<br>const wrapper &#x3D; (…args) &#x3D;&gt; {<br>callback(…args);<br>this.off(event, wrapper);<br>};<br>this.on(event, wrapper);<br>}<br>取消订阅：从回调数组中移除指定函数。</p><p>off(event, callback) {<br>const callbacks &#x3D; this.events.get(event) || [];<br>const filtered &#x3D; callbacks.filter(cb &#x3D;&gt; cb !&#x3D;&#x3D; callback);<br>this.events.set(event, filtered);<br>}<br>注意事项</p><p>内存泄漏：未及时调用 <font style="color:rgb(64, 64, 64);">off</font> 可能导致回调堆积。</p><p>命名冲突：全局事件名需统一管理（如使用前缀）。</p><p>执行顺序：多个回调按注册顺序执行，但不应依赖此顺序。</p><p>错误处理：使用 <font style="color:rgb(64, 64, 64);">try-catch</font> 避免单个回调崩溃影响整体。</p><p>应用场景</p><p>组件通信：Vue&#x2F;React 中非父子组件通信。</p><p>模块解耦：插件间通信或异步任务完成通知。</p><p>简易状态管理：小型项目中替代 Redux&#x2F;Vuex。</p><p>常见库与框架</p><p>Node.js：内置 <font style="color:rgb(64, 64, 64);">EventEmitter</font> 模块。</p><p>Vue：利用 <font style="color:rgb(64, 64, 64);">Vue.prototype.$bus &#x3D; new Vue()</font> 实现。</p><p>第三方库：<font style="color:rgb(64, 64, 64);">mitt</font>（轻量）、<font style="color:rgb(64, 64, 64);">PubSubJS</font>（跨平台）。</p><p>封装简易事件总线</p><p>class MyEventBus {<br>constructor() {<br>this.events &#x3D; new Map()<br>}<br>&#x2F;&#x2F;订阅函数<br>on(event, callback) {<br>&#x2F;&#x2F;第一次执行,初始化为{event,[]}的 Map 结构<br>if (!this.events.has(event)) {<br>this.events.set(event, []);<br>}<br>&#x2F;&#x2F;每次订阅,添加到对应保存事件的[]中<br>this.events.get(event).push(callback);<br>}<br>&#x2F;&#x2F;触发函数<br>emit(event, …args) {<br>&#x2F;&#x2F;取出事件总线中对应的[],依次执行<br>const callbacks &#x3D; this.events.get(event) || [];<br>callbacks.forEach(cb &#x3D;&gt; cb(…args)); &#x2F;&#x2F; 注意复制数组避免循环时修改<br>}<br>&#x2F;&#x2F;仅订阅一次<br>once(event, callback) {<br>&#x2F;&#x2F;创建包装函数,执行代码体,执行完后,执行 off 函数,取消订阅<br>const wrapper &#x3D; (…args) &#x3D;&gt; {<br>callback(…args);<br>this.off(event, wrapper);<br>};<br>&#x2F;&#x2F;进行订阅<br>this.on(event, wrapper);<br>}<br>&#x2F;&#x2F;取消订阅<br>off(event, callback) {<br>const callbacks &#x3D; this.events.get(event) || [];<br>&#x2F;&#x2F;filter 过滤出要取消订阅的 callback 函数,将得到的数组重新设置 set(event, filtered)<br>const filtered &#x3D; callbacks.filter(cb &#x3D;&gt; cb !&#x3D;&#x3D; callback);<br>this.events.set(event, filtered);<br>}<br>}</p><pre><code class="hljs">const myEventBus = new MyEventBus()myEventBus.on(&#39;myClick&#39;, () =&gt; &#123;  console.log(&#39;myClick,001&#39;);&#125;)myEventBus.on(&#39;myClick&#39;, () =&gt; &#123;  console.log(&#39;myClick,002&#39;);&#125;)myEventBus.on(&#39;youClick&#39;, () =&gt; &#123;  console.log(&#39;youClick,001&#39;);&#125;)const buttonEle = document.querySelector(&#39;button&#39;)buttonEle.onclick = () =&gt; &#123;  console.log(&#39;自己监听&#39;);  myEventBus.emit(&#39;myClick&#39;)&#125;</code></pre><p>网络请求</p><p>前端网络</p><p>一、HTTP 基础</p><p>请求方法</p><p><font style="color:rgb(64, 64, 64);">GET</font>：获取资源（幂等，参数在 URL 中）</p><p><font style="color:rgb(64, 64, 64);">POST</font>：提交数据（非幂等，参数在请求体）</p><p><font style="color:rgb(64, 64, 64);">PUT</font>：更新资源（幂等）</p><p><font style="color:rgb(64, 64, 64);">DELETE</font>：删除资源（幂等）</p><p><font style="color:rgb(64, 64, 64);">PATCH</font>：部分更新资源</p><p>状态码</p><p><font style="color:rgb(64, 64, 64);">200 OK</font>：请求成功</p><p><font style="color:rgb(64, 64, 64);">301&#x2F;302</font>：重定向</p><p><font style="color:rgb(64, 64, 64);">400 Bad Request</font>：客户端错误</p><p><font style="color:rgb(64, 64, 64);">401 Unauthorized</font>：未认证</p><p><font style="color:rgb(64, 64, 64);">403 Forbidden</font>：无权限</p><p><font style="color:rgb(64, 64, 64);">404 Not Found</font>：资源不存在</p><p><font style="color:rgb(64, 64, 64);">500 Internal Server Error</font>：服务端错误</p><p>Header 常见字段</p><p><font style="color:rgb(64, 64, 64);">Content-Type</font>：数据类型（如 <font style="color:rgb(64, 64, 64);">application&#x2F;json</font>）</p><p><font style="color:rgb(64, 64, 64);">Authorization</font>：身份验证（如 <font style="color:rgb(64, 64, 64);">Bearer Token</font>）</p><p><font style="color:rgb(64, 64, 64);">Cache-Control</font>：缓存策略（如 <font style="color:rgb(64, 64, 64);">max-age&#x3D;3600</font>）</p><p><font style="color:rgb(64, 64, 64);">Accept-Encoding</font>：压缩方式（如 <font style="color:rgb(64, 64, 64);">gzip</font>）</p><p>二、AJAX（Asynchronous JavaScript and XML）</p><p>核心对象 <strong><font style="color:rgb(64, 64, 64);">XMLHttpRequest</font></strong></p><p>const xhr &#x3D; new XMLHttpRequest();<br>xhr.open(‘GET’, ‘<a href="https://api.example.com/data">https://api.example.com/data</a>‘);<br>&#x2F;&#x2F;监听状态的改变<br>xhr.onreadystatechange &#x3D; function() {<br>if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) {<br>console.log(JSON.parse(xhr.responseText));<br>}<br>};<br>xhr.send();<br>&#x2F;&#x2F; function myAjax({<br>&#x2F;&#x2F; url,<br>&#x2F;&#x2F; method &#x3D; ‘get’,<br>&#x2F;&#x2F; timeout &#x3D; 5000,<br>&#x2F;&#x2F; headers &#x3D; {},<br>&#x2F;&#x2F; data &#x3D; {},<br>&#x2F;&#x2F; success,<br>&#x2F;&#x2F; failure<br>&#x2F;&#x2F; } &#x3D; {}) {<br>&#x2F;&#x2F; const xhr &#x3D; new XMLHttpRequest()<br>&#x2F;&#x2F; xhr.onload &#x3D; function () {<br>&#x2F;&#x2F; &#x2F;&#x2F;使用回调函数获取响应结果<br>&#x2F;&#x2F; if (xhr.status &#x3D;&#x3D; 200) {<br>&#x2F;&#x2F; success &amp;&amp; success(xhr.response)<br>&#x2F;&#x2F; } else {<br>&#x2F;&#x2F; failure &amp;&amp; failure({ status: xhr.status, message: xhr.statusText })<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; xhr.responseType &#x3D; ‘json’<br>&#x2F;&#x2F; if (method.toUpperCase() &#x3D;&#x3D;&#x3D; ‘GET’) {<br>&#x2F;&#x2F; const queryStrings &#x3D; []<br>&#x2F;&#x2F; for (const key in data) {<br>&#x2F;&#x2F; queryStrings.push(<code>$&#123;key&#125;=$&#123;data[key]&#125;</code>)<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; url &#x3D; url + ‘?’ + queryStrings.join(‘&amp;’)<br>&#x2F;&#x2F; xhr.open(method, url)<br>&#x2F;&#x2F; xhr.send()<br>&#x2F;&#x2F; } else {<br>&#x2F;&#x2F; xhr.open(method, url)<br>&#x2F;&#x2F; xhr.setRequestHeader(‘Content-type’, ‘application&#x2F;json’)<br>&#x2F;&#x2F; xhr.send(JSON.stringify(data))<br>&#x2F;&#x2F; }<br>&#x2F;&#x2F; }</p><pre><code class="hljs">function myAjax(&#123;  url,  method = &#39;get&#39;,  timeout = 5000,  headers = &#123;&#125;,  data = &#123;&#125;,&#125; = &#123;&#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    //使用Promise获取响应结果    const xhr = new XMLHttpRequest()    xhr.onload = function () &#123;      if (xhr.status == 200) &#123;        resolve(xhr.response)      &#125; else &#123;        reject(&#123; status: xhr.status, message: xhr.statusText &#125;)      &#125;    &#125;    xhr.responseType = &#39;json&#39;    xhr.timeout = timeout    if (method.toUpperCase() === &#39;GET&#39;) &#123;      const queryStrings = []      for (const key in data) &#123;        queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)      &#125;      url = url + &#39;?&#39; + queryStrings.join(&#39;&amp;&#39;)      xhr.open(method, url)      xhr.send()    &#125; else &#123;      xhr.open(method, url)      xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application/json&#39;)      xhr.send(JSON.stringify(data))    &#125;  &#125;)&#125;myAjax(&#123;  url: &#39;your url&#39;,  method: &#39;get&#39;,  data: &#123;    name: &#39;Mir&#39;,    age: 18  &#125;&#125;)</code></pre><p>const uploadBtn &#x3D; document.querySelector(“.upload”)<br>uploadBtn.onclick &#x3D; function() {<br>&#x2F;&#x2F; 1.创建对象<br>const xhr &#x3D; new XMLHttpRequest()</p><pre><code class="hljs">  // 2.监听结果  xhr.onload = function() &#123;    console.log(xhr.response)  &#125;  xhr.onprogress = function(event) &#123;    console.log(event)  &#125;  xhr.responseType = &quot;json&quot;  xhr.open(&quot;post&quot;, &quot;http://123.207.32.32:1888/02_param/upload&quot;)  const fileEl = document.querySelector(&quot;.file&quot;)  const file = fileEl.files[0]  const formData = new FormData()  formData.append(&quot;avatar&quot;, file)  xhr.send(formData)&#125;</code></pre><p>优缺点</p><ul><li><font style="color:rgb(64, 64, 64);">优点：兼容性好，支持老浏览器。</font></li><li><font style="color:rgb(64, 64, 64);">缺点：回调地狱，API 设计繁琐。</font></li></ul><ol><li>基本用法</li></ol><p>创建对象：<font style="color:rgb(64, 64, 64);">const xhr &#x3D; new XMLHttpRequest();</font></p><p>初始化请求：<font style="color:rgb(64, 64, 64);">xhr.open(method, url, async);</font></p><p><font style="color:rgb(64, 64, 64);">method</font>：请求方法（<font style="color:rgb(64, 64, 64);">GET</font>、<font style="color:rgb(64, 64, 64);">POST</font> 等）。</p><p><font style="color:rgb(64, 64, 64);">url</font>：请求地址。</p><p><font style="color:rgb(64, 64, 64);">async</font>：是否异步（默认 <font style="color:rgb(64, 64, 64);">true</font>）。</p><p>发送请求：<font style="color:rgb(64, 64, 64);">xhr.send(body);</font></p><p><font style="color:rgb(64, 64, 64);">body</font>：POST 请求的数据（如 <font style="color:rgb(64, 64, 64);">FormData</font> 或字符串）。</p><ol start="2"><li>事件监听</li></ol><p>响应完成：<font style="color:rgb(64, 64, 64);">xhr.onload &#x3D; () &#x3D;&gt; { … }</font></p><p>错误处理：<font style="color:rgb(64, 64, 64);">xhr.onerror &#x3D; () &#x3D;&gt; { … }</font></p><p>进度监控：<font style="color:rgb(64, 64, 64);">xhr.onprogress &#x3D; (event) &#x3D;&gt; { … }</font>（上传&#x2F;下载进度）。</p><p>状态变化：<font style="color:rgb(64, 64, 64);">xhr.onreadystatechange</font>（通过 <font style="color:rgb(64, 64, 64);">xhr.readyState</font> 跟踪状态）。</p><ol start="3"><li>状态与响应</li></ol><p><strong><font style="color:rgb(64, 64, 64);">readyState</font></strong> <strong>值</strong>：</p><p><font style="color:rgb(64, 64, 64);">0</font>：未初始化(代理被创建,未调用 open())</p><p><font style="color:rgb(64, 64, 64);">1</font>：已打开连接(open 被调用)</p><p><font style="color:rgb(64, 64, 64);">2</font>：已接收请求头(send 被调用)</p><p><font style="color:rgb(64, 64, 64);">3</font>：正在接收响应体(loading)</p><p><font style="color:rgb(64, 64, 64);">4</font>：请求完成</p><p>状态码：<font style="color:rgb(64, 64, 64);">xhr.status</font>（如 200、404）。</p><p>响应数据：</p><p><font style="color:rgb(64, 64, 64);">xhr.responseText</font>：文本格式。</p><p><font style="color:rgb(64, 64, 64);">xhr.response</font>：根据 <font style="color:rgb(64, 64, 64);">responseType</font> 解析（如 <font style="color:rgb(64, 64, 64);">json</font>、<font style="color:rgb(64, 64, 64);">blob</font>）。</p><ol start="4"><li>其他特性</li></ol><p>设置请求头：<font style="color:rgb(64, 64, 64);">xhr.setRequestHeader(‘Content-Type’, ‘application&#x2F;json’);</font></p><p>超时设置：<font style="color:rgb(64, 64, 64);">xhr.timeout &#x3D; 5000;</font>，通过 <font style="color:rgb(64, 64, 64);">xhr.ontimeout</font> 处理。</p><p>中止请求：<font style="color:rgb(64, 64, 64);">xhr.abort();</font></p><p>三、Fetch API</p><p>基于 Promise 的现代方法</p><p>fetch(‘<a href="https://api.example.com/data">https://api.example.com/data</a>‘)<br>.then(response &#x3D;&gt; {<br>if (!response.ok) throw new Error(‘Network error’);<br>return response.json();<br>})<br>.then(data &#x3D;&gt; console.log(data))<br>.catch(error &#x3D;&gt; console.error(error));<br>const uploadBtn &#x3D; document.querySelector(“.upload”)<br>uploadBtn.onclick &#x3D; async function() {<br>const fileEl &#x3D; document.querySelector(“.file”)<br>const file &#x3D; fileEl.files[0]</p><pre><code class="hljs">  const formData = new FormData()  formData.append(&quot;avatar&quot;, file)  // 发送fetch请求  const response = await fetch(&quot;http://123.207.32.32:1888/02_param/upload&quot;, &#123;    method: &quot;post&quot;,    body: formData  &#125;)  const res = await response.json()  console.log(&quot;res:&quot;, res)&#125;</code></pre><p>关键特性</p><ul><li><font style="color:rgb(64, 64, 64);">默认不携带 Cookie（需设置</font><font style="color:rgb(64, 64, 64);"> </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;credentials: &#39;include&#39;&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);">）</font></li><li><font style="color:rgb(64, 64, 64);">支持流式数据处理（如</font><font style="color:rgb(64, 64, 64);"> </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;response.body&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);">）</font></li><li><font style="color:rgb(64, 64, 64);">可通过</font><font style="color:rgb(64, 64, 64);"> </font><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;AbortController&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">中止请求。</font></li></ul><ol><li>基本用法</li></ol><p>发起请求：<font style="color:rgb(64, 64, 64);">fetch(url, options)</font></p><ul><li><code>&lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;options&lt;/font&gt;</code><font style="color:rgb(64, 64, 64);">：配置对象（方法、头、体等）。</font><br>fetch(url, {<br>method: ‘POST’,<br>headers: { ‘Content-Type’: ‘application&#x2F;json’ },<br>body: JSON.stringify(data),<br>});<br>返回 Promise：处理响应或错误。</li></ul><ol start="2"><li>响应处理</li></ol><p>解析数据：</p><p><font style="color:rgb(64, 64, 64);">response.json()</font>：解析为 JS ON。</p><p><font style="color:rgb(64, 64, 64);">response.text()</font>：解析为文本。</p><p><font style="color:rgb(64, 64, 64);">response.blob()</font>：解析为二进制数据。</p><p>状态检查：</p><p>if (response.ok) { &#x2F;&#x2F; 状态码 200-299<br>&#x2F;&#x2F; 处理成功<br>} 3. 错误处理</p><p>网络错误：自动触发 <font style="color:rgb(64, 64, 64);">catch</font>。</p><p>HTTP 错误（如 404）：需手动检查 <font style="color:rgb(64, 64, 64);">response.ok</font>。</p><ol start="4"><li>高级功能</li></ol><p>中止请求：使用 <font style="color:rgb(64, 64, 64);">AbortController</font>。</p><p>const controller &#x3D; new AbortController();<br>fetch(url, { signal: controller.signal });<br>controller.abort(); &#x2F;&#x2F; 中止请求<br>跨域请求：默认不携带凭据，需设置 <font style="color:rgb(64, 64, 64);">credentials: ‘include’</font>。</p><p>四、Axios（第三方库）</p><p>功能丰富的 HTTP 客户端</p><p>axios.get(‘<a href="https://api.example.com/data">https://api.example.com/data</a>‘)<br>.then(response &#x3D;&gt; console.log(response.data))<br>.catch(error &#x3D;&gt; console.error(error));</p><p>&#x2F;&#x2F; POST 请求示例<br>axios.post(‘&#x2F;api&#x2F;post’, { data: ‘value’ }, {<br>headers: { ‘X-Custom-Header’: ‘value’ }<br>});<br>核心优势</p><p>自动转换 JSON 数据。</p><p>拦截器（请求&#x2F;响应拦截）。</p><p>客户端防御 XSRF。</p><p>取消请求（通过 <font style="color:rgb(64, 64, 64);">CancelToken</font> 或 <font style="color:rgb(64, 64, 64);">AbortController</font>）。</p><p>五、跨域问题（CORS）</p><p>同源策略<br>协议、域名、端口一致才允许请求。</p><p>解决方案</p><p>CORS（跨域资源共享）<br>服务端设置响应头（如 <font style="color:rgb(64, 64, 64);">Access-Control-Allow-Origin: *</font>）。</p><p>JSONP<br>利用 <font style="color:rgb(64, 64, 64);"><script></font> 标签跨域（仅支持 GET）。</p><p>function handleResponse(data) { console.log(data); }<br>const script = document.createElement('script');<br>script.src = '<a href="https://api.example.com/data?callback=handleResponse">https://api.example.com/data?callback=handleResponse</a>';<br>document.body.appendChild(script);</p><ul><li><strong><font style="color:rgb(64, 64, 64);">代理服务器</font></strong><font style="color:rgb(64, 64, 64);"><br></font>通过后端或工具（如 Webpack DevServer）转发请求。</li></ul><p>总结</p><p>XHR vs Fetch 对比</p><p>特性 XHR Fetch<br>语法 回调/事件驱动，较冗长 Promise 链式调用，更简洁<br>错误处理 需监听 <font style="color:rgb(64, 64, 64);">onerror</font><br/>和状态码 网络错误触发 <font style="color:rgb(64, 64, 64);">catch</font><br/>，HTTP 错误需手动检查<br>中止请求 <font style="color:rgb(64, 64, 64);">xhr.abort()</font> <font style="color:rgb(64, 64, 64);">AbortController</font><br>进度监控 支持（<font style="color:rgb(64, 64, 64);">onprogress</font><br/>） 不直接支持，需通过 Stream 处理<br>默认携带 Cookie 是 需设置 <font style="color:rgb(64, 64, 64);">credentials: 'include'</font><br>兼容性 广泛支持（包括旧浏览器） 不支持 IE，需 polyfill<br>传统 AJAX 适合兼容性要求高的场景。</p><p>Fetch API 是现代化、轻量的选择。</p><p>Axios 提供更全面的功能和企业级支持。</p><p>跨域问题 需服务端配合或使用代理。</p><p>WebSocket 实现实时双向通信。</p></script></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2025/02/25/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/02/25/JavaScript%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="j6qnk">Js的定义</h4><p><strong>维基百科对Js的定义:</strong></p><p>JavaScript(通常缩写为JS)是一种<font style="color:#DF2A3F;">高级的、解释型</font>的编程语言;JavaScript是一门基于<font style="color:#DF2A3F;">原型、头等函数</font>的语言，是<font style="color:#DF2A3F;">一门多范式</font>的语言，它支持<font style="color:#DF2A3F;">面向对象程序设计，指令式编程，以及函数式编程</font></p><h4 id="mnrlW">Js基本使用</h4><h5 id="OLCW7">noScript元素</h5><p><strong>如果运行的浏览器不支持JavaScript,那么我们如何给用户更好的提示呢?</strong></p><p>针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案,最终，<noscript>元素出现，被用于给不支持JavaScript 的浏览器提供替代内容;</noscript></p><p><code>&lt;noscript&gt;不支持JavaScript,请切换浏览器&lt;/noscript&gt;</code></p><h5 id="do4YF">Js注释</h5><ul><li>单行注释 &#x2F;&#x2F;单行注释</li><li>多行注释  &#x2F;*多行注释  *&#x2F;</li><li>文档注释(VSCode中需要在单独的JavaScript文件中编写才有效)</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/** </span><br><span class="hljs-comment">*某人年龄的函数</span><br><span class="hljs-comment">*@param &#123;string&#125; name 姓名</span><br><span class="hljs-comment">*@param &#123;number&#125; age 年龄</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">peopleAge</span>(name,age)&#123;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Uhkrh">==运算符和===运算符</h5><h6 id="GVeFa">==运算符</h6><p><font style="color:rgb(85, 85, 85);">&#x3D;&#x3D;运算符检查其两个操作对象是否相等，返回一个布尔值结果。当比较双方数据类型不同时，它会尝试转换不同类型的操作数，并进行比较</font></p><p><strong><font style="color:rgb(85, 85, 85);">类型相同时的特殊情况</font></strong></p><ul><li><font style="color:rgb(85, 85, 85);">对象（Object）：仅当两个操作数引用同一个对象时返回 true。</font></li><li><font style="color:rgb(85, 85, 85);">数字（Number）：如果两个操作数的值相同，则返回 true。+0 和 -0 被视为相同的值。如果任何一个操作数是 NaN，返回 false；所以，NaN 永远不等于 NaN。</font></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">NaN</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">NaN</span>;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == b); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><font style="color:rgb(85, 85, 85);">符号（Symbol）：仅当两个操作数引用相同的符号时返回 true。</font></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">null</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">undefined</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">c</span> = <span class="hljs-selector-tag">null</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">d</span> = <span class="hljs-selector-tag">undefined</span>;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == b); <span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == c); <span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(b == d); <span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == d); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>类型不相同时</strong></p><ul><li><font style="color:rgb(85, 85, 85);">如果其中一个操作数为 null 或 undefined，另一个操作数也必须为 null 或 undefined 以返回 true。否则返回 false。</font></li><li><font style="color:rgb(85, 85, 85);">如果其中一个操作数是对象，另一个是原始值，则将对象转换为原始值(ToPrimitive)。</font><br>* <font style="color:rgb(85, 85, 85);">在这一步，两个操作数都被转换为原始值（字符串、数字、布尔值、符号和大整型中的一个）。剩余的转换将分情况完成。</font><br>* <font style="color:rgb(85, 85, 85);">如果是相同的类型，使用步骤 1 进行比较。</font><br>* <font style="color:rgb(85, 85, 85);">如果其中一个操作数是符号(Symbol)而另一个不是，返回 false。</font><br>* <font style="color:rgb(85, 85, 85);">如果其中一个操作数是布尔值而另一个不是，则将布尔值转换为数字：</font><font style="color:rgb(85, 85, 85);">true 转换为 1，false 转换为 0</font><font style="color:rgb(85, 85, 85);">。然后再次对两个操作数进行宽松比较。</font><br>* <font style="color:rgb(85, 85, 85);">数字与字符串：</font><font style="color:rgb(85, 85, 85);">将字符串转换为数字</font><font style="color:rgb(85, 85, 85);">。转换失败将导致 NaN，这将保证相等比较为 false。</font><br>* <font style="color:rgb(85, 85, 85);">数字与大整型：按数值进行比较。如果数字的值为 ±∞ 或 NaN，返回 false。</font><br>* <font style="color:rgb(85, 85, 85);">字符串与大整型：使用与 BigInt() 构造函数相同的算法将字符串转换为大整型数。如果转换失败，返回 false。</font></li></ul><h6 id="Az7dI">===运算符</h6><p><font style="color:rgb(85, 85, 85);">&#x3D;&#x3D;&#x3D;运算符与 &#x3D;&#x3D; 运算符之间最显著的区别是，严格相等运算符不尝试类型转换。相反，严格相等运算符总是认为不同类型的操作数是不同的，即只要类型不同进行 <code>===</code> 操作时，结果即为 <code>false</code>。</font></p><p><strong><font style="color:rgb(85, 85, 85);">&#x3D;&#x3D;&#x3D;比较规则</font></strong></p><ul><li><font style="color:rgb(85, 85, 85);">如果操作数的类型不同，则返回 false。</font></li><li><font style="color:rgb(85, 85, 85);">如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。</font></li><li><font style="color:rgb(85, 85, 85);">如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。</font></li><li><font style="color:rgb(85, 85, 85);">如果两个操作数有任意一个为 NaN，返回 false。</font></li><li><font style="color:rgb(85, 85, 85);">否则，比较两个操作数的值</font></li></ul><h5 id="uVfRs">作用域</h5><p><strong>在ES5之前没有块级作用域的概念,函数可以定义自己的作用域</strong></p><ul><li>全局作用域,全局可以使用</li><li>使用var定义的变量,无块级作用域(es5之前),<font style="color:rgba(0, 0, 0, 0.75);">创建的变量都会作为 </font><strong><font style="color:rgba(0, 0, 0, 0.75);">window 对象</font></strong><font style="color:rgba(0, 0, 0, 0.75);">的属性保存</font></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-comment">//代码块</span><br>    &#123;<br>        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br>        <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">2</span><br>        <span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">c</span> = <span class="hljs-number">3</span><br>    &#125;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a);<span class="hljs-comment">//1</span><br><span class="hljs-comment">//es6的let,const声明的变量存在作用域</span><br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(b);<span class="hljs-comment">//is not defined</span><br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(c);<span class="hljs-comment">//is not defined</span><br><br></code></pre></td></tr></table></figure><ul><li><font style="color:rgb(77, 77, 77);">使用 var 关键字声明的</font><strong><font style="color:rgb(77, 77, 77);">变量</font></strong><font style="color:rgb(77, 77, 77);">（ 比如 </font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;var a = 1&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">），</font><strong><font style="color:rgb(77, 77, 77);">会在所有的代码执行之前被声明</font></strong><font style="color:rgb(77, 77, 77);">（但是不会赋值）。</font></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a);<span class="hljs-comment">//undefined</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = &#x27;<span class="hljs-selector-tag">a</span>&#x27;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a);<span class="hljs-comment">//a</span><br></code></pre></td></tr></table></figure><ul><li>for循环没有自己的作用域</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">foo</span>=&#x27;<span class="hljs-selector-tag">foo</span>&#x27;<br>  &#125;<br>  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(foo);<span class="hljs-comment">//foo</span><br>  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(i); <span class="hljs-comment">//3</span><br>  <br></code></pre></td></tr></table></figure><ul><li>function函数存在自己的作用域</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">foo</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span>=&#x27;<span class="hljs-selector-tag">aa</span>&#x27;<br>&#125;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a); <span class="hljs-comment">//a is not defined</span><br></code></pre></td></tr></table></figure><p><strong>作用域的上下关系</strong></p><p><font style="color:rgb(77, 77, 77);">当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（</font><strong><font style="color:rgb(77, 77, 77);">就近原则</font></strong><font style="color:rgb(77, 77, 77);">）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错 ReferenceError。</font></p><p><strong><font style="color:rgb(79, 79, 79);">函数的声明提前（函数提升）</font></strong></p><p><font style="color:rgb(77, 77, 77);">使用</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;函数声明&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">的形式创建的函数</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;function foo()&#123;&#125;&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">，</font><strong><font style="color:rgb(77, 77, 77);">会被声明提前</font></strong><font style="color:rgb(77, 77, 77);">。使用</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;函数表达式&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">创建的函数</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;var foo = function()&#123;&#125;&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">，</font><strong><font style="color:rgb(77, 77, 77);">不会被声明提前</font></strong><font style="color:rgb(77, 77, 77);">，所以不能在声明前调用。 </font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo1</span>() <span class="hljs-comment">//foo1</span><br><span class="hljs-comment">// Uncaught TypeError: foo2 is not a function,由于var声明,被提前声明</span><br><span class="hljs-comment">// 所以foo2是一个已声明未赋值的变量</span><br><span class="hljs-title function_">foo2</span>() <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo2);<span class="hljs-comment">//undefined</span><br><span class="hljs-comment">//Uncaught ReferenceError: </span><br><span class="hljs-comment">//Cannot access &#x27;foo3&#x27; before initialization</span><br><span class="hljs-comment">//但该变量在被访问时尚未完成初始化。</span><br><span class="hljs-comment">//这通常发生在使用 let 或 const 声明的变量上，</span><br><span class="hljs-comment">//因为它们具有块级作用域和暂时性死区（Temporal Dead Zone）的特性</span><br><span class="hljs-title function_">foo3</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br>&#125;<br>  <span class="hljs-keyword">const</span> foo3=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo3&#x27;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(79, 79, 79);"><br></font>****<font style="color:rgb(79, 79, 79);"> </font></strong></p><h5 id="Zifa1">对象</h5><h6 id="MQfbo">Objerct.keys</h6><p><strong>Objerct.keys拿到对象的键的数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">var</span> people=&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;2&#x27;</span><br>    &#125;<br><span class="hljs-comment">//for in 遍历对象的每一项</span><br>    <span class="hljs-comment">// for (const key in people) &#123;</span><br>    <span class="hljs-comment">//   console.log(`key:$&#123;key&#125; value:$&#123;people[key]&#125;`);</span><br>    <span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//Object.keys拿到对象中键的集合,依次进行遍历</span><br>    <span class="hljs-keyword">var</span> obj=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(people)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; obj.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> key = obj[i];<br>        <span class="hljs-keyword">const</span> val=people[key]<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`key:<span class="hljs-subst">$&#123;key&#125;</span> value:<span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="QEpue">包装类型</h6><p>JavaScript的原始类型并非对象类型，所以从理论上来说，它们是没有办法获取属性或者调用方法的,JavaScript为了可以使其可以<strong>获取属性和调用方法</strong>对其封装了对应的<strong>包装类型</strong></p><ul><li>根据原始值，创建一个原始类型对应的包装类型对象</li><li>调用对应的属性或者方法，返回一个新的值;</li><li>创建的包装类对象被销毁;</li></ul><p>通常JavaScript引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用</p><h4 id="c12Ov">DOM</h4><p><strong>DOM</strong>:<strong>文档对象模型</strong>(DocumentObject Model),简称 DOM，将页面所有的内容表示为可以修改的对象</p><h5 id="HQVap">DOM类型继承图</h5><p><img src="1737208199582-06e4f4a9-f4f0-4c40-a8e5-0c8627f8d7ef.png"></p><p>:::info<br>在 DOM 的继承体系中，<code>Document</code>和<code>Element</code>看似 “平级” 继承自<code>Node</code>，这和直观理解有所不同，原因如下：</p><p><strong>从 DOM 规范设计角度</strong></p><p>DOM 将文档结构抽象为树形结构，<code>Node</code>是所有节点的抽象基类，它定义了节点共有的属性（如<code>nodeName</code>、<code>nodeValue</code>等）和方法（如<code>appendChild</code>等） 。<code>Document</code>和<code>Element</code>都是不同类型的节点，它们虽然在文档中的角色和功能不同，但都是基于<code>Node</code>这个最基础的抽象概念进行派生的。</p><p><strong>从功能和用途角度</strong></p><ul><li><code>Document</code>代表整个文档，是 DOM 树的根，它主要用于从整体层面操作文档，比如创建新的<code>Element</code>、<code>Text</code>节点，通过<code>getElementById</code>等方法查找元素等。它是访问和操作整个文档结构的入口。</li><li><code>Element</code>表示文档中的具体元素，像<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;img&gt;</code>等 HTML 标签对应的对象，它侧重于定义元素相关的属性（如<code>className</code>、<code>id</code>等）和方法（如<code>setAttribute</code>等），用于操作元素自身的特性、样式和行为等。</li></ul><p>虽然在文档中<code>Document</code>包含了<code>Element</code>，但在 DOM 继承体系设计上，它们都是<code>Node</code>的具体派生类型，各自负责不同层面的功能，这种设计使得 DOM 结构更加清晰、模块化，便于开发者理解和使用。</p><p>:::</p><h5 id="KvhN9">document对象</h5><p>Document节点表示的整个载入的网页，<font style="color:#DF2A3F;">它的实例是全局的document对象</font></p><ul><li>对DOM的所有操作都是从 <font style="color:#DF2A3F;">document 对象</font>开始的;</li><li>它是<font style="color:#DF2A3F;">DOM的 入口点</font>，可以从document开始去访问任何节点元素;</li></ul><p>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到:</p><ul><li>html元素:<html>&#x3D;document.documentElement</html></li><li>body元素:<body>&#x3D;document.body</body></li><li>head元素:<head>&#x3D;document.head</head></li><li>文档声明:<!DOCTYPE html>&#x3D; document.doctype</li></ul><p><strong>如果我们获取到一个节点(Node)后，可以根据这个节点去获取其他的节点我们称之为节点之间的导航</strong></p><ul><li>父节点:parentNode </li><li>前兄弟节点:previousSibling</li><li>后兄弟节点:nextSibling</li><li>子节点:childNodes</li><li>第一个子节点:firstChild</li><li>最后一个子节点:lastChild</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bodyEl=<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bodyEl.<span class="hljs-property">childNodes</span>); <span class="hljs-comment">//所有子节点</span><br><span class="hljs-keyword">const</span> firstEl=bodyEl.<span class="hljs-property">firstChild</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstEl); <span class="hljs-comment">//第一个子节点</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstEl.<span class="hljs-property">nextSibling</span>); <span class="hljs-comment">//下一个子节点</span><br></code></pre></td></tr></table></figure><p><strong>element(元素)之间的导航</strong></p><ul><li>父元素:parentElement</li><li>前兄弟节点:previousElementSibling</li><li>后兄弟节点:nextElementSibling</li><li>子节点:children</li><li>第一个子节点:firstElementChild</li><li>最后一个子节点:lastElementChild</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bodyEl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span><br><span class="hljs-keyword">const</span> ele =bodyEl.<span class="hljs-property">children</span> <span class="hljs-comment">//获取body节点下的子元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ele);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bodyEl.<span class="hljs-property">firstElementChild</span>); <span class="hljs-comment">//第一个子元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bodyEl.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//第一个子元素</span><br></code></pre></td></tr></table></figure><h5 id="fE0im">Element元素</h5><h6 id="IdAji">attribute</h6><p><strong>浏览器在解析HTML元素时，会将对应的attribute也创建出来放到对应的元素对象上</strong></p><ul><li>比如id、class就是全局的attribute，会有对应的id、class属性</li><li>比如href属性是针对a元素的，type、value属性是针对input元素的;</li></ul><p><strong>属性attribute的分类:</strong></p><ul><li>标准的attribute:某些attribute属性是标准的，比如id、class、href、type、value等;(<font style="color:#DF2A3F;">在对应的对象模型中都有对应的property</font>)</li><li>非标准的attribute:某些attribute属性是自定义的，比如age、height等</li></ul><p><strong>对于所有的attribute访问都支持如下的方法:</strong></p><ul><li>elem.hasAttribute(name)- 检查特性是否存在。</li><li>elem.getAttribute(name)- 获取这个特性值,</li><li>elem.setAttribute(name, value)- 设置这个特性值。</li><li>elem.removeAttribute(name)- 移除这个特性。</li><li>attributes:attr对象的集合，具有name、value属性:</li></ul><p>:::info<br>attribute具备以下特征:</p><ol><li>它们的名字是大小写不敏感的(id 与 ID 相同)。</li><li>它们的值总是字符串类型的。</li></ol><p>:::</p><h6 id="M6Vck">property</h6><p><strong>对于标准的attribute，会在DOM对象上创建与其对应的property属性</strong></p><p>在大多数情况下，它们是相互作用的</p><ul><li>改变property，通过attribute获取的值，会随着改变;</li><li>通过attribute操作修改，property的值会随着改变;</li></ul><p>除非特别情况，大多数情况下，设置、获取attribute，推荐使用<font style="color:#DF2A3F;">property</font>的方式:</p><ul><li>这是因为它默认情况下是有类型的;</li></ul><h6 id="asXaD">class和style</h6><p>有时候我们会通过JavaScript来动态修改样式，这个时候我们有两个选择</p><ul><li>在CSS中编写好对应的样式,动态的添加class</li><li>动态的修改style属性:</li></ul><p>elem.classList 是一个特殊的对象(可迭代,for of):</p><ul><li>添加一个类 elem.classList.add (class)</li><li>移除一个类 elem.classList.remove(class):</li><li>添加&#x2F;移除类,存在就移除它,如果类不存在就添加类 elem.classList.toggle(class)</li><li>检查给定类，返回 true&#x2F;false。elem.classList.contains(class)</li></ul><p>如果我们需要读取样式:</p><ul><li>对于内联样式，是可以通过style.*的方式读取到的;</li><li>对于style、css文件中的样式，是读取不到的;这个时候，我们可以通过getComputedstyle的全局函数来实现:</li></ul><p><code> console.log(getComputedStyle(boxEl).backgroundColor);</code></p><h6 id="gya1i">元素操作</h6><p>** 插入元素:**</p><ul><li>直接innerHTML插入</li><li>创建DOM对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div class=&quot;box&quot;&gt;<br><br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const boxEl = document.querySelector(&#x27;.box&#x27;)<br>    // boxEl.innerHTML=`&lt;h2&gt;h2&lt;/h2&gt;`<br><br>    //创建DOM对象插入,可以对其进行系列操作,最后插入<br>    const H2El = document.createElement(&#x27;h2&#x27;)<br>    H2El.style.color = &#x27;red&#x27;<br>    H2El.innerHTML=&#x27;123&#x27;<br>    boxEl.append(H2El)<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>:::info<br>– 在 node 末尾 插入节点或字符串，</p><p>node.append(…nodes or strings)</p><p>– 在 node 开头 插入节点或字符串</p><p>node.prepend(…nodes or strings)</p><p>– 在 node 前面 插入节点或字符串,</p><p>node.before(…nodes or strings)</p><p>–在 node 后面 插入节点或字符串</p><p>node.after(…nodes or strings)</p><p>– 将 node 替换为给定的节点或字符串。</p><p>node.replaceWith(…nodes or strings)</p><p>:::</p><p><strong>移除和复制元素</strong></p><ul><li>移除元素我们可以调用元素本身的remove方法</li><li>如果我们想要复制一个现有的元素，可以通过cloneNode方法<ul><li>可以传入一个Boolean类型的值，来决定是否是深度克隆</li><li>深度克隆会克隆对应元素的子元素，否则不会克隆对应元素的子元素</li></ul></li></ul><h6 id="Lq6RD">元素的大小,滚动</h6><p><img src="1737438656840-4ad29814-3340-4a91-8e1e-1c1c435b29d7.png"></p><ul><li>clientWidth:contentWith+padding(不包含滚动条)</li><li>clientHeight: contentHeight+padding</li><li>clientTop:border-top的宽度</li><li>clientLeft:border-left的宽度</li><li>offsetWidth:元素完整的宽度</li><li>offsetHeight:元素完整的高度</li><li>offsetLeft:距离父元素的x</li><li>offsetHeight:距离父元素的y</li><li>scrollHeight:整个可滚动的区域高度</li><li>scrollTop:滚动部分的高度</li></ul><h6 id="nkot5">window的大小,滚动</h6><p><strong>widow的width,height:</strong></p><ul><li>innerWidth、innerHeight:获取window窗囗的宽度和高度(包含滚动条)</li><li>outerWidth、outerHeight:获取window窗口的整个宽度和高度(包括调试工具、工具栏)</li><li>documentElement.clientHeight、documentElement.clientWidth:获取html的宽度和高度(不包含滚动条)</li></ul><p><strong>window的滚动:</strong></p><ul><li>x轴上滚动的位置:scrollX(pageXOffset)</li><li>y轴上滚动的位置:scrollY(pageYOffset)</li><li>scrollBy(x,y):将页面滚动至 相对于当前位置的(x,y),位置;</li><li>scrollTo(pageX,pageY)将页面滚动至 绝对坐标;</li></ul><h5 id="RMlKC">事件</h5><h6 id="RR2Vf">事件监听</h6><p><strong>如何进行事件监听</strong></p><ul><li>事件监听方式一:在script中直接监听(很少使用)</li><li>事件监听方式二:DOM属性，通过元素的on来监听事件;</li><li>事件监听方式三:通过EventTarget中的addEventListener来监听;</li></ul><p><strong>鼠标事件</strong></p><ul><li>click – 当鼠标点击一个元素时(触摸屏设备会在点击时生成)</li><li>mouseover&#x2F;mouseout –当鼠标指针移入&#x2F;离开一个元素时,</li><li>mousedown&#x2F;mouseup–当在元素上按下&#x2F;释放鼠标按钮时。</li><li>mousemove–当鼠标移动时。</li></ul><p><strong>键盘事件:</strong></p><ul><li>keydown 和 keyup – 当按下和松开一个按键时,</li></ul><p><strong>表单(form)元素事件:</strong></p><ul><li>submit – 当访问者提交了一个 <form>时。</form></li><li>focus – 当访问者聚焦于一个元素时，例如聚焦于 <input>。</li></ul><p><strong>Document 事件:</strong></p><ul><li>DOMContentLoaded –当 HTML的加载和处理均完成，DOM 被完全构建完成时。</li></ul><p><strong>CSS 事件:</strong></p><ul><li>transitionend–当一个 CSS 动画完成时。</li></ul><h6 id="jCF3F">事件冒泡,捕获</h6><p>事实上对于事件有一个概念叫做事件流，为什么会产生事件流呢?</p><p>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身,这是因为我们的HTML元素是存在<font style="color:#DF2A3F;">父子元素叠加层级</font>的; </p><ul><li>我们会发现默认情况下事件是从最内层的span向外依次传递的顺序，这个顺序我们称之为<strong>事件冒泡</strong>(EventBubble)</li><li>事实上，还有另外一种监听事件流的方式就是从外层到内层(body-&gt;span)，这种称之为<strong>事件捕获</strong>(Event Capture)</li></ul><h6 id="mRNDQ">事件对象Event</h6><p>当一个事件发生时，就会有和这个事件相关的很多信息,那么这些信息会被封装到一个Event对象中，这个对象由浏览器创建，称之为<strong>event对象</strong></p><p><strong>常见event的属性</strong></p><ul><li>type:事件的类型;</li><li>target:当前事件发生的元素</li><li>currentTarget:当前处理事件的元素;</li><li>eventPhase:事件所处的阶段</li><li>offsetX、offsetY:事件发生在元素内的位置;</li><li>clientX、clientY:事件发生在客户端内的位置</li><li>pageX、pageY:事件发生在客户端相对于document的位置:</li><li>screenX、screenY:事件发生相对于屏幕的位置,</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  &lt;/div&gt;<br><br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;parent&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">//当你点击 #child 按钮时，event.target 会指向 #child 按钮，因为它是实际触发点击事件的元素。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>);<br>  <span class="hljs-comment">//如果你点击 #child 按钮，event.currentTarget 会指向 #parent 元素，因为事件处理函数是绑定在 #parent 元素上的。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">currentTarget</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>常见的方法</strong></p><ul><li>preventDefault:取消事件的默认行为，</li><li>stopPropagation:阻止事件的进一步传递(冒泡或者捕获都可以阻止)</li></ul><p>在函数中，我们也可以通过this来获取当前的发生元素,这是因为在浏览器内部，调用event handler是绑定到当前的curentTarget上的</p><p>:::info<br>css属性也可以禁止鼠标交互事件</p><p><code>pointer-events:none</code></p><p>:::</p><h6 id="AJWJF">EventTarget</h6><ul><li>所有的节点、元素都继承自EventTarget,事实上Window也继承自EventTarget;</li><li>EventTarget是一个DOM接口，主要用于添加、删除、派发Event事件</li></ul><p><strong>EventTarget常见的方法</strong></p><ul><li>addEventListener:注册某个事件类型以及事件处理函数;</li><li>removeEventListener:移除某个事件类型以及事件处理函数;</li><li>dispatchEvent:派发某个事件类型到EventTarget上;</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;MirZ&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MirZ事件&#x27;</span>);<br>   &#125;)<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;MirZ&#x27;</span>))<br>   &#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><h6 id="svsAi">事件委托</h6><p>事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式<font style="color:#DF2A3F;"> 事件委托</font>模式(也是一种设计模式)</p><p>那么这个模式是怎么样的呢?</p><ul><li>因为当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击</li><li>并且可以通过event.target获取到当前监听的元素,</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>       .active&#123;<br>        color: red;<br>       &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>   &lt;ul&gt;<br>    &lt;li&gt;1&lt;/li&gt;<br>    &lt;li&gt;2&lt;/li&gt;<br>    &lt;li&gt;3&lt;/li&gt;<br>    &lt;li&gt;4&lt;/li&gt;<br>    &lt;li&gt;5&lt;/li&gt;<br>    &lt;li&gt;6&lt;/li&gt;<br>    &lt;li&gt;7&lt;/li&gt;<br>    &lt;li&gt;8&lt;/li&gt;<br>    &lt;li&gt;9&lt;/li&gt;<br>    &lt;li&gt;10&lt;/li&gt;<br>   &lt;/ul&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    // 遍历实现<br>//   const liEls=document.querySelectorAll(&#x27;li&#x27;)  <br>//   for (let i = 0; i &lt; liEls.length; i++) &#123;<br>//     var liEl=liEls[i]<br>//     liEl.onclick=function(e)&#123;<br>//         console.log(e.currentTarget.classList.add(&#x27;active&#x27;));<br>//     &#125;<br>//   &#125;<br><br>    //ul监听<br>// const ulEl=document.querySelector(&#x27;ul&#x27;)<br>// ulEl.onclick=function(e)&#123;<br>//     e.target.classList.add(&#x27;active&#x27;)<br>// &#125;<br>  <br>  //记录变量<br>  //记录变量<br>  const ulEl=document.querySelector(&#x27;ul&#x27;)<br>  let activeEl=null<br>  ulEl.onclick=function(e)&#123;<br>    if(activeEl &amp;&amp; e.target!==ulEl)&#123;<br>        activeEl.classList.remove(&#x27;active&#x27;)      <br>    &#125;<br>    //判断是否点击ul,点击ul不触发<br>    if(e.target!==ulEl)&#123;<br>        e.target.classList.add(&#x27;active&#x27;)<br>        activeEl=e.target<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>      <br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div class=&quot;box&quot;&gt;<br>        &lt;button data-action=&quot;remove&quot;&gt;移除&lt;/button&gt;<br>        &lt;button data-action=&quot;create&quot;&gt;创建&lt;/button&gt;<br>        &lt;button data-action=&quot;updata&quot;&gt;更新&lt;/button&gt;<br>    &lt;/div&gt;<br><br>&lt;/body&gt;<br>&lt;script&gt;<br>  const boxEl=document.querySelector(&#x27;.box&#x27;)<br>  boxEl.onclick=function(e)&#123;<br>    //根据data-*,来从元素中获取到action来判断<br>    var action=e.target.dataset.action<br>    console.log(action);<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h6 id="VpP2K">常见事件</h6><p>MDN文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p><p><strong>鼠标事件:</strong></p><p><img src="1737726011745-b34a55dc-b98e-4e40-a74d-b98dc13b5b15.png"></p><p>mouseenter和mouseleave</p><ul><li>不支持冒泡</li><li>进入子元素依然属于在该元素内，没有任何反应</li></ul><p>mouseover和mouseout</p><ul><li>支持冒泡</li><li>进入元素的子元素时先调用父元素的mouseout,再调用子元素的mouseover</li><li>因为支持冒泡，所以会将mouseover传递到父元素中:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>  &lt;style&gt;<br><br>  &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>  &lt;div class=&quot;box&quot; style=&quot;width: 200px; height: 200px; background-color: aquamarine;&quot;&gt;<br>    &lt;sapn class=&quot;sp&quot; style=&quot;display: inline-block; width: 100px; height: 100px; margin:50px;background-color:beige;&quot;&gt; &lt;/sapn&gt;<br>  &lt;/div&gt;<br><br>&lt;/body&gt;<br>&lt;script&gt;<br>  const boxEl = document.querySelector(&#x27;.box&#x27;) <br>  const spanEl=document.querySelector(&#x27;.sp&#x27;)<br><br><br>  boxEl.onmouseenter=function()&#123;<br>    console.log(&#x27;box onmouseenter&#x27;);<br>  &#125;<br>  boxEl.onmouseleave=function()&#123;<br>    console.log(&#x27;box onmouseleave&#x27;);<br>  &#125;<br>  spanEl.onmouseenter=function()&#123;<br>    console.log(&#x27;spanEl onmouseenter&#x27;);<br>  &#125;<br>  spanEl.onmouseleave=function()&#123;<br>    console.log(&#x27;spanEl onmouseleave&#x27;);<br>  &#125;<br><br><br><br><br>  // boxEl.onmouseover=function()&#123;<br>  //   console.log(&#x27;box onmouseover&#x27;);<br>  // &#125;<br>  // boxEl.onmouseout=function()&#123;<br>  //   console.log(&#x27;box onmouseout&#x27;);<br>  // &#125;<br>  // spanEl.onmouseover=function()&#123;<br>  //   console.log(&#x27;spanEl onmouseover&#x27;);<br>  // &#125;<br>  // spanEl.onmouseout=function()&#123;<br>  //   console.log(&#x27;spanEl onmouseout&#x27;);<br>  // &#125;<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>键盘事件</strong></p><p><img src="1737730438301-031debb6-216c-4117-8bc5-3ed6fdbcb783.png"></p><p>事件的执行顺序是onkeydown、onkeypress、onkeyup</p><ul><li>down事件先发生,发生在按键被按下.</li><li>press发生在文本被输入;</li><li>up发生在文本输入完成;</li></ul><p>我们可以通过key和code来区分按下的键:</p><ul><li>code:“按键代码”(“KeyA”，”ArrowLeft”等)，特定于键盘上按键的物理位置。</li><li>key:字符(“A”，“a”等)，对于非字符(non-character)的按键，通常具有与 code 相同的值。)</li></ul><p><strong>表单事件</strong></p><p><img src="1737788515123-6e071f21-a08a-4fe1-9575-18aff255ebf1.png"></p><p>** 文档加载事件**</p><ul><li>DOMContentLoaded:浏览器已完全加载 HTML，并构建了 DOM 树，但像 <img>和样式表之类的外部资源可能尚未加载完成。</li><li>load:浏览器不仅加载完成了 HTML，还加载完成了所有外部资源:图片，样式等。</li></ul><p><strong>动画结束事件</strong></p><p><font style="color:rgb(27, 27, 27);">transitionend:事件会在 </font><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_transitions/Using_CSS_transitions">CSS 过渡</a><font style="color:rgb(27, 27, 27);">完成的时候触发。如果过渡在完成前就被移除</font></p><p><strong><font style="color:rgb(27, 27, 27);">文档可见性</font></strong></p><p><font style="color:rgb(27, 27, 27);">当用户导航到新页面、切换标签页、关闭标签页、最小化或关闭浏览器，或者在移动设备上从浏览器切换到不同的应用程序时，该事件就以为的状态触发。(可用于轮播图等定时器的自动清除与创建)</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">addEventListener(&quot;visibilitychange&quot;, (event) =&gt; &#123;<br>console.log(document.visibilityState)<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="sft66">BOM</h4><p><strong>BOM</strong><font style="color:#DF2A3F;">:浏览器对象模型(Browser Object Model)简称 BOM，由浏览器提供的用于处理文档(document)之外的所有内容的其他对象,比如navigator、location、history等对象;我们可以将BOM看成是连接JavaScript脚本与浏览器窗口的桥梁</font></p><p><strong>BOM主要包括的对象模型</strong></p><ul><li>window:包括全局属性、方法，控制浏览器窗口相关的属性、方法;</li><li>location:浏览器连接到的对象的位置(URL);</li><li>history:操作浏览器的历史;</li><li>navigator:用户代理(浏览器)的状态和标识(很少用到)</li><li>screen:屏幕窗口信息(很少用到);</li></ul><h5 id="orDuh">定时器</h5><ul><li>setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。</li><li>setlnterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li><li>clearTimeout:取消setTimeout的定时器;</li><li>clearInterval:取消setInterval的定时器;</li></ul><p>:::info<br>如果提前定义好的定时器let timer&#x3D;null,在后面去接收timer&#x3D;setlnterval(fun,time),在清除定时器的时候一定要将timer重新赋为null,clearInterval(timer);timer&#x3D;null</p><p>:::</p><h5 id="s6HAN">全局对象window </h5><p>window对象在浏览器中可以从两个视角来看待:</p><p><strong>视角一:全局对象。</strong></p><ul><li>我们知道ECMAScript其实是有一个全局对象的</li><li>这个全局对象在Node中是global</li><li>在浏览器中就是window对象;</li></ul><p><strong>视角二:浏览器窗口对象。</strong></p><ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的API;</li></ul><h6 id="doSRn">window对象的作用</h6><ul><li>第一包含大量的属性:localStorage、console、location、history、screenX、scrolX…</li><li>第二包含大量的方法:alert、close、scrollTo、open…</li><li>第三:包含大量的事件:focus、blur、load、hashchange…</li><li>第四:包含从EventTarget继承的方法，addEventListener、removeEventlistener、dispatchEvent方法</li></ul><p>MDN文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a></p><h5 id="vee1l">location对象</h5><p><strong>location对象用于表示window上当前链接到的URL信息。</strong></p><p>**常见的属性:  **</p><ul><li>href: 当前window对应的超链接URL, 整个URL;</li><li>protocol: 当前的协议;</li><li>host: 主机地址;</li><li>hostname: 主机地址(不带端口);</li><li>port: 端囗;</li><li>pathname: 路径;</li><li>search: 查询字符串;</li><li>hash: 哈希值;</li><li>username:URL中的username(很多浏览器已经禁用)</li><li>password:URL中的password(很多浏览器已经禁用)</li></ul><p><strong>location有如下常用的方法:</strong></p><ul><li>assign:赋值一个新的URL，并且跳转到该URL中;</li><li>replace:打开一个新的URL，并且跳转到该URL中(不同的是不会在浏览记录中留下之前的记录);</li><li>reload:重新加载页面，可以传入一个Boolean类型;</li></ul><h6 id="DpOcJ">URLSearchParams</h6><p>URLSearchParams定义了一些实用的方法来处理URL的查询字符串。</p><ul><li>可以将一个字符串转化成URLSearchParams类型:</li><li>也可以将一个URLSearchParams类型转成字符串;</li></ul><p><strong>URLSearchParams常见的方法有如下:</strong></p><ul><li>get:获取搜索参数的值;</li><li>set:设置一个搜索参数和值;</li><li>append:追加一个搜索参数和值;</li><li>has:判断是否有某个搜索参数;</li></ul><p>MDN:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;script&gt;<br>        var urlSearchString = &#x27;?name=MirZ&amp;age=18&amp;height=188&#x27;<br>        //字符串转为URLSearchParams<br>        var searchParams=new URLSearchParams(urlSearchString)<br>        //获取搜索参数<br>        console.log(searchParams.get(&#x27;name&#x27;));<br>        //URLSearchParams转为String<br>        console.log(searchParams.toString());<br>        //添加搜索参数<br>        searchParams.append(&#x27;adresss&#x27;,&#x27;河南&#x27;)<br>        <br>        <br>        <br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="k3GIk">history对象</h5><p><strong>history对象允许我们访问浏览器曾经的会话历史记录。</strong></p><p>属性:</p><ul><li>length:会话中的记录条数;</li><li>state:当前保留的状态值;</li></ul><p>方法:</p><ul><li>back():返回上一页，等价于history.go(-1);</li><li>forward():前进下一页，等价于history.go(1);</li><li>go():加载历史中的某一页;</li><li>pushState():打开一个指定的地址:</li><li>replaceState():打开一个新的地址，并且使用replace;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>修改history<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> btns=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span><br><span class="language-javascript">        btns[<span class="hljs-number">0</span>].<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            history.<span class="hljs-title function_">pushState</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Mir&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;18&#x27;</span>&#125;,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;/Mir&#x27;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        btns[<span class="hljs-number">1</span>].<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//后退</span></span><br><span class="language-javascript">            <span class="hljs-comment">// history.back()</span></span><br><span class="language-javascript">            <span class="hljs-comment">//前进</span></span><br><span class="language-javascript">            <span class="hljs-comment">// history.forward()</span></span><br><span class="language-javascript">            <span class="hljs-comment">//加载某一页</span></span><br><span class="language-javascript">            <span class="hljs-comment">// history.go(2)    </span></span><br><span class="language-javascript">            history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="cdkbU">navigator和screen</h5><p><strong>navigator对象表示用户代理的状态和标识等信息。</strong></p><p><img src="1737990304029-3c4752ad-5cc5-41ed-b635-86faba095035.png"></p><p><strong>screen主要记录的是浏览器窗口外面的客户端显示器的信息:</strong></p><p><img src="1737990500532-78c0914e-9cd9-4f68-93a0-a90584407979.png"></p><h5 id="QC2cp">JSON</h5><p>JSON是一种重要的数据格式，它并不是编程语言，而是一种在服务器和客户端之间传输的数据格式,JSON的全称是JavaScript Object Notation(JavaScript对象符号)</p><p><strong>JSON被使用的场景</strong></p><ul><li>网络数据的传输JSON数据</li><li>项目的某些配置文件:</li><li>非关系型数据库(NoSQL)将json作为存储格式</li></ul><p><strong>JSON的顶层支持三种类型的值:</strong></p><ul><li>简单值:数字(Number)、字符串(String，不支持单引号)、布尔类型(Boolean)、null类型;</li><li>对象值:由key、value组成，key是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值;</li><li>数组值:数组的值可以是简单值、对象值、数组值;</li></ul><p><strong>序列化和反序列化</strong></p><p>某些情况下我们希望将JavaScript中的复杂类型转化成JSON格式的字符串，这样方便对其进行处理:</p><ul><li>比如我们希望将一个对象保存到localStorage中;但是如果我们直接存放一个对象，这个对象会被转化成[object Object]格式的字符串，并不是我们想要的结果</li><li>stringify方法:将JavaScript类型转成对应的JSON字符串;</li><li>parse方法:解析JSON字符串，转回对应的JavaScript类型;</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>   <br>    &lt;script&gt;<br>        const obj=&#123;<br>            name:&#x27;MirZ&#x27;,<br>            age:&#x27;18&#x27;<br>        &#125;<br>        //进行序列化在存储,否则存储的为[Object,Object]<br>        var objJsonStr=JSON.stringify(obj)<br>        //存储到localStorage<br>        localStorage.setItem(&#x27;info&#x27;,objJsonStr)<br>        //获取存储到localStorage的info<br>        const item=localStorage.getItem(&#x27;info&#x27;)<br>        //获取到的时序列化后的字符串<br>        console.log(item);<br>        //反序列化,获取对象<br>        const newObj=JSON.parse(item)<br>        console.log(newObj);<br>        <br>        <br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>部分知识记录</title>
    <link href="/2024/12/26/%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/26/%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h5 id="i3uQg">文档声明</h5><p>HTML 最上方的一段文本称之位文档类型声明,用于声明文档类型</p><p><code>&lt;!DOCTYPE html&gt;</code></p><p>1 HTML 文档声明，告诉浏览器当前页面是<font style="color:#DF2A3F;">HTML5</font>页面</p><p>2 让浏览器用<font style="color:#DF2A3F;">HTML5 的标准去解析识别</font>内容:</p><p>3 必须放在 HTML 文档的<font style="color:#DF2A3F;">最前面，不能省略</font>，省略了会出现<font style="color:#DF2A3F;">兼容性</font>问题</p><h5 id="XBwWO">html元素</h5><html>元素 表示一个 HTML 文档的根元素(顶级元素)。所有其他元素必须是此元素的后代<p><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;/html&gt;</code></p><p>W3C 标准建议为 html 元素增加一个 lang 属性，作用是</p><p>1 帮助语音合成工具确定要使用的发音;</p><p>2 帮助翻译工具确定要使用的翻译规则;</p><p>比如常用的规则:</p><p>lang&#x3D;“en”表示这个 HTML 文档的语言是英文</p><p>lang&#x3D;“zh-CN”表示这个 HTML 文档的语言是中文</p><h5 id="PTmF9">head元素</h5><p>HTML head 元素 规定文档相关的<font style="color:#DF2A3F;">配置信息</font>(也称之为<font style="color:#DF2A3F;">元数据</font>)，包括文档的<font style="color:#DF2A3F;">标题，引用的文档样式和脚本</font>等。</p><p>1 什么是元数据(metadaka)，是描述数据的数据;</p><p>2 这里我们可以理解成对整个页面的配置:</p><p>常见的设置有哪些呢?一般会至少包含如下 2 个设置。</p><p>网页的标题:<strong>title 元素</strong></p><p><code>&lt;title&gt;标题&lt;/title&gt;</code></p><p>网页的编码:<strong>meta 元素</strong></p><p><code>&lt;meta charset=&quot;UTF-8&quot;&gt; </code></p><p>可以用于设置网页的<font style="color:#DF2A3F;">字符编码</font>，让浏览器更精准地显示每一个文字，<font style="color:#DF2A3F;">不设置或者设置错误会导致乱码</font></p><p>一般都使用<font style="color:#DF2A3F;">utf-8</font>编码，涵盖了世界上几乎所有的文字;</p><p><strong>meta 元素用于定义元数据:</strong></p><p><strong>meta 用于定义那些不能使用其他定元相关(meta-related)元素定义的任何元数据信息;</strong></p><p>meta 元素定义的元数据的类型包括以下几种:</p><ul><li>如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。</li><li>如果设置 http-equiv 属性，meta 元素则是编译指令</li><li>如果设置了 name 属性，meta 元素提供的是文档级别(document-level)的元数据，应用于整个页面。</li></ul><h5 id="l96Bj">a标签</h5><p>在网页中我们经常需要<strong>跳转到另外一个链接</strong>，这个时候我们使用 a 元素:</p><p>a 元素有两个常见的属性:</p><p>href:Hypertext Reference 的简称 指定要打开的 URL 地址;</p><p>target:该属性指定在何处显示链接的资源，self:默认值，在当前窗口打开 URL; blank:在一个新的窗口中打开 URL;</p><p>parent top 其他不常用</p><p>锚点链接可以实现:<strong>跳转到网页中的具体位置</strong></p><p>锚点链接有两个重要步骤:</p><p>在要跳到的元素上定义一个 id 属性</p><p>定义 a 元素，并且 a 元素的 href 指向对应的 id，</p><p><code> &lt;a href=&quot;#id&quot;&gt;&lt;/a&gt;</code></p><h5 id="RMX4t">iframe标签</h5><p>利用 iframe 元素可以实现:在一个 HTML 文档中嵌入其他 HTML 文档</p><p><code>    &lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></p><p>frameborder 属性 用于规定是否显示边框 1:显示 0:不显示</p><p>a 元素 target 的其他值:</p><p>_parent:在父窗口中打开 URL</p><p>_top:在顶层窗口中打开 URL</p><h5 id="NQWt2">字符实体</h5><p>思考:我们编写的 HTML 代码会被浏览器解析。如下代码是如何被解析的呢?</p><p>口如果你使用小于号(&lt;)，浏览器会将其后的文本解析为一个 tag 标签。但是某些情况下，我们确实需要编写一个小于号(&lt;);这个时候我们就可以使用字符实体;</p><p>HTML 实体是一段以连字号(&amp;)开头、以分号(;)结尾的文本(字符串):实体常常用于显示<font style="color:#DF2A3F;">保留字符</font>(这些字符会被解析为 HTML 代码)和<font style="color:#DF2A3F;">不可见的字符</font>(如“不换行空格”);你也可以用实体来<font style="color:#DF2A3F;">代替其他难以用标准键盘键入的字符</font></p><p>常见字符实体:</p><p><code>&amp;nbsp;  //空格    </code></p><p><code>&amp;lt;    //小于号  </code></p><p><code>&amp;gt;    //大于号  </code></p><h5 id="xEwuh">URL和URl</h5><p>URl&#x3D;Uniform Resource ldentifier 统一资源<strong>标志符</strong>, 用于标识 <font style="color:#DF2A3F;">Web 技术使用的逻辑或物理资源</font>。</p><p>URL&#x3D;Uniform Resource Locator 统一资源<strong>定位符</strong>，俗称<font style="color:#DF2A3F;">网络地址</font>，相当于网络中的门牌号;</p><p><code>&lt;font style=&quot;color:rgb(68, 68, 68);background-color:rgb(243, 243, 243);&quot;&gt;[协议类型]://[服务器地址]:[端口号]/[文件路径][文件名]?[查询]#[片段ID]&lt;/font&gt;</code></p><ul><li><font style="color:rgb(85, 85, 85);">URL 是 URI 的子集，即 URL 一定是 URI，但 URI 不一定是 URL</font></li><li><font style="color:rgb(85, 85, 85);">前端可以通过访问并得到资源，这是 URL</font></li><li><font style="color:rgb(85, 85, 85);">服务器内部，可以得到某一图片等资源，即图片等资源会有一个标识交给服务器，服务器可以通过该标识访问到该资源，甚至是物理设备，这期间不一定有 WEB 的参与，这是 URI</font></li></ul><h5 id="ufcYy">元素语义化</h5><p>元素的语义化:用正确的元素做正确的事情。</p><p>标签语义化的好处:</p><ul><li>方便代码维护</li><li>减少让开发者之间的沟通成本</li><li>能让语音合成工具正确识别网页元素的用途，以便作出正确的反应</li><li>有利于 SEO</li><li>…</li></ul><h5 id="v6xo4">DNS解析</h5><p>浏览器通过域名获取资源时, 会先访问域名服务器（DNS）, DNS 服务器会解析域名, 找到对应的 IP 地址, 再通过 IP 地址访问对应服务器。</p><p>域名的解析这一过程也是需要时间的, 我们可以尝试提前解析资源所在域名, 以提高获取资源时的访问速度</p><p>可以通过对 link 标签设置 dns-prefetch 来进行优化, 如下:</p><p><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;</code></p><h5 id="Vam9e">text-align理解</h5><p>W3C 中的解释:</p><p>This shorthand propertly sets the “text-align-all’and “text-align-last’properties and describes how</p><p>the <font style="color:#DF2A3F;">inline-level content</font> of a block is aligned along the inline axis if the content does not completely fill</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-comment">/* text-align只作用于行内级元素(inline); */</span></span><br><span class="language-css">        <span class="hljs-comment">/* display: inline-block; */</span></span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: bisque;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="QrKNk">选择器权重</h5><p>按照经验，为了方便比较 CSS 属性的优先级，可以给 CSS 属性所处的环境定义一个权值(权重)</p><ul><li>!important: 10000</li><li>内联样式:1000</li><li>id 选择器:100</li><li>类选择器、属性选择器、伪类:10</li><li>元素选择器、伪元素:1</li><li>通配符:0</li></ul><h5 id="pbS3z">display:block-inline</h5><p>block 元素:</p><ul><li>独占父元素的一行</li><li>可以随意设置宽高</li><li>高度默认由内容决定</li></ul><p>inline-block 元素</p><ul><li>跟其他行内级元素在同一行显示</li><li>可以随意设置宽高</li></ul><p>:::tips<br>可以这样理解</p><p>对外来说，它是一个行内级元素</p><p>对内来说，它是一个块级元素</p><p>:::</p><p>:::tips<br>使用 display : inline-block 使两个元素同行排布时,元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal，合并多余空白），原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，间距为 8px。</p><p>:::</p><p>inline:</p><ul><li>跟其他行内级元素在同一行显示</li><li>不可以随意设置宽高</li><li>宽高都由内容决定</li></ul><h5 id="VQ48G">margin上下传递和折叠</h5><h6 id="QRiPD">margin的上下传递</h6><p>margin-top 传递</p><p>如果块级元素的顶部线和父元素的顶部线重叠，那么这个块级元素的 margin-top 值会传递给父元素</p><p>margin-bottom 传递</p><p>如果块级元案的底部线和父元案的底部线重写，并且父元案的高度是 auto，那么这个块级元案的 margin-bottom 值会传递给父元案</p><p><strong>如何防止出现传递问题?</strong></p><ul><li>给父元素设置 padding-topipadding-bottom</li><li>给父元素设置 border</li><li>触发 BFC: 设置 overflow 为 auto</li></ul><h6 id="MPS2x">margin的上下折叠</h6><ul><li>垂直方向上相邻的 2 个 margin(margin-top、margin-bottom)有可能会合并为 1 个 margin，这种现象叫做 collapse(折叠)</li><li>水平方向上的 margin(margin-left、margin-right)不会 collapse</li><li>折叠后最终值的计算规则:两个值进行比较，取较大的值</li><li>如何防止 margin collapse? 只设置其中一个元素的 margin</li></ul><h5 id="C0yz9">行内非替换元素的特殊性</h5><p>对于行内非替换元素(span,a,strong,i)等,某些属性具有特殊性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><br><span class="language-css">        <span class="hljs-comment">/* width,height不生效 */</span></span><br><span class="language-css">        <span class="hljs-comment">/* width: 100px;</span></span><br><span class="hljs-comment"><span class="language-css">            height: 100px; */</span></span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/*上下会撑开,但不占据空间  */</span></span><br><span class="language-css">        <span class="hljs-comment">/* padding: 30px; */</span></span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/*上下会撑开,但不占据空间  */</span></span><br><span class="language-css">        <span class="hljs-comment">/* border: 30px solid green; */</span></span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* margin上下不生效 */</span></span><br><span class="language-css">        <span class="hljs-comment">/* margin:30px */</span></span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span> 123 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Rh2BO">position</h5><h6 id="AbcxI">标准流</h6><p>默认情况下，元素都是按照 normal flow(标准流、常规流、正常流、文档流【documentflow】)进行排布</p><ul><li>从左到右、从上到下按顺序摆放好</li><li>默认情况下，互相之间不存在层叠现象</li></ul><p>在标准流中，可以使用 margin、padding 对元素进行定位</p><ul><li>其中 margin 还可以设置负数</li></ul><p>比较明显的缺点是</p><ul><li>设置一个元素的 margin 或者 padding,通常会影响到标准流中其他元素的定位效果</li><li>不便于实现元素层叠的效果</li></ul><p>如果我们希望一个元素可以跳出标准量,单独的对某个元素进行定位呢?我们可以通过 position 属性来进行设置:</p><p>利用 position 可以对元素进行定位，常用取值有 5 个:</p><p>默认值:</p><ul><li>static:默认值,静态定位</li></ul><p>使用下面的值，可以让元素变成定位元素(positionedelement)</p><ul><li>relative:相对定位</li><li>absolute:绝对定位</li><li>fixed:固定定位</li><li>sticky:粘性定位</li></ul><h6 id="rMWWW">relative-相对定位</h6><p>元素不会完全脱离标准流,元素按照 normal flow 布局</p><p>可以通过 left、right、top、bottom 进行定位</p><p>定位参照对象是元素自己原来的位置</p><ul><li>left、right、top、bottom 用来设置元素的具体位置</li></ul><p>相对定位的应用场景</p><ul><li>在不影响其他元素位置的前提下，对当前元素位置进行微调</li></ul><h6 id="fF5jk">fixed-固定定位</h6><p>元素脱离 normal flow(脱离标准流、脱标)</p><ul><li>可以通过 left、right、top、bottom 进行定位</li><li>定位参照对象是<font style="color:#DF2A3F;">视口(viewport)</font></li><li>当画布滚动时，固定不动</li></ul><h6 id="upwkb">absolute-绝对定位</h6><p>元素脱离 normalflow(脱离标准流、脱标)</p><ul><li>可以通过 left、right、top、bottom 进行定位</li><li>定位参照对象是<font style="color:#DF2A3F;">最邻近的定位祖先元素</font> , 如果找不到这样的祖先元素，参照对象是视口</li></ul><p>定位元素(positioned element)</p><ul><li>position 值不为 static 的元素,也就是 position 值为<font style="color:#DF2A3F;">relative、absolute、fixed</font>的元素</li></ul><h6 id="YURvn">positon:absolute/fixed的元素特征</h6><p>将 position 设为 absolute&#x2F;fixed 的元素有如下特征</p><ul><li>可以随意设置宽高,宽高默认由内容决定</li><li>不再受标准流的约束 , 不再严格按照从上到下、从左到右排布</li><li>不再严格区分块级(block)、行内级(inline)，行内块级(inline·block)的很多特性都会消失</li><li>不再给父元素汇报宽高数据</li><li>定位参照对象的宽度 &#x3D; left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度</li><li>定位参照对象的高度&#x3D;top+bottom+ margin-top+ margin-bottom +绝对定位元素的实际占用高度</li></ul><p>如果希望<strong>绝对定位元素的宽高和定位参照对象</strong>一样，可以给绝对定位元素设置** **left: 0、right: 0 top:0、bottom:0、margin:0</p><p>如果希望<strong>绝对定位元素在定位参照对象中居中显示</strong>，可以给绝对定位元素设置 left: 0、right: 0、top: 0、bottom: 0、 margin: auto</p><p>另外，还得设置<strong>具体的宽高值</strong>(宽高小于定位参照对象的宽高)</p><h6 id="wfftC">sticky-粘性定位</h6><ul><li>可以看做是相对定位和固定(绝对)定位的结合体</li><li>它允许被定位的元素表现得像相对定位一样，直到它滚动到某个值点</li><li>当达到这个阈值点时,就会变成固定(绝对)定位</li><li>sticky 是相对于最近的滚动祖先包含视口的(the nearest ancestor <font style="color:#DF2A3F;">scroll</font> container’s scrollport)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">html</span>,</span><br><span class="language-css">      <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.nav</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: sticky;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aliceblue;</span><br><span class="language-css">        <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e8e8e8</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>我是导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> boxEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.box&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">genItem</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> itemList = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt;= <span class="hljs-number">50</span>; index++) &#123;</span><br><span class="language-javascript">          itemList += <span class="hljs-string">`&lt;div class=&#x27;item&#x27;&gt;`</span> + index + <span class="hljs-string">`&lt;/div&gt;`</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        boxEle.<span class="hljs-property">innerHTML</span> = itemList;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-title function_">genItem</span>();</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="M0ytX">z-index</h6><p>z-index 属性用来设置定位元素的层叠顺序(仅对定位元素有效)</p><ul><li>取值可以是正整数、负整数、0</li></ul><p><strong>比较原则</strong></p><p>如果是兄弟关系</p><ul><li><font style="color:#DF2A3F;">z-index 越大，层叠在越上面</font></li><li><font style="color:#DF2A3F;">z-index 相等，写在后面的那个元素层叠在上面</font></li></ul><p>如果不是兄弟关系</p><ul><li><font style="color:#DF2A3F;">各自从元素自己以及祖先元素中，找出最邻近的 2 个定位元素(祖先元素为兄弟元素)进行比较</font></li><li><font style="color:#DF2A3F;">而且这 2 个定位元素必须有设置 z-index 的具体数值</font></li></ul><h5 id="onhuI">浮动</h5><p>float 属性可以指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它(脱离标准流),有以下属性:left,right,none</p><h6 id="FbGGp">浮动规则</h6><p><strong>元素一旦浮动后，脱离标准流</strong></p><ul><li>朝着向左或向右方向移动，直到自己的边界紧贴着包含块(一般是父元素)或者其他浮动元素的边界为止<font style="color:#DF2A3F;">[不会超出包含块的边界(不超出 padding,只在内容中浮动)]</font></li><li><font style="color:#DF2A3F;">定位元素</font>会层叠在浮动元素上面</li></ul><p><strong>浮动元素之间不能层叠</strong></p><ul><li>如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素(左浮找左浮，右浮找右浮)</li><li>如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止</li></ul><p><strong>浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出</strong></p><ul><li>比如行内级元素、inline-block 元素、块级元素的文字内容</li></ul><p><strong>行内级元素、inline-block 元素浮动后，其顶部将与所在行的顶部对齐</strong></p><p>:::info<br>将多个行内级元素中间的空格(间隙)去除的方法</p><ol><li>删除换行符(不推荐)</li><li>将父级元素的 font-size 设置为 0，但是需要子元素设置回来</li><li>子元素设置浮动</li></ol><p>:::</p><h6 id="Cn7is">浮动引起高度塌陷-清除浮动</h6><p>由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度</p><ul><li>父元素计算总高度时，就不会计算浮动子元素的高度,导致了高度坍塌的问题</li></ul><p><strong>clear 属性可以指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面</strong></p><p>clear 的常用取值:</p><ul><li>left:要求元素的顶部低于之前生成的所有左浮动元素的底部</li><li>right:要求元素的顶部低于之前生成的所有右浮动元素的底部</li><li>both:要求元素的顶部低于之前生成的所有浮动元素的底部</li><li>none:默认值，无特殊要求</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">.clear-fix::after&#123; content: &#x27;&#x27;; display: block; clear: both; /*浏览器兼容性*/<br>visibility: hidden; height: 0; &#125; .clear-fix&#123; /* IE6/7兼容性 */ zoom: 1; &#125;<br></code></pre></td></tr></table></figure><h5 id="xtwyc">vertical-align(/*line boxes*/)</h5><p>This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.</p><p><strong>官方文档的翻译:vertical-align 会影响 **</strong><font style="color:#DF2A3F;">行内块级元素 </font>*<strong>*在一个**</strong><font style="color:#DF2A3F;"> 行盒</font>*<strong>* 中垂直方向的位置</strong></p><h6 id="gNmBh">思考</h6><p><strong>一个 div 没有设置高度的时候，会不会有高度?</strong></p><ul><li>没有内容，没有高度</li><li>有内容，内容撑起来高度</li></ul><p><strong>但是内容撑起来高度的本质是什么呢?</strong></p><ul><li>内容有行高(line-height)，撑起来了 div 的高度</li></ul><p><strong>行高为什么可以撑起 div 的高度?</strong></p><ul><li>这是因为 line boxes 的存在，并且 line-boxes 有一个特性，包裹每行的 inline level</li><li>而其中的文字是有行高的，必须将整个行高包惠进去，才算包惠这个 line-level</li></ul><p><strong>那么，进一步思考:</strong></p><ul><li>如果这个 div 中有图片，文字，inline-block，甚至他们设置了 margin 这些属性呢?</li><li>line boxes 进一步变大,包裹内容</li></ul><p><strong>有图片、文字、inline-block(比图片要大)而且设置了 margin-bottom 并且有文字，如何包裹内容?</strong></p><ul><li>由于存在文本,文本默认按照 baseline 基线对齐,<strong>inline-block</strong>会下移,line boxes 变大</li></ul><h6 id="qY2Cx">vertical-align</h6><p><strong>结论:line-boxes 一定会想办法包裹住当前行中所有的内容</strong></p><ul><li>但是，但是为什么对齐方式千奇百怪呢?因为 baseline 对齐</li></ul><p>我们来看官方 vertical-align 的默认值:没错，就是 baseline</p><p>但是 baseline 都是谁呢?</p><ul><li>文本的 baseline 是字母 x 的下方</li><li>Inline-block 默认的 baseline 是 margin-bottom 的底部(没有，就是盒子的底部)</li><li>Inline-block 有文本时，baseline 是最后一行文本的 x 的下方</li></ul><p><strong>现在，对于不同的取值就非常容易理解了</strong></p><ul><li>baseline(默认值):基线对齐</li><li>top:把行内级盒子的顶部跟 line boxes 顶部对齐</li><li>middle:行内级盒子的中心点与父盒基线加上 x-height 一半的线对齐</li><li>bottom:把行内级盒子的底部跟 line box 底部对齐</li><li><percentage>:把行内级盒子提升或者下降一段距离(距离相对于 line-height 计算\元素高度)，0%意味着同 baseline-样</percentage></li><li><length>:把行内级盒子提升或者下降一段距离，0cm 意味着同 baseline-样</length></li></ul><h5 id="Fim4V">H5新增元素</h5><p><strong>HTML5 新增了语义化的元素:</strong></p><ul><li><header>:头部元素</header></li><li><nav>:导航元素</nav></li><li><section>:定义文档某个区域的元素</section></li><li><article>:内容元素</article></li><li><aside>:侧边栏元素</aside></li><li><footer>:尾部元素</footer></li></ul><h6 id="WEzFT">video</h6><p><strong>HTML <video>元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。</video></strong></p><table><thead><tr><th>常见属性</th><th>值的方式</th><th>属性作用</th></tr></thead><tbody><tr><td>src</td><td>url 地址</td><td>视频播放的 url 地址</td></tr><tr><td>width</td><td>pixels(像素)</td><td>video 宽度</td></tr><tr><td>height</td><td>pixels(像素)</td><td>vide 高度</td></tr><tr><td>controls</td><td>Boolean</td><td>是否显示控制栏</td></tr><tr><td>autoplay</td><td>Boolean</td><td>是否自动播放(某些浏览器需要添加 muted 比如 Chrome)</td></tr><tr><td>muted</td><td>Boolean</td><td>是否静音播放</td></tr><tr><td>preload</td><td>none&#x2F;metadata&#x2F;auto</td><td>是否预加载视频,metadata 表示预加载元数据</td></tr><tr><td>poster</td><td>url 地址</td><td>一海报帧的 url</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 兼容性写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.ogg&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前浏览器不支持,请更换<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="BakTc">audio</h6><p><strong>HTML<audio>元素用于在文档中嵌入音频内容，和 video 的用法非常类似</audio></strong></p><table><thead><tr><th><strong>常见属性</strong></th><th><strong>值的方式</strong></th><th><strong>属性作用</strong></th></tr></thead><tbody><tr><td>src</td><td>url 地址</td><td>视频播放的 url 地址</td></tr><tr><td>controls</td><td>Boolean</td><td>是否显示控制栏</td></tr><tr><td>autoplay</td><td>Boolean</td><td>是否自动播放(某些浏览器需要添加 muted 比如 Chrome)</td></tr><tr><td>muted</td><td>Boolean</td><td>是否静音播放</td></tr><tr><td>preload</td><td>none&#x2F;metadata&#x2F;auto</td><td>是否预加载视频,metadata 表示预加载元数据</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.mp3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.ogg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="ljXK1">全局属性data-*</h5><p><strong>在 HTML5 中,新增一种全局属性的格式 data-*,用于自定义数据属性:</strong></p><ul><li>data 设置的属性可以在 JavaScript 的 DOM 操作中通过 dataset 轻松获取到;</li><li>通常用于 HTML 和 JavaScript 数据之间的传递</li><li>在小程序中，就是通过 data-*来传递数据的</li></ul><h5 id="cXFLV">white-space</h5><p><strong>white-space 用于设置空白处理和换行规则</strong></p><ul><li>normal:合并所有连续的空白，允许单词超屏时自动换行</li><li>nowrap:合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre:阻止合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre-wrap:阻止合并所有连续的空白，允许单词超屏时自动换行</li><li>pre-line:合并所有连续的空白(但保留换行)，允许单词超屏时自动换行</li></ul><h5 id="I7yWO">CSS函数补充</h5><h6 id="Hklff">var函数</h6><p>CSS 中可以自定义属性</p><ul><li>属性名需要以两个减号(–)开始;</li><li>属性值则可以是任何有效的 CSS 值</li><li>属性值须在父元素(根元素)定义</li><li></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">:root &#123; --v_color: #00CC4C &#125; .box &#123; width: 320px; height: 155px;<br>background-color: var(--v_color); &#125;<br></code></pre></td></tr></table></figure><h6 id="xCStG">calc函数</h6><p>calc()函数允许在声明 CSS 属性值时执行一些计算。</p><p>计算支持加减乘除的运算;</p><ul><li>+和-运算符的两边必须要有空白字符</li><li>通常用来设置一些元素的尺寸或者位置</li></ul><h6 id="H3HUt">bulr函数</h6><p><strong>blur()函数将**</strong><font style="color:#DF2A3F;">高斯模糊</font>*<strong>*应用于输出图片或者元素;</strong></p><ul><li>blur(radius)</li><li>radius, 模糊的半径,用于定义高斯函数的偏差值,偏差值越大, 图片越模糊;</li></ul><p>通常会和两个属性一起使用:</p><ul><li>filter: 将模糊或颜色偏移等图形效果应用于元素;</li><li>backdrop-filter: 为元素后面的区域添加模糊或者其他效果;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">155px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-comment">/*父元素设置也可以,继承*/</span></span><br><span class="language-css">        <span class="hljs-comment">/* filter: blur(3px); */</span></span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">3px</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://sy-1254960240.image.myqcloud.com/box/ingame/images/202412/20241222122826-675357.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">155px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/*透明遮罩层+模糊  */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.cover</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);</span><br><span class="language-css">        backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">3px</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://sy-1254960240.image.myqcloud.com/box/ingame/images/202412/20241222122826-675357.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cover&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="SxCUp">gradient函数-颜色渐变</h6><p><strong><gradient>是一种<image>CSS 数据类型的子类型，用于表现两种或多种颜色的过渡转变，</image></gradient></strong></p><p><strong><gradient>常见的函数实现有下面几种:</gradient></strong></p><ul><li>linear-gradient():创建一个表示两种或多种颜色线性渐变的图片;</li><li>radial-gradient():创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成,</li><li>repeating-linear-gradient():创建一个由重复线性渐变组成的<image>;</image></li><li>repeating-radial-gradient0):创建一个重复的原点触发渐变组成的<image>;</image></li><li>…</li></ul><p><strong>linear-gradient:创建一个表示两种或多种颜色线性渐变的图片;</strong></p><p><code>background-image: linear-gradient(to right,red,blue);</code></p><p><code>background-image: linear-gradient(to right,red,blue 40px,orange 60%,purple 100%);</code></p><p><strong>radial-gradient:创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成;</strong></p><p><code>background-image:radial-gradient(50% 50%,red,blue)</code></p><h5 id="uTQ0u">BFC(块级格式化上下文)</h5><p><strong>FC 的全称是 Formatting Context(格式化上下文)，元索在标准流里面都是属于一个 FC 的;</strong></p><blockquote><p>Boxes in the normal flow belong to a formatting context, which may be block or inline, but not bothsimultaneously. <strong>Block-level boxes</strong> participate in a <strong>block formatting context.</strong> <strong>inline-level</strong> boxes participate in an** inline formatting context.**</p></blockquote><p><strong>MDN 上有整理出在哪些具体的情况下会创建 BFC:</strong></p><ul><li>根元素(<html>)</html></li><li>浮动元素(元系的 float 不是 none)</li><li>绝对定位元素(元素的 position 为 absolute 或 fixed)</li><li>行内块元素(元素的 display 为 inline-block)</li><li>表格单元格(元案的 display 为 table-cell，HTML 表格单元格默认为该值)，表格标题(元案的 display 为 table-caption，HTML 表格标题默认为该作值)</li><li>匿名表格单元格元案(元案的 display 为 table、table-row、table-row-group、table-header-group、table-footer-group(分别是 HTML tablerow、tbody、thead、tfoot 的默认属性)或 inline-table)</li><li>overflow 计算值(Computed)不为 visible 的块元家</li><li>弹性元素(display 为 flex 或 inline-flex 元系的直接子元素)</li><li>网格元素(display 为 grid 或 inline-grid 元系的直接子元素)</li><li>display 值为 flow-root 的元素</li><li>…</li></ul><p><strong>BFC 概述:</strong></p><ul><li>在 BFC 中，box 会在垂直方向上一个挨着一个的排布</li><li>垂直方向的间距由 margin 属性决定</li><li>在同一个 BFC 中，相邻两个 box 之间的 margin 会折叠(collapse)</li><li>在 BFC 中，每个元素的左边缘是紧挨着包含块的左边缘的;</li></ul><p><strong>网上有很多说法，BFC 可以解决浮动高度塌陷，可以实现清除浮动的效果。</strong></p><p>BFC 解决高度塌陷需要满足两个条件:</p><ul><li>浮动元素的父元素触发 BFC，形成独立的块级格式化上下文(BlockFormattingContext)</li><li>浮动元素的父元素的高度是 auto 的:</li></ul><p><strong>BFC 的高度是 auto 的情况下，是如下方法计算高度的</strong></p><ul><li>1.如果只有 inline-level，是行高的顶部和底部的距离;口</li><li>2.如果有 block-level，是由最底层的块上边缘和最底层块盒子的下边缘之间的距离</li><li>3.如果有绝对定位元素，将被忽略;</li><li><font style="color:#DF2A3F;">4.如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘</font></li></ul><h5 id="UH0SB">媒体查询</h5><p>媒体查询是一种提供给开发者针对不同设备需求进行定制化开发的一个接口。</p><p>你可以根据设备的类型(比如屏幕设备、打印机设备)或者特定的特性(比如屏幕的宽度)来修改你的页面。</p><p><strong>媒体查询的使用方式主要有三种:</strong></p><p>方式一:通过@media 和@import 使用不同的 CSS 规则(常用):</p><p><code> &lt;style&gt;    @import url() (max-width:800px);   &lt;/style&gt;</code></p><p>方式二:使用 media 属性为 style,link,source 和其他 HTML 元素指定特定的媒体类型;</p><p><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width:800px)&quot; href=&quot;&quot;&gt;</code></p><p><code>@media (max-width:800px) &#123;  &#125;</code></p><p>方式三:使用 Window.matchMedia()和 MediaQueryList.addListener()方法来测试和监控媒体状态</p><p><strong>常见的媒体类型值如下:</strong></p><ul><li>all:适用于所有设备</li><li>print:适用于在打印预览模式下在屏幕上查看的分页材料和文档。</li><li>screen(掌握):主要用于屏幕。</li><li>speech:主要用于语音合成器。</li></ul><p><strong>媒体查询的表达式最终会获得一个 Boolean 值，也就是真(true)或者假(false)</strong></p><p><strong>如果有多个条件，我们可以通过逻辑操作符联合复杂的媒体查询:</strong></p><ul><li><font style="color:#DF2A3F;">and</font>:and 操作符用于将多个媒体查询规则组合成单条媒体查询</li><li>not:not 运算符用于否定媒体查询，如果不满足这个条件则返回 true，否则返回 false.</li><li>only:only 运算符仅在整个查询匹配时才用于应用样式。</li><li>，(逗号):逗号用于将多个媒体查询合并为一个规则。</li></ul><h5 id="kN0uZ">Less</h5><h6 id="jVbLV">Less的引入或使用</h6><ul><li>Node 环境下，通过 npm 包管理下载 less 编译器，对代码进行编译</li><li>通过 VSCode 插件来编译成 CSS 或者在线编译</li><li>引入 CDN 的 less 编译代码，对 less 进行实时的处理;</li></ul><h6 id="xyuzL">Less特性</h6><ol><li>使用 Less 语法支持嵌套</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-selector-class">.left</span>&#123;<br>        <span class="hljs-attribute">display</span>: block;<br>      <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>        <span class="hljs-attribute">color</span>:red<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义变量</li></ol><p><code>@TestColor: #f3c258 ;</code></p><ol start="3"><li>支持运算(数字,颜色,变量)</li><li>Mixins 混入</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.pray</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-selector-class">.pray</span>();<br>&#125;<br><span class="hljs-comment">/*混入可以传入参数  */</span><br><span class="hljs-selector-class">.pray</span>(<span class="hljs-variable">@color</span>:red) &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-selector-class">.pray</span>(black);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>Mixins 和 Map 混合使用(也可以当作简单自定义函数使用)</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.pray</span>(<span class="hljs-variable">@color</span>: red) &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: .<span class="hljs-built_in">pray</span>() [font-size];<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>继承</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.pry</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-selector-tag">&amp;</span>:<span class="hljs-selector-tag">extend</span>(.pry);<br>&#125;<br><span class="hljs-comment">/*相当于  */</span><br><span class="hljs-selector-class">.pry</span> <span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>内置函数</li></ol><p><a href="https://less.bootcss.com/functions/">Less 函数 | Less.js 中文文档 - Less 中文网</a></p><h5 id="Xy6lo">移动端适配</h5><ul><li><font style="color:#DF2A3F;">方案一:百分比设置:</font></li></ul><p>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比很难统一所以百分比在移动端适配中基本不使用</p><ul><li><font style="color:#DF2A3F;">方案二:rem 单位+动态 html 的 font-size;</font></li><li><font style="color:#DF2A3F;">方案三:vw 单位;</font></li><li><font style="color:#DF2A3F;">方案四:flex 的弹性布局</font></li></ul><h6 id="RS7Aw">rem适配移动端</h6><ol><li><font style="color:#DF2A3F;">媒体查询</font></li><li><font style="color:#DF2A3F;">JS 动态改变 fontSize</font></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs less">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">lang</span>=&quot;<span class="hljs-selector-tag">en</span>&quot;&gt;<br><br>&lt;<span class="hljs-selector-tag">head</span>&gt;<br>  &lt;<span class="hljs-selector-tag">meta</span> <span class="hljs-selector-tag">charset</span>=&quot;<span class="hljs-selector-tag">UTF-8</span>&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">meta</span> <span class="hljs-selector-tag">name</span>=&quot;<span class="hljs-selector-tag">viewport</span>&quot; <span class="hljs-selector-tag">content</span>=&quot;<span class="hljs-selector-tag">width</span>=<span class="hljs-selector-tag">device-width</span>, <span class="hljs-selector-tag">initial-scale</span>=<span class="hljs-number">1.0</span>&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">title</span>&gt;<span class="hljs-selector-tag">Document</span>&lt;/<span class="hljs-selector-tag">title</span>&gt;<br><br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br><br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">class</span>=&quot;<span class="hljs-selector-tag">box</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>  &lt;<span class="hljs-selector-tag">script</span>&gt;<br>    <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlEl</span> = <span class="hljs-selector-tag">document</span><span class="hljs-selector-class">.documentElement</span><br>    <span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">setFontSize</span>() &#123;<br>      <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlWidth</span> = <span class="hljs-selector-tag">htmlEl</span><span class="hljs-selector-class">.clientWidth</span><br>      <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlFontSize</span> = <span class="hljs-selector-tag">htmlWidth</span> / <span class="hljs-number">10</span><br>      <span class="hljs-selector-tag">htmlEl</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.fontSize</span> = <span class="hljs-selector-tag">htmlFontSize</span> + &#x27;<span class="hljs-selector-tag">px</span>&#x27;<br>    &#125;<br>    <span class="hljs-selector-tag">setFontSize</span>()<br>    <span class="hljs-selector-tag">window</span><span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, setFontSize)<br>  &lt;/<span class="hljs-selector-tag">script</span>&gt;<br>  &lt;<span class="hljs-selector-tag">style</span>&gt;<br>    <span class="hljs-selector-class">.box</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">2rem</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">2rem</span>;<br>      <span class="hljs-attribute">background-color</span>: antiquewhite;<br>    &#125;<br>  &lt;/<span class="hljs-selector-tag">style</span>,&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br><br>&lt;/<span class="hljs-selector-tag">html</span>&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li><font style="color:#DF2A3F;">使用第三方库 lib-flexible</font></li></ol><p><strong>px&#x3D;&gt;rem 方案</strong></p><ul><li><strong>手动计算</strong></li><li><strong>less&#x2F;scss 函数</strong></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/*@remUnit:37.5由设计得 */</span><br><span class="hljs-variable">@remUnit:</span> <span class="hljs-number">37.5</span>;<br><span class="hljs-selector-class">.pxToRem</span>(<span class="hljs-variable">@px</span>) &#123;<br>  result: (@px / @remUnit) * 1rem;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: .<span class="hljs-built_in">pxToRem</span>(<span class="hljs-number">100</span>) [result];<br>  <span class="hljs-attribute">height</span>: .<span class="hljs-built_in">pxToRem</span>(<span class="hljs-number">100</span>) [result];<br>  <span class="hljs-attribute">background-color</span>: antiquewhite;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><font style="color:#DF2A3F;">postcss-pxtorem </font>webpack 插件自动转化</li><li>vscode 插件 px to rem</li></ul><h6 id="UsEFp">vw适配移动端</h6><p><strong>rem 事实上是作为一种过渡的方案</strong>，它利用的也是 vw 的思想。前面不管是我们自己编写的 js，还是 flexible 的源码;</p><p>都是将 1rem 等同于设计稿的 1&#x2F;10，在利用 1rem 计算相对于整个屏幕的尺寸大小，那么我们来思考，1vw 不是刚好等于屏幕的 1&#x2F;100 吗?且相对于 rem 还更加有优势:</p><p><strong>vw 相比于 rem 的优势:</strong></p><ul><li>优势一:不需要去计算 html 的 font-size 大小，也不需要给 html 设置这样一 font-size;</li><li>优势二:不会因为设置 html 的 font-size 大小，而必须给 body 再设置一个 font-size，防止继承;</li><li>优势三:因为不依赖 font-size 的尺寸，所以不用担心某些原因 html 的 font-size 尺寸被篡改，页面尺寸混乱;</li><li>优势四:vw 相比于 rem 更加语义化，1vw 刚才是 1&#x2F;100 的 viewport 的大小;:</li><li>优势五:可以具备 rem 之前所有的优点;</li></ul><p><strong>px&#x3D;&gt;vw 方案:</strong></p><ul><li><strong>手动计算</strong></li><li><strong>less&#x2F;scss 函数</strong></li><li>**postcss-px-to-viewport-8-plugin **<font style="color:#DF2A3F;"> </font>webpack 插件自动转化</li><li>px to vw 的插件，在编写时自动转化</li></ul></html>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS的形变,过渡,动画</title>
    <link href="/2024/12/20/CSS%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%98%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7/"/>
    <url>/2024/12/20/CSS%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%98%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="VqwHr">形变-transform</h4>CSS transform属性允许对某一个元素进行某些形变,包括旋转，缩放，倾斜或平移等<p>注意事项，并非所有的盒子都可以进行transform的转换(通常行内级元素不能进行形变)</p><p>:::info<br><strong><font style="color:rgb(78, 78, 78);">Warning:</font></strong><font style="color:rgb(78, 78, 78);"> Only elements that are positioned by the box model, i.e., all elements whose layout is managed by the CSS box model, except: </font><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Inline-level_content"><font style="color:rgb(78, 78, 78);">non-replacing in-row boxes</font></a><font style="color:rgb(78, 78, 78);">, </font><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/col"><font style="color:rgb(78, 78, 78);">table columns</font></a><font style="color:rgb(78, 78, 78);">, and </font><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/colgroup"><font style="color:rgb(78, 78, 78);">table column groups</font></a><font style="color:rgb(78, 78, 78);">.</font><code>transform</code></p><p><strong><font style="color:rgb(78, 78, 78);">警告：</font></strong><font style="color:rgb(78, 78, 78);"> 只能 由盒模型定位的元素，也就是所有布局由 CSS 盒模型管理的元素，除了：</font><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Inline-level_content"><font style="color:rgb(78, 78, 78);">非替换的行内盒子</font></a><font style="color:rgb(78, 78, 78);">、</font><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/col"><font style="color:rgb(78, 78, 78);">表格列</font></a><font style="color:rgb(78, 78, 78);">和</font><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/colgroup"><font style="color:rgb(78, 78, 78);">表格列组</font></a><font style="color:rgb(78, 78, 78);">。</font><code>transform</code></p><p>:::</p><p>所以，transform对于行内级非替换元素是无效的  比如对span、a元素等:</p><p><font style="color:#DF2A3F;">常见的函数transform function有</font>:</p><ul><li>平移:translate(x, y)</li><li>缩放:scale(x,y) </li><li>旋转:rotate(deg)</li><li>倾斜:skew(deg, deg)</li></ul><p><strong><font style="color:#DF2A3F;">transform可以设置多个值</font></strong></p><p><code>transform:translate(188px) scale(0.5) rotate(45deg);</code></p><h6 id="BmQiH">translate</h6>**平移:translate(x,y)**<ul><li>translate是translateX和translateY函数的简写</li><li>这个CSS 函数用于移动元素在平面上的位置，</li><li>translate本身可以表示翻译的意思，在物理上也可以表示平移</li></ul><p><strong>值个数</strong></p><ul><li>一个值时，设置x轴上的位移</li><li>二个值时，设置x轴和y轴上的位移</li></ul><p><strong>值类型:</strong></p><ul><li>数字:100px</li><li>百分比:参照元素本身(referto the size of bounding box)</li></ul><h6 id="oytPc">scale</h6>**缩放:scale(x,y)**<p><strong>scale()可改变元系的大小</strong></p><p>值个数</p><ul><li>一个值时，设置x轴上的缩放</li><li>二个值时，设置x轴和y<font style="color:#DF2A3F;"></font>轴上的缩放</li></ul><p>**值类型:**数字:</p><ul><li>1:保持不变</li><li>2:放大一倍</li><li>0.5:缩小一半</li><li>百分比:百分比不常用</li></ul><p>scale函数是scaleX和scaleY的缩写</p><h6 id="tl3BT">rotate</h6>**旋转:rotate(<angle>)**<p>值类型:</p><ul><li>常用单位deg:旋转的角度(degrees)</li><li>正数为顺时针</li><li>负数为逆时针</li></ul><p><strong>补充一:rotate函数是rotateZ函数的简写写法。</strong></p><p><strong>补充二:rotate的其他单位</strong></p><ul><li>事实上rotate支持的单位是很多的;度(degrees)、百分度(gradians)弧度(radians)或圈数(turns)</li></ul><h6 id="KrVSR">transform-origin</h6>**transform-origin:形变的原点**<p>比如在进行scale缩放或者rotate旋转时，都会有一个原点。</p><ul><li>一个值:设置x轴的原点</li><li>两个值:设置x轴和y轴的原点</li></ul><p>必须是<length>，<percentage>，或left,center, right, top, bottom关键字中的一个</percentage></length></p><ul><li>left, center, right, top, bottom关键字</li><li>length:从左上角开始计算</li><li>百分比:参考元素本身大小</li></ul><h6 id="dwaNH">skew</h6>倾斜:skew(x，y)<p>** 函数定义了一个元素在二维平面上的倾斜转换。**</p><ul><li>一个值时，表示x轴上的倾斜</li><li>二个值时，表示x轴和y轴上的倾斜</li></ul><p>值类型:</p><ul><li>deg:旋转的角度</li><li>正数为顺时针</li><li>负数为逆时针</li></ul><h4 id="muMft">过渡-transition</h4>什么是transition动画呢?<ul><li>CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法,</li><li>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效的;</li><li>比如将一个元素从一个位置移动到另外一个位置，默认在修改完CSS属性后会立即生效:</li><li>但是我们可以通过CSS transition，让这个过程加上一定的动画效果，包括一定的曲线速率变化;</li></ul><p>通常将两个状态之间的过渡称为隐式过渡(implicit transitions)，因为开始与结束之间的状态由浏览器决定。</p><p><strong>Css transitions可以决定</strong></p><ul><li>哪些属性发生动画效果(明确地列出这些属性)</li><li>何时开始(设置 delay)</li><li>持续多久(设置 duration)</li><li>效何动画(定义timing function，比如匀速地或先快后慢)。</li></ul><p><font style="color:#DF2A3F;">transition CSS属性是 </font><strong><font style="color:#DF2A3F;">transition-property, transition-duration, transition-timing-function 和transition-delay</font></strong><font style="color:#DF2A3F;"> 的一个简写属性。</font></p><p><code>transition-property:all  //动画生效的属性</code></p><p><code>transition-duration:1s  //动画持续的时间</code></p><p><code>transition-timing-function:ease //动画执行曲线</code></p><p><code>transition-delay:1s  //延迟动画</code></p><p><strong>transition-property:指定应用过渡属性的名称</strong></p><ul><li>all:所有属性都执行动画;</li><li>none:所有属性都不执行动画:</li><li>CSS属性名称:要执行动画的CSS属性名称，比如width、left、transform等;</li></ul><p><strong>transition-duration:指定过渡动画所需的时间</strong></p><ul><li>单位可以是秒(s)或毫秒(ms)</li></ul><p><strong>transition-timing-function:指定动画的变化曲线</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function">transition-timing-function - CSS：层叠样式表 | MDN</a></li></ul><p><strong>transition-delay:指定过渡动画执行之前的等待时间</strong></p><p><strong>transition的缺点:</strong></p><ul><li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态;</li><li>transition不能重复执行，除非一再触发动画;</li><li>transition需要在特定状态下会触发才能执行，比如某个属性被修改了。</li></ul><hr><h4 id="sGDf4">动画-animation</h4>**CSS Animation的使用分成两个步骤:**<ul><li><font style="color:#DF2A3F;">步骤一</font>:使用keyframes定义动画序列(每一帧动画如何执行)</li><li><font style="color:#DF2A3F;">步骤二</font>:配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等等</li></ul><p>可以使用@keyframes来定义多个变化状态，并且使用animation-name来声明匹配</p><ul><li>关键帧使用percentage来指定动画发生的时间点;</li><li>0%表示动画的第一时刻，100%表示动画的最终时刻;</li><li>因为这两个时间点十分重要，所以还有特殊的别名:from和to</li></ul><p><code>animation-iteration-count:2; //动画执行次数</code></p><p><code>animation-direction:normal;  //动画执行方向</code></p><p><code>animation-fill-mode: forwards; //动画停留位置</code></p><p><code>animation-play-state:paused;  //js动态修改</code></p><p><strong>CSS animation 属性是 animation-name, animation-duration, animation-timing-function, animation-delay,animation-iteration-count,animation-direction,animation-fill-mode属性的一个简写属性</strong></p><p><font style="color:#DF2A3F;">animation-name</font>:指定执行哪一个关键帧动画</p><p><font style="color:#DF2A3F;">animation-duration</font>:指定动画的持续时间</p><p><font style="color:#DF2A3F;">animation-timing-function</font>:指定动画的变化曲线</p><p><font style="color:#DF2A3F;">animation-delay</font>:指定延迟执行的时间</p><p><font style="color:#DF2A3F;">animation-iteration-count</font>:指定动画执行的次数，执行infinite表示无限动画</p><p><font style="color:#DF2A3F;">animation-direction</font>:指定方向，常用值normal和reverse</p><p><font style="color:#DF2A3F;">animation-fill-mode</font>:执行动画最后保留哪一个值</p><ul><li>none:回到没有执行动画的位置</li><li>forwards:动画最后一帧的位置</li><li>backwards:动画第一帧的位置</li></ul></angle>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个不占据空间的滚动条</title>
    <link href="/2024/12/19/scrollBar/"/>
    <url>/2024/12/19/scrollBar/</url>
    
    <content type="html"><![CDATA[<p>GitHub地址:<a href="https://github.com/KingSora/OverlayScrollbars?tab=readme-ov-file">https://github.com/KingSora/OverlayScrollbars?tab=readme-ov-file</a></p><p>中文文档:<a href="https://www.koudingke.cn/docs/zh-Hans/overlay-scrollbars-docs/latest/Index">https://www.koudingke.cn/docs/zh-Hans/overlay-scrollbars-docs/latest/Index</a></p><p><font style="color:rgb(58, 62, 72);">一个 </font><code>JavaScript</code><font style="color:rgb(58, 62, 72);"> 滚动条插件，它能隐藏原生滚动条，提供可自定义样式的覆盖滚动条，并保留原生的功能和手感。创建这个插件是因为讨厌既难看又占用空间的原生滚动条。类似的插件在功能、质量、简洁性、许可协议或浏览器兼容性方面没有达到要求。</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/overlayscrollbars/2.10.0/styles/overlayscrollbars.css&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/overlayscrollbars/2.10.0/browser/overlayscrollbars.browser.es6.js&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">html</span>,</span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.wrapper</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">72px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">72px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e8e8e8</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//OverlayScrollbars初始化</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-title class_">OverlayScrollbars</span>,</span><br><span class="language-javascript">        <span class="hljs-comment">// ScrollbarsHidingPlugin,</span></span><br><span class="language-javascript">        <span class="hljs-comment">// SizeObserverPlugin,</span></span><br><span class="language-javascript">        <span class="hljs-comment">// ClickScrollPlugin</span></span><br><span class="language-javascript">    &#125; = <span class="hljs-title class_">OverlayScrollbarsGlobal</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> osInstance = <span class="hljs-title class_">OverlayScrollbars</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;body&#x27;</span>), &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">scrollbars</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//scrollbars.autoHide属性有效值为：&#x27;never&#x27;, &#x27;scroll&#x27;, &#x27;leave&#x27;, 和 &#x27;move&#x27;。自动隐藏可见滚动条的可见性，在用户执行特定操作后。</span></span><br><span class="language-javascript">            <span class="hljs-attr">autoHide</span>: <span class="hljs-string">&#x27;leave&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-comment">//自动隐藏滚动条之前的时间延迟（以毫秒为单位）。</span></span><br><span class="language-javascript">            <span class="hljs-attr">autoHideDelay</span>: <span class="hljs-number">3000</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-comment">//插件配置,见文档</span></span><br><span class="language-javascript">    <span class="hljs-comment">// OverlayScrollbarsGlobal.OverlayScrollbars.plugin([</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     OverlayScrollbarsGlobal.SizeObserverPlugin,</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     OverlayScrollbarsGlobal.ClickScrollPlugin,</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     OverlayScrollbarsGlobal.ScrollbarsHidingPlugin,</span></span><br><span class="language-javascript">    <span class="hljs-comment">// ])</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">genDiv</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> wrapperEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;wrapper&#x27;</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> divList = <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">50</span>; index++) &#123;</span><br><span class="language-javascript">            divList += <span class="hljs-string">&#x27;&lt;div class=&quot;item&quot;&gt;&#x27;</span> + index + <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        wrapperEle.<span class="hljs-property">innerHTML</span> = divList</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">genDiv</span>()</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>拓展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拓展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="/2024/12/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <url>/2024/12/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/12/12/Git/"/>
    <url>/2024/12/12/Git/</url>
    
    <content type="html"><![CDATA[<p><strong>Git 是一个免费的开源分布式版本控制系统，旨在处理从小型到 快速高效的超大型项目。</strong></p><h4 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h4><p>git官网:<a href="https://git-scm.com/">Git</a></p><p>:::tips<br>&#x2F;&#x2F; 查看git版本</p><p>git -v</p><p>初次使用git需要配置用户名和邮箱</p><p>git config –global user.name “Jasper Yang’</p><p>git config –global user.email <a href="mailto:&#x67;&#101;&#101;&#x6b;&#x68;&#x61;&#x6c;&#x6c;&#46;&#99;&#110;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#x67;&#101;&#101;&#x6b;&#x68;&#x61;&#x6c;&#x6c;&#46;&#99;&#110;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></p><p><img src="1732771915677-78ecf971-8142-462c-b6b9-5a373d49bf58-1733989032467-1.png"></p><p>查看配置的信息</p><p>git config –global –list</p><p>:::</p><h4 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h4><h5 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h5><p>:::tips<br>方式一 : git init     &#x2F;&#x2F;本地初始化仓库</p><p>方式二 : git clone  &#x2F;&#x2F;远程克隆仓库</p><p>:::</p><h5 id="工作区域和文件状态"><a href="#工作区域和文件状态" class="headerlink" title="工作区域和文件状态"></a>工作区域和文件状态</h5><blockquote><p>工作区域</p><p><img src="1732772549334-abaf791a-542c-4983-a1d2-867486e8e86d.png"></p></blockquote><blockquote><p>文件状态</p><p>:::tips<br>未跟踪:新创建的,未被git管理的文件</p><p>未修改:已被git管理,文件内容未被修改的文件</p><p>已修改:已修改,未被添加到暂存区的文件</p><p>已暂存::已被添加到暂存区的文件</p><p>:::</p></blockquote><blockquote><p><img src="1732772735047-29d7e85d-498d-40fb-b91e-46b3c66075ed.png"></p><p><img src="1732783489100-cdccaa59-036a-4abf-b29d-f532460549be.png"></p></blockquote><h5 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h5><p>:::tips<br>git init       创建仓库</p><p>git status   查看仓库</p><p>git add       添加到暂存区</p><p>git commit 提交</p><p>git log        查看历史提交记录</p><p>:::</p><h5 id="git-reset-回退版本"><a href="#git-reset-回退版本" class="headerlink" title="git reset 回退版本"></a>git reset 回退版本</h5><p>:::info<br>git reset</p><p><img src="1732773470015-e79cce61-fadd-4408-9f81-6ab750c4fb60.png"></p><p>:::</p><p>:::tips<br>ls 查看工作区所有文件</p><p>ls -a 查看工作区所有文件(包括隐藏文件)</p><p>git ls-liles 查看暂存区所有文件</p><p>:::</p><p>:::tips<br>谨慎使用 –hard 会删除两个版本之间的工作区和暂存区</p><p>若误操作删除,可以使用git reflog 查看操作的历史记录,然后使用git reset 回退到误操作前的版本</p><p>:::</p><h5 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h5><blockquote><p>git diff</p><p><img src="1732774168228-3499e932-da8b-495f-9298-8c4ff7992573.png"></p></blockquote><p>:::tips<br>&#x2F;&#x2F;  HEAD 指向分支的最新提交节点</p><p>git diff    默认查看工作区和暂存区的差异</p><p>git diff HEAD  查看工作区和版本库的差异</p><p>git diff –cached 查看暂存区和版本库的差异</p><p>git diff <ID> <ID> 查看两次版本库的差异</ID></ID></p><p>git diff <ID> <ID> <flie> 查看两次版本库中某个文件的差异</flie></ID></ID></p><p>:::</p><h5 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h5><blockquote><p>git rm</p><p><img src="1732775143522-e8eb1bcf-e989-49cb-9d6f-3705c6524b45.png"></p></blockquote><h5 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h5><blockquote><p>.gitignore</p><p><img src="1732775241241-3856ded3-d183-455f-bdbc-3862bfc32acd.png"></p></blockquote><p>Git官网匹配规则:<a href="https://git-scm.com/docs/gitignore">Git - gitignore Documentation</a></p><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><details class="lake-collapse"><summary id="u77f25584"><span class="ne-text">不存在本地仓库</span></summary><p id="u809ffe96" class="ne-p"><span class="ne-text">echo&quot;# remote-repo&quot;&gt;&gt; README.md</span></p><p id="u20eb9812" class="ne-p"><span class="ne-text">git init</span></p><p id="uc6343321" class="ne-p"><span class="ne-text">git add README.md</span></p><p id="uaba48681" class="ne-p"><span class="ne-text">git commit -m&quot;first commit&quot;</span></p><p id="ueb47bd2e" class="ne-p"><span class="ne-text">git branch - main</span></p><p id="u98a0e619" class="ne-p"><span class="ne-text">git remote add origin git@github.com:geekhall-laoyang/remote-repo.git</span></p><p id="u4a691752" class="ne-p"><span class="ne-text">git push -u origin main</span></p></details><details class="lake-collapse"><summary id="ub1ce2e9e"><span class="ne-text">存在本地仓库</span></summary><p id="u50cfc4d2" class="ne-p"><span class="ne-text">git remote add origin git@github.com:geekhall-laoyang/remote-repo.git</span></p><p id="u52d33af1" class="ne-p"><span class="ne-text">git branch - main</span></p><p id="uf0b08533" class="ne-p"><span class="ne-text">git push -u origin main</span></p></details><blockquote><p>配置SSH密钥</p><p>如果第一次使用ssh方式,需要配置SSH密钥,详见<a href="https://blog.csdn.net/lqlqlq007/article/details/78983879">git ssh key配置_git配置ssh key-CSDN博客</a></p><p><img src="1732782348793-e29eae91-71c5-4d70-8eae-5435aa735915.png"></p></blockquote><p>:::tips<br>git remote -v      查看本地仓库关联远程仓库</p><p>git push -u origin main:main 将本地分支和远程分支关联并推送(如果本地和远程分支相同,则可省略:main)</p><p>git pull&lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;  如果省略的话默认就是拉取仓库别名为origin的主分支</p><p>:::</p><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>:::tips<br>git branch    查看分支</p><p>git branch <name>     创建新的分支</name></p><p>git checkout <name>   切换分支(git checkout 也有恢复文件的功能,如果分支名和文件名重复,可能冲突)</name></p><p>git switch <name>  切换分支</name></p><p>git merge dev   合并分支   (首先切换到要接受合并的分支,例如:main)</p><p>git branch -d dev 删除已被合并的分支  ( 未被合并不能被-d删除,需要-D强制删除分支  )</p><p>git merge –abort  终止合并</p><p>:::</p><h5 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h5><p>如果两个分支修改了同一处代码,合并时会产生合并冲突,需要解决冲突</p><p>:::tips<br>当发生冲突可以使用git status 查看冲突文件列表,也可使用git diff 查看具体冲突内容</p><p>需要手动修改冲突文件,在重新提交</p><p>:::</p><h5 id="git-rebase变基"><a href="#git-rebase变基" class="headerlink" title="git  rebase变基"></a>git  rebase变基</h5><p><img src="1732784949965-9d77b1e1-d0e4-4a19-9a44-38aef9ea7520-1733989032468-11.png"></p><p><img src="1732785147042-fd8304df-3a89-4293-bdfd-af7d272816a4-1733989032468-13.png"><img src="1732785156279-aa64bcd2-9e0e-4a5c-8ce2-be406e3f104a-1733989032468-15.png"></p><h5 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h5><p>:::tips<br><code>&lt;font style=&quot;color:rgb(77, 77, 77);&quot;&gt;git cherry-pick&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">命令的作用，就是将指定的提交（</font><a href="https://so.csdn.net/so/search?q=commit">commit</a><font style="color:rgb(77, 77, 77);">）应用于其他分支。</font></p><p><font style="color:rgb(77, 77, 77);">git cherry-pick <commitHash></commitHash></font></p><p>:::</p><p><img src="1732785882221-49592d40-dda3-4867-97dd-7a8564cacd06-1733989032468-17.png"></p><p>:::tips<br> $ git cherry-pick <HashA> <HashB>   合并两次的提交</HashB></HashA></p><p>&#x2F;&#x2F; 不包含A，包含B</p><p>$ git cherry-pick A..B </p><p>&#x2F;&#x2F; 如果想搞成[]区间，使用 git cherry-pick A^..B 相当于[A B]包含A</p><p>$ git cherry-pick A^..B </p><p>:::</p><p><img src="1732786053734-4ea518c3-27d9-4a60-b874-e3c8c5834298-1733989032468-19.png"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FlexBox</title>
    <link href="/2024/12/10/FlexBox/"/>
    <url>/2024/12/10/FlexBox/</url>
    
    <content type="html"><![CDATA[<p><strong>Flexbox 翻译为弹性盒子</strong></p><p><font style="color:#DF2A3F;">弹性盒子</font>是一种用于按行或按列布同元素的一维布局方法</p><ul><li>元素可以膨胀以填充额外的空间，收缩以适应更小的空间,</li><li>通常我们使用 Flexbox 来进行布局的方案称之为 flex 布局(flexlayout);</li></ul><p>两个重要的概念:</p><ul><li>开启了 flex 布局的元素叫 flex container</li><li>flex container 里面的直接子元素叫做 flex item</li></ul><p>当 felx container 中的子元素变成了 flex item 时,具备以下特点:</p><ul><li>flex item 的布局将受 flex container 属性的设置来进行控制和布局</li><li>flex item 不再严格区分块级元素和行内级元素</li><li>flex item 默认情况下是包裹内容的,但是可以设置宽度和高度</li></ul><h5 id="display-flex-inline-flex"><a href="#display-flex-inline-flex" class="headerlink" title="display:flex&#x2F;inline-flex"></a>display:flex&#x2F;inline-flex</h5><p>设置 display 属性为 flex 或者 inline-flex 可以成为 flex container</p><ul><li>flex:flex container 以 block-level 形式存在</li><li>inline-flex: flex container 以 inline-level 形式存在</li></ul><h5 id="flex-container-上的-css-属性"><a href="#flex-container-上的-css-属性" class="headerlink" title="flex container 上的 css 属性"></a>flex container 上的 css 属性</h5><h6 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h6><p>flex items 默认都是沿着 main axis(<font style="color:#DF2A3F;">主轴</font>)从 main start 开始往 main end 方向排布</p><p><font style="color:#DF2A3F;">flex-direction</font> 决定了 main axis 的方向，有 4 个取值</p><p><font style="color:#DF2A3F;">row</font>(默认值)、row-reverse、<font style="color:#DF2A3F;">column</font>、column-reverse</p><h6 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h6><p>flex-wrap 决定了 flex container 是单行还是多行</p><ul><li>nowrap(默认):单行</li><li>wrap:多行</li><li>wrap-reverse:多行(对比 wrap，cross start 与 cross end 相反)</li></ul><h6 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h6><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写。</p><ul><li>顺序任何,并且都可以省略;</li></ul><h6 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h6><p><strong>justify-content 决定了 flex items 在 main axis 上的**</strong><font style="color:#DF2A3F;">对齐方式</font>**</p><p><font style="color:#DF2A3F;">flex-start</font>(默认值):与 main start 对齐</p><p><font style="color:#DF2A3F;">flex-end</font>:与 main end 对齐</p><p><font style="color:#DF2A3F;">center</font>:居中对齐</p><p><font style="color:#DF2A3F;">space-between</font></p><ul><li>flex items 之间的距离相等</li><li>与 main start、main end 两端对齐</li></ul><p><font style="color:#DF2A3F;">space-around</font></p><ul><li>flex items 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</li></ul><p><font style="color:#DF2A3F;">space-evenly</font></p><ul><li>flexitems 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离 等于 fex items 之间的距离</li></ul><h6 id="align-item"><a href="#align-item" class="headerlink" title="align-item"></a>align-item</h6><p><strong>align-items 决定了**</strong><font style="color:#DF2A3F;">flex items</font>*<strong>*在**</strong><font style="color:#DF2A3F;"> cross axis(交叉轴)</font>*<strong>* 上的对齐方式</strong></p><p><font style="color:#DF2A3F;">normal</font>:在弹性布局中，效果和 stretch 一样</p><p><font style="color:#DF2A3F;">stretch</font>:当 flexitems 在 cross axis 方向的 size 为 auto 时，会自动拉伸至填充 flex container</p><p><font style="color:#DF2A3F;">flex-start</font>:与 cross start 对齐</p><p><font style="color:#DF2A3F;">flex-end:</font>与 cross end 对齐</p><p><font style="color:#DF2A3F;">center</font>:居中对齐</p><p><font style="color:#DF2A3F;">baseline</font>:与基准线对齐</p><h6 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content<font style="color:#DF2A3F;"></font></h6><p><strong>align-content 决定了**</strong><font style="color:#DF2A3F;">多行 fexitems</font>*<strong>*在 **</strong><font style="color:#DF2A3F;">cross axis</font>*<strong>* 上的对齐方式，用法与 justify-content 相似</strong></p><p>stretch(默认值):与 align-items 的 stretch 类似</p><p><font style="color:#DF2A3F;">flex-start</font>:与 cross start 对齐</p><p><font style="color:#DF2A3F;">flex-end</font>:与 cross end 对齐</p><p><font style="color:#DF2A3F;">center</font>:居中对齐</p><p><font style="color:#DF2A3F;">space-between</font>:</p><ul><li>flexitems 之间的距离相等</li><li>与 cross start、cross end 两端对齐</li></ul><p><font style="color:#DF2A3F;">space-around</font></p><ul><li>√flex items 之间的距离相等</li><li>√flexitems 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li></ul><p><font style="color:#DF2A3F;">space-evenly:</font></p><ul><li>flex items 之间的距离相等</li><li>flexitems 与 cross start、cross end 之间的距离 等于 flex items 之间的距离</li></ul><h6 id><a href="#" class="headerlink" title></a></h6><h5 id="flex-item-上的-css-属性"><a href="#flex-item-上的-css-属性" class="headerlink" title="flex item 上的 css 属性"></a>flex item 上的 css 属性</h5><h6 id="order"><a href="#order" class="headerlink" title="order"></a>order</h6><p>order 决定了 flex items 的排布顺序</p><ul><li>可以设置任意整数(正整数、负整数、0)，值越小就越排在前面</li><li>默认值是 0</li></ul><h6 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h6><p>flex items 可以通过 align-self 覆盖 flex container 设置的 align-items</p><ul><li>auto(默认值):遵从 flex container 的 align-items 设置</li><li>stretch、flex-start、flex-end、center、baseline,效果跟 align-items -致</li></ul><h6 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h6><p><strong>fex-grow 决定了 flex items 如何扩展(拉伸&#x2F;成长)</strong></p><ul><li>可以设置任意非负数字(正小数、正整数、0)，默认值是 0</li><li>当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 属性才会有效</li><li>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size 为 flex container 的剩余 size*(flex-grow&#x2F;sum)</li><li>flex items 扩展后的最终 size 不能超过 max-width\max-height</li></ul><h6 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h6><p><strong>flex-shrink 决定了 fexitems 如何收缩(缩小)</strong></p><ul><li>可以设置任意非负数字(正小数、正整数、0)，默认值是 1</li><li>当 flex items 在 main axis 方向上超过了 fex container 的 size，flex-shrink 属性才会有效</li><li>如果所有 flex items 的 fex-shrink 总和超过 1，每个 fexitem 收缩的 size 为 flex items 超出 flex container 的 size*收缩比例&#x2F;所有 flex items 的收缩比例之和</li></ul><h6 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h6><p><strong>flex-basis 用来设置 fexitems 在 main axis 方向上的 base size</strong></p><ul><li>auto(默认值)、具体的宽度数值(100px)</li></ul><p><strong>决定 flexitems 最终 base size 的因素，从优先级高到低</strong></p><ul><li>max-width\max-height\min-width\min-height</li><li>flex-basis</li><li>width\height</li><li>内容本身的 size</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">700px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">120px</span>;</span><br><span class="language-css">        <span class="hljs-comment">/* width: 120px; */</span></span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>cccccccccccccccccccccccc<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h6><p><strong>flex 是 flex-grow| flex-shrink| flex-basis 的简写,flex 属性可以指定 1 个，2 个或 3 个值</strong></p><p><strong>单值语法:值必须为以下其中之一:</strong></p><ul><li>一个无单位数(<number>): 它会被当作<flex-grow>的值。</flex-grow></number></li><li>一个有效的宽度(width)值: 它会被当作 <flex-basis>的值。</flex-basis></li><li>关键字 none，auto 或 initial.</li></ul><p><strong>双值语法: 第一个值必须为一个无单位数，并且它会被当作<flex-grow>的值，</flex-grow></strong></p><p><strong>第二个值必须为以下之一:</strong></p><ul><li>一个无单位数:它会被当作<flex-shrink>的值，</flex-shrink></li><li>一个有效的宽度值: 它会被当作<flex-basis>的值,</flex-basis></li></ul><p><strong>三值语法:</strong></p><ul><li>第一个值必须为一个无单位数，并且它会被当作<flex-grow>的值,</flex-grow></li><li>第二个值必须为一个无单位数，并且它会被当作<flex-shrink>的值,</flex-shrink></li><li>第三个值必须为一个有效的宽度值，并且它会被当作<flex-basis>的值.</flex-basis></li></ul><p>:::info<br>initial</p><p>元素会根据自身宽高设置尺寸。它会缩短自身以适应 fiex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器。相当于将属性设置为”flex:0 1 auto”</p><p>auto</p><p>元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 fex 容器。这相当于将属性设置为”flex:1 1 auto”</p><p>none</p><p>元素会根据自身宽高来设置尺寸。它是完全非弹性的:既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为”flex:0 0 auto”。</p><p>:::</p><h5 id="flex-布局下的-justify-content-下最后一行元素排布"><a href="#flex-布局下的-justify-content-下最后一行元素排布" class="headerlink" title="flex 布局下的 justify-content 下最后一行元素排布"></a>flex 布局下的 justify-content 下最后一行元素排布</h5><p><strong>当使用 justify-content:space-between 时,最后一行元素可能不够填充一行,导致排布混乱,有两种解决方案</strong></p><ul><li>不使用**justify-content,**计算使用 margin</li><li>使用(列数-2)个宽度与排布元素宽度相同,无高度的元素放到末尾进行填充</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: space-between;</span><br><span class="language-css">        <span class="hljs-attribute">flex-wrap</span>: wrap;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aquamarine;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &gt; <span class="hljs-selector-tag">i</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>布局</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2024/12/08/webpack/"/>
    <url>/2024/12/08/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="ztgII">前言</h1><p><font style="color:rgb(53, 53, 53);">从Webpack开始的前端工程化探索</font></p><h1 id="dCQEd">模块化</h1><p><font style="color:rgb(53, 53, 53);">随着前端应用的日益复杂，程序员需要更高效的代码组织形式，以便提高可维护性并提升开发效率。</font></p><p><font style="color:rgb(53, 53, 53);">模块化将复杂的代码按功能的不同，分为不同的模块，单独维护，提高开发效率。</font></p><p><strong><font style="color:rgb(53, 53, 53);">模块：</font></strong></p><ol><li><font style="color:rgb(53, 53, 53);">将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。</font></li><li><font style="color:rgb(53, 53, 53);">块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</font></li></ol><h2 id="ZNsRX">演变</h2><p><strong><font style="color:rgb(53, 53, 53);">1、文件划分</font></strong><font style="color:rgb(53, 53, 53);"><br></font><font style="color:rgb(53, 53, 53);">将不同的功能及其状态数据存放在单独的JS文件中。约定一个文件就是一个模块，以单独的script标签引入至HTML。</font></p><p><font style="color:rgb(53, 53, 53);">虽然实现了功能的划分，但缺点也十分明显：</font></p><ol><li><font style="color:rgb(53, 53, 53);">污染全局作用域</font></li><li><font style="color:rgb(53, 53, 53);">命名冲突</font></li><li><font style="color:rgb(53, 53, 53);">无法管理模块的依赖关系</font></li></ol><p><strong><font style="color:rgb(53, 53, 53);">2、命名空间</font></strong><font style="color:rgb(53, 53, 53);"><br></font><font style="color:rgb(53, 53, 53);">在文件划分的基础上，约定每个模块只暴露一个全局的对象，对象包裹着模块的方法和状态。</font></p><p><font style="color:rgb(53, 53, 53);">虽然避免了命名冲突，但仍然没有私有空间，</font></p><p><strong><font style="color:rgb(53, 53, 53);">3、IIFE</font></strong><font style="color:rgb(53, 53, 53);"><br></font><font style="color:rgb(53, 53, 53);">通过立即执行函数实现私有空间，使用window暴露模块的成员，通过参数声明依赖。</font></p><p><strong>js</strong></p><p><font style="color:rgb(53, 53, 53);">在没有工具和相关规范的早期，以约定的形式，实践模块化思想的方式。</font></p><p><font style="color:rgb(53, 53, 53);">仍然存在问题：</font></p><ol><li><font style="color:rgb(53, 53, 53);">依赖管理混乱</font></li><li><font style="color:rgb(53, 53, 53);">不同开发者、不同项目，模块化的实现有差异</font></li><li><font style="color:rgb(53, 53, 53);">模块的导入不受代码控制</font></li></ol><h3 id="FjzOd">现代化</h3><ol><li><strong><font style="color:rgb(53, 53, 53);">模块化规范：</font></strong><font style="color:rgb(53, 53, 53);">对模块代码书写格式和交互规则的详细描述</font></li><li><strong><font style="color:rgb(53, 53, 53);">模块加载器：</font></strong><font style="color:rgb(53, 53, 53);">使用代码的方式，自动控制模块的导入，管理模块的依赖。</font></li></ol><p><font style="color:rgb(53, 53, 53);">在ES6模块化出现之前，为了解决模块化的需求，出现了众多的模块化机制，CommonJS(NodeJS内置)、AMD(require.js)、CMD(Sea.js)</font></p><p><font style="color:rgb(53, 53, 53);">ES6模块化出现后的</font><strong><font style="color:rgb(53, 53, 53);">最佳实践</font></strong><font style="color:rgb(53, 53, 53);">：</font></p><ol><li><font style="color:rgb(53, 53, 53);">浏览器环境：ES Module</font></li><li><font style="color:rgb(53, 53, 53);">Node环境：CommonJS</font></li></ol><h2 id="gt4Tx">ES Module</h2><p><font style="color:rgb(53, 53, 53);">ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJS 和 AMD 模块，都是运行时的</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script type=&#x27;module&#x27;&gt;<br>  import &#123; name &#125; from &#x27;./modules/index.js&#x27;;<br>  export name;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">特性：</font></p><ol><li><font style="color:rgb(53, 53, 53);">自动采用严格模式，忽略’use strict’</font></li><li><font style="color:rgb(53, 53, 53);">每个ESM模块都是单独的私有作用域</font></li><li><font style="color:rgb(53, 53, 53);">ESM通过CORS请求外部JS模块</font></li><li><font style="color:rgb(53, 53, 53);">ESM的script标签会延迟执行脚本(相当于defer)</font></li></ol><p><font style="color:rgb(53, 53, 53);">详见</font><a href="https://www.qcqx.cn/article/383b041f.html#Module%E6%A8%A1%E5%9D%97%E5%8C%96"><font style="color:rgb(53, 53, 53);">ES6查缺补漏 #Module模块化</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules"><font style="color:rgb(53, 53, 53);">MDN-JavaScript模块</font></a></p><h3 id="aTsbD">兼容性问题</h3><p><font style="color:rgb(53, 53, 53);">ES6仍然有兼容性问题，早期的浏览器，特别是国产和手机上的浏览器</font></p><p><strong>shell</strong></p><p>使用 caniuse-cmd 检查兼容性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g caniuse-cmd<br>caniuse import<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">可以引入</font><font style="color:rgb(53, 53, 53);"> </font><a href="https://polyfill.io/"><font style="color:rgb(53, 53, 53);">Polyfill</font></a><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">兼容</font></p><p><font style="color:rgb(53, 53, 53);">使用 webpack、vite 后，有更多的兼容插件可以安装使用，如</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;@vitejs/plugin-legacy&lt;/font&gt;</code></p><p><font style="color:rgb(53, 53, 53);">script添加nomodule属性，仅在不支持ESM的浏览器上执行该脚本</font></p><h3 id="tWXEu">ESM in Node</h3><p><font style="color:rgb(53, 53, 53);">ESM在Node.js的v8.5.0中作为实验性功能被引入，v12.17.0为所有Node.js应用程序提供了ESM支持</font></p><p><font style="color:rgb(53, 53, 53);">使用</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;.mjs&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">、</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;.cjs&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">文件后缀区分 ESM 和 CommonJS 模块</font></p><p><font style="color:rgb(53, 53, 53);">原生Node环境中的ESM与CommonJS：</font></p><ol><li><font style="color:rgb(53, 53, 53);">ES Module中可以导入CommonJS模块</font></li><li><font style="color:rgb(53, 53, 53);">CommonJS中不能导入ES Module模块</font></li><li><font style="color:rgb(53, 53, 53);">CommonJS始终只会导出一个默认成员</font></li></ol><p><font style="color:rgb(53, 53, 53);">ESM得到CommonJS全局成员的值：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">// console.log(__dirname)<br>// ReferenceError: __dirname is not defined in ES module scope<br>import &#123; fileURLToPath &#125; from &#x27;url&#x27;<br>import &#123; dirname &#125; from &#x27;path&#x27;<br>const __filename = fileURLToPath(import.meta.url)<br>const __dirname = dirname(__filename)<br>console.log(__filename)<br>console.log(__dirname)<br>// c:\***\esm-in-node\index.mjs<br>// c:\***\esm-in-node<br></code></pre></td></tr></table></figure><h2 id="y8o51">前端打包工具</h2><p><font style="color:rgb(53, 53, 53);">ESM仍然存在一些问题：</font></p><ol><li><font style="color:rgb(53, 53, 53);">存在兼容性问题</font></li><li><font style="color:rgb(53, 53, 53);">模块文件过多，网络请求频繁</font></li><li><font style="color:rgb(53, 53, 53);">不仅是JS，前端所有的资源，包括CSS、HTML都需要模块化</font></li></ol><p><font style="color:rgb(53, 53, 53);">前端需要更好的工具和规范，让开发者继续享受模块化带来的便利，而不需要担心对</font><strong><font style="color:rgb(53, 53, 53);">生产环境</font></strong><font style="color:rgb(53, 53, 53);">产生的影响。</font></p><p><strong><font style="color:rgb(53, 53, 53);">需求推动技术的进步</font></strong><font style="color:rgb(53, 53, 53);">，打包工具顺势出现了。打包工具解决的是前端整体的模块化，不只是局限于JS的模块化。</font></p><p><font style="color:rgb(53, 53, 53);">如今前端项目的代码组织，已经走上了</font><strong><font style="color:rgb(53, 53, 53);">编辑代码</font></strong><font style="color:rgb(53, 53, 53);">和</font><strong><font style="color:rgb(53, 53, 53);">最终运行文件</font></strong><font style="color:rgb(53, 53, 53);">完全两样的形式，一系列</font><strong><font style="color:rgb(53, 53, 53);">工具链</font></strong><font style="color:rgb(53, 53, 53);">和自动化的思想也融入进了打包工具中，打包也逐渐从一个技术问题，转变为了生态和管理问题。打包工具现在也可称为</font><strong><font style="color:rgb(53, 53, 53);">构建工具</font></strong><font style="color:rgb(53, 53, 53);">，支撑着前端工程化。</font></p><p><font style="color:rgb(53, 53, 53);">常见的打包工具：</font><a href="https://webpack.docschina.org/"><font style="color:rgb(53, 53, 53);">Webpack</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://vitejs.dev/"><font style="color:rgb(53, 53, 53);">Vite</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://rollupjs.org/"><font style="color:rgb(53, 53, 53);">Rollup</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://esbuild.github.io/"><font style="color:rgb(53, 53, 53);">esbuild</font></a></p><h1 id="uHXZM">Webpack</h1><p><a href="https://webpack.docschina.org/"><font style="color:rgb(53, 53, 53);">Webpack</font></a><font style="color:rgb(53, 53, 53);">是一个用于现代 JavaScript 应用程序的静态模块打包工具。</font></p><p><font style="color:rgb(53, 53, 53);">学习webpack大体上就是学习webpack.config.js的配置、各种loaders和plugins的使用，所以，多看文档，广泛了解，取所需使用</font><a href="https://webpack.docschina.org/concepts/"><font style="color:rgb(53, 53, 53);">文档</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://webpack.docschina.org/configuration/"><font style="color:rgb(53, 53, 53);">配置</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://webpack.docschina.org/guides/"><font style="color:rgb(53, 53, 53);">指南</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://webpack.docschina.org/loaders/"><font style="color:rgb(53, 53, 53);">loaders</font></a><font style="color:rgb(53, 53, 53);">、</font><a href="https://webpack.docschina.org/plugins/"><font style="color:rgb(53, 53, 53);">plugins</font></a></p><h2 id="yrYsD">快速上手</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm init -y<br>npm install webpack webpack-cli --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;private&quot;: true, // 防止意外发布<br>  &quot;scripts&quot;: &#123;<br>    &quot;build&quot;: &quot;webpack&quot; // 打包命令<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">创建index.html和src目录，并写两个模块化文件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;script type=&quot;module&quot; src=&quot;src/index.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; createTitle &#125; from &quot;./module.js&quot;;<br>document.body.append(createTitle(&#x27;Hello World&#x27;));<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">export const createTitle = (title) =&gt; &#123;<br>  const element = document.createElement(&#x27;h2&#x27;)<br>  element.textContent = title<br>  element.addEventListener(&#x27;click&#x27;, () =&gt; &#123;<br>    alert(title)<br>  &#125;)<br>  return element<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">直接打开 index.html 可以看到页面上的 Hello World</font></p><p><font style="color:rgb(53, 53, 53);">接着使用webpack进行打包</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">npx webpack<br># 或<br>npm run build<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">webpack自动创建了 dist 目录，存放了打包好的 main.js</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!-- &lt;script type=&quot;module&quot; src=&quot;src/index.js&quot;&gt;&lt;/script&gt; --&gt;<br>&lt;!-- 打包好的main.js已经是ES5语法，可以去掉type=&quot;module&quot; --&gt;<br>&lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">打开 index.html 仍然可以看到 Hello World</font></p><p><font style="color:rgb(53, 53, 53);">Webpack4以后，支持这样0配置的方式，快速打包项目，src是默认打包入口，dist是输出，index.js -&gt; main.js</font></p><h1 id="E4MOi">配置</h1><p><font style="color:rgb(53, 53, 53);">根目录的</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;webpack.config.js&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">是webpack默认的配置文件</font></p><p><font style="color:rgb(53, 53, 53);">可以手动创建配置文件，或在 VSCode 中下载</font><a href="https://marketplace.visualstudio.com/items?itemName=jeremyrajan.webpack"><font style="color:rgb(53, 53, 53);">webpack插件</font></a><font style="color:rgb(53, 53, 53);">，通过</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;Webpack Create&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">命令，初始化 webpack</font></p><p><strong>默认创建的wbpack.config.js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs plain">const path = require(&#x27;path&#x27;);<br>module.exports = &#123;<br>  // 设置模式为开发模式<br>  mode: &#x27;development&#x27;,<br>  // 应用程序的入口点<br>  entry: path.join(__dirname, &#x27;src&#x27;, &#x27;index&#x27;),<br>  // 启用监视模式，以在文件更改时进行自动重新编译<br>  watch: true,<br>  // 输出配置<br>  output: &#123;<br>    // 存储输出文件的目录<br>    path: path.join(__dirname, &#x27;dist&#x27;),<br>    // 打包文件的公共路径（由浏览器用于加载资源）<br>    publicPath: &#x27;/dist/&#x27;,<br>    // 主要包的输出文件名<br>    filename: &quot;bundle.js&quot;,<br>    // 动态加载的代码的输出文件名（代码分割）<br>    chunkFilename: &#x27;[name].js&#x27;<br>  &#125;,<br>  // 用于处理不同文件类型的模块配置<br>  module: &#123;<br>    // 使用Babel处理JavaScript和JSX文件的规则<br>    rules: [&#123;<br>      // 用于匹配以.jsx或.js结尾的文件<br>      test: /.jsx?$/,<br>      // 只处理src目录下的文件<br>      include: [<br>        path.resolve(__dirname, &#x27;src&#x27;)<br>      ],<br>      // 排除node_modules目录下的文件<br>      exclude: [<br>        path.resolve(__dirname, &#x27;node_modules&#x27;)<br>      ],<br>      // 使用babel-loader进行转译<br>      loader: &#x27;babel-loader&#x27;,<br>      options: &#123;<br>        // 使用指定的Babel预设<br>        presets: [<br>          [&quot;@babel/env&quot;, &#123;<br>            // 指定目标浏览器版本为最近的两个Chrome版本<br>            &quot;targets&quot;: &#123;<br>              &quot;browsers&quot;: &quot;last 2 chrome versions&quot;<br>            &#125;<br>          &#125;]<br>        ]<br>      &#125;<br>    &#125;]<br>  &#125;,<br>  // 配置模块解析的文件扩展名<br>  resolve: &#123;<br>    extensions: [&#x27;.json&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;]<br>  &#125;,<br>  // 生成源映射以方便调试<br>  devtool: &#x27;source-map&#x27;,<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 提供内容的基本目录<br>    contentBase: path.join(__dirname, &#x27;/dist/&#x27;),<br>    // 启用内联模式，自动注入脚本以处理实时更新<br>    inline: true,<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">JS配置文件运行在node环境中，所以需要使用CommonJS写法</font></p><p><font style="color:rgb(53, 53, 53);">插件还会自动安装这些插件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;devDependencies&quot;: &#123;<br>  &quot;webpack&quot;: &quot;^5.74.0&quot;,<br>  &quot;webpack-cli&quot;: &quot;^4.10.0&quot;,<br>  &quot;@babel/core&quot;: &quot;^7.18.13&quot;,<br>  &quot;@babel/preset-env&quot;: &quot;^7.18.10&quot;,<br>  &quot;babel-loader&quot;: &quot;^8.2.5&quot;,<br>  &quot;webpack-dev-server&quot;: &quot;^4.10.0&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="GATLr">基本概念</h2><ol><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;entry&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: webpack打包的入口起点，从这里开始根据各个文件之间的依赖来对文件进行打包。单页面应用只有一个入口起点，多页面应用则存在多个入口起点</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;output&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 打包文件输出定义的地方，定义打包后输出文件的名字以及输出路径等</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;mode&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 模式，webpack打包的模式，分为三种 development、production、none</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;loader&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 对javascript等文件进行预处理的，可以通过loader来构建包含javascript在内的任何静态资源</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;plugin&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 插件是用来解决loader解决不了的问题，它可以在webpack构建过程中任何一个节点来调用</font></li></ol><p><a href="https://createapp.dev/webpack/"><font style="color:rgb(53, 53, 53);">createapp.dev</font></a><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">是一个创建自定义 webpack 配置的在线工具</font></p><p><font style="color:rgb(53, 53, 53);">使用不同的配置文件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;scripts&quot;: &#123;<br>  &quot;build&quot;: &quot;webpack --config prod.config.js&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="oPcrk">入口和上下文</h1><p><font style="color:rgb(53, 53, 53);">入口对象是用于 webpack 查找开始构建 bundle 的地方。上下文是入口文件所处的目录的绝对路径的字符串。</font><a href="https://webpack.docschina.org/configuration/entry-context/"><font style="color:rgb(53, 53, 53);">文档</font></a></p><h2 id="Gw0xq">基础目录context</h2><p><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;context&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> 基础目录，</font><strong><font style="color:rgb(53, 53, 53);">绝对路径</font></strong><font style="color:rgb(53, 53, 53);">，解析入口点(entry point)和加载器(loader)</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">context: path.resolve(__dirname, &#x27;src&#x27;),<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">配置了context后，entry路径相对于context</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#x27;./src/index.js&#x27;,<br>// 配置context后<br>context: path.resolve(__dirname, &#x27;src&#x27;),<br>entry: &#x27;./index.js&#x27;,<br></code></pre></td></tr></table></figure><h2 id="G263V">入口entry</h2><p><font style="color:rgb(53, 53, 53);">entry指示webpack使用一个或多个模块，来作为构建应用的入口，webpack会找出哪些模块和是入口起点的直接或者间接的依赖，并将其打包到一起。默认值</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;./src/index.js&lt;/font&gt;</code></p><p><strong><font style="color:rgb(53, 53, 53);">value类型：</font></strong><font style="color:rgb(53, 53, 53);">string、array、object</font></p><p><font style="color:rgb(53, 53, 53);">入口分为</font><strong><font style="color:rgb(53, 53, 53);">单入口</font></strong><font style="color:rgb(53, 53, 53);">(单页应用SPA)和</font><strong><font style="color:rgb(53, 53, 53);">多入口</font></strong><font style="color:rgb(53, 53, 53);">(多页面应用)</font></p><p><strong><font style="color:rgb(53, 53, 53);">1、单入口</font></strong><font style="color:rgb(53, 53, 53);"><br></font><font style="color:rgb(53, 53, 53);">单入口主要使用string、array为值，应用于单页应用SPA</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#x27;./index.js&#x27;,<br>// 将这两个文件以及其中所依赖的代码打包到同一个文件中<br>entry: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">这种写法默认的chunkname是main，是object的简略写法</font></p><p>object完整写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#123;<br>  main: &#x27;./index.js&#x27;,<br>&#125;,<br>entry: &#123;<br>  main: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(53, 53, 53);">2、多入口</font></strong><font style="color:rgb(53, 53, 53);"><br></font><font style="color:rgb(53, 53, 53);">多入口即有多个html，分别需要不同的打包好的js</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  entry: &#123;<br>    main: &#x27;./src/main.js&#x27;,<br>    bundle: &#x27;./src/index.js&#x27;<br>  &#125;,<br>  // 这里的[name]相当于是个占位符，值就是上面入口的key值，单入口时可以写死，不过不建议<br>  output: &#123;<br>    // 多入口需要对应多出口，通常用[name]占位，不然打包会报错<br>    filename: &#x27;[name].js&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">可以看到dist目录下打包好了 main.js 和 index.js 两个文件</font></p><p><strong><font style="color:rgb(53, 53, 53);">3、更多配置</font></strong><font style="color:rgb(53, 53, 53);"><br></font><font style="color:rgb(53, 53, 53);">打包入口不仅仅是写一个入口文件地址就可以，它还有额外的配置：</font></p><ol><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;dependOn&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 指当前入口文件所依赖的模块，这些模块必须在入口文件被加载前加载</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;filename&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 指定要输出的文件名称(优先级高于output中的filename和path)</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;import&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">: 启动时要加载的模块(入口文件地址)</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  entry: &#123;<br>    index: &#x27;./index.js&#x27;,<br>    main: &#x27;./main.js&#x27;,<br>    catalog: &#123;<br>      import: &#x27;./catalog.js&#x27;,<br>      filename: &#x27;pages/log.js&#x27;,<br>      dependOn: &#x27;main&#x27;,<br>    &#125;,<br>  &#125;,<br>  output: &#123;<br>    filename: &#x27;[name].js&#x27;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LjQ58">出口output</h2><p><font style="color:rgb(53, 53, 53);">output配置的作用是告知webpack如何向硬盘写入打包好的文件。</font></p><p><strong><font style="color:rgb(53, 53, 53);">注意：</font></strong><font style="color:rgb(53, 53, 53);">entry可以存在多个入口，但output只有一个出口配置</font></p><p><strong><font style="color:rgb(53, 53, 53);">配置项：</font></strong></p><ol><li><font style="color:rgb(53, 53, 53);">filename 打包文件名，默认main.js</font></li><li><font style="color:rgb(53, 53, 53);">path 打包文件输出路径，默认dist</font></li><li><font style="color:rgb(53, 53, 53);">clean 输出包前清空输出目录，默认false</font></li></ol><p><strong><font style="color:rgb(53, 53, 53);">1、filename</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">// [name]对应entry的key<br>output: &#123;<br>  filename: &#x27;[name].js&#x27;,<br>&#125;<br>// 使用内部chunk id占位<br>output: &#123;<br>  filename: &#x27;[id].bundle.js&#x27;,<br>  // main-0.js<br>&#125;,<br>// 使用由生成的内容产生的 hash，通常和[name]组合使用<br>output: &#123;<br>  filename: &#x27;[name]-[contenthash].js&#x27;,<br>  // main-8bc05850732530fe321c.js<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(53, 53, 53);">2、path 和 clean</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">output: &#123;<br>  path: path.resolve(__dirname, &#x27;dist&#x27;),<br>  filename: &#x27;[name]-[contenthash].js&#x27;,<br>  clean: true,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="pVq9O">工作模式mode</h1><p><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;mode&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> 用于设置webpack的工作模式，告知 webpack 使用相应模式的内置优化</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  mode: &#x27;development&#x27;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">三种工作模式：</font></p><ol><li><strong><font style="color:rgb(53, 53, 53);">production</font></strong><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">默认，生产模式，启用自动压缩代码、去除业务无关代码等</font></li><li><strong><font style="color:rgb(53, 53, 53);">development</font></strong><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">开发模式</font></li><li><strong><font style="color:rgb(53, 53, 53);">none</font></strong><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">不使用任何默认优化选项</font></li></ol><h1 id="yAZpM">打包结果分析</h1><p><font style="color:rgb(53, 53, 53);">将 mode 设为 none，查看输出文件</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plain">/******/ (() =&gt; &#123; // webpackBootstrap<br>/******/ &quot;use strict&quot;;<br>/******/ var __webpack_modules__ = ([<br>/******/ ]);<br>/************************************************************************/<br>/******/ // The module cache<br>/******/ var __webpack_module_cache__ = &#123;&#125;;<br>/******/ <br>/******/ // The require function<br>/******/ function __webpack_require__(moduleId) &#123;<br>/******/ &#125;<br>/******/ <br>/************************************************************************/<br>/******/ /* webpack/runtime/define property getters */<br>/******/ (() =&gt; &#123;<br>/******/ &#125;)();<br>/******/ <br>/******/ /* webpack/runtime/hasOwnProperty shorthand */<br>/******/ (() =&gt; &#123;<br>/******/ &#125;)();<br>/******/ <br>/******/ /* webpack/runtime/make namespace object */<br>/******/ (() =&gt; &#123;<br>/******/ &#125;)();<br>/******/ <br>/************************************************************************/<br>var __webpack_exports__ = &#123;&#125;;<br>// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.<br>(() =&gt; &#123;<br>&#125;)();<br><br>// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.<br>(() =&gt; &#123;<br>&#125;)();<br><br>/******/ &#125;)()<br>;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">先看最末尾的两个IIFE，两个入口文件 index.js 和 main.js，分别被打包为了立即执行函数，以此实现私有作用域</font></p><h1 id="WlqMk">loader</h1><p><a href="https://webpack.docschina.org/concepts/loaders/"><font style="color:rgb(53, 53, 53);">loader</font></a><font style="color:rgb(53, 53, 53);">是webpack实现前端模块化的核心，用于将指定格式的资源文件按一定格式进行转换输出</font></p><p><font style="color:rgb(53, 53, 53);">例如，可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。</font></p><p><font style="color:rgb(53, 53, 53);">官方:</font><a href="https://webpack.docschina.org/loaders/"><font style="color:#117CEE;">Loaders | webpack 中文文档</font></a></p><p><strong><font style="color:rgb(53, 53, 53);">特点：</font></strong></p><ol><li><font style="color:rgb(53, 53, 53);">单一职责：一个Loader只做一件事情，正因为职责越单一，所以Loaders的组合性强，可配置性好</font></li><li><font style="color:rgb(53, 53, 53);">loader支持链式调用，上一个loader的处理结果可以传给下一个loader接着处理，上一个Loader的参数options可以传递给下一个loader，直到最后一个loader，返回Webpack所期望的JavaScript</font></li></ol><p><font style="color:rgb(53, 53, 53);">webpack内部的default loader只能处理JavaScript，想要处理如css、ts等其它类型文件，就要安装对应的loader</font></p><p><font style="color:rgb(53, 53, 53);">loader可以分为三类：</font></p><ol><li><font style="color:rgb(53, 53, 53);">编译转换型：如css-loader</font></li><li><font style="color:rgb(53, 53, 53);">文件操作型：如file-loader</font></li><li><font style="color:rgb(53, 53, 53);">代码检查型：如eslint-loader</font></li></ol><p><strong><font style="color:rgb(53, 53, 53);">案例：</font></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 用于处理不同文件类型的模块配置</span><br><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-comment">// 使用Babel处理JavaScript和JSX文件的规则</span><br>  <span class="hljs-attr">rules</span>: [&#123;<br>    <span class="hljs-comment">// 用于匹配以.jsx或.js结尾的文件</span><br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.jsx?$/</span>,<br>    <span class="hljs-comment">// 只处理src目录下的文件</span><br>    <span class="hljs-attr">include</span>: [<br>      path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>    ],<br>    <span class="hljs-comment">// 排除node_modules目录下的文件</span><br>    <span class="hljs-attr">exclude</span>: [<br>      path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;node_modules&#x27;</span>)<br>    ],<br>    <span class="hljs-comment">// 使用babel-loader进行转译</span><br>    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>    <span class="hljs-attr">options</span>: &#123;<br>      <span class="hljs-comment">// 使用指定的Babel预设</span><br>      <span class="hljs-attr">presets</span>: [<br>        [<span class="hljs-string">&quot;@babel/env&quot;</span>, &#123;<br>          <span class="hljs-comment">// 指定目标浏览器版本为最近的两个Chrome版本</span><br>          <span class="hljs-string">&quot;targets&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;browsers&quot;</span>: <span class="hljs-string">&quot;last 2 chrome versions&quot;</span><br>          &#125;<br>        &#125;]<br>      ]<br>    &#125;<br>  &#125;]<br>&#125;,<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">Module的文档：</font><a href="https://webpack.docschina.org/configuration/module/"><font style="color:#117CEE;">Module | webpack 中文文档</font></a></p><h2 id="ijkvD">加载css</h2><p><font style="color:rgb(53, 53, 53);">查看官方文档</font><a href="https://webpack.docschina.org/guides/asset-management/#loading-css"><font style="color:rgb(53, 53, 53);">指南-管理资源-加载CSS</font></a></p><p><font style="color:rgb(53, 53, 53);">安装所需的loader</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install --save-dev style-loader css-loader<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">添加配置，</font><a href="https://webpack.docschina.org/loaders/css-loader/"><font style="color:rgb(53, 53, 53);">css-loader</font></a><font style="color:rgb(53, 53, 53);">将css文件打包为js模块，</font><a href="https://webpack.docschina.org/loaders/style-loader/"><font style="color:rgb(53, 53, 53);">style-loader</font></a><font style="color:rgb(53, 53, 53);">把 CSS 插入到 DOM 中（css-loader将css push到一个数组中，style-loader将数组中的css通过style标签追加到html-head中）</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        // 正则匹配loader要处理的资源<br>        test: /\.css$/i,<br>        // 逆序执行，从右往左<br>        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">src目录下创建index.css,打包入口中使用该css</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#x27;./index.css&#x27;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">现在样式已经生效</font></p><p><font style="color:rgb(53, 53, 53);">webpack推荐我们使用import根据JS代码的需要</font><strong><font style="color:rgb(53, 53, 53);">动态</font></strong><font style="color:rgb(53, 53, 53);">导入资源，就像刚刚import css一样，这样的代码与资源的关系，更符合模块化的依赖思想</font></p><h2 id="ampB3">加载其它资源</h2><p><font style="color:rgb(53, 53, 53);">webpack5使用</font><a href="https://webpack.docschina.org/guides/asset-modules/"><font style="color:#117CEE;">资源模块Asset Modules</font></a><font style="color:rgb(53, 53, 53);">来加载图片、字体等资源，webpack4则使用</font><a href="https://v4.webpack.docschina.org/loaders/file-loader/"><font style="color:rgb(53, 53, 53);">file-loader</font></a><font style="color:rgb(53, 53, 53);">和</font><a href="https://v4.webpack.docschina.org/loaders/url-loader/"><font style="color:rgb(53, 53, 53);">url-loader</font></a><font style="color:rgb(53, 53, 53);">等</font></p><h3 id="OBn90">file-loader</h3><p><font style="color:rgb(53, 53, 53);">安装</font><a href="https://v4.webpack.docschina.org/loaders/file-loader/"><font style="color:#117CEE;">file-loader</font></a><font style="color:rgb(53, 53, 53);">：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i file-loader -D<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import avatar from &#x27;./avatar.png&#x27; // 导入打包后资源的路径<br>const img = new Image();<br>img.src = avatar;<br>document.body.append(img);<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">配置规则</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">module: &#123;<br>  rules: [<br>    /******/<br>    &#123;<br>      test: /\.png$/,<br>      use: &#x27;file-loader&#x27;,<br>    &#125;<br>  ],<br>&#125;,<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">打包后，在dist目录下生成了871132b331c17257fcba75273b57f9fe.png，这是将文件的hash值作为了打包后的文件名，当然，这也是可以自定义的。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.png$/,<br>  use: &#123;<br>    loader: &#x27;file-loader&#x27;,<br>    options: &#123;<br>      // 默认[hash].[ext]<br>      name: &#x27;[path][name].[ext]&#x27;,<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">这样就能保留图片的原始相对路径和名称。</font></p><h3 id="vK2Dh">url-loader</h3><p><font style="color:rgb(53, 53, 53);">file-loader拷贝文件到输出目录，而</font><a href="https://v4.webpack.docschina.org/loaders/url-loader/"><font style="color:rgb(53, 53, 53);">url-loader</font></a><font style="color:rgb(53, 53, 53);">通过</font><strong><font style="color:rgb(53, 53, 53);">durl</font></strong><font style="color:rgb(53, 53, 53);">的形式表示文件</font></p><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i url-loader -D<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">durl即Data URLs，可以通过url直接去表示文件的内容，不会产生任何请求</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 一个html类型的文件内容，编码是utf-8<br>data:text/html;charset=UTF-8,&lt;h1&gt;html content&lt;/h1&gt;<br>// 如果是图片这种无法直接通过文本表示的文件，则可以将文件内容进行base64编码<br>data:image/png;base64,iDAHAidhbaIADHA...AHiDAd<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(53, 53, 53);">最佳实践：</font></strong><font style="color:rgb(53, 53, 53);">配置小文件使用url-loader，大文件则使用file-loader</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.(png|ico)$/,<br>  use: &#123;<br>    loader: &quot;url-loader&quot;,<br>    options: &#123;<br>      name: &quot;[path][name]_[hash:6].[ext]&quot;,<br>      limit: 50 * 1024, //小于50kb的进行编码<br>      // 超过这个大小，url-loader会自动调用file-loader<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; createImage &#125; from &quot;./module.js&quot;;<br>import avatar from &#x27;./avatar.png&#x27;<br>import icon from &#x27;./icon.ico&#x27;<br>document.body.append(createImage(avatar));<br>document.body.append(createImage(icon));<br></code></pre></td></tr></table></figure><h3 id="mggbT">Asset Modules</h3><p><font style="color:rgb(53, 53, 53);">webpack5使用</font><a href="https://webpack.docschina.org/guides/asset-modules/"><font style="color:#117CEE;">资源模块Asset Modules</font></a><font style="color:rgb(53, 53, 53);">来加载图片、字体等资源。</font></p><p><font style="color:rgb(53, 53, 53);">在webpack5之前，通常使用：raw-loader将文件导入为字符串，url-loader将文件作为durl内联到bundle中，file-loader将文件发送到输出目录</font></p><p><font style="color:rgb(53, 53, 53);">资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</font></p><ol><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;asset/resource&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;asset/inline&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">导出一个资源的 data URI。之前通过使用 url-loader 实现。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;asset/source&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">导出资源的源代码。之前通过使用 raw-loader 实现。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;asset&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。</font></li></ol><p><strong><font style="color:rgb(53, 53, 53);">案例：</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.(png|jpg|svg|gif|ico)$/,<br>  // type选择类型<br>  type: &quot;asset/resource&quot;,<br>  // 通过generator属性进行配置<br>  generator: &#123;<br>    filename: &quot;img/[name]_[hash:6][ext]&quot;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">asset/inline&#123;<br>  test: /\.(png|jpg|svg|gif|ico)$/,<br>  type: &quot;asset/inline&quot;,<br>&#125;,<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">最佳实践：type设为asset，添加一个parser属性，并且制定dataUrl的条件，添加maxSize属性；</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.(png|jpg|svg|gif|ico)$/,<br>  type: &quot;asset&quot;,<br>  generator: &#123;<br>    filename: &quot;img/[name]_[hash:6][ext]&quot;,<br>  &#125;,<br>  parser: &#123;<br>    dataUrlCondition: &#123;<br>      maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>    &#125;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="jcGSI">babel-loader</h2><p><font style="color:rgb(53, 53, 53);">webpack由于打包需要，会去处理import和export，但对于其它ES6新特性，则不会去做兼容处理</font></p><p><font style="color:rgb(53, 53, 53);">如果需要将代码中的ES6进行转换，则需要</font><a href="https://webpack.docschina.org/loaders/babel-loader/"><font style="color:rgb(53, 53, 53);">babel-loader</font></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 安装babel-loader及其依赖的核心库和特性转换集合<br>npm install -D babel-loader @babel/core @babel/preset-env<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(53, 53, 53);">注意：</font></strong><font style="color:rgb(53, 53, 53);">babel只是转换JS代码的一个平台，还需要用其它的插件，如@babel&#x2F;preset-env，通过该平台来转换ES6特性</font></p><p><font style="color:rgb(53, 53, 53);">进行配置：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">module: &#123;<br>  rules: [<br>    &#123;<br>      test: /\.js$/i,<br>      include: [<br>        path.resolve(__dirname, &#x27;src&#x27;)<br>      ],<br>      exclude: [<br>        path.resolve(__dirname, &#x27;node_modules&#x27;)<br>      ],<br>      loader: &#x27;babel-loader&#x27;,<br>      options: &#123;<br>        presets: [&quot;@babel/preset-env&quot;]<br>      &#125;<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">开启ESM转CommonJS(会导致Tree Shaking失效，不推荐开启)</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">presets: [<br>  [&quot;@babel/preset-env&quot;, &#123;<br>    modules: &quot;commonjs&quot;, // 开启ESM转CommonJS，默认：&quot;auto&quot;<br>  &#125;]<br>]<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">这样就完成了简单的ES6转换，更完善的使用core-js@3兼容，后面再说吧。</font></p><h2 id="Pmsfh">资源加载方式</h2><p><font style="color:rgb(53, 53, 53);">除了在js文件中使用import加载资源，webpack还会自动处理其它加载资源的方式，如css文件中的url()、@import</font></p><p><font style="color:rgb(53, 53, 53);">例如：当css-loader在处理css文件时遇到url()时，会找到符合的规则对所需的资源进行处理，如使用asset&#x2F;resource对图片资源处理</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">/* main.css */<br>body&#123;<br>  background-image: url(avatar.png);<br>  background-size: auto;<br>&#125;<br><br>/* index.css */<br>@import &#x27;./main.css&#x27;;<br>body&#123;<br>  background-color: #ccc;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zM3TD">开发loader</h2><p><font style="color:rgb(53, 53, 53);">尝试开发一个markdown-loader，深入了解loader的工作过程</font></p><p><strong><font style="color:rgb(53, 53, 53);">文档：</font></strong><a href="https://www.webpackjs.com/contribute/writing-a-loader/"><font style="color:rgb(53, 53, 53);">编写loader</font></a></p><p><strong><font style="color:rgb(53, 53, 53);">功能：</font></strong><font style="color:rgb(53, 53, 53);">将模块中所需的markdown资源转为html内容导入</font></p><p><font style="color:rgb(53, 53, 53);">在根目录新建</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;markdown-loader.js&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">，一个最简单的loader是一个函数，接收传入的资源内容，若该loader是最后一个执行的，返回结果必须是JS代码</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = source =&gt; &#123;<br>  console.log(source)<br>  return &#x27;console.log(source)&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">使用该loader</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.md$/i,<br>  use: path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">在模块中导入markdown，webpack只会处理模块所依赖的资源</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">import md from &#x27;./01.md&#x27;<br>console.log(md)<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">打包时控制台输出了markdown的内容。查看打包结果，loader返回的js也在其中，被一个IIFE包裹。</font></p><p><font style="color:rgb(53, 53, 53);">下面继续完成功能：</font></p><p><font style="color:rgb(53, 53, 53);">安装解析markdown内容的模块，使用</font><a href="https://www.npmjs.com/package/marked"><font style="color:rgb(53, 53, 53);">marked</font></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i marked -D<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">修改 </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;markdown-loader.js&lt;/font&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const marked = require(&#x27;marked&#x27;);<br><br>module.exports = source =&gt; &#123;<br>  console.log(source)<br>  const html = marked.parse(source)<br>  console.log(html)<br>  return &#x27;console.log(source)&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">输出如下，现在loader已经能解析markdown文件了</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 简介<br>这是一个**markdown**<br>&lt;h1&gt;简介&lt;/h1&gt;<br>&lt;p&gt;这是一个&lt;strong&gt;markdown&lt;/strong&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">完善loader，将html暴露给模块使用，会作为模块中import markdown文件的default值</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const marked = require(&#x27;marked&#x27;);<br><br>module.exports = source =&gt; &#123;<br>  const html = marked.parse(source)<br>  // html中存在一些字符，使用JSON.stringify进行转译<br>  return `export default $&#123;JSON.stringify(html)&#125;`<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">现在，markdown-loader就完成了，模块导入的就是解析好的html内容</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import md from &#x27;./01.md&#x27;<br>console.log(md)<br>// &lt;h1&gt;简介&lt;/h1&gt;<br>// &lt;p&gt;这是一个&lt;strong&gt;markdown&lt;/strong&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">当然，markdown-loader也可以直接返回解析好的html内容，再交给loader管道中下一个loader进行处理，webpack只要求最后一个loader返回的需要是JS代码</font></p><p><font style="color:rgb(53, 53, 53);">处理html就需要安装html-loader，</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i html-loader -D&lt;/font&gt;</code></p><p><font style="color:rgb(53, 53, 53);">修改代码：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.md$/i,<br>  use: [<br>    &#x27;html-loader&#x27;,<br>    path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const marked = require(&#x27;marked&#x27;);<br><br>module.exports = source =&gt; &#123;<br>  const html = marked.parse(source)<br>  return html<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">实现的功能也是一样的</font></p><h1 id="BCeWv">plugin</h1><p><font style="color:rgb(53, 53, 53);">loader用于处理资源的加载，而插件</font><a href="https://webpack.docschina.org/concepts/plugins/"><font style="color:rgb(53, 53, 53);">plugin</font></a><font style="color:rgb(53, 53, 53);">用于实现各种</font><strong><font style="color:rgb(53, 53, 53);">自动化</font></strong><font style="color:rgb(53, 53, 53);">操作，如压缩代码、替换内容、处理资源</font></p><p><font style="color:rgb(53, 53, 53);">官方</font><a href="https://webpack.docschina.org/plugins/"><font style="color:rgb(53, 53, 53);">plugins</font></a></p><h2 id="RQuMG">打包分析插件</h2><p><a href="https://www.npmjs.com/package/webpack-bundle-analyzer"><font style="color:rgb(53, 53, 53);">webpack-bundle-analyzer</font></a><font style="color:rgb(53, 53, 53);">是一个打包分析插件，使用交互式可缩放树形地图可视化，并输出文件的大小。可以方便开发人员检查打包后的文件拆分、分析文件大小。</font></p><p><font style="color:rgb(53, 53, 53);">每次打包时，会自动打开浏览器，访问</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;127.0.0.1:8888&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">查看项目结构</font></p><p><font style="color:rgb(53, 53, 53);">安装：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i webpack-bundle-analyzer -D&lt;/font&gt;</code></p><p><font style="color:rgb(53, 53, 53);">webpack中，插件都需要导入后使用，且通常插件导出的都是一个class，需要new实例。配置项plugins是一个数组，保存插件的实例。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;);<br>/*****/<br>plugins: [<br>  new BundleAnalyzerPlugin(),<br>],<br></code></pre></td></tr></table></figure><h2 id="RKMW1">自动生成HTML</h2><p><font style="color:rgb(53, 53, 53);">手动在根目录创建index.html，并配置打包好的JS等资源的路径，这样硬编码过于麻烦且易出错</font></p><p><font style="color:rgb(53, 53, 53);">可以使用</font><a href="https://webpack.docschina.org/plugins/html-webpack-plugin/"><font style="color:rgb(53, 53, 53);">html-webpack-plugin</font></a><font style="color:rgb(53, 53, 53);">简化HTML文件的创建，自动引入打包好的JS模块，这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。</font></p><p><font style="color:rgb(53, 53, 53);">安装：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i html-webpack-plugin --D&lt;/font&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)<br>plugins: [<br>  new HtmlWebpackPlugin(&#123;<br>    template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>    inject: &#x27;body&#x27;, // 插入到body<br>    filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>    title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>    minify: true, // 压缩<br>  &#125;),<br>]<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">修改根目录下的index.html，使其作为一个模板</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;!-- 去掉js文件的引入，插件会自动引入 --&gt;<br>  &lt;!-- &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt; --&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">查看打包后的index.html</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;webpack测试&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;script defer src=&quot;main_0cc0be.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">html-webpack-plugin还有其它的配置项，查看官方仓库文档：</font><a href="https://github.com/jantimon/html-webpack-plugin#options"><font style="color:rgb(53, 53, 53);">配置项</font></a></p><p><font style="color:rgb(53, 53, 53);">若是多页面、多个html文件，则创建多个插件实例加入到plugins数组中</font></p><h2 id="JC5om">拷贝文件</h2><p><font style="color:rgb(53, 53, 53);">通常项目中还有一些无需打包的静态文件存放于public目录，这些资源同样需要输出到dist</font></p><p><a href="https://webpack.docschina.org/plugins/copy-webpack-plugin/"><font style="color:rgb(53, 53, 53);">copy-webpack-plugin</font></a></p><p><font style="color:rgb(53, 53, 53);">安装：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i copy-webpack-plugin -D&lt;/font&gt;</code></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);<br>plugins: [<br>  new CopyPlugin(&#123;<br>    patterns: [<br>      // 复制public文件夹内的文件到&#123;output&#125;中<br>      &#123; from: path.resolve(__dirname, &#x27;public&#x27;), to: &quot;&quot; &#125;,<br>    ],<br>  &#125;),<br>]<br></code></pre></td></tr></table></figure><h2 id="KjyCM">开发plugin</h2><p><font style="color:rgb(53, 53, 53);">相较于loader只作用于模块加载，plugin的作用范围更广。plugin通过常见的</font><strong><font style="color:rgb(53, 53, 53);">钩子机制</font></strong><font style="color:rgb(53, 53, 53);">实现，就像Vue生命周期提供的钩子一样。</font></p><p><font style="color:rgb(53, 53, 53);">webpack提供了很多打包过程中的</font><strong><font style="color:rgb(53, 53, 53);">钩子</font></strong><font style="color:rgb(53, 53, 53);">，plugin向这些钩子上</font><strong><font style="color:rgb(53, 53, 53);">挂载</font></strong><font style="color:rgb(53, 53, 53);">任务，并获取</font><strong><font style="color:rgb(53, 53, 53);">上下文</font></strong><font style="color:rgb(53, 53, 53);">，来实现对资源的操作等功能。</font></p><p><font style="color:rgb(53, 53, 53);">钩子相关文档：</font><a href="https://webpack.docschina.org/api/compiler-hooks/"><font style="color:rgb(53, 53, 53);">compiler-hooks</font></a></p><p><font style="color:rgb(53, 53, 53);">webpack要求plugin必须是一个函数，或一个</font><strong><font style="color:rgb(53, 53, 53);">包含apply方法</font></strong><font style="color:rgb(53, 53, 53);">的对象，通常是定义一个包含apply方法的类</font></p><p><font style="color:rgb(53, 53, 53);">新建</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;myPlugin.js&lt;/font&gt;</code></p><p><strong>js</strong></p><p><font style="color:rgb(53, 53, 53);">现在开发一个用于清除webpack生成的</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;/******/&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">注释，以方便阅读打包后的JS代码</font></p><p><font style="color:rgb(53, 53, 53);">明确了功能，考虑需要用到哪些钩子，显然，清除注释要在输出文件前执行，对要输出的内容进行处理。</font><a href="https://webpack.docschina.org/api/compiler-hooks/#emit"><font style="color:rgb(53, 53, 53);">emit</font></a><font style="color:rgb(53, 53, 53);">钩子符合需求，这个钩子在输出 asset 到 output 目录之前执行。</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default class &#123;<br>  // apply接收一个compiler对象参数<br>  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数<br>  apply(compiler) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default class &#123;<br>  // apply接收一个compiler对象参数<br>  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数<br>  apply(compiler) &#123;<br>    // 通过hooks属性访问钩子，tap方法注册钩子函数<br>    // tap方法第一个参数为plugin名，第二个参数是接收了compilation对象的钩子函数<br>    compiler.hooks.emit.tap(&#x27;MyPlugin&#x27;, compilation =&gt; &#123;<br>      // compilation是此次打包过程中的上下文，存放了打包过程的信息和结果<br>      // compilation.assets获取即将输出的资源文件信息<br>      for (const name in compilation.assets) &#123;<br>        console.log(name); // 输出文件名<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">使用插件</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const MyPlugin = require(&#x27;./myPlugin.js&#x27;);<br>plugins: [<br>  new MyPlugin(),<br>]<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">输出：</font></p><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">main_28990539038fea465479.js<br>img/avatar_871132b331c17257fcba.png<br>img/icon_36fa45932bf38a34e9af.ico<br>favicon.ico<br>index.html<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">插件已经能读取到打包后的文件名，接下来通过正则替换来处理JS文件</font></p><p><strong>js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> &#123;<br>  #<span class="hljs-title function_">isJSFile</span>(<span class="hljs-params">filename</span>) &#123;<br>    <span class="hljs-comment">// 使用正则表达式检查文件名是否以 .js 结尾</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\.js$/i</span>.<span class="hljs-title function_">test</span>(filename);<br>  &#125;<br><br>  <span class="hljs-comment">// apply接收一个compiler对象参数</span><br>  <span class="hljs-comment">// 这个对象包含了打包过程中所有信息以及用于注册钩子函数</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// 通过hooks属性访问钩子，tap方法注册钩子函数</span><br>    <span class="hljs-comment">// tap方法第一个参数为plugin名，第二个参数是接收了compilation对象的钩子函数</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function"><span class="hljs-params">compilation</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// compilation是此次打包过程中的上下文，存放了打包过程的信息和结果</span><br>      <span class="hljs-comment">// compilation.assets获取即将输出的资源文件信息</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> compilation.<span class="hljs-property">assets</span>) &#123;<br>        <span class="hljs-comment">// console.log(name);</span><br>        <span class="hljs-comment">// 使用source方法获取文件内容</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">isJSFile</span>(name))&#123;<br>          <span class="hljs-keyword">let</span> content = compilation.<span class="hljs-property">assets</span>[name].<span class="hljs-title function_">source</span>();<br>          <span class="hljs-comment">// 使用正则去除webpack生成的/******/</span><br>          content = content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/\*&#123;3,&#125;\//g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>          <span class="hljs-comment">// 覆盖文件信息</span><br>          compilation.<span class="hljs-property">assets</span>[name] = &#123;<br>            <span class="hljs-comment">// 覆盖内容</span><br>            <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> content,<br>            <span class="hljs-comment">// webpack要求指定大小</span><br>            <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> content.<span class="hljs-property">length</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">现在，打包的JS文件内容已经去除了</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;/******/&lt;/font&gt;</code></p><p><font style="color:rgb(53, 53, 53);">但控制台有警告信息：</font></p><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(node:76292) [DEP_WEBPACK_COMPILATION_ASSETS] DeprecationWarning: Compilation.assets will be frozen in future, all modifications are deprecated.<br>BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.<br>        Do changes to assets earlier, e. g. in Compilation.hooks.processAssets.<br>        Make sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.<br>(Use `node --trace-deprecation ...` to show where the warning was created)<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">这是因为Webpack5将在未来版本冻结</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;compilation.assets&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">，需在</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;compiler.hooks.thisCompilation&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">钩子中使用 Compilation 中的 processAssets hook 来对资源进行再处理</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = class &#123;<br>  #isJSFile(filename) &#123;<br>    // 使用正则表达式检查文件名是否以 .js 结尾<br>    return /\.js$/i.test(filename);<br>  &#125;<br><br>  // apply接收一个compiler对象参数<br>  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数<br>  apply(compiler) &#123;<br>    // 使用thisCompilation钩子，在 compilation 对象创建时执行一些自定义逻辑<br>    compiler.hooks.thisCompilation.tap(&#x27;MyPlugin&#x27;, compilation =&gt; &#123;<br>      // processAssets钩子用于在 webpack 编译完成后，但在最终资源输出之前，处理资源文件的阶段执行插件代码<br>      compilation.hooks.processAssets.tap(<br>        &#123;<br>          name: &#x27;MyPlugin&#x27;,<br>          // https://webpack.docschina.org/api/compilation-hooks/#list-of-asset-processing-stages<br>          stage: compilation.PROCESS_ASSETS_STAGE_OPTIMIZE, // 以通用的方式优化已有asset<br>        &#125;,<br>        (assets) =&gt; &#123;<br>          for (const name in assets) &#123;<br>            if (this.#isJSFile(name)) &#123;<br>              // 使用正则表达式去除块注释<br>              const content = assets[name].source().replace(/\/\*&#123;3,&#125;\//g, &#x27;&#x27;);<br>              // 覆盖文件信息<br>              assets[name] = &#123;<br>                source: () =&gt; content,<br>                size: () =&gt; content.length,<br>              &#125;;<br>            &#125;<br>          &#125;<br>        &#125;<br>      );<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="hyJBV">优化开发过程</h1><p><font style="color:rgb(53, 53, 53);">项目打包过程已经自动化了，但开发过程仍然在手动操作</font></p><p><font style="color:rgb(53, 53, 53);">编写代码-&gt;命令打包-&gt;运行应用-&gt;刷新浏览器，这个繁琐的过程也需要自动化，以提高开发效率</font></p><p><font style="color:rgb(53, 53, 53);">提出下面的需求：</font></p><ol><li><font style="color:rgb(53, 53, 53);">以 HTTP Server 运行，而不是打开文件浏览</font></li><li><font style="color:rgb(53, 53, 53);">自动编译 + 自动刷新</font></li><li><font style="color:rgb(53, 53, 53);">提供 Source Map 支持，方便调试</font></li></ol><h2 id="SwxYz">watch工作模式</h2><p><font style="color:rgb(53, 53, 53);">处于watch工作模式时，webpack会监听文件变化，自动重新打包</font></p><p><font style="color:rgb(53, 53, 53);">添加watch配置：</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  watch: true,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MMMYw">DevServer</h2><p><a href="https://webpack.docschina.org/configuration/dev-server"><font style="color:rgb(53, 53, 53);">webpack dev server</font></a><font style="color:rgb(53, 53, 53);">提供了HTTP Server，集成了自动编译和自动刷新浏览器的功能。</font></p><p><font style="color:rgb(53, 53, 53);">该插件会将将打包结果暂时存放于内存，而不输出于硬盘，以提高性能。</font></p><p><font style="color:rgb(53, 53, 53);">安装：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i webpack-dev-server -D&lt;/font&gt;</code></p><p><strong>js</strong></p><p>添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>    // 启用Gzip<br>    compress: true,<br>    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>     // 使用static配置从目录提供静态文件的选项，默认public<br>    static: &#123;<br>      // 告诉服务器从哪里提供内容<br>      directory: path.join(__dirname, &#x27;public&#x27;),<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">添加命令脚本</font></p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;scripts&quot;: &#123;<br>    &quot;serve&quot;: &quot;webpack serve&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">使用命令运行</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm run serve&lt;/font&gt;</code></p><h2 id="d1fjn">代理API服务</h2><p><font style="color:rgb(53, 53, 53);">前后端同源部署时，本地开发在请求api时可能有cors问题，可以使用开发服务器代理api请求，服务器间通信就不存在cors了</font></p><p><font style="color:rgb(53, 53, 53);">DevServer就支持</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;proxy&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">配置api代理，</font><a href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy"><font style="color:rgb(53, 53, 53);">文档</font></a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">devServer: &#123;<br>  proxy: &#123;<br>    // 代理api路径<br>    &#x27;/api&#x27;: &#123;<br>      // localhost:8080/api/user -&gt; api.github.com/api/user<br>      target: &#x27;https://api.github.com&#x27;,<br>      // 请求路径重写 /api/user -&gt; /user<br>      pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>      // 将 host 请求头修改为 target 的 URL<br>      changeOrigin: true,<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="nI3ag">Source Map</h2><p><font style="color:rgb(53, 53, 53);">前端工程化后，源代码和运行代码几乎完全不同，调试和报错都是基于运行代码，调试源代码就成了问题</font></p><p><font style="color:rgb(53, 53, 53);">Source Map用于映射源代码和运行代码之间的关系</font></p><p><font style="color:rgb(53, 53, 53);">一个Source Map的组成：</font></p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;version&quot;: 3, // 当前Map使用的Source Map标准版本<br>  &quot;sources&quot;: [&quot;main.js&quot;], // 记录源文件的名称，可以是多个文件<br>  &quot;names&quot;: [&quot;global&quot;,/****/], // 源代码使用的成员名称，如变量的原名<br>  &quot;mappings&quot;: &quot;;/****/&quot; // 核心，记录源码和运行代码一些字符的映射关系<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">通过一行特定格式的注释引入Source Map</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">//# sourceMappingURL=main.map<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">如果Source Map不起作用，需在浏览器控制台-设置-偏好设置中启用JavaScript源代映射</font></p><p><font style="color:rgb(53, 53, 53);">使用</font><a href="https://webpack.docschina.org/configuration/devtool/"><font style="color:rgb(53, 53, 53);">Devtool</font></a><font style="color:rgb(53, 53, 53);">在webpack中配置Source Map：</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  devtool: &#x27;source-map&#x27;, // 值为Source Map工作模式<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">相关文章：</font><a href="https://juejin.cn/post/6960941899616092167"><font style="color:rgb(53, 53, 53);">一文搞懂SourceMap以及webpack devtool</font></a></p><p><font style="color:rgb(53, 53, 53);">Source Map工作模式：</font></p><p><strong>text</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map<br></code></pre></td></tr></table></figure><ol><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;inline-&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> 将SourceMap内联到原始文件中，而不是创建一个单独的文件。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;hidden-&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">仍然会生成.map文件，但是打包后的代码中没有sourceMappingURL，即浏览器不会加载.map文件，控制台中看不到源代码。Map生成后只供服务端分析使用，前端将出错的行列传给服务端。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;eval-&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">通过eval包裹每个模块打包后代码以及对应生成的SourceMap（不实际生成），因为eval中为字符串形式，进行字符串处理会提升rebuild的速度。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;nosources-&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">不包含 sourcesContent 内容，调试时只能看到文件信息和行信息，无法看到源码。</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;cheap-[module-]&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">只定位到源码所在的行，不定位至具体的列，构建速度有所提升。如果只用 cheap ，显示的是 loader 编译之后的源代码，加上 module 后会显示编译之前的源代码。</font></li></ol><p><font style="color:rgb(53, 53, 53);">如何选择devtool：</font></p><ol><li><strong><font style="color:rgb(53, 53, 53);">production：</font></strong><font style="color:rgb(53, 53, 53);">none，source-map，hidden-source-map，nosources-source-map</font></li><li><strong><font style="color:rgb(53, 53, 53);">development：</font></strong><font style="color:rgb(53, 53, 53);">eval，eval-source-map，eval-cheap-source-map，eval-cheap-module-source-map</font></li></ol><p><font style="color:rgb(53, 53, 53);">开发环境下，需要频繁的修改代码，更多地考虑的开发效率和调试效率，所以更多关注 performance 中 rebuild 的性能。生产环境下，不必过多关注打包性能，主要考虑 quality 代码的保护性、出错的定位速度已经安全性</font></p><h2 id="Zfh6G">热替换HMR</h2><p><font style="color:rgb(53, 53, 53);">监视模块变动后重新打包、自动刷新会导致页面的一些状态丢失（输入的文本内容），如果能让页面不刷新，模块也能更新，这样的开发体验会好很多</font></p><p><font style="color:rgb(53, 53, 53);">模块热替换</font><a href="https://webpack.docschina.org/configuration/dev-server/#devserverhot"><font style="color:rgb(53, 53, 53);">HMR</font></a><font style="color:rgb(53, 53, 53);">(Hot Module Replacement)可以实现无刷更新模块，</font><a href="https://juejin.cn/post/6870258201384714253"><font style="color:rgb(53, 53, 53);">「webpack 核心特性」模块热替换(HMR)</font></a></p><p><font style="color:rgb(53, 53, 53);">HMR作用：</font></p><ol><li><font style="color:rgb(53, 53, 53);">保留在完全重新加载页面期间丢失的应用程序状态。</font></li><li><font style="color:rgb(53, 53, 53);">只更新变更内容，以节省宝贵的开发时间。</font></li><li><font style="color:rgb(53, 53, 53);">在源代码中 CSS&#x2F;JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</font></li></ol><p><strong>js</strong></p><p>使用HMR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">devServer: &#123;<br>  hot: true, // 开启HMR<br>  // 在构建失败时不刷新页面作为回退<br>  // hot: &#x27;only&#x27;,<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">从webpack-dev-server v4开始，HMR已默认启用。会自动应用HotModuleReplacementPlugin插件</font></p><p><strong><font style="color:rgb(53, 53, 53);">注意：</font></strong><font style="color:rgb(53, 53, 53);">HMR并不是开箱即用，还需要使用</font><a href="https://webpack.docschina.org/api/hot-module-replacement/"><font style="color:rgb(53, 53, 53);">HMR-API</font></a><font style="color:rgb(53, 53, 53);">手动处理模块的热替换逻辑，否则还会自动刷新，部分loader和插件如style-loader已经处理好了css的热更新逻辑，在Vue等框架下开发，框架本身也处理好了HMR</font></p><p><font style="color:rgb(53, 53, 53);">使用</font><a href="https://webpack.docschina.org/api/hot-module-replacement/"><font style="color:rgb(53, 53, 53);">HMR-API</font></a><font style="color:rgb(53, 53, 53);">手动处理JS模块热替换：</font></p><p><strong>js</strong></p><p>通常在入口模块统一做处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (module.hot) &#123;<br>  module.hot.accept(&#x27;./library.js&#x27;, function() &#123;<br>    // 对更新过的 library 模块做些事情...<br>  &#125;);<br>&#125;<br>// or<br>if (import.meta.webpackHot) &#123;<br>  import.meta.webpackHot.accept(&#x27;./library.js&#x27;, function () &#123;<br>    // Do something with the updated library module…<br>  &#125;);<br>&#125;<br><br>// accept方法<br>module.hot.accept(<br>  dependencies, // 可以是一个字符串或字符串数组<br>  callback // 用于在模块更新后触发的函数<br>  errorHandler // (err, &#123;moduleId, dependencyId&#125;) =&gt; &#123;&#125;<br>);<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">案例：</font></p><p><strong>js</strong></p><p>src&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; appendMarkdown &#125; from &quot;./module.js&quot;;<br>import md from &#x27;./01.md&#x27;<br>let mde = appendMarkdown(md);<br><br>if (module.hot) &#123;<br>  // 处理01.md的更新<br>  module.hot.accept(&#x27;./01.md&#x27;, () =&gt; &#123;<br>    // 热重载，先移除原来的<br>    document.body.removeChild(mde);<br>    // 再创建新的<br>    mde = appendMarkdown(md);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">热重载的需要根据自己的业务逻辑去实现，没有通用的方法，这也是webpack没有提供JS模块HMR的原因。</font></p><p><font style="color:rgb(53, 53, 53);">打包后，HMR相关代码会被自动去除</font></p><h1 id="HfM4W">不同环境的配置</h1><p><font style="color:rgb(53, 53, 53);">不同的环境需要不同的webpack配置，主要是区分生产和开发环境，</font><a href="https://webpack.docschina.org/configuration/"><font style="color:rgb(53, 53, 53);">文档</font></a></p><p><font style="color:rgb(53, 53, 53);">区分环境有两种方式</font></p><ol><li><font style="color:rgb(53, 53, 53);">配置函数中判断env，返回不同的配置信息</font></li><li><font style="color:rgb(53, 53, 53);">创建多个配置文件对应不同的环境（推荐）</font></li></ol><h2 id="c4N7I">判断env</h2><p><font style="color:rgb(53, 53, 53);">webpack配置导出一个函数而非对象，</font><a href="https://webpack.docschina.org/configuration/configuration-types/#exporting-a-function"><font style="color:rgb(53, 53, 53);">导出函数</font></a><font style="color:rgb(53, 53, 53);">，</font><a href="https://webpack.docschina.org/guides/environment-variables/"><font style="color:rgb(53, 53, 53);">环境变量</font></a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs plain">/**<br> * <br> * @param &#123;string&#125; env 环境名参数<br> * @param &#123;array&#125; argv cli传递的所有参数<br> * @returns &#123;object&#125; webpack配置<br> */<br>module.exports = (env, argv) =&gt; &#123;<br>  console.log(env);<br>  // 默认的通用配置<br>  const config = &#123;<br>    mode: &#x27;none&#x27;,<br>    // 生成源映射以方便调试<br>    devtool: &#x27;eval-source-map&#x27;,<br>    // watch: true,<br>    context: path.resolve(__dirname, &#x27;src&#x27;),<br>    entry: &#123;<br>      main: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>    &#125;,<br>    output: &#123;<br>      path: path.resolve(__dirname, &#x27;dist&#x27;),<br>      filename: &#x27;[name]_[contenthash].js&#x27;,<br>      clean: true,<br>    &#125;,<br>    module: &#123;<br>      rules: [<br>        &#123;<br>          // 正则匹配loader要处理的资源<br>          test: /\.css$/i,<br>          // 逆序执行，从右往左<br>          use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],<br>        &#125;,<br>        &#123;<br>          test: /\.(png|jpg|svg|gif|ico)$/,<br>          type: &quot;asset&quot;,<br>          generator: &#123;<br>            filename: &quot;img/[name]_[contenthash][ext]&quot;,<br>          &#125;,<br>          parser: &#123;<br>            dataUrlCondition: &#123;<br>              maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>            &#125;,<br>          &#125;,<br>        &#125;,<br>        &#123;<br>          test: /\.js$/i,<br>          include: [<br>            path.resolve(__dirname, &#x27;src&#x27;)<br>          ],<br>          exclude: [<br>            path.resolve(__dirname, &#x27;node_modules&#x27;)<br>          ],<br>          loader: &#x27;babel-loader&#x27;,<br>          options: &#123;<br>            presets: [&quot;@babel/preset-env&quot;]<br>          &#125;<br>        &#125;,<br>        &#123;<br>          test: /\.md$/i,<br>          use: path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>        &#125;<br>      ],<br>    &#125;,<br>    plugins: [<br>      new HtmlWebpackPlugin(&#123;<br>        template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>        inject: &#x27;body&#x27;, // 插入到body<br>        filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>        title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>        minify: true, // 压缩<br>      &#125;),<br>    ],<br>    // 配置开发服务器<br>    devServer: &#123;<br>      // 服务器主机<br>      host: &#x27;localhost&#x27;,<br>      // 服务器端口<br>      port: 8080,<br>      // 使用HMR<br>      hot: true,<br>      // 启用Gzip<br>      compress: true,<br>      // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>      // 使用static配置从目录提供静态文件的选项，默认public<br>      static: &#123;<br>        // 告诉服务器从哪里提供内容<br>        directory: path.join(__dirname, &#x27;public&#x27;),<br>      &#125;,<br>      proxy: &#123;<br>        // 代理api路径<br>        &#x27;/api&#x27;: &#123;<br>          // localhost:8080/api/user -&gt; api.github.com/api/user<br>          target: &#x27;https://api.github.com&#x27;,<br>          // 请求路径重写 /api/user -&gt; /user<br>          pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>          // 将 host 请求头修改为 target 的 URL<br>          changeOrigin: true,<br>        &#125;,<br>      &#125;,<br>    &#125;<br>  &#125;<br>  // 判断环境，修改配置<br>  if (env.production) &#123; // 生产环境<br>    config.mode = &#x27;production&#x27;;<br>    config.devtool = false;<br>    config.plugins = [<br>      ...config.plugins,<br>      new CopyPlugin(&#123;<br>        patterns: [<br>          // 复制public文件夹内的文件到&#123;output&#125;中<br>          &#123; from: path.resolve(__dirname, &#x27;public&#x27;), to: &quot;&quot; &#125;,<br>        ],<br>      &#125;),<br>    ];<br>  &#125; else if (env.development) &#123; // 开发环境<br>    config.mode = &#x27;development&#x27;;<br>  &#125;<br><br>  return config<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npx webpack --env production<br>npx webpack --env development<br></code></pre></td></tr></table></figure><h2 id="M29q7">多配置文件</h2><p><font style="color:rgb(53, 53, 53);">若项目较大配置复杂，就不适合用判断env的方式，写多个配置文件更清晰明了，</font><a href="https://webpack.docschina.org/guides/production/"><font style="color:rgb(53, 53, 53);">文档</font></a></p><p><font style="color:rgb(53, 53, 53);">通常有三个配置文件：</font></p><ol><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;webpack.common.js&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">通用配置文件，写一些项目的通用基础配置</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;webpack.dev.js&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">开发配置文件</font></li><li><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;webpack.prod.js&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);"> </font><font style="color:rgb(53, 53, 53);">生产配置文件</font></li></ol><p><font style="color:rgb(53, 53, 53);">安装</font><a href="https://www.npmjs.com/package/webpack-merge"><font style="color:rgb(53, 53, 53);">webpack-merge</font></a><font style="color:rgb(53, 53, 53);">合并配置对象：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i webpack-merge -D&lt;/font&gt;</code></p><p><strong>js</strong></p><p>webpack.common.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs plain">const path = require(&#x27;path&#x27;);<br>const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);<br><br>module.exports = &#123;<br>  mode: &#x27;none&#x27;,<br>  // 生成源映射以方便调试<br>  devtool: &#x27;source-map&#x27;,<br>  // watch: true,<br>  context: path.resolve(__dirname, &#x27;src&#x27;),<br>  entry: &#123;<br>    main: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>  &#125;,<br>  output: &#123;<br>    path: path.resolve(__dirname, &#x27;dist&#x27;),<br>    filename: &#x27;[name]_[contenthash].js&#x27;,<br>    clean: true,<br>  &#125;,<br>  //警告 webpack 的性能提示<br>  performance: &#123;<br>    hints: &#x27;warning&#x27;,<br>    //入口起点的最大体积<br>    maxEntrypointSize: 1024 * 1024 * 10,<br>    //生成文件的最大体积<br>    maxAssetSize: 1024 * 1024,<br>    //只给出 js 文件的性能提示<br>    assetFilter: function (assetFilename) &#123;<br>      return /\.js$/.test(assetFilename);<br>    &#125;<br>  &#125;,<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        // 正则匹配loader要处理的资源<br>        test: /\.css$/i,<br>        // 逆序执行，从右往左<br>        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],<br>      &#125;,<br>      &#123;<br>        test: /\.(png|jpg|svg|gif|ico)$/,<br>        type: &quot;asset&quot;,<br>        generator: &#123;<br>          filename: &quot;img/[name]_[contenthash][ext]&quot;,<br>        &#125;,<br>        parser: &#123;<br>          dataUrlCondition: &#123;<br>            maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        test: /\.js$/i,<br>        include: [<br>          path.resolve(__dirname, &#x27;src&#x27;)<br>        ],<br>        exclude: [<br>          path.resolve(__dirname, &#x27;node_modules&#x27;)<br>        ],<br>        loader: &#x27;babel-loader&#x27;,<br>        options: &#123;<br>          presets: [&quot;@babel/preset-env&quot;]<br>        &#125;<br>      &#125;,<br>      &#123;<br>        test: /\.md$/i,<br>        use: path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>      &#125;<br>    ],<br>  &#125;,<br>  plugins: [<br>    new HtmlWebpackPlugin(&#123;<br>      template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>      inject: &#x27;body&#x27;, // 插入到body<br>      filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>      title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>      minify: true, // 压缩<br>    &#125;),<br>  ],<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>    // 使用HMR<br>    hot: true,<br>    // 启用Gzip<br>    compress: true,<br>    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>    // 使用static配置从目录提供静态文件的选项，默认public<br>    static: &#123;<br>      // 告诉服务器从哪里提供内容<br>      directory: path.join(__dirname, &#x27;public&#x27;),<br>    &#125;,<br>    proxy: &#123;<br>      // 代理api路径<br>      &#x27;/api&#x27;: &#123;<br>        // localhost:8080/api/user -&gt; api.github.com/api/user<br>        target: &#x27;https://api.github.com&#x27;,<br>        // 请求路径重写 /api/user -&gt; /user<br>        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>        // 将 host 请求头修改为 target 的 URL<br>        changeOrigin: true,<br>      &#125;,<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>webpack.dev.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const common = require(&quot;./webpack.common&quot;);<br>const &#123; merge &#125; = require(&quot;webpack-merge&quot;);<br><br>module.exports = merge(common, &#123;<br>  mode: &#x27;development&#x27;,<br>  devtool: &#x27;eval-source-map&#x27;,<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>webpack.prod.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">const common = require(&quot;./webpack.common&quot;);<br>const path = require(&#x27;path&#x27;);<br>const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);<br>const &#123; merge &#125; = require(&quot;webpack-merge&quot;);<br><br>module.exports = merge(common, &#123;<br>  mode: &#x27;production&#x27;,<br>  devtool: false,<br>  plugins: [<br>    new CopyPlugin(&#123;<br>      patterns: [<br>        // 复制public文件夹内的文件到&#123;output&#125;中<br>        &#123; from: path.resolve(__dirname, &#x27;public&#x27;), to: &quot;&quot; &#125;,<br>      ],<br>    &#125;),<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">通过 —config 标志使用不同的配置文件</font></p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;scripts&quot;: &#123;<br>  &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,<br>  &quot;build-dev&quot;: &quot;webpack --config webpack.dev.js&quot;,<br>  &quot;prod&quot;: &quot;webpack serve --config webpack.prod.js&quot;,<br>  &quot;dev&quot;: &quot;webpack serve --config webpack.dev.js&quot;<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="Fhu5a">内置插件</h1><p><font style="color:rgb(53, 53, 53);">webpack本身内置了很多插件对bundle进行优化，且一些插件在</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;mode: production&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">时会自动开启，进行一些通用的优化操作，</font><a href="https://webpack.docschina.org/configuration/optimization/"><font style="color:rgb(53, 53, 53);">优化(Optimization)</font></a></p><h2 id="iuMQm">DefinePlugin</h2><p><a href="https://webpack.docschina.org/plugins/define-plugin/"><font style="color:rgb(53, 53, 53);">DefinePlugin</font></a><font style="color:rgb(53, 53, 53);">用来注入全局成员，在</font><strong><font style="color:rgb(53, 53, 53);">编译时</font></strong><font style="color:rgb(53, 53, 53);">将代码中的变量替换为其他值或表达式</font></p><p><font style="color:rgb(53, 53, 53);">在</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;mode: production&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">时，DefinePlugin默认启用，并注入了</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;process.env.NODE_ENV&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">，许多第三方的模块使用这个常量来判断当前环境</font></p><p><font style="color:rgb(53, 53, 53);">DefinePlugin接收一个对象，对象中的值若为字符串，将被作为代码片段使用，</font></p><p><strong>js</strong></p><p>使用API_BASE_URL区分生产和开发环境API接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const webpack = require(&#x27;webpack&#x27;);<br><br>plugins: [<br>  new webpack.DefinePlugin(&#123;<br>    // 使用JSON.stringify作为表示字符串的代码片段<br>    API_BASE_URL: JSON.stringify(&#x27;http://api.github.com&#x27;),<br>  &#125;),<br>],<br><br>console.log(API_BASE_URL)<br></code></pre></td></tr></table></figure><h2 id="zHa1p">Tree Shaking</h2><p><a href="https://webpack.docschina.org/guides/tree-shaking/"><font style="color:rgb(53, 53, 53);">Tree Shaking</font></a><font style="color:rgb(53, 53, 53);">用于移除JS上下文中的</font><strong><font style="color:rgb(53, 53, 53);">未引用</font></strong><font style="color:rgb(53, 53, 53);">代码(dead-code)，</font><strong><font style="color:rgb(53, 53, 53);">基于ESM</font></strong></p><p><font style="color:rgb(53, 53, 53);">在</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;mode: production&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">时Tree Shaking功能自动开启，也可通过配置开启</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  optimization: &#123;<br>    // 只导出使用了的成员<br>    usedExports: true,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">测试代码：</font></p><p><strong>js</strong></p><p>src&#x2F;utils.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">const info = &#123;<br>  name: &#x27;chuckle&#x27;,<br>  age: &#x27;20&#x27;,<br>&#125;<br>export function getName()&#123;<br>  return info.name<br>&#125;<br>export function getAge()&#123;<br>  return info.age<br>&#125;<br>export function logName()&#123;<br>  console.log(info.name);<br>&#125;<br>export function logAge()&#123;<br>  console.log(info.age);<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">打包结果，仍然存在未使用的代码片段，这是因为usedExports只是标记了未引用代码，而</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;optimization.minimize&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">才是用于压缩bundle，并去除未引用代码，两者搭配才实现了Tree Shaking</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;<br>/* harmony export */   logName: () =&gt; (/* binding */ logName)<br>/* harmony export */ &#125;);<br>/* unused harmony exports getName, getAge, logAge */<br>var info = &#123;<br>  name: &#x27;chuckle&#x27;,<br>  age: &#x27;20&#x27;<br>&#125;;<br>function getName() &#123;<br>  return info.name;<br>&#125;<br>function getAge() &#123;<br>  return info.age;<br>&#125;<br>function logName() &#123;<br>  var _console;<br>  /* eslint-disable */(_console = console).log.apply(_console, _toConsumableArray(oo_oo(&quot;3634127370_12_2_12_24_4&quot;, info.name)));<br>&#125;<br>function logAge() &#123;<br>  var _console2;<br>  /* eslint-disable */(_console2 = console).log.apply(_console2, _toConsumableArray(oo_oo(&quot;3634127370_15_2_15_23_4&quot;, info.age)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="rFB9Q">压缩代码去除未引用</h3><p><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;optimization.minimize&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">压缩bundle并去除未引用代码，</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;mode: production&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">默认开启</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  //...<br>  optimization: &#123;<br>    minimize: true,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">打包后，未使用过的代码已经去除</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">e.d(_,&#123;logName:()=&gt;d&#125;);var t=&#123;name:&quot;chuckle&quot;,age:&quot;20&quot;&#125;;<br></code></pre></td></tr></table></figure><h3 id="Lnxqo">副作用</h3><p><font style="color:rgb(53, 53, 53);">将文件标记为</font><a href="https://webpack.docschina.org/guides/tree-shaking/#mark-the-file-as-side-effect-free"><font style="color:rgb(53, 53, 53);">side-effect-free</font></a><font style="color:rgb(53, 53, 53);">(无副作用)安全地删除未用到的export，目的是为了给Tree Shaking更大的优化空间</font></p><p><font style="color:rgb(53, 53, 53);">副作用：模块执行时，除了导出成员之外所作的事情</font></p><p><a href="https://webpack.docschina.org/configuration/optimization/#optimizationsideeffects"><font style="color:rgb(53, 53, 53);">optimization.sideEffects</font></a><font style="color:rgb(53, 53, 53);">告知webpack去辨识package.json中的副作用标记或规则，以跳过那些当导出不被使用且被标记不包含副作用的模块。</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">optimization: &#123;<br>  sideEffects: true, // 开启<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;sideEffects&quot;: false, // 项目所有模块都无副作用<br>// or<br>&quot;sideEffects&quot;: [&quot;*.css&quot;], // 使用css-loader且在css文件中使用import时很有必要<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">常见副作用代码：</font></p><p><strong>js</strong></p><p>src&#x2F;pad.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 数字前补全0<br>Number.prototype.pad = function (size) &#123;<br>  let result = String(this);<br>  while (result.length &lt; size) &#123;<br>    result += &#x27;0&#x27;;<br>  &#125;<br>  return result;<br>&#125;<br><br>// 导入使用<br>import &#x27;./pad&#x27;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">若没有标记副作用，打包会排除该代码片段</font></p><p><strong>text</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Uncaught TypeError: 8.pad is not a function<br>  at ./main.js (main.js:17:72)<br>  at __webpack_require__ (bootstrap:24:1)<br>  at startup:7:1<br>  at startup:7:1<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">标记副作用</font></p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;./src/pad.js&quot;],<br></code></pre></td></tr></table></figure><h2 id="R9T71">模块分包</h2><p><font style="color:rgb(53, 53, 53);">webpack会将所有小颗粒度的模块，从入口模块开始打包到一个JS模块，若项目较大，bundle也会很大，一些模块可以分包出来，减小bundle的体积，</font><a href="https://webpack.docschina.org/guides/code-splitting/"><font style="color:rgb(53, 53, 53);">文档</font></a></p><p><font style="color:rgb(53, 53, 53);">模块分包办法：</font></p><ol><li><font style="color:rgb(53, 53, 53);">多入口打包</font></li><li><font style="color:rgb(53, 53, 53);">动态导入</font></li></ol><h3 id="q8PNg">多入口打包</h3><p><font style="color:rgb(53, 53, 53);">多入口打包通常用于多页面应用，但也可以一个页面应用多个bundle，实现分包</font></p><p><font style="color:rgb(53, 53, 53);">同事可以使用</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;dependOn&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">指定依赖的公共模块，并在html中引入公共模块</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#123;<br>  main: &#123;<br>    import: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>    dependOn: &#x27;shared&#x27;,<br>  &#125;,<br>  about: &#123;<br>    import: [&#x27;./about.js&#x27;],<br>    dependOn: &#x27;shared&#x27;,<br>  &#125;,<br>  shared: &#x27;./module.js&#x27;,<br>&#125;,<br>output: &#123;<br>  path: path.resolve(__dirname, &#x27;dist&#x27;),<br>  filename: &#x27;[name]_[contenthash].js&#x27;,<br>  clean: true,<br>&#125;,<br>plugins: [<br>  new HtmlWebpackPlugin(&#123;<br>    template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>    inject: &#x27;body&#x27;, // 插入到body<br>    filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>    title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>    minify: true, // 压缩<br>    chunks: [&#x27;main&#x27;, &#x27;shared&#x27;], // 公共模块也要引入<br>  &#125;),<br>  new HtmlWebpackPlugin(&#123;<br>    template: path.resolve(__dirname, &#x27;./about.html&#x27;),<br>    inject: &#x27;body&#x27;,<br>    filename: &#x27;about.html&#x27;,<br>    title: &#x27;关于页&#x27;,<br>    minify: true, // 压缩<br>    chunks: [&#x27;about&#x27;, &#x27;shared&#x27;],<br>  &#125;),<br>],<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">如果想要在一个 HTML 页面上使用多个入口，还需设置</font><font style="color:rgb(53, 53, 53);"> </font><a href="https://webpack.docschina.org/configuration/optimization/#optimizationruntimechunk"><font style="color:rgb(53, 53, 53);">runtimeChunk</font></a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">optimization: &#123;<br>  // 用于指定运行时(runtime)代码的拆分策略<br>  runtimeChunk: &#x27;single&#x27;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="IFW6L">自动提取</h3><p><font style="color:rgb(53, 53, 53);">当多个模块引入了同一个模块，可以使用</font><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/"><font style="color:rgb(53, 53, 53);">splitChunks</font></a><font style="color:rgb(53, 53, 53);">将其自动提取为独立的chunk</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">splitChunks: &#123;<br>  chunks: &#x27;all&#x27;,<br>  minSize: 20 * 1024, // 设置最小分包大小,默认20000<br>  minSizeReduction: 50 * 1024, // 需要分包的bundle最小大小<br>&#125;,<br></code></pre></td></tr></table></figure><p><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;minSizeReduction&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">：设置需要分包的bundle最小大小，这意味着如果分割成一个 chunk 并没有减少主 chunk（bundle）的给定字节数，它将不会被分割，即使它满足 splitChunks.minSize</font></p><p><font style="color:rgb(53, 53, 53);">这样就不用使用</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;dependOn&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">指定依赖的公共模块了</font></p><h3 id="zBmI2">动态导入</h3><p><a href="https://webpack.docschina.org/guides/code-splitting/#dynamic-imports"><font style="color:rgb(53, 53, 53);">动态导入</font></a><font style="color:rgb(53, 53, 53);">实现按需加载，需要某个模块再加载该模块，所有动态导入的模块都会被自动分包</font></p><p><font style="color:rgb(53, 53, 53);">使用ESM的</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;import()&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">实现动态导入</font></p><p><font style="color:rgb(53, 53, 53);">下面是一个hash路由的小demo</font></p><p><strong>html</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;body&gt;<br>  &lt;header&gt;<br>    &lt;a href=&quot;#Home&quot;&gt;首页&lt;/a&gt;<br>    &lt;a href=&quot;#List&quot;&gt;列表&lt;/a&gt;<br>  &lt;/header&gt;<br>  &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>src&#x2F;blog.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">import home from &#x27;./home&#x27;;<br>import list from &#x27;./list&#x27;;<br><br>const render = ()=&gt;&#123;<br>  const hash = window.location.hash || &quot;#Home&quot;;<br>  const mainEle = document.querySelector(&#x27;#main&#x27;);<br>  mainEle.innerHTML = &quot;&quot;;<br>  if(hash === &quot;#List&quot;)&#123;<br>    mainEle.appendChild(list());<br>  &#125;else if(hash === &quot;#Home&quot;)&#123;<br>    mainEle.appendChild(home());<br>  &#125;<br>&#125;<br>render();<br><br>window.addEventListener(&quot;hashchange&quot;, render)<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>src&#x2F;home&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; renderMarkdown &#125; from &quot;../module&quot;;<br>import &#x27;./index.css&#x27;<br>import md from &#x27;./index.md&#x27;<br>export default () =&gt; renderMarkdown(md, &quot;home&quot;);<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>src&#x2F;list&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; renderMarkdown &#125; from &quot;../module&quot;;<br>import &#x27;./index.css&#x27;<br>import md from &#x27;./index.md&#x27;<br>export default () =&gt; renderMarkdown(md, &#x27;list&#x27;);<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">若不使用动态导入，不同路由页引入的css都同时影响样式，导致样式冲突，下面使用</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;import()&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">改造</font></p><p><strong>js</strong></p><p>src&#x2F;blog.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">const render = () =&gt; &#123;<br>  const hash = window.location.hash || &quot;#Home&quot;;<br>  const mainEle = document.querySelector(&#x27;#main&#x27;);<br>  mainEle.innerHTML = &quot;&quot;;<br>  if (hash === &quot;#List&quot;) &#123;<br>    import(&#x27;./list&#x27;).then((&#123; default: list &#125;) =&gt; &#123;<br>      mainEle.appendChild(list());<br>    &#125;)<br>  &#125; else if (hash === &quot;#Home&quot;) &#123;<br>    import(&#x27;./home&#x27;).then((&#123; default: home &#125;) =&gt; &#123;<br>      mainEle.appendChild(home());<br>    &#125;)<br>  &#125;<br>&#125;<br>render();<br><br>window.addEventListener(&quot;hashchange&quot;, render)<br></code></pre></td></tr></table></figure><h3 id="Y3ON1">魔法注释</h3><p><font style="color:rgb(53, 53, 53);">在动态导入过程中可以加入魔法注释，控制分包命名、合并、开启</font><a href="https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules"><font style="color:rgb(53, 53, 53);">预加载</font></a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 使用chunkName设置分包命名<br>import(/* webpackChunkName: &quot;home&quot; */&#x27;./home&#x27;)<br>import(/* webpackChunkName: &quot;list&quot; */&#x27;./list&#x27;)<br>// 相同chunkName会被打包到一起<br>import(/* webpackChunkName: &quot;components&quot; */&#x27;./home&#x27;)<br>import(/* webpackChunkName: &quot;components&quot; */&#x27;./list&#x27;)<br>// 开启预加载<br>import(/* webpackPrefetch: true */&#x27;./list&#x27;);<br></code></pre></td></tr></table></figure><h1 id="XjBRY">css处理进阶</h1><p><font style="color:rgb(53, 53, 53);">css这东西吧，还得琢磨琢磨</font></p><h2 id="ijIJ0">css-loader模块化</h2><p><font style="color:rgb(53, 53, 53);">开启</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;options.modules&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">，css-loader会将样式中的类名进行转换，根据模块路径和类名生成转换为一个唯一的hash值。</font><a href="https://webpack.docschina.org/loaders/css-loader/#modules"><font style="color:rgb(53, 53, 53);">文档</font></a></p><p><strong><font style="color:rgb(53, 53, 53);">作用：</font></strong><font style="color:rgb(53, 53, 53);">CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">rules: [<br>  &#123;<br>    test: /\.css$/i,<br>    loader: &quot;css-loader&quot;,<br>    options: &#123;<br>      modules: true,<br>    &#125;,<br>  &#125;,<br>],<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">通过导出对象访问类名来应用样式</font></p><p><strong>css</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.list&#123;<br>  background-color: #2f59b4<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; renderMarkdown &#125; from &quot;../module&quot;;<br>import css from &#x27;./index.css&#x27;<br>import md from &#x27;./index.md&#x27;<br>export default () =&gt; renderMarkdown(md, css.list);<br></code></pre></td></tr></table></figure><h2 id="ROK4P">提取css</h2><p><font style="color:rgb(53, 53, 53);">之前css通过style-loader直接应用到style标签内，而css则保存在js模块中，若css体积较大，还是提取css为一个单独的文件好</font></p><p><a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/"><font style="color:rgb(53, 53, 53);">MiniCssExtractPlugin</font></a><font style="color:rgb(53, 53, 53);">将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载</font></p><p><font style="color:rgb(53, 53, 53);">安装：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i mini-css-extract-plugin -D&lt;/font&gt;</code></p><p><strong>js</strong></p><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);<br><br>module.exports = &#123;<br>  plugins: [new MiniCssExtractPlugin()],<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: /\.css$/i,<br>        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="mlkJ3">压缩css</h2><p><font style="color:rgb(53, 53, 53);">webpack本身只能压缩JS模块,需要压缩CSS等其它类型文件需要安装对应的插件</font></p><p><font style="color:rgb(53, 53, 53);">使用</font><a href="https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/"><font style="color:rgb(53, 53, 53);">CssMinimizerWebpackPlugin</font></a><font style="color:rgb(53, 53, 53);">优化和压缩独立的CSS模块</font></p><p><font style="color:rgb(53, 53, 53);">安装：</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm i css-minimizer-webpack-plugin -D&lt;/font&gt;</code></p><p><strong>js</strong></p><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);<br><br>optimization: &#123;<br>  minimize: true,<br>  // 压缩类的插件应配置在minimizer，受minimize控制<br>  minimizer: [<br>    // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`）<br>    `...`,<br>    new CssMinimizerPlugin(),<br>  ],<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="jiFAz">文件hash</h1><p><font style="color:rgb(53, 53, 53);">开启静态资源的客户端缓存后，为了能及时更新资源，资源文件就需要带上hash，</font><a href="https://webpack.docschina.org/guides/caching/"><font style="color:rgb(53, 53, 53);">文档</font></a></p><p><font style="color:rgb(53, 53, 53);">绝大多数插件都支持使用</font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;filename&lt;/font&gt;</code><font style="color:rgb(53, 53, 53);">配置输出的文件名</font></p><p><font style="color:rgb(53, 53, 53);">三种hash：</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">// [hash]项目级hash，项目中一个模块有变化，该hash就变化<br>filename: &#x27;[name]_[hash].js&#x27;,<br>// [chunkhash]chunk级hash，同一路的打包相同hash<br>filename: &#x27;[name]_[chunkhash].js&#x27;,<br>// [contenthash]文件级hash，根据输出文件内容的hash<br>filename: &#x27;[name]_[contenthash].js&#x27;,<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">指定hash长度</font></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">filename: &#x27;[name]_[contenthash:8].js&#x27;,<br></code></pre></td></tr></table></figure><p><font style="color:rgb(53, 53, 53);">控制缓存最佳实践：8位contenthash</font></p><h1 id="hC4TN">总结</h1><p><strong>json</strong></p><p>package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;name&quot;: &quot;webpack01&quot;,<br>  &quot;version&quot;: &quot;1.0.0&quot;,<br>  &quot;description&quot;: &quot;&quot;,<br>  &quot;private&quot;: true,<br>  &quot;scripts&quot;: &#123;<br>    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,<br>    &quot;build-dev&quot;: &quot;webpack --config webpack.dev.js&quot;,<br>    &quot;prod&quot;: &quot;webpack serve --config webpack.prod.js&quot;,<br>    &quot;dev&quot;: &quot;webpack serve --config webpack.dev.js&quot;<br>  &#125;,<br>  &quot;sideEffects&quot;: [<br>    &quot;*.css&quot;,<br>    &quot;./src/pad.js&quot;<br>  ],<br>  &quot;keywords&quot;: [],<br>  &quot;author&quot;: &quot;&quot;,<br>  &quot;license&quot;: &quot;ISC&quot;,<br>  &quot;devDependencies&quot;: &#123;<br>    &quot;@babel/core&quot;: &quot;^7.23.3&quot;,<br>    &quot;@babel/preset-env&quot;: &quot;^7.23.3&quot;,<br>    &quot;babel-loader&quot;: &quot;^8.3.0&quot;,<br>    &quot;copy-webpack-plugin&quot;: &quot;^11.0.0&quot;,<br>    &quot;css-loader&quot;: &quot;^6.8.1&quot;,<br>    &quot;css-minimizer-webpack-plugin&quot;: &quot;^5.0.1&quot;,<br>    &quot;file-loader&quot;: &quot;^6.2.0&quot;,<br>    &quot;html-loader&quot;: &quot;^4.2.0&quot;,<br>    &quot;html-webpack-plugin&quot;: &quot;^5.5.3&quot;,<br>    &quot;marked&quot;: &quot;^9.1.6&quot;,<br>    &quot;mini-css-extract-plugin&quot;: &quot;^2.7.6&quot;,<br>    &quot;style-loader&quot;: &quot;^3.3.3&quot;,<br>    &quot;url-loader&quot;: &quot;^4.1.1&quot;,<br>    &quot;webpack&quot;: &quot;^5.74.0&quot;,<br>    &quot;webpack-bundle-analyzer&quot;: &quot;^4.9.1&quot;,<br>    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;,<br>    &quot;webpack-dev-server&quot;: &quot;^4.15.1&quot;,<br>    &quot;webpack-merge&quot;: &quot;^5.10.0&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="VmFlU">配置TS环境</h1><p><font style="color:rgb(53, 53, 53);">安装TS相关依赖：</font></p><ol><li><font style="color:rgb(53, 53, 53);">编译TS</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm install ts-loader -D&lt;/font&gt;</code></li><li><font style="color:rgb(53, 53, 53);">TS环境</font><font style="color:rgb(53, 53, 53);"> </font><code>&lt;font style=&quot;color:rgb(233, 105, 0);&quot;&gt;npm install typescript -D&lt;/font&gt;</code></li></ol><p><strong>js</strong></p><p>配置webpack.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs plain">const path = require(&#x27;path&#x27;);<br>const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);<br>const webpack = require(&#x27;webpack&#x27;);<br>const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);<br>const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);<br><br>module.exports = &#123;<br>  mode: &#x27;none&#x27;,<br>  // 生成源映射以方便调试<br>  devtool: &#x27;source-map&#x27;,<br>  // watch: true,<br>  context: path.resolve(__dirname, &#x27;src&#x27;),<br>  entry: &#123;<br>    main: &#123;<br>      import: [&#x27;./index.ts&#x27;],<br>    &#125;<br>  &#125;,<br>  output: &#123;<br>    path: path.resolve(__dirname, &#x27;dist&#x27;),<br>    filename: &#x27;[name]_[contenthash].js&#x27;,<br>    clean: true,<br>  &#125;,<br>  optimization: &#123;<br>    usedExports: true,<br>    // minimize: true,<br>    // 用于指定运行时(runtime)代码的拆分策略<br>    // runtimeChunk: &#x27;single&#x27;,<br>    // splitChunks: &#123;<br>    //   chunks: &#x27;all&#x27;,<br>    //   minSize: 10 * 1024, // 设置最小分包大小<br>    //   // minSizeReduction: 50 * 1024, // 需要分包的bundle最小大小<br>    // &#125;,<br>    minimizer: [<br>      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`）<br>      `...`,<br>      new CssMinimizerPlugin(),<br>    ],<br>  &#125;,<br>  //警告 webpack 的性能提示<br>  performance: &#123;<br>    hints: &#x27;warning&#x27;,<br>    //入口起点的最大体积<br>    maxEntrypointSize: 1024 * 1024 * 10,<br>    //生成文件的最大体积<br>    maxAssetSize: 1024 * 1024,<br>    //只给出 js 文件的性能提示<br>    assetFilter: function (assetFilename) &#123;<br>      return /\.ts$/.test(assetFilename);<br>    &#125;<br>  &#125;,<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        // 正则匹配loader要处理的资源<br>        test: /\.css$/i,<br>        // 逆序执行，从右往左<br>        use: [<br>          // &#123;<br>          //   loader: &#x27;style-loader&#x27;,<br>          // &#125;,<br>          &#123;<br>            loader: MiniCssExtractPlugin.loader<br>          &#125;,<br>          &#123;<br>            loader: &#x27;css-loader&#x27;,<br>            // options: &#123;<br>            //   modules: true // css-loader会将样式中的类名进行转换，根据模块路径和类名生成转换为一个唯一的hash值。<br>            // &#125;,<br>          &#125;,<br>        ],<br>      &#125;,<br>      &#123;<br>        test: /\.(png|jpg|svg|gif|ico)$/,<br>        type: &quot;asset&quot;,<br>        generator: &#123;<br>          filename: &quot;img/[name]_[contenthash][ext]&quot;,<br>        &#125;,<br>        parser: &#123;<br>          dataUrlCondition: &#123;<br>            maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        test: /\.js$/i,<br>        include: [<br>          path.resolve(__dirname, &#x27;src&#x27;)<br>        ],<br>        exclude: [<br>          path.resolve(__dirname, &#x27;node_modules&#x27;)<br>        ],<br>        loader: &#x27;babel-loader&#x27;,<br>        options: &#123;<br>          presets: [&quot;@babel/preset-env&quot;]<br>          // presets: [<br>          //   [&quot;@babel/preset-env&quot;, &#123;<br>          //     modules: &quot;commonjs&quot;, // 开启ESM转CommonJS<br>          //   &#125;]<br>          // ]<br>        &#125;<br>      &#125;,<br>      &#123;<br>        test: /\.ts$/i,<br>        loader: &quot;ts-loader&quot;,<br>        include: [<br>          path.resolve(__dirname, &#x27;src&#x27;)<br>        ],<br>        exclude: [<br>          path.resolve(__dirname, &#x27;node_modules&#x27;)<br>        ],<br>      &#125;<br>    ],<br>  &#125;,<br>  plugins: [<br>    new HtmlWebpackPlugin(&#123;<br>      template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>      inject: &#x27;body&#x27;, // 插入到body<br>      filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>      title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>      minify: true, // 压缩<br>      chunks: [&#x27;main&#x27;],<br>    &#125;),<br>    new webpack.DefinePlugin(&#123;<br>      API_BASE_URL: JSON.stringify(&#x27;http://api.github.com&#x27;),<br>    &#125;),<br>    new MiniCssExtractPlugin(),<br>  ],<br>  resolve: &#123;<br>    extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;],<br>    alias: &#123;<br>      &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;)<br>    &#125;<br>  &#125;,<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>    // 使用HMR<br>    hot: true,<br>    // 启用Gzip<br>    compress: true,<br>    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>    // 使用static配置从目录提供静态文件的选项，默认public<br>    static: &#123;<br>      // 告诉服务器从哪里提供内容<br>      directory: path.join(__dirname, &#x27;public&#x27;),<br>    &#125;,<br>    proxy: &#123;<br>      // 代理api路径<br>      &#x27;/api&#x27;: &#123;<br>        // localhost:8080/api/user -&gt; api.github.com/api/user<br>        target: &#x27;https://api.github.com&#x27;,<br>        // 请求路径重写 /api/user -&gt; /user<br>        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>        // 将 host 请求头修改为 target 的 URL<br>        changeOrigin: true,<br>      &#125;,<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>json</strong></p><p>tsconfig.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;compilerOptions&quot;: &#123;<br>    &quot;incremental&quot;: false, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度<br>    // &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置<br>    &quot;diagnostics&quot;: true, // 打印诊断信息 <br>    &quot;target&quot;: &quot;esnext&quot;, /* 指定 ECMAScript 目标版本：&#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;,&#x27;ES2018&#x27; or &#x27;ESNEXT&#x27;. */<br>    &quot;module&quot;: &quot;esnext&quot;, /* 输出的代码使用什么方式进行模块化： &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */<br>    &quot;lib&quot;: [ /* 指定引用的标准库 */<br>      &quot;esnext&quot;,<br>      &quot;dom&quot;,<br>      &quot;dom.iterable&quot;,<br>    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,<br>    &quot;allowJs&quot;: true, // 允许编译器编译JS，JSX文件<br>    &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用<br>    &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录<br>    &quot;rootDir&quot;: &quot;./src&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构<br>    &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件<br>    &quot;declarationDir&quot;: &quot;./dist/typings&quot;, // 指定生成声明文件存放目录<br>    // &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件<br>    &quot;sourceMap&quot;: false, // 生成目标文件的sourceMap文件<br>    // &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中<br>    &quot;declarationMap&quot;: false, // 为声明文件生成sourceMap<br>    // &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types<br>    &quot;types&quot;: [], // 加载的声明文件包<br>    &quot;removeComments&quot;: true, // 删除注释 <br>    &quot;noEmit&quot;: false, // 不输出文件,即编译后不会生成任何js文件<br>    &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件<br>    &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用<br>    &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块<br>    &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现<br>    &quot;strict&quot;: true, // 开启所有严格的类型检查<br>    &quot;alwaysStrict&quot;: true, // 在代码中注入&#x27;use strict&#x27;<br>    &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型<br>    &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量<br>    &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变<br>    &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化<br>    &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查<br>    &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型<br>    &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错)<br>    &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错)<br>    &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)<br>    &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值<br>    &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入<br>    &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块<br>    &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入<br>    &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录<br>    &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl<br>      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置<br>      // &quot;jquery&quot;: [<br>      //   &quot;node_modules/jquery/dist/jquery.min.js&quot;<br>      // ],<br>      &quot;@/*&quot;: [<br>        &quot;src/*&quot;<br>      ]<br>    &#125;,<br>    &quot;rootDirs&quot;: [<br>      &quot;src&quot;<br>    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错<br>    &quot;listEmittedFiles&quot;: true, // 打印输出文件<br>    &quot;listFiles&quot;: true, // 打印编译的文件(包括引用的声明文件)<br>    &quot;experimentalDecorators&quot;: true,<br>    &quot;emitDecoratorMetadata&quot;: true,<br>    &quot;resolveJsonModule&quot;: true,<br>    &quot;allowImportingTsExtensions&quot;: true,<br>  &#125;,<br>  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）<br>  &quot;include&quot;: [<br>    &quot;src/**/*&quot;,<br>  ],<br>  // 指定一个排除列表（include的反向操作）<br>  // &quot;exclude&quot;: [<br>  //   &quot;demo.ts&quot;<br>  // ],<br>  // 指定哪些文件使用该配置（属于手动一个个指定文件）<br>  // &quot;files&quot;: [<br>  //   &quot;demo.ts&quot;<br>  // ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo图片加载问题</title>
    <link href="/2024/12/08/foreworld/"/>
    <url>/2024/12/08/foreworld/</url>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>文档 : <a href="https://hexo.io/zh-cn/docs/">hexo|文档</a></p><h5 id="Ddzce">hexo常用命令</h5><p>:::info<br>hexo c &#x2F;&#x2F;清除缓存</p><p>hexo g &#x2F;&#x2F;生成静态资源</p><p>hexo s &#x2F;&#x2F;本地部署预览</p><p>hexo d &#x2F;&#x2F;云端部署</p><p>hexo new title &#x2F;&#x2F;生成文章</p><p>:::</p><h5 id="CCkF4"><font style="color:rgb(82, 95, 127);">解决方法</font></h5><p><font style="color:rgb(82, 95, 127);">可以通过修改配置并安装插件的方法完成图片的插入。你需要</font><strong><font style="color:rgb(82, 95, 127);">修改站点配置</font></strong><code>&lt;font style=&quot;color:rgb(94, 102, 135);&quot;&gt;_config.yml&lt;/font&gt;</code><font style="color:rgb(82, 95, 127);">，将 </font><code>&lt;font style=&quot;color:rgb(94, 102, 135);&quot;&gt;post_asset_folder&lt;/font&gt;</code><font style="color:rgb(82, 95, 127);"> 设置为 </font><code>&lt;font style=&quot;color:rgb(94, 102, 135);&quot;&gt;true&lt;/font&gt;</code></p><p><font style="color:rgb(94, 102, 135);">这样在 hexo new xxx 会生成一个同名文件夹存放图片资源</font></p><p><font style="color:rgb(82, 95, 127);">然后安装插件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install hexo-asset-image -- save<br></code></pre></td></tr></table></figure><p><font style="color:rgb(82, 95, 127);">在 typora 中修改图片设置</font></p><p><img src="1733662577985-c91c13a3-1ee6-4ea4-8775-91a6933e9fca.png"></p><p><font style="color:rgb(82, 95, 127);"> 如果你使用的是插件，当生成预览的时候，可能依旧无法正常查看图片。通过直接查看 HTML 文件，我们可以看到是因为多了 &#x2F;.com&#x2F;，所以在加载图片的时候无法获得正确的路径。</font></p><p><font style="color:rgb(82, 95, 127);">具体的修改也很简单，我们只需要到 </font><code>&lt;font style=&quot;color:rgb(94, 102, 135);&quot;&gt;node_modules&lt;/font&gt;</code><font style="color:rgb(82, 95, 127);"> 中找到 </font><code>&lt;font style=&quot;color:rgb(94, 102, 135);&quot;&gt;hexo-asset-image&lt;/font&gt;</code><font style="color:rgb(82, 95, 127);">，并将 58、89 行的</font></p><p><img src="1733662764449-d1f26996-9963-4abd-8e91-a9c542dc6a03.png"></p><p><font style="color:rgb(82, 95, 127);">修改为</font></p><p><img src="1733662782894-6cefafe5-30d4-4d20-9108-6a4f795c6cf4.png"></p><p><font style="color:rgb(82, 95, 127);">不出意外的话，就可以看到正常显示的图片了</font></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts</title>
    <link href="/2024/12/08/Ts/"/>
    <url>/2024/12/08/Ts/</url>
    
    <content type="html"><![CDATA[<h3 id="Ts-介绍"><a href="#Ts-介绍" class="headerlink" title="Ts 介绍"></a>Ts 介绍</h3><p><strong>TypeScript 是由微软开发的，基于 JavaScript（JS）的一个扩展语言，包含 JS 所有内容，并增加了静态类型检查、接口、泛型等特性.</strong></p><p><strong>Ts 支持静态类型检查,在代码运行前进行检查,减少运行异常的概率.同样的功能,Ts 的代码量大于 Js,但是代码结构更加清晰,更加便于维护.</strong></p><p><strong>Ts 编译:Ts 不能直接被浏览器运行,需要先编译为 Js,再交由浏览器解析执行.(vue,react 基于 webpack,vite 等配置进行 Ts 编译)</strong></p><details class="lake-collapse"><summary id="uf812c35c"><span class="ne-text">1.命令行编译</span></summary><p id="u4edc343b" class="ne-p" style="text-indent: 2em"><span class="ne-text">安装ts,命令npm i typescript -g(全局安装) ,编译命令tsc &lt;ts文件&gt;解析编译出ts文件对应的js文件</span></p></details><details class="lake-collapse"><summary id="uf7a681eb"><span class="ne-text">2.自动化编译</span></summary><p id="u27e3738b" class="ne-p" style="text-indent: 2em"><span class="ne-text">同样先全局安装ts,输入命令tsc --init,生成tsconfig.json配置文件.</span></p><p id="u692d87af" class="ne-p" style="text-indent: 2em"><span class="ne-text">ts --watch监视全部ts文件,也可监视单个ts文件</span></p><p id="ufea8de56" class="ne-p"><span class="ne-text">技巧:当出现错误时,不进行编译 tsc --noEmitOnError --watch(也可直接修改tsconfig.json的noEmitOnError 属性)</span></p></details><p>对于变量,函数进行基本的类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">boolean</span>;<br>a = <span class="hljs-string">&quot;hello&quot;</span>;<br>b = <span class="hljs-number">1</span>;<br>c = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>Ts 类型推断,Ts 会根据代码进行类型推断,面对复杂类型可能出错,尽量明确编写的类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> d= <span class="hljs-number">99</span><br>d=<span class="hljs-string">&#x27;123</span><br></code></pre></td></tr></table></figure><h3 id="基础类型总览"><a href="#基础类型总览" class="headerlink" title="基础类型总览"></a>基础类型总览</h3><details class="lake-collapse"><summary id="uaabb7dd7"><span class="ne-text">js中的数据类型</span></summary><p id="ua5bf1f19" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">① string </span></p><p id="ub8258016" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">② </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">number </span></p><p id="u306b5347" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">③ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">boolean </span></p><p id="ud79c25c0" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">④ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">null </span></p><p id="u17e78bca" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑤ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">undefined </span></p><p id="u0d936672" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑥ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">bigint </span></p><p id="ud4c5383f" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑦ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">symbol </span></p><p id="u6ecacdea" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑧ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">object </span></p><p id="u1b4cd798" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">备注：其中 object 包含： Array 、 Function 、 Date 、 Error 等.....</span></p></details><details class="lake-collapse"><summary id="u32dbb78f"><span class="ne-text">ts中的数据类型</span></summary><p id="u2ff6582f" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">1. 上述所有 JavaScript 类型 </span></p><p id="u590a9d1e" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">2. </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">六个新类型： </span></p><p id="u01c33d3a" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">① </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">any </span></p><p id="u76ff1110" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">② </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">unknown </span></p><p id="u56d902db" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">③ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">never </span></p><p id="u4585c27d" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">④ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">void </span></p><p id="u57ba264a" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑤ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">tuple </span></p><p id="ue42ab522" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑥ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">enum </span></p><p id="ud2723297" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">3. </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">两个⽤于⾃定义类型的⽅式： </span></p><p id="u0254fc1f" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">① </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">type </span></p><p id="u2451c65d" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">② interface</span></p></details><p>:::info<br>注意:<font style="color:rgb(38,38,38);">在 JavaScript 中的这些内置构造函数： Number 、 String 、 Boolean ，⽤于 </font></p><p><font style="color:rgb(38,38,38);">创建对应的包装对象， 在⽇常开发时</font><font style="color:rgb(173,26,43);">很少使⽤</font><font style="color:rgb(38,38,38);">，在 </font><font style="color:rgb(38,38,38);">TypeScript </font><font style="color:rgb(38,38,38);">中也是同理，所以 </font></p><p><font style="color:rgb(38,38,38);">在 </font><font style="color:rgb(38,38,38);">TypeScript </font><font style="color:rgb(38,38,38);">中进⾏类型声明时，通常都是⽤⼩写的 </font><font style="color:rgb(38,38,38);">number </font><font style="color:rgb(38,38,38);">、 </font><font style="color:rgb(38,38,38);">string </font><font style="color:rgb(38,38,38);">、 </font><font style="color:rgb(38,38,38);">bo </font></p><p><font style="color:rgb(38,38,38);">olean</font></p><ol><li><font style="color:rgb(38,38,38);">原始类型 VS 包装对象<br></font><font style="color:rgb(38,38,38);">原始类型：如 number 、 string 、 boolean ，在 JavaScript 中是简单数据<br></font><font style="color:rgb(38,38,38);">类型，它们在内存中占⽤空间少，处理速度快。<br></font><font style="color:rgb(38,38,38);">包装对象：如 Number 对象、 String 对象、 Boolean 对象，是复杂类型，在<br></font><font style="color:rgb(38,38,38);">内存中占⽤更多空间，在⽇常开发时很少由开发⼈员⾃⼰创建包装对象。</font></li><li><font style="color:rgb(38,38,38);">⾃动装箱：JavaScript 在必要时会⾃动将原始类型包装成对象，以便调⽤⽅法或访<br></font><font style="color:rgb(38,38,38);">问属性</font></li></ol><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 原始类型字符串</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">// 当访问str.length时，JavaScript引擎做了以下⼯作：</span><br><span class="hljs-keyword">let</span> size = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. ⾃动装箱：创建⼀个临时的String对象包装原始字符串</span><br>  <span class="hljs-keyword">let</span> tempStringObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str);<br>  <span class="hljs-comment">// 2. 访问String对象的length属性</span><br>  <span class="hljs-keyword">let</span> lengthValue = tempStringObject.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 3. 销毁临时对象，返回⻓度值</span><br>  <span class="hljs-comment">// （JavaScript引擎⾃动处理对象销毁，开发者⽆感知）</span><br>  <span class="hljs-keyword">return</span> lengthValue;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(size); <span class="hljs-comment">// 输出: 5</span><br></code></pre></td></tr></table></figure><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><p>**any:**任意类型,<font style="color:rgb(38,38,38);">可以赋值给任意类型的变量(容易造成类型错误,比如将一个 any 类型的数据赋值给一个 string 类型的数据),不进行声明时 Ts 会判断为隐式 any.</font></p><p><strong><font style="color:rgb(38,38,38);">unknow:</font></strong><font style="color:rgb(38,38,38);">可以理解为一个类型安全的 any,适⽤于：起初不确定数据的具体类型，要后期才能确定.使用时强制开发者进行类型判断,从而保证类型安全.(可以使用断言进行强制推断)</font></p><p>:::info<br><strong><font style="color:rgb(38,38,38);">tip(断言):</font></strong></p><p><font style="color:rgb(38,38,38);">第 1 种⽅式<br></font><font style="color:rgb(38,38,38);">x &#x3D; a as string<br></font><font style="color:rgb(38,38,38);">第 2 种⽅式<br></font><font style="color:rgb(38,38,38);">x &#x3D; <string>a</string></font></p><p>:::</p><p><strong>never</strong>:不是任何值,一般不主动使用(无意义),一般由 ts 进行类型推断,推断为”never”.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 指定a的类型为string</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 给a设置⼀个值</span><br>a = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toUpperCase</span>());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// TypeScript会推断出此处的a是never，因为没有任何⼀个值符合此处的</span><br>  逻辑;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font style="color:rgb(38,38,38);">void </font></strong><font style="color:rgb(38,38,38);">：函数不返回任何值，调⽤者也不应依赖其返回值进⾏</font><font style="color:rgb(223,42,63);">任何操作</font><font style="color:rgb(38,38,38);">！</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"><span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;<br><span class="hljs-title function_">logMessage</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br></code></pre></td></tr></table></figure><p>:::info<br><font style="color:rgb(38,38,38);">注意：编码者没有编写 return 指定函数返回值，所以 logMessage 函数是没有</font><font style="color:rgb(223,42,63);">显式 </font></p><p><font style="color:rgb(223,42,63);">返回值</font><font style="color:rgb(38,38,38);">的，但会有⼀个</font><font style="color:rgb(223,42,63);">隐式返回值 </font><font style="color:rgb(38,38,38);">，是 </font><font style="color:rgb(38,38,38);">undefined </font><font style="color:rgb(38,38,38);">，虽然函数返回类型为 </font><font style="color:rgb(38,38,38);">void </font><font style="color:rgb(38,38,38);">，但 </font></p><p><font style="color:rgb(38,38,38);">也是可以接受 undefined 的，简单记： </font><strong><font style="color:rgb(38,38,38);">undefined </font></strong><font style="color:rgb(38,38,38);">是 </font><strong><font style="color:rgb(38,38,38);">void </font></strong><font style="color:rgb(38,38,38);">可以接受的⼀种“空”。</font></p><p>:::</p><details class="lake-collapse"><summary id="u3118a979"><strong><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">理解 void 与 undefined </span></strong></summary><p id="u5c954ab3" class="ne-p" style="text-indent: 2em"><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">void </span><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">是⼀个⼴泛的概念，⽤来表达“空”，⽽ </span><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">undefined </span><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">则是这种“空”的具体 </span></p><p id="ucba7d1dd" class="ne-p"><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">实现。 </span></p><p id="uff48e4eb" class="ne-p" style="text-indent: 2em"><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">因此可以说 undefined 是 void 能接受的⼀种“空”的状态。也可以理解为： void 包含 undefined ，但 void 所表达的语义超越了 undefined ， void 是⼀种意图上的约定，⽽不仅仅是特定值的限制。 </span></p></details><p><strong><font style="color:rgb(47,142,244);">object </font></strong><font style="color:rgb(38,38,38);">（⼩写) ：</font>所有⾮原始类型，可存储：对象、函数、数组等，由于限制的范围⽐较宽泛，在实际开发中使⽤的相对较少。</p><p><font style="color:rgb(223,42,63);">Object（⼤写）: </font><font style="color:rgb(38,38,38);">所有可以调⽤ </font><strong><font style="color:rgb(223,42,63);">Object </font></strong><font style="color:rgb(38,38,38);">⽅法的类型。(除了 undefined 和 null 的任何值.)</font></p><h4 id="声明对象类型"><a href="#声明对象类型" class="headerlink" title="声明对象类型"></a><font style="color:rgb(38,38,38);">声明对象类型</font></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 限制person1对象必须有name属性，age为可选属性</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person1</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age?: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-comment">// 含义同上，也能⽤分号做分隔</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person2</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age?: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-comment">// 含义同上，也能⽤换⾏做分隔</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person3</span>: &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>索引签名</strong>： 允许定义对象可以具有任意数量的属性，这些属性的键和类型是可变的,常⽤于：描述类型不确定的属性，（具有动态属性的对象）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 限制person对象必须有name属性，可选age属性但值必须是数字，同时可以有任意数</span><br>量、任意类型的其他属性<br><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>: &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br> age?: <span class="hljs-built_in">number</span><br> [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明函数类型"><a href="#声明函数类型" class="headerlink" title="声明函数类型"></a><font style="color:rgb(38,38,38);">声明函数类型</font></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>count = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>:::info<br><font style="color:rgb(38,38,38);">备注：TypeScript 中的 &#x3D;&gt; 在函数类型声明时表示函数类型，描述其参数类型和返回类 型。 </font></p><p><font style="color:rgb(38,38,38);">JavaScript 中的 &#x3D;&gt; 是⼀种定义函数的语法，是具体的函数实现。函数类型声明还可以使⽤：接⼝、⾃定义类型等⽅式</font></p><p>:::</p><p>:::info<br>tip:<font style="color:rgb(38,38,38);">在函数定义时，限制函数返回值为 void ，那么函数的返回值就必须是空。使⽤类型声明限制函数返回值为 void 时，</font><strong><font style="color:rgb(223,42,63);">TypeScript </font></strong><font style="color:rgb(223,42,63);">并不会严格要求函数返回空。</font></p><p><font style="color:rgb(38,38,38);">是为了确保如下代码成⽴，我们知道 Array.prototype.push 的返回值是⼀个数字 Array.prototype.forEach ⽅法期望其回调的返回类型是 void 。</font></p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> src = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> dst = [<span class="hljs-number">0</span>];<br><span class="hljs-comment">//若是src.forEach((el) =&gt; &#123;dst.push(el)&#125;)返回值为void;若是简写形式则返回为number</span><br>src.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> dst.<span class="hljs-title function_">push</span>(el));<br></code></pre></td></tr></table></figure><h4 id="声明数组类型"><a href="#声明数组类型" class="headerlink" title="声明数组类型"></a><font style="color:rgb(38,38,38);">声明数组类型</font></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-built_in">string</span>[];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">//泛型</span><br>arr1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br>arr2 = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];<br></code></pre></td></tr></table></figure><p><strong>元组(tuple):</strong><font style="color:rgb(38,38,38);">tuple 是⼀种特殊的数组类型，可以存储固定数量的元素，并且每个元素的类型是已 </font></p><p><font style="color:rgb(38,38,38);">知的且可以不同。元组⽤于精确描述⼀组值的类型，? 表示可选元素。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 第⼀个元素必须是 string 类型，第⼆个元素必须是 number 类型。</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-comment">// 第⼀个元素必须是 number 类型，第⼆个元素是可选的，如果存在，必须是 boolean 类型。</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>?];<br><span class="hljs-comment">// 第⼀个元素必须是 number 类型，后⾯的元素可以是任意数量的 string 类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr3</span>: [<span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">string</span>[]];<br></code></pre></td></tr></table></figure><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p><strong><font style="color:rgb(38,38,38);">枚举（ enum ）</font></strong><font style="color:rgb(38,38,38);">:可以定义</font><font style="color:rgb(223,42,63);">⼀组命名常量</font><font style="color:rgb(38,38,38);">，它能增强代码的可读性，也让代码更好维护</font></p><p><strong><font style="color:rgb(38,38,38);">数字枚举:</font></strong><font style="color:rgb(38,38,38);">数字枚举⼀种最常⻅的枚举类型，其成员的值会</font><font style="color:rgb(223,42,63);">⾃动递增</font><font style="color:rgb(38,38,38);">，且数字枚举还具备</font><font style="color:rgb(223,42,63);">反向映射</font><font style="color:rgb(38,38,38);">的 </font></p><p><font style="color:rgb(38,38,38);">特点,</font><font style="color:#DF2A3F;">也可以指定枚举成员的初始值，其后的成员值会⾃动递增</font><font style="color:rgb(38,38,38);">。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span>,<br>  <span class="hljs-title class_">Down</span>,<br>  <span class="hljs-title class_">Left</span>,<br>  <span class="hljs-title class_">Right</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>); <span class="hljs-comment">// 打印Direction会看到如下内容</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> &#123;</span><br><span class="hljs-comment"> 0:&#x27;Up&#x27;, </span><br><span class="hljs-comment"> 1:&#x27;Down&#x27;, </span><br><span class="hljs-comment"> 2:&#x27;Left&#x27;, </span><br><span class="hljs-comment"> 3:&#x27;Right&#x27;, </span><br><span class="hljs-comment"> Up:0, </span><br><span class="hljs-comment"> Down:1, </span><br><span class="hljs-comment"> Left:2,</span><br><span class="hljs-comment"> Right:3</span><br><span class="hljs-comment"> &#125; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 反向映射</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 此⾏代码报错，枚举中的属性是只读的</span><br><span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span> = <span class="hljs-string">&quot;shang&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>字符串枚举:</strong><font style="color:rgb(38,38,38);">枚举成员的值是字符串</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span> = <span class="hljs-string">&quot;up&quot;</span>,<br>  <span class="hljs-title class_">Down</span> = <span class="hljs-string">&quot;down&quot;</span>,<br>  <span class="hljs-title class_">Left</span> = <span class="hljs-string">&quot;left&quot;</span>,<br>  <span class="hljs-title class_">Right</span> = <span class="hljs-string">&quot;right&quot;</span>,<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">dir</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dir); <span class="hljs-comment">// 输出: &quot;up&quot;</span><br></code></pre></td></tr></table></figure><p><strong>常量枚举:</strong><font style="color:rgb(38,38,38);">官⽅描述：常量枚举是⼀种特殊枚举类型，它使⽤ </font><font style="color:rgb(38,38,38);">const </font><font style="color:rgb(38,38,38);">关键字定义，在编译时会被 </font></p><p><font style="color:rgb(223,42,63);">内联</font><font style="color:rgb(38,38,38);">，</font><font style="color:rgb(223,42,63);">避免</font><font style="color:rgb(38,38,38);">⽣成⼀些</font><font style="color:rgb(223,42,63);">额外</font><font style="color:rgb(38,38,38);">的代码。</font></p><p>:::info<br><font style="color:rgb(38,38,38);">何为</font><font style="color:rgb(223,42,63);">编译时内联</font><font style="color:rgb(38,38,38);">？ </font></p><p><font style="color:rgb(38,38,38);">所谓“内联”其实就是 TypeScript 在编译时，会将枚举成员引⽤替换为它们的实际值,⽽不是⽣成额外的枚举对象。这可以减少⽣成的 JavaScript 代码量，并提⾼运⾏时性能</font></p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Directions</span> &#123;<br>  <span class="hljs-title class_">Up</span>,<br>  <span class="hljs-title class_">Down</span>,<br>  <span class="hljs-title class_">Left</span>,<br>  <span class="hljs-title class_">Right</span>,<br>&#125;<br><span class="hljs-keyword">let</span> x = <span class="hljs-title class_">Directions</span>.<span class="hljs-property">Up</span>;<br></code></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p><strong><font style="color:rgb(38,38,38);">type</font></strong><font style="color:rgb(38,38,38);"> :可以为任意类型创建别名，让代码更简洁、可读性更强，同时能更⽅便地进⾏类型复⽤和扩展</font></p><p><strong><font style="color:rgb(38,38,38);">基本用法:</font></strong><font style="color:rgb(38,38,38);">类型别名使⽤ type 关键字定义， type 后跟类型名称</font></p><p><strong><font style="color:rgb(38,38,38);">联合类型:</font></strong><font style="color:rgb(38,38,38);">联合类型是⼀种⾼级类型，它表示⼀个值可以是⼏种不同类型之⼀。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Status</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Gender</span> = <span class="hljs-string">&quot;男&quot;</span> | <span class="hljs-string">&quot;⼥&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>交叉类型</strong>:<font style="color:rgb(38,38,38);">交叉类型（Intersection Types）允许将多个类型合并为⼀个类型。合并后的类型将拥 </font></p><p><font style="color:rgb(38,38,38);">有所有被合并类型的成员。交叉类型通常⽤于对象类型。 </font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//⾯积</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Area</span> = &#123;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//⾼</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//宽</span><br>&#125;;<br><span class="hljs-comment">//地址</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Address</span> = &#123;<br>  <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//楼号</span><br>  <span class="hljs-attr">cell</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//单元号</span><br>  <span class="hljs-attr">room</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//房间号</span><br>&#125;;<br><span class="hljs-comment">// 定义类型House，且House是Area和Address组成的交叉类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">House</span> = <span class="hljs-title class_">Area</span> &amp; <span class="hljs-title class_">Address</span>;<br></code></pre></td></tr></table></figure><p>:::info<br>tip:<font style="color:rgb(38,38,38);">在函数定义时，限制函数返回值为 void ，那么函数的返回值就必须是空。使⽤类型声明限制函数返回值为 void 时，</font><strong><font style="color:rgb(223,42,63);">TypeScript </font></strong><font style="color:rgb(223,42,63);">并不会严格要求函数返回空。</font></p><p><font style="color:rgb(38,38,38);">是为了确保如下代码成⽴，我们知道 Array.prototype.push 的返回值是⼀个数字 Array.prototype.forEach ⽅法期望其回调的返回类型是 void 。</font></p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> src = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> dst = [<span class="hljs-number">0</span>];<br><span class="hljs-comment">//若是src.forEach((el) =&gt; &#123;dst.push(el)&#125;)返回值为void;若是简写形式则返回为number</span><br>src.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> dst.<span class="hljs-title function_">push</span>(el));<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// 属性声明</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-comment">// ⽅法</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Person实例</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>  &#125;<br>  <span class="hljs-comment">// 备注本例中若Student类不需要额外的属性，Student的构造器可以省略</span><br>  <span class="hljs-comment">// 重写从⽗类继承的⽅法</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我是学⽣，我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁，在读<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.grade&#125;</span></span><br><span class="hljs-string">年级`</span>);<br>  &#125;<br>  <span class="hljs-comment">// ⼦类⾃⼰的⽅法</span><br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努⼒学习中......`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h4><table><thead><tr><th><strong><font style="color:#117CEE;">修饰符</font></strong></th><th><strong><font style="color:#117CEE;">含义</font></strong></th><th><strong><font style="color:#117CEE;"> 是否可以被访问</font></strong></th></tr></thead><tbody><tr><td>public</td><td>公开的</td><td>可以被 <font style="color:#DF2A3F;">类内部,子类,类外部</font> 访问</td></tr><tr><td>protected</td><td>受保护的</td><td>可以被 <font style="color:#DF2A3F;">类内部,子类</font> 访问</td></tr><tr><td>private</td><td>私有的</td><td>可以被 <font style="color:#DF2A3F;">类内部</font> 访问</td></tr><tr><td>readonly</td><td>只读</td><td>属性无法被修改,<font style="color:#DF2A3F;">只读</font></td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// name写了public修饰符，age没写修饰符，最终都是public修饰符</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类的【内部】可以访问public修饰的name和age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 类的【外部】可以访问public修饰的属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>);<br><span class="hljs-comment">//子类也可访问到</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>  &#125;<br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 【⼦类中】可以访问⽗类中public修饰的：name属性、age属性</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁的<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努⼒学习`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//完整写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//简写形式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// name和age是受保护属性，不能在类外部访问，但可以在【类】与【⼦类】中访问</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">protected</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// getDetails是受保护⽅法，不能在类外部访问，但可以在【类】与【⼦类】中访问</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">getDetails</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-comment">// 类中能访问受保护的name和age属性</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，年龄是：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-comment">// introduce是公开⽅法，类、⼦类、类外部都能使⽤</span><br>  <span class="hljs-title function_">introduce</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类中能访问受保护的getDetails⽅法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getDetails</span>());<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;杨超越&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 可以在类外部访问introduce</span><br>p1.<span class="hljs-title function_">introduce</span>();<br><span class="hljs-comment">// 以下代码均报错</span><br><span class="hljs-comment">// p1.getDetails()</span><br><span class="hljs-comment">// p1.name</span><br><span class="hljs-comment">// p1.age</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>  &#125;<br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ⼦类中可以访问introduce</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">introduce</span>();<br>    <span class="hljs-comment">// ⼦类中可以访问name</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努⼒学习`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">17</span>);<br>s1.<span class="hljs-title function_">introduce</span>();<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">    <span class="hljs-comment">// IDCard属性为私有的(private)属性，只能在【类内部】使⽤</span></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-title class_">IDCard</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  </span>) &#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">getPrivateInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类内部可以访问私有的(private)属性 —— IDCard</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`身份证号码为：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.IDCard&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-title function_">getInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类内部可以访问受保护的(protected)属性 —— name和age</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, 今年刚满<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁`</span>;<br>  &#125;<br>  <span class="hljs-title function_">getFullInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类内部可以访问公开的getInfo⽅法，也可以访问私有的getPrivateInfo⽅法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getInfo</span>() + <span class="hljs-string">&quot;，&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPrivateInfo</span>();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;110114198702034432&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getFullInfo</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getInfo</span>());<br><span class="hljs-comment">// 以下代码均报错</span><br><span class="hljs-comment">// p1.IDCard</span><br><span class="hljs-comment">// p1.getPrivateInfo()</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">vin</span>: <span class="hljs-built_in">string</span>, <span class="hljs-comment">//⻋辆识别码，为只读属性</span></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">year</span>: <span class="hljs-built_in">number</span>, <span class="hljs-comment">//出⼚年份，为只读属性</span></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">sound</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  </span>) &#123;&#125;<br>  <span class="hljs-comment">// 打印⻋辆信息</span><br>  <span class="hljs-title function_">displayInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`</span><br><span class="hljs-string"> 识别码：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vin&#125;</span>,</span><br><span class="hljs-string"> 出⼚年份：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.year&#125;</span>,</span><br><span class="hljs-string"> 颜⾊：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.color&#125;</span>,</span><br><span class="hljs-string"> ⾳响：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.sound&#125;</span></span><br><span class="hljs-string"> `</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;1HGCM82633A123456&quot;</span>, <span class="hljs-number">2018</span>, <span class="hljs-string">&quot;⿊⾊&quot;</span>, <span class="hljs-string">&quot;Bose⾳响&quot;</span>);<br>car.<span class="hljs-title function_">displayInfo</span>();<br></code></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><strong>抽象类:</strong><font style="color:rgb(38,38,38);">抽象类是⼀种</font><font style="color:rgb(223,42,63);">⽆法被实例化</font><font style="color:rgb(38,38,38);">的类，专⻔⽤来定义类的</font><font style="color:rgb(223,42,63);">结构和⾏为</font><font style="color:rgb(38,38,38);">，类中可以写</font><font style="color:rgb(223,42,63);">抽象⽅法</font><font style="color:rgb(38,38,38);">，也可以写</font><font style="color:rgb(223,42,63);">具体实现</font><font style="color:rgb(38,38,38);">。抽象类主要⽤来为其派⽣类提供⼀个</font><font style="color:rgb(223,42,63);">基础结构</font><font style="color:rgb(38,38,38);">，要求其派⽣类</font><font style="color:rgb(223,42,63);">必须实现</font><font style="color:rgb(38,38,38);">其中的抽象法。 简记：抽象类</font><font style="color:rgb(223,42,63);">不能实例化</font><font style="color:rgb(38,38,38);">，其意义是</font><font style="color:rgb(223,42,63);">可以被继承</font><font style="color:rgb(38,38,38);">，抽象类⾥可以有</font><font style="color:rgb(223,42,63);">普通⽅法</font><font style="color:rgb(38,38,38);">、也可以有</font><font style="color:rgb(223,42,63);">抽象⽅法</font><font style="color:rgb(38,38,38);">。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Package</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">weight</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// 抽象⽅法：⽤来计算运费，不同类型包裹有不同的计算⽅式</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">calculate</span>(): <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 通⽤⽅法：打印包裹详情</span><br>  <span class="hljs-title function_">printPackage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`包裹重量为: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.weight&#125;</span>kg，运费为: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.calculate()&#125;</span>元`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 标准包裹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardPackage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Package</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">weight</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">unitPrice</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 每公⽄的固定费率</span></span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-variable language_">super</span>(weight);<br>  &#125;<br>  <span class="hljs-comment">// 实现抽象⽅法：计算运费</span><br>  <span class="hljs-title function_">calculate</span>(): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">unitPrice</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建标准包裹实例</span><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardPackage</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>s1.<span class="hljs-title function_">printPackage</span>();<br></code></pre></td></tr></table></figure><p>:::info<br><font style="color:rgb(38,38,38);">总结：何时使⽤</font><font style="color:rgb(223,42,63);">抽象类</font><font style="color:rgb(38,38,38);">？ </font></p><p><font style="color:rgb(38,38,38);">1. 定义 通用接口：为⼀组相关的类定义通⽤的⾏为（⽅法或属性）时。 </font></p><p><font style="color:rgb(38,38,38);">2. 提供 基础实现：在抽象类中提供某些⽅法或为其提供基础实现，这样派⽣类就可以继承这 </font></p><p><font style="color:rgb(38,38,38);">些实现。 </font></p><p><font style="color:rgb(38,38,38);">3. 确保关键实现：强制派⽣类实现⼀些关键⾏为。 </font></p><p><font style="color:rgb(38,38,38);">4. 共享代码和逻辑：当多个类需要共享部分代码时，抽象类可以避免代码重复。 </font></p><p>:::</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>接口</strong>:<font style="color:rgb(38,38,38);">interface 是⼀种</font><font style="color:rgb(223,42,63);">定义结构</font><font style="color:rgb(38,38,38);">的⽅式，主要作⽤是为：类、对象、函数等规定</font><font style="color:rgb(223,42,63);">⼀种契约</font><font style="color:rgb(38,38,38);">，这样可以确保代码的⼀致性和类型安全，但要注意 interface </font><font style="color:rgb(223,42,63);">只能</font><font style="color:rgb(38,38,38);">定义</font><font style="color:rgb(223,42,63);">格式</font><font style="color:rgb(38,38,38);">，</font><font style="color:rgb(223,42,63);">不能</font><font style="color:rgb(38,38,38);">包含</font><font style="color:rgb(223,42,63);">任何实现.</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// PersonInterface接⼝，⽤与限制Person类的格式</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-comment">// 定义⼀个类 Person，实现 PersonInterface 接⼝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// 实现接⼝中的 speak ⽅法</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-comment">// 打印出包含名字和年龄的问候语句</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建⼀个 Person 类的实例 p1，传⼊名字 &#x27;tom&#x27; 和年龄 18</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">18</span>);<br>p1.<span class="hljs-title function_">speak</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 只读属性</span><br>  age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可选属性</span><br>  <span class="hljs-attr">run</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">UserInterface</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-title function_">run</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`奔跑了<span class="hljs-subst">$&#123;n&#125;</span>⽶`</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CountInterface</span> &#123;<br>  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">count</span>: <span class="hljs-title class_">CountInterface</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>接口的继承:</strong><font style="color:rgb(38,38,38);">⼀个 interface 继承另⼀个 interface ，从⽽实现代码的复⽤</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 姓名</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 年龄</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 年级</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">stu</span>: <span class="hljs-title class_">StudentInterface</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">grade</span>: <span class="hljs-string">&quot;⾼三&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>tip:当接口重复定义时,会自动合并</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// PersonInterface接⼝</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-comment">// 属性声明</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// 给PersonInterface接⼝添加新属性</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-comment">// ⽅法声明</span><br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-comment">// Person类实现PersonInterface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-comment">// ⽅法</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好！我是⽼师:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>:::info<br>总结：何时使⽤接⼝？</p><ol><li>定义对象的格式： 描述数据模型、API 响应格式、配置对象……..等等，是开发中⽤的最多<br>的场景。</li><li>类的契约：规定⼀个类需要实现哪些属性和⽅法。</li><li>扩展已有接⼝：⼀般⽤于扩展第三⽅库的类型， 这种特性在⼤型项⽬中可能会⽤到。</li></ol><p>:::</p><h4 id="interface-和-type"><a href="#interface-和-type" class="headerlink" title="interface 和 type"></a><font style="color:rgb(38,38,38);">interface 和 type</font></h4><p>:::info<br><font style="color:rgb(38,38,38);">相同点： interface 和 type 都可以⽤于定义</font><font style="color:rgb(223,42,63);">对象结构</font><font style="color:rgb(38,38,38);">，在定义对象结构时两者可以互换。 </font></p><p><font style="color:rgb(38,38,38);">不同点： </font></p><p><font style="color:rgb(38,38,38);">1️⃣</font><font style="color:rgb(38,38,38);"> </font><font style="color:rgb(38,38,38);">interface </font><font style="color:rgb(38,38,38);">：更专注于定义</font><font style="color:rgb(223,42,63);">对象</font><font style="color:rgb(38,38,38);">和</font><font style="color:rgb(223,42,63);">类</font><font style="color:rgb(38,38,38);">的结构，⽀持</font><font style="color:rgb(223,42,63);">继承</font><font style="color:rgb(38,38,38);">、</font><font style="color:rgb(223,42,63);">合并</font><font style="color:rgb(38,38,38);">。 </font></p><p><font style="color:rgb(38,38,38);">2️⃣</font><font style="color:rgb(38,38,38);"> type ：可以定义</font><font style="color:rgb(223,42,63);">类型别名、联合类型</font><font style="color:rgb(38,38,38);">、</font><font style="color:rgb(223,42,63);">交叉类型</font><font style="color:rgb(38,38,38);">，但不⽀持继承和⾃动合并。 </font></p><p>:::</p><h4 id="interface-和抽象类"><a href="#interface-和抽象类" class="headerlink" title="interface 和抽象类"></a><font style="color:rgb(38,38,38);">interface 和抽象类</font></h4><p>:::info<br><font style="color:rgb(38,38,38);">相同点：都能定义⼀个</font><font style="color:rgb(223,42,63);">类的格式</font><font style="color:rgb(38,38,38);">（定义类应遵循的契约） </font></p><p><font style="color:rgb(38,38,38);">不相同： </font></p><p><font style="color:rgb(38,38,38);">1️⃣</font><font style="color:rgb(38,38,38);"> 接⼝：</font><font style="color:rgb(223,42,63);">只能</font><font style="color:rgb(38,38,38);">描述</font><font style="color:rgb(223,42,63);">结构</font><font style="color:rgb(38,38,38);">，</font><font style="color:rgb(223,42,63);">不能</font><font style="color:rgb(38,38,38);">有任何</font><font style="color:rgb(223,42,63);">实现代码</font><font style="color:rgb(38,38,38);">，⼀个类可以实现</font><font style="color:rgb(223,42,63);">多个</font><font style="color:rgb(38,38,38);">接⼝。 </font></p><p><font style="color:rgb(38,38,38);">2️⃣</font><font style="color:rgb(38,38,38);"> 抽象类：既可以包含</font><font style="color:rgb(223,42,63);">抽象⽅法</font><font style="color:rgb(38,38,38);">，也可以包含</font><font style="color:rgb(223,42,63);">具体⽅法</font><font style="color:rgb(38,38,38);">， ⼀个类只能继承</font><font style="color:rgb(223,42,63);">⼀个</font><font style="color:rgb(38,38,38);">抽象类。</font></p><p>:::</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><font style="color:rgb(38,38,38);">泛型</font></h3><p><strong>泛型:</strong><font style="color:rgb(38,38,38);">泛型允许我们在定义函数、类或接⼝时，使⽤类型参数来表示</font><font style="color:rgb(223,42,63);">未指定的类型</font><font style="color:rgb(38,38,38);">，这些参数在具体</font><font style="color:rgb(223,42,63);">使⽤时</font><font style="color:rgb(38,38,38);">，才被指定</font><font style="color:rgb(223,42,63);">具体的类型</font><font style="color:rgb(38,38,38);">，泛型能让同⼀段代码适⽤于多种类型，同时仍然保持类型的安全性。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> logData&lt;T&gt;(<span class="hljs-attr">data</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br>logData&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">100</span>);<br>logData&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//也可以多个泛型</span><br><span class="hljs-keyword">function</span> logData&lt;T, U&gt;(<span class="hljs-attr">data1</span>: T, <span class="hljs-attr">data2</span>: U): T | U &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1, data2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() % <span class="hljs-number">2</span> ? data1 : data2;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">extraInfo</span>: T;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">PersonInterface</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p2</span>: <span class="hljs-title class_">PersonInterface</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br>p1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">extraInfo</span>: <span class="hljs-string">&quot;⼀个好⼈&quot;</span> &#125;;<br>p2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">extraInfo</span>: <span class="hljs-number">250</span> &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LengthInterface</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// 约束规则是：传⼊的类型T必须具有 length 属性</span><br><span class="hljs-keyword">function</span> logPerson&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LengthInterface</span>&gt;(<span class="hljs-attr">data</span>: T): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;<br>logPerson&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 报错：因为number不具备length属性</span><br><span class="hljs-comment">// logPerson&lt;number&gt;(100)</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;T&gt; &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params"> <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params"> <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params"> <span class="hljs-keyword">public</span> <span class="hljs-attr">extraInfo</span>: T</span><br><span class="hljs-params"> </span>) &#123; &#125;<br> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁了`</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">extraInfo</span>)<br> &#125;<br>&#125;<br><span class="hljs-comment">// 测试代码1</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">250</span>);<br><span class="hljs-comment">// 测试代码2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JobInfo</span> = &#123;<br> <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br> <span class="hljs-attr">company</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;<span class="hljs-title class_">JobInfo</span>&gt;(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">30</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;研发总监&#x27;</span>, <span class="hljs-attr">company</span>: <span class="hljs-string">&#x27;发发发</span><br><span class="hljs-string">科技公司&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a>类型声明文件</h3><p>:::info<br><font style="color:rgb(38,38,38);">类型声明⽂件是 TypeScript 中的⼀种特殊⽂件，通常以 .d.ts 作为扩展名。它的主要作⽤ </font></p><p><font style="color:rgb(38,38,38);">是为现有的 </font><font style="color:rgb(223,42,63);">JavaScript 代码</font><font style="color:rgb(38,38,38);">提供</font><font style="color:rgb(223,42,63);">类型信息</font><font style="color:rgb(38,38,38);">，使得 TypeScript 能够在使⽤这些 JavaScript 库 </font></p><p><font style="color:rgb(38,38,38);">或模块时进⾏</font><font style="color:rgb(223,42,63);">类型检查和提示</font><font style="color:rgb(38,38,38);">。</font></p><p>:::</p><h3 id="Ts-装饰器"><a href="#Ts-装饰器" class="headerlink" title="Ts 装饰器"></a><font style="color:rgb(38,38,38);">Ts 装饰器</font></h3><h4 id="Ts-装饰器简介"><a href="#Ts-装饰器简介" class="headerlink" title="Ts 装饰器简介"></a><font style="color:rgb(38,38,38);">Ts 装饰器</font>简介</h4><ol><li>装饰器本质是一种特殊的<strong>函数</strong>，它可以对：类、属性、方法、参数进行扩展，同时能让代码更简洁。</li><li>装饰器自<code>2015</code>年在<code>ECMAScript-6</code>中被提出到现在，已将近 10 年。</li><li>截止目前，装饰器依然是实验性特性 ，需要开发者手动调整配置，来开启装饰器支持。</li><li>装饰器有 5 种：</li></ol><p>1⃣ 类装饰器<br>2⃣ 属性装饰器<br>3⃣ 方法装饰器<br>4⃣ 访问器装饰器<br>5⃣ 参数装饰器</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  Demo函数会在Person类定义时执行</span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">     target参数是被装饰的类，即：Person</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>&#125;<br><br><span class="hljs-comment">// 使用装饰器</span><br><span class="hljs-meta">@Demo</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用装饰器重写toString方法 + 封闭其原型对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomString</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-comment">// 向被装饰类的原型上添加自定义的 toString 方法</span><br>  target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;;<br>  <span class="hljs-comment">// 封闭其原型对象，禁止随意操作其原型对象</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>&#125;<br><br><span class="hljs-comment">// 使用 CustomString 装饰器</span><br><span class="hljs-meta">@CustomString</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好呀！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 测试代码如下 */</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 输出：&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">toString</span>());<br><span class="hljs-comment">// 禁止随意操作其原型对象</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-comment">// Person.prototype.a = 100 // 此行会报错：Cannot add property a, object is not extensible</span><br><span class="hljs-comment">// console.log(p1.a)</span><br></code></pre></td></tr></table></figure><p><strong>类装饰器的返回值</strong></p><p>:::info<br><font style="color:rgb(51, 51, 51);">类装饰器有返回值：若类装饰器返回一个新的类，那这个新类将</font><strong><font style="color:rgb(51, 51, 51);">替换</font></strong><font style="color:rgb(51, 51, 51);">掉被装饰的类。</font></p><p><font style="color:rgb(51, 51, 51);">类装饰器无返回值：若类装饰器无返回值或返回</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;undefined&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，那被装饰的类</font><strong><font style="color:rgb(51, 51, 51);">不会</font></strong><font style="color:rgb(51, 51, 51);">被替换。</font></p><p>:::</p><p><strong><font style="color:rgb(51, 51, 51);">关于构造类型</font></strong></p><p><font style="color:rgb(119, 119, 119);">在 TypeScript 中，</font><code>&lt;font style=&quot;color:rgb(119, 119, 119);background-color:rgb(243, 244, 244);&quot;&gt;Function&lt;/font&gt;</code><font style="color:rgb(119, 119, 119);"> 类型所表示的范围十分广泛，包括：普通函数、箭头函数、方法等等。但并非</font><code>&lt;font style=&quot;color:rgb(119, 119, 119);background-color:rgb(243, 244, 244);&quot;&gt;Function&lt;/font&gt;</code><font style="color:rgb(119, 119, 119);"> 类型的函数都可以被 </font><code>&lt;font style=&quot;color:rgb(119, 119, 119);background-color:rgb(243, 244, 244);&quot;&gt;new&lt;/font&gt;</code><font style="color:rgb(119, 119, 119);"> 关键字实例化，例如箭头函数是不能被实例化的，那么 TypeScript 中概如何声明一个构造类型呢？有以下两种方式：</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ○ new     表示：该类型是可以用new操作符调用。</span><br><span class="hljs-comment">  ○ ...args 表示：构造器可以接受【任意数量】的参数。</span><br><span class="hljs-comment">  ○ any[]   表示：构造器可以接受【任意类型】的参数。</span><br><span class="hljs-comment">  ○ &#123;&#125;      表示：返回类型是对象(非null、非undefined的对象)。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 定义Constructor类型，其含义是构造类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; &#123;&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-attr">fn</span>: <span class="hljs-title class_">Constructor</span></span>) &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-title class_">Person</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个构造类型，且包含一个静态属性 wife</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = &#123;<br>  <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): &#123;&#125;; <span class="hljs-comment">// 构造签名</span><br>  <span class="hljs-attr">wife</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// wife属性</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-attr">fn</span>: <span class="hljs-title class_">Constructor</span></span>) &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">static</span> wife = <span class="hljs-string">&quot;asd&quot;</span>;<br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-title class_">Person</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// User接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">getTime</span>(): <span class="hljs-title class_">Date</span>;<br>  <span class="hljs-title function_">log</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// 自定义类型Class</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; &#123;&#125;;<br><br><span class="hljs-comment">// 创建一个装饰器，为类添加日志功能和创建时间</span><br><span class="hljs-keyword">function</span> <span class="hljs-title class_">LogTime</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Constructor</span>&gt;(<span class="hljs-attr">target</span>: T) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> target &#123;<br>    <span class="hljs-attr">createdTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(...args);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 记录对象创建时间</span><br>    &#125;<br>    <span class="hljs-title function_">getTime</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`该对象创建时间为：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.createdTime&#125;</span>`</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@LogTime</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：你好啊！`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">13</span>);<br>user1.<span class="hljs-title function_">speak</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-title function_">getTime</span>());<br></code></pre></td></tr></table></figure><h4 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h4><p><strong><font style="color:rgb(51, 51, 51);">装饰器工厂是一个返回装饰器函数的函数，可以为装饰器添加参数，可以更灵活地控制装饰器的行为。</font></strong></p><p><strong><font style="color:rgb(51, 51, 51);">需求：</font></strong><font style="color:rgb(51, 51, 51);">定义一个</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;LogInfo&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">类装饰器工厂，实现</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;Person&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">实例可以调用到</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;introduce&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">方法，且</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;introduce&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">中输出内容的次数，由</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;LogInfo&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">接收的参数决定。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">introduce</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个装饰器工厂 LogInfo，它接受一个参数 n，返回一个类装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LogInfo</span>(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-comment">// 装饰器函数，target 是被装饰的类</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">introduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我的名字：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@LogInfo</span>(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好呀！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// console.log(p1) // 打印的p1是：_classThis，转换的JS版本比较旧时，会出现，不必纠结</span><br>p1.<span class="hljs-title function_">speak</span>();<br>p1.<span class="hljs-title function_">introduce</span>();<br></code></pre></td></tr></table></figure><p>:::info<br><font style="color:rgb(51, 51, 51);">装饰器可以组合使用，执行顺序为：先【由上到下】的执行所有的装饰器工厂，依次获取到装饰器，然后再【由下到上】执行所有的装饰器。</font></p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test1&quot;</span>);<br>&#125;<br><span class="hljs-comment">//装饰器工厂</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test2工厂&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test2&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">//装饰器工厂</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test3工厂&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test3&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">//装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test4</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test4&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@test1</span><br><span class="hljs-meta">@test2</span>()<br><span class="hljs-meta">@test3</span>()<br><span class="hljs-meta">@test4</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  控制台打印：</span><br><span class="hljs-comment">    test2工厂</span><br><span class="hljs-comment">    test3工厂</span><br><span class="hljs-comment">    test4</span><br><span class="hljs-comment">    test3</span><br><span class="hljs-comment">    test2</span><br><span class="hljs-comment">    test1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target: 对于静态属性来说值是类，对于实例属性来说值是类的原型对象。</span><br><span class="hljs-comment">    ○ propertyKey: 属性名。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, propertyKey);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Demo</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-meta">@Demo</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-meta">@Demo</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">school</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p><font style="color:rgb(119, 119, 119);">如下代码中：当构造器中的</font><code>&lt;font style=&quot;color:rgb(119, 119, 119);background-color:rgb(243, 244, 244);&quot;&gt;this.age = age&lt;/font&gt;</code><font style="color:rgb(119, 119, 119);">试图在实例上赋值时，实际上是调用了原型上</font><code>&lt;font style=&quot;color:rgb(119, 119, 119);background-color:rgb(243, 244, 244);&quot;&gt;age&lt;/font&gt;</code><font style="color:rgb(119, 119, 119);">属性的</font><code>&lt;font style=&quot;color:rgb(119, 119, 119);background-color:rgb(243, 244, 244);&quot;&gt;set&lt;/font&gt;</code><font style="color:rgb(119, 119, 119);">方法。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> value = <span class="hljs-number">99</span>;<br><span class="hljs-comment">// 使用defineProperty给Person原型添加age属性，并配置对应的get与set</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;age&quot;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;<br>    value = val;<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">//与js同理,实例对象上无age属性,沿原型链逐级查找,在原型对象查找到age,进行修改,则不会在实例对象上创建age属性</span><br><span class="hljs-comment">//若先创建示例对象,在调用Object.defineProperty方法去添加属性,则示例对象的age为给定的值,原型上的age为原拟定的value</span><br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>); <span class="hljs-comment">//18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span>); <span class="hljs-comment">//18</span><br></code></pre></td></tr></table></figure><p><font style="color:rgb(51, 51, 51);">需求：定义一个</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;State&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">属性装饰器，来监视属性的修改。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 声明一个装饰器函数 State，用于捕获数据的修改</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">State</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 存储属性的内部值</span><br>  <span class="hljs-keyword">let</span> key = <span class="hljs-string">`__<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>;<br><br>  <span class="hljs-comment">// 使用 Object.defineProperty 替换类的原始属性</span><br>  <span class="hljs-comment">// 重新定义属性，使其使用自定义的 getter 和 setter</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[key];<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params"><span class="hljs-attr">newVal</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>的最新值为：<span class="hljs-subst">$&#123;newVal&#125;</span>`</span>);<br>      <span class="hljs-comment">//将变化的值存在实例本身,以免发生多个实例对象捕获无法区分的错误</span><br>      <span class="hljs-variable language_">this</span>[key] = newVal;<br>    &#125;,<br>    <span class="hljs-comment">//可枚举性</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">//可配置性</span><br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">//使用State装饰器</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  school = <span class="hljs-string">&quot;atguigu&quot;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">30</span>);<br><br>p1.<span class="hljs-property">age</span> = <span class="hljs-number">80</span>;<br>p2.<span class="hljs-property">age</span> = <span class="hljs-number">90</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;------------------&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>); <span class="hljs-comment">//80</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">age</span>); <span class="hljs-comment">//90</span><br></code></pre></td></tr></table></figure><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target: 对于静态方法来说值是类，对于实例方法来说值是原型对象。</span><br><span class="hljs-comment">    ○ propertyKey:方法的名称。</span><br><span class="hljs-comment">    ○ descriptor: 方法的描述对象，其中value属性是被装饰的方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propertyKey);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// Demo装饰实例方法</span><br>  <span class="hljs-meta">@Demo</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>  <span class="hljs-comment">// Demo装饰静态方法</span><br>  <span class="hljs-meta">@Demo</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">isAdult</span>(<span class="hljs-params"><span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>p1.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>需求：</p><ol><li>定义一个<code>Logger</code>方法装饰器，用于在方法执行前和执行后，均追加一些额外逻辑。</li><li>定义一个<code>Validate</code>方法装饰器，用于验证数据。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Logger</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 保存原始方法</span><br>  <span class="hljs-keyword">const</span> original = descriptor.<span class="hljs-property">value</span>;<br>  <span class="hljs-comment">// 替换原始方法</span><br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>开始执行......`</span>);<br>    <span class="hljs-comment">//不能直接调用original,否则会丢失this,使用call函数,修改this指向</span><br>    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>执行完毕......`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Validate</span>(<span class="hljs-params"><span class="hljs-attr">maxValue</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 保存原始方法</span><br>    <span class="hljs-keyword">const</span> original = descriptor.<span class="hljs-property">value</span>;<br>    <span class="hljs-comment">// 替换原始方法</span><br>    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>      <span class="hljs-comment">// 自定义的验证逻辑</span><br>      <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] &gt; maxValue) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;年龄非法！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 如果所有参数都符合要求，则调用原始方法</span><br>      <span class="hljs-comment">//call和apply都能修改this,call需要一个一个传参数,apply一次性传入数组</span><br>      <span class="hljs-keyword">return</span> original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-meta">@Logger</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>  <span class="hljs-meta">@Validate</span>(<span class="hljs-number">120</span>)<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isAdult</span>(<span class="hljs-params"><span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>p1.<span class="hljs-title function_">speak</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">isAdult</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><h4 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target: </span><br><span class="hljs-comment">        1. 对于实例访问器来说值是【所属类的原型对象】。</span><br><span class="hljs-comment">        2. 对于静态访问器来说值是【所属类】。</span><br><span class="hljs-comment">    ○ propertyKey:访问器的名称。</span><br><span class="hljs-comment">    ○ descriptor: 描述对象。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propertyKey);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Demo</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">address</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;北京宏福科技园&quot;</span>;<br>  &#125;<br>  <span class="hljs-meta">@Demo</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">country</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;中国&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(51, 51, 51);">需求：对</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;Weather&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">类的</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;temp&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">属性的</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;set&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">访问器进行限制，设置的最低温度</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;-50&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，最高温度</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;50&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);"></font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">RangeValidate</span>(<span class="hljs-params"><span class="hljs-attr">min</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">max</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 保存原始的 setter 方法，以便在后续调用中使用</span><br>    <span class="hljs-keyword">const</span> originalSetter = descriptor.<span class="hljs-property">set</span>;<br><br>    <span class="hljs-comment">// 重写 setter 方法，加入范围验证逻辑</span><br>    descriptor.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>      <span class="hljs-comment">// 检查设置的值是否在指定的最小值和最大值之间</span><br>      <span class="hljs-keyword">if</span> (value &lt; min || value &gt; max) &#123;<br>        <span class="hljs-comment">// 如果值不在范围内，抛出错误</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>的值应该在 <span class="hljs-subst">$&#123;min&#125;</span> 到 <span class="hljs-subst">$&#123;max&#125;</span>之间！`</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 如果值在范围内，且原始 setter 方法存在，则调用原始 setter 方法</span><br>      <span class="hljs-keyword">if</span> (originalSetter) &#123;<br>        originalSetter.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, value);<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_temp</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">_temp</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_temp</span> = _temp;<br>  &#125;<br>  <span class="hljs-comment">// 设置温度范围在 -50 到 50 之间</span><br>  <span class="hljs-meta">@RangeValidate</span>(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>)<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">temp</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_temp</span> = value;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">temp</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_temp</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> w1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weather</span>(<span class="hljs-number">25</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(w1);<br>w1.<span class="hljs-property">temp</span> = <span class="hljs-number">67</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(w1);<br></code></pre></td></tr></table></figure><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target:</span><br><span class="hljs-comment">      1.如果修饰的是【实例方法】的参数，target 是类的【原型对象】。</span><br><span class="hljs-comment">      2.如果修饰的是【静态方法】的参数，target 是【类】。</span><br><span class="hljs-comment">    ○ propertyKey：参数所在的方法的名称。</span><br><span class="hljs-comment">    ○ parameterIndex: 参数在函数参数列表中的索引，从 0 开始。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">parameterIndex</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propertyKey);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parameterIndex);<br>&#125;<br><br><span class="hljs-comment">// 类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"><span class="hljs-meta">@Demo</span> <span class="hljs-attr">message1</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">message2</span>: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>想对说：<span class="hljs-subst">$&#123;message1&#125;</span>，<span class="hljs-subst">$&#123;message2&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font style="color:rgb(51, 51, 51);">需求：定义方法装饰器</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;Validate&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，同时搭配参数装饰器</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;NotNumber&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，来对</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;speak&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">方法的参数类型进行限制。</font></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NotNumber</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">parameterIndex</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-comment">// 初始化或获取当前方法的参数索引列表</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">notNumberArr</span>: <span class="hljs-built_in">number</span>[] = target[<span class="hljs-string">`__notNumber_<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>] || [];<br>  <span class="hljs-comment">// 将当前参数索引添加到列表中</span><br>  notNumberArr.<span class="hljs-title function_">push</span>(parameterIndex);<br>  <span class="hljs-comment">// 将列表存储回目标对象</span><br>  target[<span class="hljs-string">`__notNumber_<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>] = notNumberArr;<br>&#125;<br><br><span class="hljs-comment">// 方法装饰器定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Validate</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> method = descriptor.<span class="hljs-property">value</span>;<br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-comment">// 获取被标记为不能为空的参数索引列表</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">notNumberArr</span>: <span class="hljs-built_in">number</span>[] = target[<span class="hljs-string">`__notNumber_<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>] || [];<br>    <span class="hljs-comment">// 检查参数是否为 null 或 undefined</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> index <span class="hljs-keyword">of</span> notNumberArr) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[index] === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>          <span class="hljs-string">`方法 <span class="hljs-subst">$&#123;propertyKey&#125;</span> 中索引为 <span class="hljs-subst">$&#123;index&#125;</span> 的参数不能是数字！`</span><br>        );<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 调用原始方法</span><br>    <span class="hljs-keyword">return</span> method.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-comment">// 类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-meta">@Validate</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"><span class="hljs-meta">@NotNumber</span> <span class="hljs-attr">message1</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">mesage2</span>: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>想对说：<span class="hljs-subst">$&#123;message1&#125;</span>，<span class="hljs-subst">$&#123;mesage2&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>s1.<span class="hljs-title function_">speak</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
