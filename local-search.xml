<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack补充</title>
    <link href="/2025/04/04/webpack%E8%A1%A5%E5%85%85/"/>
    <url>/2025/04/04/webpack%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h3 id="n8Ieg">Webpack性能优化</h3><h4 id="nzSvD">代码分离</h4><p>由于Webpack打包后的代码都糅杂在bundle.js中 , 导致bundle.js 比较大,加载速度比较慢 ,导致首屏渲染速度慢 ,可能用户打开会有白屏时间 , 所以需要进行分包处理</p><p>Webpack常用代码分离:</p><ul><li>入口起点：使用entry配置手动分离代码； </li><li>防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码； </li><li>动态导入：通过模块的内联函数调用来分离代码；</li></ul><h5 id="zoY0b">多入口文件</h5><p>分别配置两个入口文件,output时占位符动态生成输出文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">entry</span>: &#123;<br>       <span class="hljs-attr">index</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>),<br>       <span class="hljs-attr">main</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>),<br>   &#125;,<br>   <span class="hljs-attr">output</span>: &#123;<br>       <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>       <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>       <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name]-bundle.js&#x27;</span><br>   &#125;,<br></code></pre></td></tr></table></figure><hr><pre><code class="hljs">如果多个入口文件共享同一依赖,每个输出文件中都会有一份打包后的依赖,需要配置文件共享</code></pre><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">entry</span>: &#123;<br>       <span class="hljs-attr">index</span>: &#123;<br>           <span class="hljs-attr">import</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>),<br>           <span class="hljs-attr">dependOn</span>: <span class="hljs-string">&#x27;shared&#x27;</span><br>       &#125;,<br>       <span class="hljs-attr">main</span>: &#123;<br>           <span class="hljs-attr">import</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>),<br>           <span class="hljs-attr">dependOn</span>: <span class="hljs-string">&#x27;shared&#x27;</span><br>       &#125;,<br>       <span class="hljs-attr">shared</span>: [<span class="hljs-string">&#x27;axios&#x27;</span>]<br>   &#125;,<br>   <span class="hljs-attr">output</span>: &#123;<br>       <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>       <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>       <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name]-bundle.js&#x27;</span><br>   &#125;,<br></code></pre></td></tr></table></figure><h5 id="Kr7FY">动态导入</h5><ul><li>第一种，使用ECMAScript中的 import() 语法来完成，也是目前推荐的方式</li><li>第二种，使用webpack遗留的 require.ensure，目前已经不推荐使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 当执行点击事件才被动态导入</span><br>btn1.<span class="hljs-property">conclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./router/about&#x27;</span>)<br>&#125;<br>btn1.<span class="hljs-property">conclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./router/tip&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li>因为动态导入通常是一定会打包成独立的文件的，所以并不会在cacheGroups中进行配置； </li><li>那么它的命名我们通常会在output中，通过 <strong>chunkFilename</strong> 属性来命名；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>        <span class="hljs-comment">//单独对分包的文件进行命名</span><br>        <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name]_chunk.js&#x27;</span><br>    &#125;,<br></code></pre></td></tr></table></figure><p>默认情况下[id]和[name]是相同的 , 如果我们希望修改name的值，可以通过<strong>magic comments（魔法注释）</strong>的方式；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">btn1.<span class="hljs-property">conclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackChunkName:&quot;about&quot; */</span> <span class="hljs-string">&#x27;./router/about&#x27;</span>)<br>&#125;<br>btn1.<span class="hljs-property">conclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackChunkName:&quot;tip&quot; */</span><span class="hljs-string">&#x27;./router/tip&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/foo&#x27;</span><br>btn1.<span class="hljs-property">conclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//开启预下载</span><br>    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true, webpackChunkName:&quot;about&quot; */</span> <span class="hljs-string">&#x27;./router/about&#x27;</span>)<br>&#125;<br>btn1.<span class="hljs-property">conclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//开启预加载</span><br>    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackPreload: true, webpackChunkName:&quot;tip&quot; */</span><span class="hljs-string">&#x27;./router/tip&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">foo</span>()<br><br></code></pre></td></tr></table></figure><ul><li><strong>prefetch</strong>(预获取)：将来某些导航下可能需要的资源 </li><li><strong>preload</strong>(预加载)：当前导航下可能需要资源</li></ul><hr><h5 id="l3cLo">自定义分包</h5><p>另外一种分包的模式是<strong>splitChunk</strong>，它底层是使用<strong>SplitChunksPlugin</strong>来实现的： </p><p>因为该插件webpack已经默认安装和集成，所以我们并不需要单独安装和直接使用该插件； </p><p>只需要提供SplitChunksPlugin相关的配置信息即可； </p><p>Webpack<strong>提供了SplitChunksPlugin默认的配置</strong>，我们也可以手动来修改它的配置</p><ul><li>比如默认配置中，chunks仅仅针对于异步（async）请求，我们也可以设置为all</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">optimization</span>: &#123;<br>       <span class="hljs-attr">splitChunks</span>: &#123;<br>           <span class="hljs-comment">//默认对async分包</span><br>           <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>, <br>           <span class="hljs-attr">maxSize</span>: <span class="hljs-number">200000</span>, <span class="hljs-comment">//当一个包大于指定大小,继续拆分</span><br>           <span class="hljs-attr">minSize</span>: <span class="hljs-number">20</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 设置最小分包大小,默认20000</span><br>           <span class="hljs-attr">minSizeReduction</span>: <span class="hljs-number">50</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 需要分包的bundle最小大小</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><hr><p>用于对拆分的包就行分组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">optimization</span>: &#123;<br>       <span class="hljs-attr">splitChunks</span>: &#123;<br>           <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>, <span class="hljs-comment">// 拆分所有模块（同步/异步）</span><br>           <span class="hljs-attr">minSize</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 允许拆分任意大小的模块（测试时使用，生产环境按需调整）</span><br>           <span class="hljs-attr">maxSize</span>: <span class="hljs-number">200000</span>,<br>           <span class="hljs-attr">cacheGroups</span>: &#123;<br>               <span class="hljs-attr">vendors</span>: &#123;<br>                   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>                   <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;vendors_chunk.js&#x27;</span>, <br>               &#125;,<br>               <span class="hljs-attr">utils</span>: &#123;<br>                   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]src[\\/]utils[\\/]/</span>,<br>                   <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;utils_chunk.js&#x27;</span>,<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>用于对拆分的包就行分组，比如一个lodash在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打包；</p><ul><li>test属性：匹配符合规则的包； </li><li>name属性：拆分包的name属性； </li><li>filename属性：拆分包的名称，可以自己使用placeholder属性</li></ul><hr><p>optimization.chunkIds配置用于告知webpack模块的id采用什么算法生成</p><ul><li>natural：按照数字的顺序使用id； </li><li>named：development下的默认值，一个可读的名称的id； </li><li>deterministic：确定性的，在不同的编译中不变的短数字id</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">optimization</span>: &#123;<br>       <span class="hljs-attr">chunkIds</span>: <span class="hljs-string">&#x27;natural&#x27;</span>,<br>       <span class="hljs-attr">splitChunks</span>: &#123;<br>           <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>, <span class="hljs-comment">// 拆分所有模块（同步/异步）</span><br>           <span class="hljs-attr">minSize</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 允许拆分任意大小的模块（测试时使用，生产环境按需调整）</span><br>           <span class="hljs-attr">maxSize</span>: <span class="hljs-number">200000</span>,<br>           <span class="hljs-attr">cacheGroups</span>: &#123;<br>               <span class="hljs-attr">vendors</span>: &#123;<br>                   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>                   <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[id]_vendors_chunk.js&#x27;</span>,<br>               &#125;,<br>               <span class="hljs-attr">utils</span>: &#123;<br>                   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]src[\\/]utils[\\/]/</span>,<br>                   <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[id]_utils_chunk.js&#x27;</span>,<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><hr><h5 id="oh1oM">CDN</h5><p>CDN称之为内容分发网络（Content Delivery Network或Content Distribution Network，缩写：CDN） </p><p>它是指通过相互连接的网络系统，利用最靠近每个用户的服务器； 更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户； 来提供高性能、可扩展性及低成本的网络内容传递给用户；</p><ul><li>方式一:打包的所有静态资源，放到CDN服务器,用户所有资源都是通过CDN服务器加载的:</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">output</span>: &#123;<br>       <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>       <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>       <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>       <span class="hljs-comment">//单独对分包的文件进行命名</span><br>       <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name]_chunk.js&#x27;</span>,<br>       <span class="hljs-comment">// 将静态资源所部署的cdn服务器进行配置</span><br>       <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;http://cdn/&quot;</span><br>   &#125;,<br></code></pre></td></tr></table></figure><p>如果所有的静态资源都想要放到CDN服务器上，我们需要购买自己的CDN服务器,项目中，我们如何去引入这些CDN呢</p><pre><code class="hljs">- 第一，在打包的时候我们不再需要对类似于lodash或者dayjs这些库进行打包； - 第二，在html模块中，我们需要自己加入对应的CDN服务器地址；</code></pre><ul><li>方式二:一些第三方资源放到CDN服务器上;</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">//配置不需要打包的文件</span><br><span class="hljs-attr">externals</span>: &#123;<br>  <span class="hljs-comment">//key:排除的框架名</span><br>  <span class="hljs-comment">//value:引入cdn中的导出名</span><br>        <span class="hljs-attr">react</span>: <span class="hljs-string">&#x27;React&#x27;</span>,<br>        <span class="hljs-attr">axios</span>: <span class="hljs-string">&#x27;axios&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="usOfK">提取css</h5><p>安装：npm i mini-css-extract-plugin -D</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>),<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>        <span class="hljs-comment">//单独对分包的文件进行命名</span><br>        <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name]_chunk.js&#x27;</span>,<br>        <span class="hljs-comment">// 将静态资源所部署的cdn服务器进行配置</span><br>        <span class="hljs-comment">// publicPath: &quot;http://cdn/&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">module</span>: &#123;<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>            &#125;,<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./index.html&#x27;</span>)<br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name]_[hash:6].css&#x27;</span>,<br>            <span class="hljs-comment">//动态导入的css文件分包</span><br>            <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name]_[hash:6].css&#x27;</span><br>        &#125;)<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>之前使用style-loader将style创建style标签,将css存储在style标签中,目前使用mini-css-extract-plugin,不需要style-loader,需要使用MiniCssExtractPlugin.loader将css以内联形式插入html中</p><h5 id="huxIn">hash值的区别</h5><p>**在我们给打包的文件进行命名的时候，会使用placeholder，placeholder中有几个属性比较相似： **</p><ul><li>hash、chunkhash、contenthash </li><li>hash本身是通过MD4的散列函数处理后，生成一个128位的hash值（32个十六进制）</li></ul><p>**hash值的生成和整个项目有关系： **</p><ul><li>比如我们现在有两个入口index.js和main.js； </li><li>它们分别会输出到不同的bundle文件中，并且在文件名称中我们有使用hash； </li><li>这个时候，如果修改了index.js文件中的内容，那么hash会发生变化； </li><li>那就意味着两个文件的名称都会发生变化；</li></ul><p>**chunkhash可以有效的解决上面的问题，它会根据不同的入口进行解析来生成hash值： **</p><ul><li>比如我们修改了index.js，那么main.js的chunkhash是不会发生改变的；</li></ul><p>**contenthash表示生成的文件hash名称，只和内容有关系： **</p><ul><li>比如我们的index.js，引入了一个style.css，style.css有被抽取到一个独立的css文件中； </li><li>这个css文件在命名时，如果我们使用的是chunkhash； </li><li>那么当index.js文件的内容发生变化时，css文件的命名也会发生变化； </li><li>这个时候我们可以使用contenthash；</li></ul><h4 id="cF3O4">代码压缩</h4><h5 id="hzRqW">Terser</h5><p>Terser是一个JavaScript的解释（Parser）、Mangler（绞肉机）&#x2F;Compressor（压缩机）的工具集；terser可以帮助我们压缩、丑化我们的代码，让我们的bundle变得更小</p><p>terser是一个单独的工具,可以独立安装:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"># 全局安装<br>npm install terser -g<br># 局部安装<br>npm install terser -D<br></code></pre></td></tr></table></figure><p>可以在单独使用terser:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">terser [input files] [options]<br># 举例说明<br>terser js/file1.<span class="hljs-property">js</span> -o foo.<span class="hljs-property">min</span>.<span class="hljs-property">js</span> -c -m<br></code></pre></td></tr></table></figure><hr><p>**Compress option： **</p><ul><li>arrows：class或者object中的函数，转换成箭头函数； </li><li>arguments：将函数中使用 arguments[index]转成对应的形参名称； </li><li>dead_code：移除不可达的代码（tree shaking）</li></ul><p>其他属性查看文档</p><p>**Mangle option **</p><ul><li>toplevel：默认值是false，顶层作用域中的变量名称，进行丑化（转换）； </li><li>keep_classnames：默认值是false，是否保持依赖的类名称； </li><li>keep_fnames：默认值是false，是否保持原来的函数名称；</li></ul><p>其他属性查看文档</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">npx terser ./src/abc.<span class="hljs-property">js</span> -o abc.<span class="hljs-property">min</span>.<span class="hljs-property">js</span> -c <br>arrows,<span class="hljs-variable language_">arguments</span>=<span class="hljs-literal">true</span>,dead_code -m <br>toplevel=<span class="hljs-literal">true</span>,keep_classnames=<span class="hljs-literal">true</span>,keep_fnames=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><p><strong>webpack配置terser</strong></p><ul><li>在webpack中有一个minimizer属性，在production模式下，默认就是使用TerserPlugin来处理我们的代码的； </li><li>如果我们对默认的配置不满意，也可以自己来创建TerserPlugin的实例，并且覆盖相关的配置；</li></ul><p>首先，我们需要打开minimize，让其对我们的代码进行压缩（默认production模式下已经打开了） 其次，我们可以在minimizer创建一个TerserPlugin： </p><ul><li><strong>extractComments</strong>：默认值为true，表示会将注释抽取到一个单独的文件中； <ul><li>在开发中，我们不希望保留这个注释时，可以设置为false；</li></ul></li><li><strong>parallel</strong>：使用多进程并发运行提高构建的速度，默认值是true <ul><li>并发运行的默认数量： os.cpus().length - 1； </li><li>我们也可以设置自己的个数，但是使用默认值即可；</li></ul></li><li><strong>terserOptions</strong>：设置我们的terser相关的配置 <ul><li>compress：设置压缩相关的选项； </li><li>mangle：设置丑化相关的选项，可以直接设置为true； </li><li>toplevel：顶层变量是否进行转换； </li><li>keep_classnames：保留类的名称； </li><li>keep_fnames：保留函数的名称；</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minimizer</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPulgin</span>(&#123;<br>      <span class="hljs-comment">//第三方库注释不会抽取到单独的注释文件中</span><br>      <span class="hljs-attr">extractComments</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-comment">//terser压缩设置</span><br>      <span class="hljs-attr">terserOptions</span>: &#123;<br>        <span class="hljs-attr">compress</span>: &#123;<br>          <span class="hljs-attr">arguments</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-comment">//无用代码删除[默认true]( 类似tree shaking )</span><br>          <span class="hljs-attr">unused</span>:<span class="hljs-literal">false</span><br>        &#125;,<br>        <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">toplevel</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">//保留函数名</span><br>        <span class="hljs-attr">keep_fnames</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    &#125;)<br>  ]<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="mdXWX">css压缩</h5><p>使用<a href="https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/">CssMinimizerWebpackPlugin</a>优化和压缩独立的CSS模块</p><p>安装：npm i css-minimizer-webpack-plugin -D</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;css-minimizer-webpack-plugin&quot;</span>);<br><br><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minimizer</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPulgin</span>(&#123;<br>      <span class="hljs-comment">//第三方库注释不会抽取到单独的注释文件中</span><br>      <span class="hljs-attr">extractComments</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-comment">//terser压缩设置</span><br>      <span class="hljs-attr">terserOptions</span>: &#123;<br>        <span class="hljs-attr">compress</span>: &#123;<br>          <span class="hljs-attr">arguments</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-comment">//无用代码删除[默认true]( 类似tree shaking )</span><br>          <span class="hljs-attr">unused</span>:<span class="hljs-literal">false</span><br>        &#125;,<br>        <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">toplevel</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">//保留函数名</span><br>        <span class="hljs-attr">keep_fnames</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()<br>  ]<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="D8OUL">http压缩</h5><p><strong>HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式</strong></p><p>HTTP压缩的流程什么呢？ </p><ul><li>第一步：HTTP数据在服务器发送前就已经被压缩了；（可以在webpack中完成） </li><li>第二步：兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式； </li><li>第三步：服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器；</li></ul><p>**目前的压缩格式非常的多： **</p><ul><li>compress – UNIX的“compress”程序的方法（历史性原因，不推荐大多数应用使用，应该使用gzip或deflate）； </li><li>deflate – 基于deflate算法（定义于RFC 1951）的压缩，使用zlib数据格式封装； </li><li>gzip – GNU zip格式（定义于RFC 1952），是目前使用比较广泛的压缩算法； </li><li>br – 一种新的开源压缩算法，专为HTTP内容的编码而设计；</li></ul><p>**webpack中相当于是实现了HTTP压缩的第一步操作，我们可以使用CompressionPlugin。 **</p><p>第一步，安装CompressionPlugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install compression-webpack-plugin -D<br></code></pre></td></tr></table></figure><p>第二步，使用CompressionPlugin即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|css|)$/</span>, <span class="hljs-comment">// 匹配要压缩的文件类型</span><br>          <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[path][base].gz&#x27;</span>, <span class="hljs-comment">// 压缩后的文件名</span><br>          <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>, <span class="hljs-comment">// 压缩算法</span><br>          <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>, <span class="hljs-comment">// 只有文件大小大于该值时才会进行压缩（单位：字节）</span><br>          <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span> <span class="hljs-comment">// 只有压缩率小于该值时才会生成压缩文件</span><br>      &#125;)<br></code></pre></td></tr></table></figure><h5 id="dq3ph">html压缩</h5><p>我们之前使用了HtmlWebpackPlugin插件来生成HTML的模板，事实上它还有一些其他的配置： </p><p>inject：设置打包的资源插入的位置 </p><ul><li>true、 false 、body、head</li></ul><p>cache：设置为true，只有当文件改变时，才会生成新的文件（默认值也是true） </p><p>minify：默认会使用一个插件html-minifier-terser进行压缩</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-attr">plugins</span>: [<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>    <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./index.html&#x27;</span>), <span class="hljs-comment">// 自定义模板</span><br>    <span class="hljs-attr">inject</span>: <span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-comment">// 插入到body</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-comment">// 输出文件名，默认index.html</span><br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;webpack测试&#x27;</span>, <span class="hljs-comment">// 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用</span><br>    <span class="hljs-comment">// minify: true, // 压缩,也可以自定义压缩</span><br>    <span class="hljs-attr">minify</span>: isProduction ? &#123;<br>      <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//会移除 HTML 中的空白字符</span><br>      <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//移除 HTML 中的注释</span><br>      <span class="hljs-attr">removeRedundantAttributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//移除 HTML 中的注释</span><br>      <span class="hljs-attr">removeScriptTypeAttributes</span>: <span class="hljs-literal">true</span>, <br>      <span class="hljs-attr">removeStyleLinkTypeAttributes</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">useShortDoctype</span>: <span class="hljs-literal">true</span><br>    &#125; : <span class="hljs-literal">false</span><br>  &#125;),<br>]<br></code></pre></td></tr></table></figure><h4 id="ysps3">treeshaking</h4><h5 id="Wwb1j">js-treeshaking</h5><p>Tree Shaking 是一种在打包工具中用于移除代码中未使用部分的技术，它能显著减小打包文件的体积，提高应用的加载速度。Tree Shaking 的核心原理基于** ES6 的静态模块结构<strong>。ES6 模块采用静态导入和导出，这意味着</strong>在编译阶段就能确定模块之间的依赖关系**，无需执行代码。通过分析这些静态依赖，打包工具可以找出哪些代码实际上并未被使用，然后将其从最终的打包文件中移除。</p><p>在 production 模式下，webpack默认开启Tree Shaking </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-comment">//配置usedExports,告诉Terser该代码无用,可以删除</span><br>  <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minimizer</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPulgin</span>(&#123;<br>      <span class="hljs-comment">//第三方库注释不会抽取到单独的注释文件中</span><br>      <span class="hljs-attr">extractComments</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-comment">//terser压缩设置</span><br>      <span class="hljs-attr">terserOptions</span>: &#123;<br>        <span class="hljs-attr">compress</span>: &#123;<br>          <span class="hljs-attr">arguments</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-comment">//无用代码删除[默认true]( 类似tree shaking )</span><br>          <span class="hljs-attr">unused</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">toplevel</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">//保留函数名</span><br>        <span class="hljs-attr">keep_fnames</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()<br>  ]<br>&#125;,<br></code></pre></td></tr></table></figure><p>在usedExports设置为true时，会有一段注释：unused harmony export mul</p><p>这段注释的意义是什么呢？告知Terser在优化时，可以删除掉这段代码</p><hr><p><strong>sideEffects</strong></p><p>sideEffects用于告知webpack compiler哪些模块时有副作用的： 副作用的意思是这里面的代码有执行一些特殊的任务，不能仅仅通过export来判断这段代码的意义</p><p>在<strong>package.json中</strong>设置<strong>sideEffects</strong>的值： </p><ul><li>如果我们将sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports； </li><li>如果有一些我们希望保留，可以设置为数组；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-app&quot;</span>,<br>    <span class="hljs-string">&quot;sideEffects&quot;</span>: [<br>        <span class="hljs-string">&quot;./src/some-side-effectful-file.js&quot;</span>,<br>        <span class="hljs-string">&quot;*.css&quot;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>在optimization中配置usedExports为true，来帮助Terser进行优化</p><p>在package.json中配置sideEffects，直接对模块进行优化</p><hr><h5 id="Odemc">css-treeshaking</h5><p>PurgeCSS 是一款能分析 HTML、JavaScript 等文件，找出未使用的 CSS 代码并将其移除的工具。它可以和 Webpack、Gulp 等构建工具集成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install purgecss-webpack-plugin --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">PurgeCSSPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;purgecss-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurgeCSSPlugin</span>(&#123;<br>      <span class="hljs-comment">//扫描的路径,使用glob按照指定模式查找文件,&#123;nodir&#125;指定不是文件夹</span><br>      <span class="hljs-attr">paths</span>: glob.<span class="hljs-title function_">sync</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)&#125;</span>/**/*`</span>, &#123; <span class="hljs-attr">nodir</span>: <span class="hljs-literal">true</span> &#125;),<br>      <span class="hljs-comment">//配置白名单,不进行treeshaking</span><br>      <span class="hljs-attr">safelist</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">standard</span>: [<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>]<br>        &#125;<br>      &#125;<br>    &#125;)<br>  ],<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BL39y">作用域提升</h4><p>Scope Hoisting 是 webpack3 的新功能，直译为 “<strong>作用域提升</strong>”，它可以让 webpack 打包出来的<strong>代码文件更小</strong>，<strong>运行更快</strong>。</p><p>作用域提升的原理是将模块之间的依赖关系进行静态分析，找出模块之间的共享依赖关系，并将它们合并到一个函数作用域中去。这样做可以减少模块之间的函数声明，从而减少打包后的代码量，提高代码运行时的性能。</p><p>在 webpack 的 mode 设置为 production 时，会默认自动启用 Scope Hooting</p><p>手动配置 Scope Hooting</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">ModuleConcatenationPlugin</span>()<br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="A0vZ8">打包分析</h4><p><strong>webpack –profile –json生成打包分析文件</strong></p><p>该命令可以生成一个包含打包详细信息的 JSON 文件，其中包含了各个模块的构建时间、资源生成时间等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">webpack --profile --json &gt; stats.<span class="hljs-property">json</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --profile --json=stats.json&quot;</span>,<br></code></pre></td></tr></table></figure><p>可以在官方分析工具进行分析:<a href="https://github.com/webpack/analyse">https://github.com/webpack/analyse</a></p><hr><p><strong>speed-measure-webpack-plugin插件</strong></p><p>speed-measure-webpack-plugin插件能够测量 Webpack 各个插件和加载器的执行时间，帮助你找出哪些插件或加载器耗时较长。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install speed-measure-webpack-plugin --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">const SpeedMeasurePlugin = require(<span class="hljs-string">&quot;speed-measure-webpack-plugin&quot;</span>);<br>const smp = new SpeedMeasurePlugin();<br><br>const webpackConfig = &#123;<br>    // 你的 Webpack 配置<br>    entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    output: &#123;<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>    &#125;,<br>    // 其他配置...<br>&#125;;<br><br>module.exports = smp.wrap(webpackConfig);<br></code></pre></td></tr></table></figure><p>tip:可能会有兼容性问题,与其他插件冲突</p><hr><p><strong>使用webpack-bundle-analyzer工具</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i webpack-bundle-analyzer -D<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123; BundleAnalyzerPlugin &#125; = require(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>)<br> plugins: [<br>    new BundleAnalyzerPlugin()<br> ]<br></code></pre></td></tr></table></figure><p>打包webpack的时候，这个工具是帮助我们打开一个8888端口上的服务，我们可以直接的看到每个包的大小。 </p><ul><li>比如有一个包时通过一个Vue组件打包的，但是非常的大，那么我们可以考虑是否可以拆分出多个组件，并且对其进行懒加载； </li><li>比如一个图片或者字体文件特别大，是否可以对其进行压缩或者其他的优化处理；</li></ul>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts补充</title>
    <link href="/2025/03/30/Ts%E8%A1%A5%E5%85%85/"/>
    <url>/2025/03/30/Ts%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p><p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p><p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function</code>的函数体进行合并</p><p>例如我们有一个 add 函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 上边是声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>;<br><span class="hljs-comment">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字</span><br><br><span class="hljs-comment">// 下边是实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&quot;string&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg1 === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> arg2 === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ts-中-this-相关的内置工具"><a href="#Ts-中-this-相关的内置工具" class="headerlink" title="Ts 中 this 相关的内置工具"></a>Ts 中 this 相关的内置工具</h4><ul><li><strong>ThisParameterType</strong> : 用于提取一个函数类型 Type 的 this(opens new window)参数类型 , 如果这个函数类型没有 this 参数返回 unknown</li><li>**OmitThisParameter **: 用于移除一个函数类型 Type 的 this 参数类型,并且返回当前的函数类型</li><li>**ThisType **: ThisType,用于绑定一个上下文的 this</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"><span class="hljs-attr">this</span>: &#123; name: <span class="hljs-built_in">string</span> &#125;, <span class="hljs-attr">info</span>: &#123; name: <span class="hljs-built_in">string</span> &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>, info);<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooType</span> = <span class="hljs-keyword">typeof</span> foo;<br><br><span class="hljs-comment">//获取FooType类型中this的类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooThisType</span> = <span class="hljs-title class_">ThisParameterType</span>&lt;<span class="hljs-title class_">FooType</span>&gt;;<br><br><span class="hljs-comment">//剔除this类型,返回新的类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooPureType</span> = <span class="hljs-title class_">OmitThisParameter</span>&lt;<span class="hljs-title class_">FooType</span>&gt;;<br><br><span class="hljs-comment">//ThisType,用于绑定一个上下文的this</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IStata</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IStore</span> &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-title class_">IStata</span>;<br>  <span class="hljs-attr">runing</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-comment">//开发noImplicitThis设置为true,this在上下文不能正确推导的情况下,必须明确的指定</span><br><span class="hljs-comment">//将store中的this类型指定IStata</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">store</span>: <span class="hljs-title class_">IStore</span> &amp; <span class="hljs-title class_">ThisType</span>&lt;<span class="hljs-title class_">IStata</span>&gt; = &#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;MirZ&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  &#125;,<br>  <span class="hljs-attr">runing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>&#125;;<br><br>store.<span class="hljs-property">runing</span>.<span class="hljs-title function_">call</span>(store.<span class="hljs-property">state</span>);<br></code></pre></td></tr></table></figure><h4 id="Ts-类型检测-鸭子类型"><a href="#Ts-类型检测-鸭子类型" class="headerlink" title="Ts 类型检测-鸭子类型"></a>Ts 类型检测-鸭子类型</h4><p>在 TypeScript 里，鸭子类型（Duck Typing）也叫结构子类型（Structural Subtyping），它的核心观念是：若一个对象满足了某个类型的结构特征，那么它就可被当作该类型来使用</p><p>鸭子类型关注对象的结构而不是其具体的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个 Animal 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-comment">// 定义 speak 方法，返回值类型为 string</span><br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义 Dog 类，实现 speak 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Woof!&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义 Cat 类，实现 speak 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Meow!&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，接收一个 Animal 类型的参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAnimalSpeak</span>(<span class="hljs-params"><span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-title function_">speak</span>());<br>&#125;<br><br><span class="hljs-comment">// 创建 Dog 类的实例</span><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-comment">// 创建 Cat 类的实例</span><br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br><span class="hljs-comment">// 调用 makeAnimalSpeak 函数，传入 dog 实例</span><br><span class="hljs-title function_">makeAnimalSpeak</span>(dog);<br><span class="hljs-comment">// 调用 makeAnimalSpeak 函数，传入 cat 实例</span><br><span class="hljs-title function_">makeAnimalSpeak</span>(cat);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 和 <code>Cat</code> 类都没有显式地实现 <code>Animal</code> 接口，但它们都有 <code>speak</code> 方法，所以可以作为 <code>Animal</code> 类型的参数传递给 <code>makeAnimalSpeak</code> 函数</p><h4 id="映射类型-Mapped-Types"><a href="#映射类型-Mapped-Types" class="headerlink" title="映射类型( Mapped Types )"></a>映射类型( Mapped Types )</h4><p>在 TypeScript 里，映射能依据现有类型来创建新类型。借助类型映射，你能够对已有类型中的每个属性进行转换，进而生成新类型。</p><p><strong>基本语法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MappedType</span>&lt;T&gt; = &#123;<br>  [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof T]: T[<span class="hljs-title class_">Property</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>T</code> 是要映射的原始类型。</li><li><code>Property</code> 是一个类型变量，代表 <code>T</code> 中的每个属性名。</li><li><code>keyof Type</code> 是一个索引类型查询操作符，它返回 <code>Type</code> 中所有属性名组成的联合类型。</li><li><code>T[Property]</code> 是映射后每个属性的新类型。此处是原值 , 可自定义为新值</li></ul><hr><p><strong>修饰符</strong></p><ul><li>**readonly : **转为只读属性</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyType</span>&lt;T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyUser</span> = <span class="hljs-title class_">ReadonlyType</span>&lt;<span class="hljs-title class_">User</span>&gt;;<br><span class="hljs-comment">// ReadonlyUser 类型等价于：</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     readonly name: string;</span><br><span class="hljs-comment">//     readonly age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><ul><li>**? : **可选</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialType</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialUser</span> = <span class="hljs-title class_">PartialType</span>&lt;<span class="hljs-title class_">User</span>&gt;;<br><span class="hljs-comment">// PartialUser 类型等价于：</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     name?: string;</span><br><span class="hljs-comment">//     age?: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><hr><p><strong>移除修饰符</strong></p><p>在类型映射里增加或移除 <code>readonly</code> 和 <code>?</code> 修饰符</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Mutable</span>&lt;T&gt; = &#123;<br>  -<span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadonlyUser</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MutableUser</span> = <span class="hljs-title class_">Mutable</span>&lt;<span class="hljs-title class_">ReadonlyUser</span>&gt;;<br><span class="hljs-comment">// MutableUser 类型等价于：</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     age: number;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">RequiredType</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P];<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PartialUser</span> &#123;<br>  name?: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">RequiredUser</span> = <span class="hljs-title class_">RequiredType</span>&lt;<span class="hljs-title class_">PartialUser</span>&gt;;<br><span class="hljs-comment">// RequiredUser 类型等价于：</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><hr><p><strong>索引签名</strong></p><p>类型映射也能处理索引签名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyRecord</span>&lt;K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> K]: T;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyStringRecord</span> = <span class="hljs-title class_">ReadonlyRecord</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-comment">// ReadonlyStringRecord 类型等价于：</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     readonly [key: string]: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>创建了一个只读的字符串索引签名类型</p><h4 id="类型声明文件和内置类型声明"><a href="#类型声明文件和内置类型声明" class="headerlink" title="类型声明文件和内置类型声明"></a>类型声明文件和内置类型声明</h4><p>TypeScript 类型声明文件（<code>.d.ts</code> 文件）的作用是为 JavaScript 代码提供类型信息，让 TypeScript 编译器能够理解和检查 JavaScript 代码</p><p>声明文件以 <code>.d.ts</code> 为扩展名，它不会生成 JavaScript 代码，仅用于提供类型信息。例如，当你使用第三方 JavaScript 库时，就可以通过类型声明文件为这个库添加类型支持。</p><ul><li>内置类型声明<ul><li>内置类型声明是 typescript 提供的、帮助我们内置了 JavaScript 运行时的一些标准化 API 的声明文件</li><li>包括比如 Function、String、Math、Date 等内置类型;</li><li>运行环境中的 DOM API，比如 Window、Document 等;</li></ul></li><li>外部定义类型声明( 第三方库 )<ul><li>在自己库中存在类型声明(编写.d.ts 文件)，比如 axios</li><li>通过社区的一个公有库 DefinitelyTyped 存放类型声明文件</li></ul></li><li>自定义类型声明</li></ul><hr><p><code>tsconfig.json</code>配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>    <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES6&quot;</span>,<br>        <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,<br>        <span class="hljs-string">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;es6&quot;</span>, <span class="hljs-string">&quot;dom&quot;</span>],<br>          <span class="hljs-comment">//outDir：指定编译后文件的输出目录。</span><br>        <span class="hljs-string">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./dist&quot;</span>,<br>          <span class="hljs-comment">//rootDir：指定 TypeScript 文件的根目录，编译器会根据这个目录来生成输出文件的目录结构</span><br>        <span class="hljs-string">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./src&quot;</span>,<br>        <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;esModuleInterop&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;skipLibCheck&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>  <span class="hljs-comment">//指定需要编译的文件或目录</span><br>    <span class="hljs-string">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src/**/*.ts&quot;</span>],<br>  <span class="hljs-comment">//指定不需要编译的文件或目录</span><br>    <span class="hljs-string">&quot;exclude&quot;</span>: [<span class="hljs-string">&quot;node_modules&quot;</span>, <span class="hljs-string">&quot;dist&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>**target**</code>：指定编译后 JavaScript 代码的 ECMAScript 版本，比如 <code>ES3</code>、<code>ES5</code>、<code>ES6</code> 等</li><li><code>**module**</code>：指定生成代码的模块系统，可选值有 <code>commonjs</code>、<code>amd</code>、<code>system</code>、<code>umd</code>、<code>es6</code> 等</li><li><code>**lib**</code>：指定要包含在编译中的库文件，例如 <code>es5</code>、<code>es6</code>、<code>dom</code> 等</li><li><code>**strict**</code>：启用所有严格类型检查选项，开启后能提高代码的类型安全性</li><li><code>**esModuleInterop**</code>：允许在 CommonJS 模块中使用 ES6 模块的导入语法</li><li><code>**skipLibCheck**</code>：跳过对所有库类型检查( 仅检测你所用的类型 )</li><li><code>**forceConsistentCasingInFileNames**</code>：确保文件名的大小写一致，避免在不同操作系统上出现问题</li></ul><hr><p>为一个简单的第三方库 <code>simple-library.js</code> 创建声明文件</p><p>假设 <code>simple-library.js</code> 的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  sayHello,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对应的声明文件 <code>simple-library.d.ts</code> 如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// simple-library.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;simple-library&quot;</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用该库</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; sayHello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;simple-library&quot;</span>;<br><br><span class="hljs-title function_">sayHello</span>();<br></code></pre></td></tr></table></figure><hr><p>全局声明文件用于为全局作用域添加类型定义，无需显式导入即可使用。通常将其放在 <code>src</code> 目录下 types 下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// global.d.ts</span><br><span class="hljs-comment">// 声明一个全局变量</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">MY_GLOBAL_VARIABLE</span>: <span class="hljs-built_in">string</span>;<br><br><span class="hljs-comment">// 声明一个全局函数</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myGlobalFunction</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;<br><br><span class="hljs-comment">// 声明一个全局类</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGlobalClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>);<br>  <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当遇到 asset 文件 , less,sass 文件等 , ts 类型也会确实类型声明,无法引入,需要全局声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.svg&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.png&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.jpg&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.jpeg&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.gif&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.bmp&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.tiff&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.gif&quot;</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.less&quot;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.sass&quot;</span>;<br></code></pre></td></tr></table></figure><p>vue 引入类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.vue&quot;</span> &#123;<br>  <span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">DefineComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">component</span>: <span class="hljs-title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="hljs-built_in">any</span>&gt;;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> component;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><p>在 TypeScript 里，条件类型可以依据条件来选择不同的类型。它的语法和 JavaScript 里的三元运算符很相似，格式为 <code>T extends U ? X : Y</code>，意思是若 <code>T</code> 能够赋值给 <code>U</code>，那么类型就是 <code>X</code>，反之则是 <code>Y</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result1</span> = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//类型重载</span><br><span class="hljs-keyword">function</span> sum&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;(<br>  <span class="hljs-attr">num1</span>: T,<br>  <span class="hljs-attr">num2</span>: T<br>): T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><span class="hljs-keyword">const</span> res1 = <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> res2 = <span class="hljs-title function_">sum</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-keyword">export</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><hr><ul><li>ReturnType 获取返回值的类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooType</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooResType</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">FooType</span>&gt;;<br></code></pre></td></tr></table></figure><p><code>infer</code> 关键字可以在条件类型里推断类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//推断返回值</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetReturnType</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-title function_">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R<br>  ? R<br>  : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnValue</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-title class_">Func</span>&gt;; <span class="hljs-comment">// string</span><br><br><span class="hljs-comment">//推断参数类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetParamsType</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-title function_">extends</span> (<br>  ...<span class="hljs-attr">args</span>: infer A<br>) =&gt; <span class="hljs-built_in">any</span><br>  ? A<br>  : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><p><code>GetReturnType</code> 条件类型接收一个函数类型 <code>T</code>。通过 <code>infer R</code> 推断出函数的返回类型</p><hr><p>当泛型参数为联合类型，并且在条件类型里直接使用该泛型参数时，条件类型会自动对联合类型的每个成员进行分发</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ToArray</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? T[] : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">ToArray</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// number[] | string[]</span><br></code></pre></td></tr></table></figure><h4 id="内置工具"><a href="#内置工具" class="headerlink" title="内置工具"></a>内置工具</h4><p><strong>Partial<Type> : 所有属性转为可选</Type></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Partial,转为可选</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Ikun</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>;<br>&#125;<br><span class="hljs-comment">//类型体操</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyParType</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IkunParType</span> = <span class="hljs-title class_">MyParType</span>&lt;<span class="hljs-title class_">Ikun</span>&gt;;<br></code></pre></td></tr></table></figure><hr><p><strong>Required<Type> : 所有属性转为必选</Type></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Required,转为必选</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Ikun</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-number">18</span>;<br>&#125;<br><span class="hljs-comment">//类型体操</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyRequirdType</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P];<br>&#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IkunParType</span> = <span class="hljs-title class_">MyRequirdType</span>&lt;<span class="hljs-title class_">Ikun</span>&gt;;<br></code></pre></td></tr></table></figure><hr><p><strong>Readonly<Type> : 所有属性转为只读</Type></strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Readonly,转为只读</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Ikun</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>;<br>&#125;<br><span class="hljs-comment">//类型体操</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyReadonlyType</span>&lt;T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IkunParType</span> = <span class="hljs-title class_">MyReadonlyType</span>&lt;<span class="hljs-title class_">Ikun</span>&gt;;<br></code></pre></td></tr></table></figure><hr><p><code>**Pick&lt;T, K&gt;**</code></p><p><strong>作用</strong>：从类型 <code>T</code> 中选取指定属性 <code>K</code> 组成新类型。<br><strong>实现</strong>：通过 <code>keyof</code> 提取 <code>T</code> 的所有键，<code>K extends keyof T</code> 约束 <code>K</code> 必须是 <code>T</code> 的键，最后通过映射类型 <code>[P in K]: T[P]</code> 生成新对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyPick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123; [P <span class="hljs-keyword">in</span> K]: T[P] &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IkunPickType</span> = <span class="hljs-title class_">MyPick</span>&lt;<span class="hljs-title class_">Ikun</span>, <span class="hljs-string">&quot;name&quot;</span>&gt;;<br></code></pre></td></tr></table></figure><hr><p><code>**Omit&lt;T, K&gt;**</code></p><p><strong>作用</strong>：从类型 <code>T</code> 中剔除指定属性 <code>K</code>。<br><strong>实现</strong>：结合 <code>Exclude</code> 和 <code>Pick</code>，先用 <code>Exclude&lt;keyof T, K&gt;</code> 获取未被剔除的键，再用 <code>Pick</code> 选取</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyOmit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> P <span class="hljs-keyword">extends</span> K ? <span class="hljs-built_in">never</span> : P]: T[P];<br>&#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">IkunType</span> = <span class="hljs-title class_">MyOmit</span>&lt;<span class="hljs-title class_">Ikun</span>, <span class="hljs-string">&quot;name&quot;</span>&gt;;<br></code></pre></td></tr></table></figure><hr><p><code>**Exclude&lt;T, U&gt;**</code>** 和 **<code>**Extract&lt;T, U&gt;**</code></p><p><strong>作用</strong>：<code>Exclude</code> 从联合类型 <code>T</code> 中排除 <code>U</code>，<code>Extract</code> 保留 <code>T</code> 中与 <code>U</code> 重叠的部分。<br><strong>实现</strong>：基于条件类型 <code>T extends U ? never : T</code> 和 <code>T extends U ? T : never</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">type MyExclude&lt;T, U&gt; = T extends U ? never : T;<br>type MyExtract&lt;T, U&gt; = T extends U ? T : never;<br></code></pre></td></tr></table></figure><hr><ul><li><strong>NonNullable : 去除 null 和 undefined 类型</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">type TestType = string | number | null | undefined;<br>type MyNoNullType&lt;T&gt; = T extends null | undefined ? never : T;<br>type MyType=MyNoNullType&lt;TestType&gt;<br></code></pre></td></tr></table></figure><hr><p>…</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Ts-封装-Axios"><a href="#Ts-封装-Axios" class="headerlink" title="Ts 封装 Axios"></a>Ts 封装 Axios</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">AxiosHeaders</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">AxiosInstance</span>,<br>  <span class="hljs-title class_">AxiosRequestConfig</span>,<br>  <span class="hljs-title class_">AxiosResponse</span>,<br>  <span class="hljs-title class_">InternalAxiosRequestConfig</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-comment">//传入拦截器类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterCeptors</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt; &#123;<br>  requestSuccessFn?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-attr">config</span>: <span class="hljs-title class_">InternalAxiosRequestConfig</span></span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-title class_">InternalAxiosRequestConfig</span>;<br>  requestFailureFn?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">err</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br>  responseSuccessFn?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">res</span>: T</span>) =&gt;</span> T;<br>  responseFailureFn?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">err</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-comment">//对AxiosRequestConfig进行类型拓展,可选是否传入拦截器</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyRequestConfig</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt;<br>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosRequestConfig</span> &#123;<br>  interceptors?: <span class="hljs-title class_">MyInterCeptors</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-comment">//封装类 用于不同情景创建 不同实例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAxios</span> &#123;<br>  <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span>;<br>  <span class="hljs-comment">//创建实例对象时进行config配置</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">config</span>: <span class="hljs-title class_">MyRequestConfig</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = axios.<span class="hljs-title function_">create</span>(config);<br>    <span class="hljs-comment">//全局添加通用拦截</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功拦截&quot;</span>);<br>        <span class="hljs-keyword">return</span> config;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败拦截&quot;</span>);<br>        <span class="hljs-keyword">return</span> err;<br>      &#125;<br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应成功拦截&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>      &#125;,<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应失败拦截&quot;</span>);<br>        <span class="hljs-keyword">return</span> err;<br>      &#125;<br>    );<br>    <span class="hljs-comment">//如果传入interceptors,则将传入config.interceptors添加拦截器(也可使用?可选链)</span><br>    <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>        config.<span class="hljs-property">interceptors</span>.<span class="hljs-property">requestSuccessFn</span>,<br>        config.<span class="hljs-property">interceptors</span>.<span class="hljs-property">requestFailureFn</span><br>      );<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>        config.<span class="hljs-property">interceptors</span>.<span class="hljs-property">responseSuccessFn</span>,<br>        config.<span class="hljs-property">interceptors</span>.<span class="hljs-property">responseFailureFn</span><br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//封装网络请求</span><br>  <span class="hljs-comment">//进行请求时也可单次进行config配置</span><br>  request&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">MyRequestConfig</span>&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestSuccessFn</span>) &#123;<br>      <span class="hljs-comment">//手动去执行requestSuccessFn回调,传入新的config,并用config去接收</span><br>      <span class="hljs-comment">//requestSuccessFn要求传入InternalAxiosRequestConfig类型,</span><br>      <span class="hljs-comment">// 而config是MyRequestConfig类型需要进行两次断言</span><br>      <span class="hljs-comment">//   const internalConfig = config as InternalAxiosRequestConfig;</span><br>      <span class="hljs-comment">//   config = config.interceptors.requestSuccessFn(</span><br>      <span class="hljs-comment">//     internalConfig</span><br>      <span class="hljs-comment">//   ) as MyRequestConfig&lt;T&gt;;</span><br>      <span class="hljs-comment">// 将 MyRequestConfig 转换为 InternalAxiosRequestConfig</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">internalConfig</span>: <span class="hljs-title class_">InternalAxiosRequestConfig</span> = &#123;<br>        ...config,<br>        <span class="hljs-attr">headers</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AxiosHeaders</span>(config.<span class="hljs-property">headers</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">AxiosHeaders</span>),<br>      &#125;;<br>      <span class="hljs-keyword">const</span> newInternalConfig =<br>        config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">requestSuccessFn</span>(internalConfig);<br>      <span class="hljs-comment">// 将返回的 InternalAxiosRequestConfig 转换回 MyRequestConfig</span><br>      config = &#123;<br>        ...newInternalConfig,<br>        <span class="hljs-attr">interceptors</span>: config.<span class="hljs-property">interceptors</span>,<br>      &#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">MyRequestConfig</span>&lt;T&gt;;<br>    &#125;<br>    <span class="hljs-comment">// config = config.interceptors.requestSuccessFn(config);</span><br>    <span class="hljs-comment">//响应需要直接返回,所以要进行拦截必须在响应之后返回之前</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;T&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span><br>        .<span class="hljs-property">request</span>&lt;<span class="hljs-built_in">any</span>, T&gt;(config)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseSuccessFn</span>) &#123;<br>            <span class="hljs-comment">//responseSuccessFn要求传入AxiosResponse,此时传入的是T</span><br>            <span class="hljs-comment">//   const internalRes = config as AxiosResponse;</span><br>            <span class="hljs-comment">// res = config.interceptors.responseSuccessFn(internalRes);</span><br>            res = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">responseSuccessFn</span>(res);<br>          &#125;<br>          <span class="hljs-title function_">resolve</span>(res);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;);<br>    &#125;);<br>  &#125;<br>  get&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">MyRequestConfig</span>&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span> &#125;);<br>  &#125;<br>  <span class="hljs-comment">//   post&lt;T extends AxiosResponse = AxiosResponse&gt;(config: MyRequestConfig&lt;T&gt;) &#123;</span><br>  <span class="hljs-comment">//     return this.request(&#123; ...config, method: &quot;POST&quot; &#125;);</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">// 示例：为 post 方法添加独立的 url 和 data 参数,更接近原生axios</span><br>  post&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt;(<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    data?: <span class="hljs-built_in">any</span>,<br>    config?: <span class="hljs-title class_">MyRequestConfig</span>&lt;T&gt;<br>  ) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123;<br>      ...config,<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>      url,<br>      data,<br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">delete</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">MyRequestConfig</span>&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;DELETE&quot;</span> &#125;);<br>  &#125;<br>  put&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosResponse</span> = <span class="hljs-title class_">AxiosResponse</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">MyRequestConfig</span>&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;PUT&quot;</span> &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyAxios</span>;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyAxios</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./request/index&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">BASE_URL</span>, <span class="hljs-variable constant_">TIME_OUT</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./config&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyRequest</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAxios</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-variable constant_">BASE_URL</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-variable constant_">TIME_OUT</span>,<br>  <span class="hljs-comment">//可选参数,是否单独添加拦截</span><br>  <span class="hljs-attr">interceptors</span>: &#123;<br>    <span class="hljs-attr">requestSuccessFn</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;单独对某些请求进行拦截&quot;</span>);<br>      <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-attr">requestFailureFn</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-attr">responseSuccessFn</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;单独对某些响应进行拦截&quot;</span>);<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>    <span class="hljs-attr">responseFailureFn</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;&#125;,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-title class_">MyRequest</span> &#125;;<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ts补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue补充</title>
    <link href="/2025/03/24/vue%E8%A1%A5%E5%85%85/"/>
    <url>/2025/03/24/vue%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h4 id="Kre6j">自定义指令</h4><p>自定义指令是 Vue3 中用于封装底层 DOM 操作的高级特性，适用于需要直接操作元素样式、事件或生命周期的场景。</p><ul><li><strong>逻辑复用</strong>：将特定 DOM 行为抽象为可复用的指令</li><li><strong>关注点分离</strong>：避免组件中混杂复杂的 DOM 操作逻辑</li><li><strong>性能优化</strong>：减少不必要的组件渲染开销</li></ul><p><strong>注意</strong>：仅在必须直接操作 DOM 时使用指令，优先考虑组件化方案。避免在多根节点组件上使用指令，可能引发不可预期的行为。</p><h5 id="qyzMm">指令注册方式</h5><p><strong>局部指令注册</strong> : 在组件内部通过 <code>directives</code> 选项定义：</p><ul><li>在选项Api中在directives中定义</li><li>在组合式Api定义Vxxx变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const vFocus = &#123;<br>  mounted(el) &#123;<br>    el.focus(); // 元素挂载后自动聚焦<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-focus /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>**全局指令注册 : **通过应用实例的 <code>directive</code> 方法注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">// main.js<br>import &#123; createApp &#125; from &#x27;vue&#x27;;<br>import App from &#x27;./App.vue&#x27;;<br><br>const app = createApp(App);<br><br>// 对象形式（完整生命周期）<br>app.directive(&#x27;color&#x27;, &#123;<br>  mounted(el, binding) &#123;<br>    el.style.color = binding.value;<br>  &#125;,<br>  updated(el, binding) &#123;<br>    el.style.color = binding.value;<br>  &#125;<br>&#125;);<br><br>// 函数形式（简写 mounted 和 updated）<br>app.directive(&#x27;debounce&#x27;, (el, binding) =&gt; &#123;<br>  let timer;<br>  el.addEventListener(&#x27;click&#x27;, () =&gt; &#123;<br>    clearTimeout(timer);<br>    timer = setTimeout(() =&gt; binding.value(), 300);<br>  &#125;);<br>&#125;);<br><br>app.mount(&#x27;#app&#x27;);<br></code></pre></td></tr></table></figure><h5 id="g3mv7">自定义指令生命周期</h5><p>Vue3 的指令生命周期与组件生命周期高度对齐，提供七个关键钩子</p><table><thead><tr><th align="left"><strong>钩子名称</strong></th><th align="left"><strong>触发时机</strong></th></tr></thead><tbody><tr><td align="left"><code>created</code></td><td align="left"></td></tr><tr><td align="left"><code>beforeMount</code></td><td align="left">指令首次绑定元素且父组件挂载前</td></tr><tr><td align="left"><code>mounted</code></td><td align="left">父组件挂载完成，元素已插入 DOM（最常用钩子）</td></tr><tr><td align="left"><code>beforeUpdate</code></td><td align="left">组件更新前，元素对应的 VNode 更新前</td></tr><tr><td align="left"><code>updated</code></td><td align="left">组件更新后，元素及其子节点的 VNode 更新完成</td></tr><tr><td align="left"><code>beforeUnmount</code></td><td align="left">父组件卸载前，指令与元素解绑前</td></tr><tr><td align="left"><code>unmounted</code></td><td align="left">指令与元素完全解绑，父组件卸载完成（清理资源的最佳时机）</td></tr></tbody></table><h5 id="OGMLz">自定义指令参数修饰符</h5><ul><li><code>el</code>：指令绑定的 DOM 元素。</li><li><code>binding</code>：包含以下属性的对象：<ul><li><code>value</code>：指令绑定的值（如 <code>v-my-directive=&quot;42&quot;</code>，则 <code>value</code> 为 <code>42</code>）。</li><li><code>oldValue</code>：更新前的值（仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用）。</li><li><code>arg</code>：指令参数（如 <code>v-my-directive:foo</code>，则 <code>arg</code> 为 <code>&#39;foo&#39;</code>）。</li><li><code>modifiers</code>：修饰符对象（如 <code>v-my-directive.modif</code>，则 <code>modifiers</code> 为 <code>&#123; modif: true &#125;</code>）。</li><li><code>instance</code>：当前组件实例</li></ul></li><li><code>vnode</code>：虚拟节点。 </li><li><code>prevNode</code>：上一个虚拟节点（仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用）。</li></ul><h5 id="DKW0U">示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">app.directive(&#x27;permission&#x27;, &#123;<br>  mounted(el, &#123; value: requiredRoles &#125;) &#123;<br>    const currentRole = store.state.user.role;<br>    if (!requiredRoles.includes(currentRole)) &#123;<br>      el.parentNode?.removeChild(el);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">app.directive(&#x27;permission&#x27;, &#123;<br>  mounted(el, binding) &#123;<br>    const &#123; value, instance &#125; = binding;<br>    if (!instance.$user.roles.includes(value)) &#123;<br>      el.style.display = &#x27;none&#x27;;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">import dayjs from &quot;dayjs&quot;;<br>export default function directiveFormatTime(app) &#123;<br>    app.directive(&#x27;format-time&#x27;, &#123;<br>        mounted(el, bindings) &#123;<br>            let timestamp = el.textContent<br>            if (timestamp.length === 10) &#123;<br>                timestamp = timestamp * 1000<br>            &#125;<br>            let value = bindings.value<br>            if (!value) &#123;<br>                value = &#x27;YYYY-MM-DD HH:mm:ss&#x27;<br>            &#125;            <br>            const formatTime = dayjs(timestamp).format(value)<br>            el.textContent = formatTime<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>优先使用简写形式</strong>：若 <code>mounted</code> 和 <code>updated</code> 行为一致，可简化为函数形式。</li><li><strong>资源清理</strong>：在 <code>beforeUnmount</code> 中移除事件监听器，避免内存泄漏。</li><li><strong>避免组件依赖</strong>：尽量通过 <code>binding.value</code> 传递参数，减少对 <code>instance</code> 的依赖。</li></ol><h4 id="UBWHR">内置组件</h4><p><strong>teleport</strong></p><p>可以将子组件渲染到 DOM 中的其他位置，例如模态框或者弹出菜单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;showModal = true&quot;&gt;打开模态框&lt;/button&gt;<br>    &lt;teleport to=&quot;body&quot;&gt;<br>      &lt;div v-if=&quot;showModal&quot; class=&quot;modal&quot;&gt;<br>        &lt;div class=&quot;modal-content&quot;&gt;<br>          &lt;h2&gt;模态框标题&lt;/h2&gt;<br>          &lt;p&gt;这是模态框内容&lt;/p&gt;<br>          &lt;button @click=&quot;showModal = false&quot;&gt;关闭模态框&lt;/button&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/teleport&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const showModal = ref(false)<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.modal &#123;<br>  position: fixed;<br>  top: 0;<br>  left: 0;<br>  width: 100%;<br>  height: 100%;<br>  background-color: rgba(0, 0, 0, 0.5);<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>&#125;<br><br>.modal-content &#123;<br>  background-color: white;<br>  padding: 20px;<br>  border-radius: 5px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>Suspense</strong></p><p>Suspense 是 Vue 3 提供的一个内置组件，主要用于处理异步依赖的加载状态。在开发中，当组件依赖一些异步操作（比如异步组件、异步数据获取）时，在数据加载完成之前显示一个加载中的状态，加载完成后再显示实际内容。( 实验性功能 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- main.vue --&gt;<br>&lt;template&gt;<br>  &lt;Suspense&gt;<br>    &lt;!-- 加载完成后显示的内容 --&gt;<br>    &lt;template #default&gt;<br>      &lt;AsyncComponent /&gt;<br>    &lt;/template&gt;<br>    &lt;!-- 加载过程中显示的内容 --&gt;<br>    &lt;template #fallback&gt;<br>      &lt;p&gt;Loading...&lt;/p&gt;<br>    &lt;/template&gt;<br>  &lt;/Suspense&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br>import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;<br>// 定义一个异步组件<br>const AsyncComponent = defineAsyncComponent(() =&gt; import(&#x27;./AsyncComponent.vue&#x27;))<br>&lt;/script&gt;<br><br><br>&lt;!-- AsyncComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;<br><br>const message = ref(&#x27;&#x27;)<br><br>// 模拟异步数据加载<br>const fetchData = () =&gt; &#123;<br>  return new Promise((resolve) =&gt; &#123;<br>    setTimeout(() =&gt; &#123;<br>      resolve(&#x27;Data loaded!&#x27;)<br>    &#125;, 2000)<br>  &#125;)<br>&#125;<br><br>onMounted(async () =&gt; &#123;<br>  const data = await fetchData()<br>  message.value = data<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;Suspense&gt;</code> 组件有两个插槽：<ul><li><code>#default</code>：当异步依赖加载完成后，显示这个插槽里的内容。</li><li><code>#fallback</code>：在异步依赖加载过程中，显示这个插槽里的内容，一般用于展示加载中的提示信息。</li></ul></li></ul><h4 id="cMK7E">vue插件本质</h4><p>在 Vue 里，插件本质上是一种扩展 Vue 功能的方式，它可以封装一些通用逻辑，从而在多个项目或者组件中复用。安装插件的本质是借助 <code>app.use()</code> 方法把插件集成到 Vue 应用实例里，让插件的功能在整个应用中生效。</p><p>Vue 插件一般是一个对象，该对象包含 <code>install</code> 方法；或者是一个函数，这个函数本身就作为 <code>install</code> 方法。</p><hr><p><strong>对象形式的插件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myPlugin = &#123;<br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">app, options</span>) &#123;<br>        <span class="hljs-comment">// 插件逻辑</span><br>        app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是一个全局方法&#x27;</span>);<br>        &#125;;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myPlugin;<br></code></pre></td></tr></table></figure><p><strong>函数形式的插件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugin</span> = (<span class="hljs-params">app, options</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 插件逻辑</span><br>    app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是一个全局方法&#x27;</span>);<br>    &#125;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myPlugin;<br></code></pre></td></tr></table></figure><hr><p>在创建 Vue 应用实例之后，你可以使用 <code>app.use()</code> 方法来安装插件。<code>app.use()</code> 方法会调用插件的 <code>install</code> 方法，并且把应用实例 <code>app</code> 以及可能的选项参数传递给它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; createApp &#125; from &#x27;vue&#x27;;<br>import App from &#x27;./App.vue&#x27;;<br>import myPlugin from &#x27;./myPlugin&#x27;;<br><br>const app = createApp(App);<br><br>// 安装插件<br>app.use(myPlugin, &#123; /* 可选的选项参数 */ &#125;);<br><br>app.mount(&#x27;#app&#x27;);<br></code></pre></td></tr></table></figure><hr><ul><li>插件能够向 <code>app.config.globalProperties</code> 注入全局属性和方法，这样在所有组件里都可以访问这些属性和方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">const myPlugin = &#123;<br>    install(app) &#123;<br>        app.config.globalProperties.$myProperty = &#x27;这是一个全局属性&#x27;;<br>        app.config.globalProperties.$myMethod = function () &#123;<br>            console.log(&#x27;这是一个全局方法&#x27;);<br>        &#125;;<br>    &#125;<br>&#125;;<br><br>// 在组件中使用<br>export default &#123;<br>    mounted() &#123;<br>        console.log(this.$myProperty); // 输出: 这是一个全局属性<br>        this.$myMethod(); // 输出: 这是一个全局方法<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>插件可以注册全局指令，使这些指令在所有组件中都能使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">const myPlugin = &#123;<br>    install(app) &#123;<br>        app.directive(&#x27;my-directive&#x27;, &#123;<br>            mounted(el) &#123;<br>                el.style.color = &#x27;red&#x27;;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;;<br><br>// 在组件模板中使用<br>&lt;template&gt;<br>    &lt;p v-my-directive&gt;这段文字会变成红色&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>全局组件注册</li><li>全局混入</li><li>…</li></ul><h4 id="DERWF">h函数</h4><p><code>h</code> 函数是用于创建虚拟 DOM 节点（VNode）的核心工具。它通常用于编写渲染函数或处理需要动态生成内容</p><hr><p><strong>基本用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">h(type, props?, children?)<br></code></pre></td></tr></table></figure><ul><li><code>**type**</code>：必填项，它可以是字符串（表示 HTML 标签名）、组件定义（如通过 <code>defineComponent</code> 创建的组件）或者异步组件。</li><li><code>**props**</code>：可选参数，它是一个对象，包含了传递给节点的属性、事件监听器等。</li><li><code>**children**</code>：可选参数，它可以是字符串、数组或者其他虚拟节点，用于表示当前节点的子节点。</li></ul><hr><p><strong>创建元素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">h(&#x27;div&#x27;, &#123; class: &#x27;container&#x27; &#125;, [<br>  h(&#x27;h1&#x27;, &#x27;标题&#x27;),<br>  h(&#x27;p&#x27;, &#x27;内容&#x27;)<br>])<br></code></pre></td></tr></table></figure><p><strong>创建组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">import MyComponent from &#x27;./MyComponent.vue&#x27;<br><br>// 传递 props 和事件<br>h(MyComponent, &#123;<br>  title: &#x27;Hello&#x27;,<br>  onCustomEvent: (data) =&gt; console.log(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>setup函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; h, ref &#125; from &#x27;vue&#x27;<br><br>export default &#123;<br>  setup() &#123;<br>    const count = ref(0)<br>    return () =&gt; h(&#x27;div&#x27;, [<br>      h(&#x27;button&#x27;, &#123; onClick: () =&gt; count.value++ &#125;, &#x27;增加&#x27;),<br>      h(&#x27;span&#x27;, `计数：$&#123;count.value&#125;`)<br>    ])<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;render/&gt;<br>  &lt;/template&gt;<br>  <br>  &lt;script setup&gt;<br>  import &#123; h &#125; from &#x27;vue&#x27;;<br>  <br>  const render = () =&gt; &#123;<br>      return h(&#x27;div&#x27;, &#123; class: &#x27;custom&#x27; &#125;, &#x27;This is rendered by h function&#x27;);<br>  &#125;;<br>  <br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="i3KGI">jsx语法</h4><p>要在 Vue 3 项目里使用 JSX，首先得安装 <code>@vue/babel-plugin-jsx</code> 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue"># 使用babel支持vue的jsx语法<br>npm install @vue/babel-plugin-jsx -D<br># 如果使用vite,需要安装<br>npm install @vitejs/plugin-vue-jsx -D<br></code></pre></td></tr></table></figure><pre><code class="hljs">在项目根目录下的 `.babelrc` 或者 `babel.config.js` 文件里添加 `@vue/babel-plugin-jsx` 插件：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">module.exports = &#123;<br>    presets: [<br>        // 其他预设<br>    ],<br>    plugins: [<br>        &#x27;@vue/babel-plugin-jsx&#x27;<br>    ]<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang=&quot;jsx&quot;&gt;<br>  import &#123; ref &#125; from &#x27;vue&#x27;;<br>  <br>  const message = ref(&#x27;Hello, Vue 3 with JSX!&#x27;);<br>  <br>  const render = () =&gt; &#123;<br>      return (<br>          &lt;div&gt;<br>              &lt;h1&gt;&#123;message.value&#125;&lt;/h1&gt;<br>          &lt;/div&gt;<br>      );<br>  &#125;;<br>  <br>  // 返回渲染函数<br>  export default &#123;<br>      render<br>  &#125;;<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>绑定事件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- 这里的模板会被 JSX 渲染覆盖 --&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;jsx&quot; setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br><br>const count = ref(0);<br><br>const increment = () =&gt; &#123;<br>    count.value++;<br>&#125;;<br><br>// 直接返回 JSX<br>return (<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;count.value&#125;&lt;/p&gt;<br>        &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;<br>    &lt;/div&gt;<br>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="UfKeM">vue过渡动画</h4><p>Vue 3 提供了强大的过渡动画系统，主要通过 <code>&lt;Transition&gt;</code> 和 <code>&lt;TransitionGroup&gt;</code> 组件实现元素的进入&#x2F;离开动画，以及列表动画</p><hr><p><code>**&lt;Transition&gt;**</code>** 组件**</p><ul><li><strong>作用</strong>：为单个元素或组件添加进入&#x2F;离开过渡动画。</li><li><strong>核心机制</strong>：自动在元素进入&#x2F;离开时添加特定的 CSS 类名，触发 CSS 过渡或动画。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;button @click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt;<br>  &lt;Transition&gt;<br>    &lt;div v-if=&quot;show&quot;&gt;Hello Vue 3!&lt;/div&gt;<br>  &lt;/Transition&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>CSS 过渡类名</strong></p><ul><li><strong>进入阶段</strong>：<ul><li><code>v-enter-from</code>: 进入动画的起始状态。</li><li><code>v-enter-active</code>: 进入动画的持续时间和缓动函数。</li><li><code>v-enter-to</code>: 进入动画的结束状态。</li></ul></li><li><strong>离开阶段</strong>：<ul><li><code>v-leave-from</code>: 离开动画的起始状态。</li><li><code>v-leave-active</code>: 离开动画的持续时间和缓动函数。</li><li><code>v-leave-to</code>: 离开动画的结束状态。</li></ul></li><li><strong>自定义类名前缀</strong>：通过 <code>name</code> 属性修改前缀。例如，<code>name=&quot;fade&quot;</code> 会生成 <code>fade-enter-from</code> 等类名。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">.v-enter-from,<br>.v-leave-to &#123;<br>  opacity: 0;<br>  transform: translateY(20px);<br>&#125;<br>.v-enter-to,<br>.v-leave-from &#123;<br>  opacity: 1;<br>  transform: translateY(-20px);<br>&#125;<br>  <br>.v-enter-active,<br>.v-leave-active &#123;<br>  transition: all 0.3s ease;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>淡入淡出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">.fade-enter-from,<br>.fade-leave-to &#123;<br>  opacity: 0;<br>&#125;<br><br>.fade-enter-active,<br>.fade-leave-active &#123;<br>  transition: opacity 0.3s;<br>&#125;<br></code></pre></td></tr></table></figure><p>滑动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">.slide-leave-to,<br>.slide-enter-from &#123;<br>  transform: translateX(-100%);<br>&#125;<br>.slide-leave-from,<br>.slide-enter-to &#123;<br>  transform: translateX(0);<br>&#125;<br>.slide-enter-active,<br>.slide-leave-active &#123;<br>  transition: all 1s ease-in-out;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>使用 CSS 的<code>animation</code>属性来实现动画效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt;<br>    &lt;Transition name=&quot;fade&quot;&gt;<br>      &lt;p v-if=&quot;show&quot;&gt;这是一段文本，会有淡入淡出动画效果。&lt;/p&gt;<br>    &lt;/Transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br><br>const show = ref(false);<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>/* 定义淡入动画 */<br>@keyframes fadeIn &#123;<br>  from &#123;<br>    opacity: 0;<br>  &#125;<br>  to &#123;<br>    opacity: 1;<br>  &#125;<br>&#125;<br><br>/* 定义淡出动画 */<br>@keyframes fadeOut &#123;<br>  from &#123;<br>    opacity: 1;<br>  &#125;<br>  to &#123;<br>    opacity: 0;<br>  &#125;<br>&#125;<br><br>/* 进入动画 */<br>.fade-enter-active &#123;<br>  animation: fadeIn 0.5s;<br>&#125;<br><br>/* 离开动画 */<br>.fade-leave-active &#123;<br>  animation: fadeOut 0.5s;<br>&#125;<br>&lt;/style&gt;    <br></code></pre></td></tr></table></figure><hr><p><strong>过渡模式</strong></p><p>解决进入和离开动画同时发生的问题：</p><ul><li><code>mode=&quot;in-out&quot;</code>：先进入后离开。</li><li><code>mode=&quot;out-in&quot;</code>：先离开后进入（常用）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;button @click=&quot;toggleComponent&quot;&gt;切换组件&lt;/button&gt;<br>        &lt;Transition mode=&quot;out-in&quot;&gt;<br>            &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;<br>        &lt;/Transition&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref, markRaw &#125; from &#x27;vue&#x27;;<br>import ComponentA from &#x27;./components/c1.vue&#x27;;<br>import ComponentB from &#x27;./components/c2.vue&#x27;;<br><br>// 使用 markRaw 标记组件，避免变成响应式对象<br>const ComponentARaw = markRaw(ComponentA);<br>const ComponentBRaw = markRaw(ComponentB);<br><br>const currentComponent = ref(ComponentARaw);<br><br>const toggleComponent = () =&gt; &#123;<br>    currentComponent.value = currentComponent.value === ComponentARaw ? ComponentBRaw : ComponentARaw;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>.v-enter-active,<br>.v-leave-active &#123;<br>    transition: opacity 0.5s ease;<br>&#125;<br><br>.v-enter-from,<br>.v-leave-to &#123;<br>    opacity: 0;<br>&#125;<br>&lt;/style&gt;    <br></code></pre></td></tr></table></figure><hr><p>通过 <code>appear</code> 属性触发元素初次渲染时的动画</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Transition appear&gt;<br>  &lt;!-- 元素 --&gt;<br>&lt;/Transition&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>引入第三方动画库</strong></p><ol><li>安装动画库</li><li>引入动画库</li><li>在组件中结合 <code>&lt;Transition&gt;</code> 组件使用提供的动画类。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt;<br>    &lt;Transition<br>      enter-active-class=&quot;animate__animated animate__fadeIn&quot;<br>      leave-active-class=&quot;animate__animated animate__fadeOut&quot;<br>    &gt;<br>      &lt;p v-if=&quot;show&quot;&gt;这是一段文本，使用 Animate.css 实现淡入淡出动画。&lt;/p&gt;<br>    &lt;/Transition&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br><br>const show = ref(false);<br>&lt;/script&gt;    <br></code></pre></td></tr></table></figure><ul><li><code>enter-active-class</code> 属性指定元素进入时应用的动画类</li><li><code>leave-active-class</code> 属性指定元素离开时应用的动画类</li></ul><hr><p>使用 <code>&lt;TransitionGroup&gt;</code> 组件为列表元素添加过渡动画。<code>&lt;TransitionGroup&gt;</code> 用于多个元素或组件的过渡效果，它会在列表中的元素插入、删除或移动时应用过渡动画</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>      &lt;button @click=&quot;addItem&quot;&gt;添加元素&lt;/button&gt;<br>      &lt;button @click=&quot;removeItem&quot;&gt;移除元素&lt;/button&gt;<br>      &lt;TransitionGroup tag=&quot;ul&quot; name=&quot;slide&quot;&gt;<br>        &lt;li v-for=&quot;item in items&quot; :key=&quot;item&quot; style=&quot;width: 20px;&quot;&gt;<br>          &#123;&#123; item &#125;&#125;<br>        &lt;/li&gt;<br>      &lt;/TransitionGroup&gt;<br>    &lt;/div&gt;<br>  &lt;/template&gt;<br>  <br>  &lt;script setup&gt;<br>  import &#123; ref &#125; from &#x27;vue&#x27;;<br>  <br>  const items = ref([1, 2, 3]);<br>  <br>  const addItem = () =&gt; &#123;<br>    items.value.push(items.value.length + 1);<br>  &#125;;<br>  <br>  const removeItem = () =&gt; &#123;<br>    if (items.value.length &gt; 0) &#123;<br>      items.value.pop();<br>    &#125;<br>  &#125;;<br>  &lt;/script&gt;<br>  <br>  &lt;style scoped&gt;<br>  /* 定义进入动画 */<br>  .slide-enter-active &#123;<br>    transition: all 0.5s ease;<br>  &#125;<br>  .slide-enter-from &#123;<br>    opacity: 0;<br>    transform: translateX(-100%);<br>  &#125;<br>  <br>  /* 定义离开动画 */<br>  .slide-leave-active &#123;<br>    transition: all 0.5s ease;<br>    /* position: absolute; */<br>  &#125;<br>  .slide-leave-to &#123;<br>    opacity: 0;<br>    transform: translateX(100%);<br>  &#125;<br>  &lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li><code>**key**</code>** **<strong>属性</strong>：在 <code>&lt;TransitionGroup&gt;</code> 中，每个子元素都必须有唯一的 <code>key</code>，这样 Vue 才能正确识别元素的插入、删除和移动。</li><li><code>**tag**</code>** 属性**：<code>tag</code> 属性用于指定 <code>&lt;TransitionGroup&gt;</code> 渲染的根元素，如果不指定，默认会渲染为一个 <code>&lt;span&gt;</code> 元素。</li><li><strong>移动动画</strong>：除了插入和删除动画，<code>&lt;TransitionGroup&gt;</code> 还支持元素移动时的动画效果。可以通过设置 <code>move-class</code> 属性来定义移动动画的类名。</li><li>定义离开动画时,尽量使用<code>position: absolute</code> 作用是确保元素在离开时不会影响其他元素的布局，从而正确执行过渡动画<ul><li>不加 <code>position: absolute</code><ul><li>元素仍处于文档流中。</li><li>其他元素会立即占据被移除元素的位置。或者删除时,仍占据位置直至从 DOM 中移除导致其他元素因被移除元素的位置被占据无法过渡动画</li></ul></li><li>加 <code>position: absolute</code><ul><li>元素脱离文档流，其他元素不会移动。</li><li>元素在原位执行过渡动画（如向右移动），动画结束后再从 DOM 中移除。</li></ul></li></ul></li></ul><h4 id="N25tc">响应式</h4><h5 id="R33wG">响应式本质</h5><p>Vue 的响应式系统是其核心机制之一，它通过数据劫持和依赖追踪实现数据变化到视图更新的自动化</p><p><strong>响应式系统的本质</strong>：当数据变化时，自动触发依赖该数据的代码（如视图渲染、计算属性等），实现数据和 UI 的同步。</p><h5 id="Qv8dr">vue2响应式</h5><p> Vue 2 响应式系统的核心逻辑，主要借助 <code>Object.defineProperty</code> 方法对对象属性进行劫持，以此实现数据的响应式更新。通过发布 - 订阅模式，当对象的属性值发生变化时，能够自动触发与之关联的依赖函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><code class="hljs vue">const obj = &#123;<br>    name: &#x27;mirZ&#x27;,<br>    age: 18<br>&#125;<br><br>//  /* 1. 手动收集依赖 */<br><br>// //定义收集依赖函数的数组<br>// const watchFnList = []<br>// //定义一个执行响应式函数的函数<br>// function watchFn(fn) &#123;<br>//     watchFnList.push(fn)<br>//     //收集依赖时默认执行一次<br>//     fn()<br>// &#125;<br><br>// watchFn(function foo1() &#123;<br>//     console.log(&#x27;foo1&#x27;, obj.name);<br>// &#125;)<br>// watchFn(function foo2() &#123;<br>//     console.log(&#x27;foo2&#x27;, obj.name, obj.age);<br>// &#125;)<br><br>// watchFnList.map((fn) =&gt; &#123;<br>//     fn()<br>// &#125;)<br><br><br><br><br>// /* 2. 定义类创建实例管理收集的依赖 */<br>// class Depend &#123;<br>//     constructor() &#123;<br>//         this.watchFnList = []<br>//     &#125;<br>//     //收集依赖函数<br>//     addDepend(fn) &#123;<br>//         if (fn) &#123;<br>//             this.watchFnList.push(fn)<br>//         &#125;<br>//     &#125;<br>//     //通知触发依赖函数<br>//     notify() &#123;<br>//         this.watchFnList.map((fn) =&gt; &#123;<br>//             fn()<br>//         &#125;)<br>//     &#125;<br>// &#125;<br><br>// const dep = new Depend()<br>// function watchFn(fn) &#123;<br>//     dep.addDepend(fn)<br>//     fn()<br>// &#125;<br><br>// watchFn(function foo1() &#123;<br>//     console.log(&#x27;foo1&#x27;, obj.name);<br>// &#125;)<br>// watchFn(function foo2() &#123;<br>//     console.log(&#x27;foo2&#x27;, obj.name, obj.age);<br>// &#125;)<br>// //通知触发依赖<br>// dep.notify()<br><br><br><br><br>// /* 3. vue2 监听属性变化 */<br>// Object.keys(obj).forEach((key) =&gt; &#123;<br>//     let value = obj[key]<br>//     Object.defineProperty(obj, key, &#123;<br>//         set: function (newValue) &#123;<br>//             // 不要直接使用 obj.value=newValue 会形成递归<br>//             value = newValue<br>//             dep.notify()<br>//         &#125;,<br>//         get: function () &#123;<br>//             return value<br>//         &#125;<br>//     &#125;)<br>// &#125;)<br>// class Depend &#123;<br>//     constructor() &#123;<br>//         this.watchFnList = []<br>//     &#125;<br>//     //收集依赖函数<br>//     addDepend(fn) &#123;<br>//         if (fn) &#123;<br>//             this.watchFnList.push(fn)<br>//         &#125;<br>//     &#125;<br>//     //通知触发依赖函数<br>//     notify() &#123;<br>//         this.watchFnList.map((fn) =&gt; &#123;<br>//             fn()<br>//         &#125;)<br>//     &#125;<br>// &#125;<br><br>// const dep = new Depend()<br>// function watchFn(fn) &#123;<br>//     dep.addDepend(fn)<br>//     fn()<br>// &#125;<br><br>// watchFn(function foo1() &#123;<br>//     console.log(&#x27;foo1&#x27;, obj.name);<br>// &#125;)<br>// watchFn(function foo2() &#123;<br>//     console.log(&#x27;foo2&#x27;, obj.name, obj.age);<br>// &#125;)<br><br>// console.log(&#x27;name变化-----&#x27;);<br>// obj.name = &#x27;MirZ&#x27;<br><br>// console.log(&#x27;age变化-----&#x27;);<br>// obj.age = 16<br><br><br><br><br>// /* 4. vue2 监听属性变化(自动收集依赖)[仅实现了对obj对象的劫持] */<br>// Object.keys(obj).forEach((key) =&gt; &#123;<br>//     let value = obj[key]<br>//     Object.defineProperty(obj, key, &#123;<br>//         set: function (newValue) &#123;<br>//             value = newValue<br>//             const dep = getDep(obj, key)<br>//             dep.notify()<br>//         &#125;,<br>//         get: function () &#123;<br>//             const dep = getDep(obj, key)<br>//             // dep.addDepend(reactiveFn)<br>//             dep.depent()<br>//             return value<br>//         &#125;<br>//     &#125;)<br>// &#125;)<br>// //定义Depend类<br>// class Depend &#123;<br>//     constructor() &#123;<br>//         // this.watchFnList = []  使用set去重,防止同一函数多次添加<br>//         this.watchFnList = new Set()<br>//     &#125;<br>//     //收集依赖函数<br>//     addDepend(fn) &#123;<br>//         if (fn) &#123;<br>//             this.watchFnList.add(fn)<br>//         &#125;<br>//     &#125;<br>//     //优化get时添加dep<br>//     depent() &#123;<br>//         if (reactiveFn) &#123;<br>//             this.watchFnList.add(reactiveFn)<br>//         &#125;<br>//     &#125;<br>//     //通知触发依赖函数<br>//     notify() &#123;<br>//         this.watchFnList.forEach((fn) =&gt; &#123;<br>//             fn()<br>//         &#125;)<br>//     &#125;<br>// &#125;<br><br>// //收集全部对象的Map<br>// const objMap = new WeakMap()<br>// //封装函数,负责通过obj的key获取对应数据Dep对象<br>// function getDep(obj, key) &#123;<br>//     //1. 根据obj对象找对应的map对象<br>//     let map = objMap.get(obj)<br>//     if (!map) &#123;<br>//         //如果objMap不存在obj对象的map进行创建<br>//         map = new Map()<br>//         objMap.set(obj, map)<br>//     &#125;<br>//     //根据key找到对应的Dep对象<br>//     let dep = map.get(key)<br>//     if (!dep) &#123;<br>//         dep = new Depend()<br>//         map.set(key, dep)<br>//     &#125;<br>//     return dep<br>// &#125;<br><br>// let reactiveFn = null<br>// function watchFn(fn) &#123;<br>//     reactiveFn = fn<br>//     fn()<br>//     reactiveFn = null<br>// &#125;<br><br>// watchFn(function foo() &#123;<br>//     console.log(obj.age);<br>// &#125;)<br>// console.log(&#x27;name变化-------&#x27;);<br>// obj.name = &#x27;Mi&#x27;<br><br><br><br><br><br>/* 5. vue2 监听属性变化(自动收集依赖)[多个对象劫持] */<br><br>//封装函数,每次创建对象使用该函数封装<br>function reactive(obj) &#123;<br>    Object.keys(obj).forEach((key) =&gt; &#123;<br>        let value = obj[key]<br>        Object.defineProperty(obj, key, &#123;<br>            set: function (newValue) &#123;<br>                value = newValue<br>                const dep = getDep(obj, key)<br>                dep.notify()<br>            &#125;,<br>            get: function () &#123;<br>                const dep = getDep(obj, key)<br>                // dep.addDepend(reactiveFn)<br>                dep.depent()<br>                return value<br>            &#125;<br>        &#125;)<br>    &#125;)<br>    return obj<br>&#125;<br>//定义Depend类<br>class Depend &#123;<br>    constructor() &#123;<br>        // this.watchFnList = []  使用set去重,防止同一函数多次添加<br>        this.watchFnList = new Set()<br>    &#125;<br>    //收集依赖函数<br>    addDepend(fn) &#123;<br>        if (fn) &#123;<br>            this.watchFnList.add(fn)<br>        &#125;<br>    &#125;<br>    //优化get时添加dep<br>    depent() &#123;<br>        if (reactiveFn) &#123;<br>            this.watchFnList.add(reactiveFn)<br>        &#125;<br>    &#125;<br>    //通知触发依赖函数<br>    notify() &#123;<br>        this.watchFnList.forEach((fn) =&gt; &#123;<br>            fn()<br>        &#125;)<br>    &#125;<br>&#125;<br><br>//收集全部对象的Map<br>const objMap = new WeakMap()<br>//封装函数,负责通过obj的key获取对应数据Dep对象<br>function getDep(obj, key) &#123;<br>    //1. 根据obj对象找对应的map对象<br>    let map = objMap.get(obj)<br>    if (!map) &#123;<br>        //如果objMap不存在obj对象的map进行创建<br>        map = new Map()<br>        objMap.set(obj, map)<br>    &#125;<br>    //根据key找到对应的Dep对象<br>    let dep = map.get(key)<br>    if (!dep) &#123;<br>        dep = new Depend()<br>        map.set(key, dep)<br>    &#125;<br>    return dep<br>&#125;<br><br>let reactiveFn = null<br>function watchFn(fn) &#123;<br>    reactiveFn = fn<br>    fn()<br>    reactiveFn = null<br>&#125;<br><br>const info = reactive(&#123;<br>    name: &#x27;李卓&#x27;,<br>    age: 20<br>&#125;)<br><br>watchFn(function () &#123;<br>    console.log(info.name);<br>&#125;)<br>info.name=&#x27;叶茂华&#x27;<br><br></code></pre></td></tr></table></figure><hr><p><strong>reactive函数实现属性劫持与依赖收集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">function reactive(obj) &#123;<br>    Object.keys(obj).forEach((key) =&gt; &#123;<br>        let value = obj[key]<br>        Object.defineProperty(obj, key, &#123;<br>            set: function (newValue) &#123;<br>                value = newValue<br>                const dep = getDep(obj, key)<br>                dep.notify()<br>            &#125;,<br>            get: function () &#123;<br>                const dep = getDep(obj, key)<br>                dep.depent()<br>                return value<br>            &#125;<br>        &#125;)<br>    &#125;)<br>    return obj<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数接收一个对象 <code>obj</code> 作为参数，通过 <code>Object.keys(obj).forEach</code> 遍历对象的所有属性。</li><li>对于每个属性，使用 <code>Object.defineProperty</code> 进行劫持：<ul><li><code>**setter**</code>：当属性值被修改时，更新内部的 <code>value</code> 变量，然后通过 <code>getDep</code> 函数获取该属性对应的 <code>Depend</code> 对象，调用其 <code>notify</code> 方法通知所有依赖函数执行。</li><li><code>**getter**</code>：在属性被访问时，通过 <code>getDep</code> 函数获取该属性对应的 <code>Depend</code> 对象，调用其 <code>depent</code> 方法将当前的 <code>reactiveFn</code> 收集为依赖，最后返回属性的内部值 <code>value</code>。</li></ul></li><li>最后返回经过劫持处理后的对象 <code>obj</code>。</li></ul><hr><p><code>**Depend**</code>** 类**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">class Depend &#123;<br>    constructor() &#123;<br>        this.watchFnList = new Set()<br>    &#125;<br>    addDepend(fn) &#123;<br>        if (fn) &#123;<br>            this.watchFnList.add(fn)<br>        &#125;<br>    &#125;<br>    depent() &#123;<br>        if (reactiveFn) &#123;<br>            this.watchFnList.add(reactiveFn)<br>        &#125;<br>    &#125;<br>    notify() &#123;<br>        this.watchFnList.forEach((fn) =&gt; &#123;<br>            fn()<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Depend</code> 类用于管理依赖函数，内部使用 <code>Set</code> 类型的 <code>watchFnList</code> 存储依赖函数，以避免同一函数被重复添加。<ul><li><code>**addDepend**</code>** **<strong>方法</strong>：将传入的依赖函数 <code>fn</code> 添加到 <code>watchFnList</code> 中。</li><li><code>**depent**</code>** **<strong>方法</strong>：如果 <code>reactiveFn</code> 存在，则将其添加到 <code>watchFnList</code> 中。</li><li><code>**notify**</code>** 方法**：遍历 <code>watchFnList</code>，依次执行其中的每个依赖函数。</li></ul></li></ul><hr><p><strong>存储依赖信息映射</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">const objMap = new WeakMap()<br>function getDep(obj, key) &#123;<br>    let map = objMap.get(obj)<br>    if (!map) &#123;<br>        map = new Map()<br>        objMap.set(obj, map)<br>    &#125;<br>    let dep = map.get(key)<br>    if (!dep) &#123;<br>        dep = new Depend()<br>        map.set(key, dep)<br>    &#125;<br>    return dep<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>objMap</code> 是一个 <code>WeakMap</code>，用于存储对象和其对应的依赖信息映射。</li><li><code>getDep</code> 函数用于根据对象 <code>obj</code> 和属性名 <code>key</code> 获取对应的 <code>Depend</code> 对象：<ul><li>首先从 <code>objMap</code> 中查找对象 <code>obj</code> 对应的 <code>Map</code>。</li><li>如果该 <code>Map</code> 不存在，则创建一个新的 <code>Map</code> 并将其存入 <code>objMap</code>。</li><li>然后从这个 <code>Map</code> 中查找属性 <code>key</code> 对应的 <code>Depend</code> 对象。</li><li>如果该 <code>Depend</code> 对象不存在，则创建一个新的 <code>Depend</code> 对象并将其存入 <code>Map</code>。</li><li>最后返回找到或创建的 <code>Depend</code> 对象。</li></ul></li></ul><hr><p><code>**watchFn**</code>** 函数**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">let reactiveFn = null<br>function watchFn(fn) &#123;<br>    reactiveFn = fn<br>    fn()<br>    reactiveFn = null<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>reactiveFn</code> 是一个全局变量，用于临时存储当前正在执行的依赖函数。</li><li><code>watchFn</code> 函数接收一个依赖函数 <code>fn</code> 作为参数：<ul><li>将 <code>fn</code> 赋值给 <code>reactiveFn</code>。</li><li>执行 <code>fn</code>，在执行过程中，如果访问了被劫持的属性，会触发该属性的 <code>getter</code>，从而将 <code>reactiveFn</code> 收集为依赖。</li><li>执行完 <code>fn</code> 后，将 <code>reactiveFn</code> 置为 <code>null</code>。</li></ul></li></ul><p><strong>在vue中模板语法最后都会转成Vnode , 最后被渲染函数h函数去渲染 , h函数中就使用了类似watchFn的函数 , 实现可以依赖响应式数据实现数据响应式</strong></p><hr><p><strong>总结</strong></p><ul><li><strong>响应式原理</strong>：利用 <code>Object.defineProperty</code> 对对象属性进行劫持，在 <code>getter</code> 中收集依赖，在 <code>setter</code> 中触发依赖更新。</li><li><strong>依赖管理</strong>：使用 <code>Depend</code> 类和 <code>Set</code> 数据结构管理依赖函数，避免重复添加。</li><li><strong>多对象支持</strong>：通过 <code>WeakMap</code> 和 <code>Map</code> 存储不同对象及其属性对应的依赖信息，支持对多个对象的属性进行劫持和依赖管理。</li><li><strong>使用方式</strong>：通过 <code>reactive</code> 函数将普通对象转换为响应式对象，使用 <code>watchFn</code> 函数包裹依赖函数，实现依赖的自动收集和响应式更新。</li></ul><h5 id="n5vg8">vue3响应式</h5><p> Vue 3 响应式系统，能够对多个对象的属性变化进行监听，并自动收集依赖。当对象的属性值发生改变时，与之关联的依赖函数会被自动触发执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs vue">/* 3. vue3 监听属性变化(自动收集依赖)[多个对象劫持] */<br><br>//封装函数,每次创建对象使用该函数封装<br>function reactive(obj) &#123;<br>    const objProxy = new Proxy(obj, &#123;<br>        set(target, key, newValue, receiver) &#123;<br>            // target[key] = newValue<br>            Reflect.set(target, key, newValue, receiver)<br>            const dep = getDep(target, key)<br>            dep.notify()<br>        &#125;,<br>        get(target, key, receiver) &#123;<br>            const dep = getDep(target, key)<br>            dep.depent()<br>            return Reflect.get(target, key, receiver)<br>        &#125;<br>    &#125;)<br>    return objProxy<br>&#125;<br>//定义Depend类<br>class Depend &#123;<br>    constructor() &#123;<br>        // this.watchFnList = []  使用set去重,防止同一函数多次添加<br>        this.watchFnList = new Set()<br>    &#125;<br>    //收集依赖函数<br>    addDepend(fn) &#123;<br>        if (fn) &#123;<br>            this.watchFnList.add(fn)<br>        &#125;<br>    &#125;<br>    //优化get时添加dep<br>    depent() &#123;<br>        if (reactiveFn) &#123;<br>            this.watchFnList.add(reactiveFn)<br>        &#125;<br>    &#125;<br>    //通知触发依赖函数<br>    notify() &#123;<br>        this.watchFnList.forEach((fn) =&gt; &#123;<br>            fn()<br>        &#125;)<br>    &#125;<br>&#125;<br><br>//收集全部对象的Map<br>const objMap = new WeakMap()<br>//封装函数,负责通过obj的key获取对应数据Dep对象<br>function getDep(obj, key) &#123;<br>    //1. 根据obj对象找对应的map对象<br>    let map = objMap.get(obj)<br>    if (!map) &#123;<br>        //如果objMap不存在obj对象的map进行创建<br>        map = new Map()<br>        objMap.set(obj, map)<br>    &#125;<br>    //根据key找到对应的Dep对象<br>    let dep = map.get(key)<br>    if (!dep) &#123;<br>        dep = new Depend()<br>        map.set(key, dep)<br>    &#125;<br>    return dep<br>&#125;<br><br>let reactiveFn = null<br>function watchFn(fn) &#123;<br>    reactiveFn = fn<br>    fn()<br>    reactiveFn = null<br>&#125;<br><br>const info = reactive(&#123;<br>    name: &quot;李卓&quot;,<br>    age: 20<br>&#125;)<br>watchFn(function () &#123;<br>    console.log(info.name);<br>&#125;)<br>info.name = &#x27;叶茂华&#x27;<br></code></pre></td></tr></table></figure><hr><p><code>**reactive**</code>** 函数数据拦截和依赖收集**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">function reactive(obj) &#123;<br>    const objProxy = new Proxy(obj, &#123;<br>        set(target, key, newValue, receiver) &#123;<br>            // target[key] = newValue<br>            Reflect.set(target, key, newValue, receiver)<br>            const dep = getDep(target, key)<br>            dep.notify()<br>        &#125;,<br>        get(target, key, receiver) &#123;<br>            const dep = getDep(target, key)<br>            dep.depent()<br>            return Reflect.get(target, key, receiver)<br>        &#125;<br>    &#125;)<br>    return objProxy<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数接收一个普通对象 <code>obj</code> 作为参数，使用 <code>Proxy</code> 对象对其进行代理。<ul><li><code>**set**</code>** **<strong>拦截器</strong>：当修改代理对象的属性时，此拦截器会被触发。借助 <code>Reflect.set</code> 方法更新目标对象 <code>target</code> 上的属性值。然后通过 <code>getDep</code> 函数获取该属性对应的 <code>Depend</code> 对象，调用其 <code>notify</code> 方法通知所有依赖函数执行。</li><li><code>**get**</code>** 拦截器**：当访问代理对象的属性时，该拦截器会被触发。通过 <code>getDep</code> 函数获取该属性对应的 <code>Depend</code> 对象，调用其 <code>depent</code> 方法将当前的 <code>reactiveFn</code> 收集为依赖，最后借助 <code>Reflect.get</code> 方法返回目标对象 <code>target</code> 上该属性的值。</li></ul></li><li>最终返回代理对象 <code>objProxy</code>。</li></ul><h5 id="FEh1t">总结</h5><table><thead><tr><th><strong>特性</strong></th><th><strong>Vue 2 (Object.defineProperty)</strong></th><th><strong>Vue 3 (Proxy)</strong></th></tr></thead><tbody><tr><td>对象属性新增&#x2F;删除</td><td>不支持，需用 <code>Vue.set</code><br>&#x2F;<code>Vue.delete</code></td><td>原生支持</td></tr><tr><td>数组索引修改</td><td>需重写方法或 <code>Vue.set</code></td><td>原生支持</td></tr><tr><td>初始化性能</td><td>递归遍历所有属性，性能较差</td><td>惰性代理，按需响应式</td></tr><tr><td>代码复杂度</td><td>实现简单</td><td>依赖复杂的数据结构（WeakMap&#x2F;Map）</td></tr></tbody></table><p><strong>响应式工作流程</strong></p><ol><li><strong>数据劫持</strong>：通过 <code>Object.defineProperty</code> 或 <code>Proxy</code> 监听数据读写。</li><li><strong>依赖收集</strong>：在 <code>getter</code> 中收集当前正在执行的依赖（如组件的渲染函数）。</li><li><strong>触发更新</strong>：在 <code>setter</code> 中通知所有依赖执行更新逻辑（如重新渲染组件）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态加载图片</title>
    <link href="/2025/03/18/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
    <url>/2025/03/18/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>在 Vue 项目里，若 <code>img</code> 标签的 <code>src</code> 属性是动态的，可通过绑定 <code>:src</code> 来动态加载图片。下面会分别介绍基于 Webpack 和 Vite 的项目中动态加载图片的方式。</p><p>在 Webpack 项目中，需要借助 <code>require</code> 函数来动态加载图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;!-- 动态绑定图片 src 属性 --&gt;<br>    &lt;img :src=&quot;getImageUrl(imageName)&quot; alt=&quot;Dynamic Image&quot;&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>      getImageUrl(name) &#123;<br>        try &#123;<br>          // 使用 require 动态加载图片<br>          return require(`@/assets/$&#123;name&#125;`);<br>        &#125; catch (error) &#123;<br>          console.error(&#x27;图片加载失败:&#x27;, error);<br>          return &#x27;&#x27;;<br>        &#125;<br>  &#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在 Webpack 里，<code>require</code> 是用于引入模块的函数。当使用 <code>require</code> 动态加载图片时，Webpack 会在打包阶段就对 <code>require</code> 语句进行解析，把图片文件处理成可以在浏览器中使用的 URL。因为 Webpack 在打包时会对整个项目进行静态分析，所以 <code>require</code> 能够准确地找到图片文件并处理它。</p><hr><p>在 Vite 项目中，要使用 <code>import.meta.glob</code> 或者 <code>new URL</code> 来动态加载图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;!-- 动态绑定图片 src 属性 --&gt;<br>    &lt;img :src=&quot;getImageUrl(imageName)&quot; alt=&quot;Dynamic Image&quot;&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    getImageUrl(name) &#123;<br>      try &#123;<br>        // 使用 new URL 动态加载图片<br>        return new URL(`/src/assets/$&#123;name&#125;`, import.meta.url).href;<br>      &#125; catch (error) &#123;<br>        console.error(&#x27;图片加载失败:&#x27;, error);<br>        return &#x27;&#x27;;<br>      &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>Vite 是基于 ES 模块的开发服务器，它利用了现代浏览器原生支持 ES 模块的特性。在开发阶段，Vite 不会对项目进行打包，而是直接启动一个开发服务器，根据浏览器的请求按需加载模块。只有在生产环境下，Vite 才会进行打包。</p><p><code>new URL</code> 是 JavaScript 原生的构造函数，用于创建一个 URL 对象。在 Vite 项目中，使用 <code>new URL</code> 可以根据当前模块的 URL 来生成图片的绝对 URL。因为 Vite 在开发阶段不会对项目进行打包，所以可以直接使用原生的 JavaScript 方法来处理图片路径。</p><p><code>import.meta.glob</code> 是 Vite 提供的一个特殊功能，用于动态导入多个模块。在 Vite 项目中，使用 <code>import.meta.glob</code> 可以动态加载多个图片文件。<code>import.meta.glob</code> 会返回一个对象，对象的键是图片文件的路径，值是图片文件的模块。这样就可以根据图片的名称动态获取图片的 URL。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios</title>
    <link href="/2025/03/17/Axios/"/>
    <url>/2025/03/17/Axios/</url>
    
    <content type="html"><![CDATA[<p>Axios 是一个基于 Promise 的 HTTP 客户端，广泛用于浏览器和 Node.js 环境。它支持请求&#x2F;响应拦截、取消请求、自动转换 JSON 数据等特性，简化了 HTTP 请求处理。</p><h4 id="93837276">安装与引入</h4><p><strong>安装</strong><br>通过 npm 或 yarn 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install axios<br># 或<br>yarn add axios<br></code></pre></td></tr></table></figure><p><strong>引入方式</strong></p><p>ES6 Module：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">import axios from &#x27;axios&#x27;;<br></code></pre></td></tr></table></figure><p>CommonJS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">const axios = require(&#x27;axios&#x27;);<br></code></pre></td></tr></table></figure><p>浏览器 CDN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="N9XFT">基本用法</h4><p><strong>GET 请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.get(&#x27;/user?ID=123&#x27;)<br>  .then(response =&gt; &#123;<br>    console.log(response.data);<br>  &#125;)<br>  .catch(error =&gt; &#123;<br>    console.error(error);<br>  &#125;);<br><br>// 或使用 params 参数<br>axios.get(&#x27;/user&#x27;, &#123;<br>  params: &#123; ID: 123 &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>POST 请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.post(&#x27;/user&#x27;, &#123;<br>  name: &#x27;John&#x27;,<br>  age: 30<br>&#125;)<br>.then(response =&gt; &#123;<br>  console.log(response.data);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>并发请求</strong><br>使用 <code>Promise.all</code> 或 <code>axios.all</code>（已弃用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.all([<br>  axios.get(&#x27;/user/123&#x27;),<br>  axios.get(&#x27;/posts?user=123&#x27;)<br>]).then(([userResp, postsResp]) =&gt; &#123;<br>  // 处理结果<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p>在发起请求时，可以传递一个配置对象来定制请求。常见的配置选项包括：</p><ul><li><code>url</code>：请求的 URL。</li><li><code>method</code>：请求方法，如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等。</li><li><code>params</code>：URL 参数，用于 <code>GET</code> 请求。</li><li><code>data</code>：请求体数据，用于 <code>POST</code>、<code>PUT</code> 等请求。</li><li><code>headers</code>：请求头信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">axios(&#123;<br>  method: &#x27;post&#x27;,<br>  url: &#x27;/user&#x27;,<br>  data: &#123; name: &#x27;John&#x27; &#125;,<br>  headers: &#123; &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27; &#125;,<br>  timeout: 1000, // 超时时间（毫秒）<br>  baseURL: &#x27;https://api.example.com&#x27;, // 基础路径<br>  params: &#123; ID: 123 &#125;, // GET 参数<br>  responseType: &#x27;json&#x27; // 响应格式（默认）<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p>设置默认值，简化重复配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.defaults.baseURL = &#x27;https://api.example.com&#x27;;<br>axios.defaults.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN;<br>axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;<br></code></pre></td></tr></table></figure><hr><p><code>axios</code> 的响应对象包含以下属性：</p><ul><li><code>data</code>：服务器返回的数据。</li><li><code>status</code>：HTTP 状态码。</li><li><code>statusText</code>：HTTP 状态信息。</li><li><code>headers</code>：响应头信息。</li><li><code>config</code>：请求时的配置对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">axios.get(&#x27;https://api.example.com/data&#x27;)<br>  .then(response =&gt; &#123;<br>    console.log(&#x27;Data:&#x27;, response.data);<br>    console.log(&#x27;Status:&#x27;, response.status);<br>    console.log(&#x27;Status Text:&#x27;, response.statusText);<br>    console.log(&#x27;Headers:&#x27;, response.headers);<br>    console.log(&#x27;Config:&#x27;, response.config);<br>  &#125;)<br>  .catch(error =&gt; &#123;<br>    console.error(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>取消请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">const controller = new AbortController();<br><br>axios.get(&#x27;/user/123&#x27;, &#123;<br>  signal: controller.signal<br>&#125;).catch(error =&gt; &#123;<br>  if (error.name === &#x27;AbortError&#x27;) &#123;<br>    console.log(&#x27;请求已取消&#x27;);<br>  &#125;<br>&#125;);<br><br>// 取消请求<br>controller.abort();<br></code></pre></td></tr></table></figure><hr><p><strong>创建实例</strong></p><p>复用配置，隔离不同请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const api = axios.create(&#123;<br>  baseURL: &#x27;https://api.example.com&#x27;,<br>  timeout: 5000<br>&#125;);<br><br>api.get(&#x27;/user&#x27;); // 发送到 https://api.example.com/user<br></code></pre></td></tr></table></figure><h4 id="TLjdk">拦截器</h4><p><strong>请求拦截器</strong><br>修改请求配置或添加通用头信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.interceptors.request.use(config =&gt; &#123;<br>  config.headers.Authorization = `Bearer $&#123;token&#125;`;<br>  return config;<br>&#125;, error =&gt; &#123;<br>  return Promise.reject(error);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>响应拦截器</strong><br>统一处理响应或错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.interceptors.response.use(response =&gt; &#123;<br>  return response.data; // 直接返回数据部分<br>&#125;, error =&gt; &#123;<br>  if (error.response.status === 401) &#123;<br>    // 处理未授权<br>  &#125;<br>  return Promise.reject(error);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>封装Axios</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">import axios from &quot;axios&quot;;<br><br>const request = axios.create(&#123;<br>    baseURL: &#x27;example/api&#x27;,<br>    timeout: 3000<br>&#125;)<br><br>request.interceptors.request.use((config) =&gt; &#123;<br>    config.headers.Authorization = `Bearer $&#123;token&#125;`;<br>    return config;<br>&#125;, err =&gt; &#123;<br>    throw Promise.reject(err)<br>&#125;<br>)<br><br>request.interceptors.response.use((response) =&gt; &#123;<br>    return response.data;<br>&#125;, err =&gt; &#123;<br>    throw Promise.reject(err)<br>&#125;<br>)<br><br>export default request<br></code></pre></td></tr></table></figure><p><strong>封装Axios类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plain">import axios from &quot;axios&quot;;<br><br>class MyAxios &#123;<br>    constructor(baseURL, timeout) &#123;<br>        // 初始化 this.instance<br>        this.instance = axios.create(&#123;<br>            baseURL,<br>            timeout<br>        &#125;);<br>        // 请求拦截器<br>        this.instance.interceptors.request.use((config) =&gt; &#123;<br>            if (token) &#123;<br>                config.headers.Authorization = `Bearer $&#123;token&#125;`;<br>            &#125;<br>            return config;<br>        &#125;, (err) =&gt; &#123;<br>            return Promise.reject(err);<br>        &#125;);<br><br>        // 响应拦截器<br>        this.instance.interceptors.response.use((response) =&gt; &#123;<br>            return response.data;<br>        &#125;, (err) =&gt; &#123;<br>            return Promise.reject(err);<br>        &#125;);<br>    &#125;<br><br>&#125;<br><br>// 创建一个 MyAxios 实例并导出<br>const request_o = new MyAxios(&#x27;example/api/o&#x27;, 3000);<br>const request_z = new MyAxios(&#x27;example/api/z&#x27;, 5000);<br><br>export &#123;<br>    request_o,<br>    request_z,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/2025/03/10/Vue/"/>
    <url>/2025/03/10/Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="e8xp9">认识Vue</h3><h4 id="x9Dvj">认识Vue</h4><p>Vue  是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型 。</p><ul><li>无需构建步骤，渐进式增强静态的 HTML</li><li>在任何页面中作为 Web Components 嵌入</li><li>单页应用 (SPA)</li><li>全栈 &#x2F; 服务端渲染 (SSR)</li><li>Jamstack &#x2F; 静态站点生成 (SSG)</li><li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li></ul><h4 id="RJFJj">Vue安装</h4><ul><li>CDN引入&#x2F;本地下载引入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>使用Webpack&#x2F;CLI构建Vue项目</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">方式一: vue-cli创建<br>npm install -g @vue/cli  全局安装vue/cli<br>vue create my-vue-project<br>方式二: 基于vite创建<br>npm create vue@latest<br></code></pre></td></tr></table></figure><h4 id="YJuGK">Vue基本使用</h4><h5 id="hWfRa">命令式编程 vs 声明式编程</h5><ol><li><strong>命令式编程</strong></li></ol><ul><li><strong>核心思想</strong>：关注“如何做”（具体步骤）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const btn = document.getElementById(&#x27;btn&#x27;);<br>btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123;<br>  const text = document.getElementById(&#x27;text&#x27;);<br>  text.textContent = &#x27;New Text&#x27;;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>：需逐步编写逻辑，直接控制 DOM 更新流程。</li></ul><ol start="2"><li><strong>声明式编程</strong></li></ol><ul><li><strong>核心思想</strong>：关注“做什么”（结果），隐藏实现细节。</li><li><strong>Vue 示例</strong>：<br>数据驱动视图，通过模板绑定：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;button @click=&quot;updateText&quot;&gt;Click&lt;/button&gt;<br>  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123; message: &#x27;Hello&#x27; &#125;;<br>  &#125;,<br>  methods: &#123;<br>    updateText() &#123; this.message = &#x27;New Text&#x27;; &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>：数据变化自动触发视图更新，无需手动操作 DOM。</li></ul><h5 id="IFwLS">MVC vs MVVM</h5><ol><li><strong>MVC（Model-View-Controller）</strong><ul><li><strong>组成</strong>：<ul><li><strong>Model</strong>：数据逻辑（如 API 请求、数据库操作）。</li><li><strong>View</strong>：用户界面（如 HTML&#x2F;CSS）。</li><li><strong>Controller</strong>：接收用户输入，协调 Model 和 View。</li></ul></li><li><strong>数据流</strong>：<br>用户操作 → Controller → 更新 Model → View 从 Model 拉取数据渲染。</li><li><strong>痛点</strong>：View 和 Model 可能紧密耦合，需手动同步。</li></ul></li><li><strong>MVVM（Model-View-ViewModel）</strong><ul><li><strong>组成</strong>：<ul><li><strong>Model</strong>：数据层（同 MVC）。</li><li><strong>View</strong>：界面（模板）。</li><li><strong>ViewModel</strong>：数据绑定与同步（Vue 实例）。</li></ul></li><li><strong>数据流</strong>：<ul><li><strong>双向绑定</strong>：View 中表单输入自动更新 Model（如 <code>v-model</code>）。</li><li><strong>响应式更新</strong>：Model 变化自动触发 View 刷新（通过数据劫持）。</li></ul></li></ul></li></ol><h5 id="tR665">简单使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">          <span class="hljs-attr">template</span>: <span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">          &lt;div&gt;count:&#123;&#123;count&#125;&#125;&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">          &lt;div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">              &lt;button @click=add&gt;加1&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">              &lt;button @click=remove&gt;减1&lt;/button&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">              &lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">          `</span>,</span><br><span class="language-javascript">          <span class="hljs-comment">//本质上是一个返回对象的函数</span></span><br><span class="language-javascript">          <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">              <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                  <span class="hljs-attr">count</span>: <span class="hljs-number">10</span></span><br><span class="language-javascript">              &#125;</span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">          <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">              <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++</span><br><span class="language-javascript">              &#125;,</span><br><span class="language-javascript">              <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--</span><br><span class="language-javascript">              &#125;</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">      app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>     // 如果找不到 template ,会找到要挂载的容器当作模板渲染<br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>count:&#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">add</span>&gt;</span>加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">remove</span>&gt;</span>减1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">       <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">           <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">               <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                   <span class="hljs-attr">count</span>: <span class="hljs-number">10</span></span><br><span class="language-javascript">               &#125;</span><br><span class="language-javascript">           &#125;,</span><br><span class="language-javascript">           <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">               <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                   <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++</span><br><span class="language-javascript">               &#125;,</span><br><span class="language-javascript">               <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                   <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--</span><br><span class="language-javascript">               &#125;</span><br><span class="language-javascript">           &#125;</span><br><span class="language-javascript">       &#125;)</span><br><span class="language-javascript">       app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="sOdOu">Vue基本语法</h3><h4 id="umUma">options</h4><h5 id="QcIX2">data和method</h5><p><strong>data</strong></p><ul><li><strong>作用</strong>：用于定义组件的数据。它是一个函数，返回一个包含数据的对象。</li><li><strong>data属性是传入一个函数，并且该函数需要返回一个对象</strong><ul><li>在Vue2的时候，也可以传入一个对象(官方推荐是一个函数)</li><li>在Vue3的时候，必须传入一个函数，否则就会直接在浏览器中报错</li></ul></li><li><strong>原理:</strong><ul><li>data中返回的对象会被Vue的响应式系统劫持, 之后对该对象的修改或访问都会在劫持中被处理 ,所以我们在template或者app中通过  访问counter，可以从对象中获取到数据. 所以我们修改counter的值时，app中的 也会发生改变</li></ul></li></ul><hr><p><strong>methods</strong></p><ul><li><strong>作用</strong>：用于定义组件的方法。这些方法可以在模板中通过事件绑定调用，也可以在组件的其他方法中调用。</li><li><strong>methods属性是一个对象，通常我们会在这个对象中定义很多的方法:</strong><ul><li>这些方法可以被绑定到模板中:在该方法中，我们可以使用this关键字来直接访问到data中返回的对象的属性<ul><li>注意，不应该使用箭头函数来定义method 函数,箭头函数绑定了父级作用域的上下文,不会按照期望指向组件实例</li></ul></li><li>vue3不再通过this来访问组件实例中的数据和方法。</li></ul></li></ul><hr><h5 id="aTlJA">computed</h5><p>在 Vue 中，<strong>计算属性（Computed）</strong> 是一种基于响应式依赖进行缓存的属性，用于简化模板中的复杂逻辑，避免重复计算</p><hr><p><strong>定义</strong></p><ul><li><strong>计算属性</strong>是声明式的属性，通过依赖其他响应式数据动态计算得出值。</li><li>当依赖的数据变化时，计算属性会<strong>自动重新计算</strong>，否则直接返回<strong>缓存结果</strong></li></ul><hr><p><strong>语法</strong></p><ul><li><strong>选项式API(Vue2&#x2F;Vue3)</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">computed: &#123;<br>  fullName() &#123;<br>    return this.firstName + &#x27; &#x27; + this.lastName;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>组合式API(Vue3)</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">import &#123; ref, computed &#125; from &#x27;vue&#x27;;<br>const firstName = ref(&#x27;John&#x27;);<br>const lastName = ref(&#x27;Doe&#x27;);<br>const fullName = computed(() =&gt; firstName.value + &#x27; &#x27; + lastName.value);<br></code></pre></td></tr></table></figure><p><strong>核心特点</strong></p><p>**1. 缓存机制 **</p><ul><li><strong>缓存结果</strong>：只有依赖的响应式数据变化时才会重新计算。</li><li><strong>对比方法（Methods）</strong>：方法每次调用都会执行逻辑。</li></ul><p><strong>2. 响应式依赖</strong></p><ul><li>自动追踪依赖：计算属性内部使用的所有响应式数据都会被追踪。</li><li><strong>非响应式数据不会触发更新</strong>（如 <code>Date.now()</code>）。</li></ul><p><strong>3. 同步计算</strong></p><ul><li><strong>不支持异步</strong>：计算属性必须是同步操作（异步需用 <code>watch</code> 或方法）。</li></ul><p><strong>4. 可写计算属性（Setter）</strong></p><ul><li>提供 <code>get</code> 和 <code>set</code> 方法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">computed: &#123;<br>  fullName: &#123;<br>    get() &#123;<br>      return this.firstName + &#x27; &#x27; + this.lastName;<br>    &#125;,<br>    set(newValue) &#123;<br>      const [first, last] = newValue.split(&#x27; &#x27;);<br>      this.firstName = first;<br>      this.lastName = last;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ch8tX">watch</h5><p>在 Vue 中，<strong>侦听器（Watch）</strong> 用于监听响应式数据的变化并执行副作用操作（如异步请求、复杂逻辑处理等）。</p><p><strong>定义</strong></p><ul><li><code>**watch**</code> 用于观察特定的响应式数据，并在其变化时执行回调函数。</li><li>适用于需要<strong>副作用</strong>（如网络请求、DOM 操作）的场景。</li></ul><p><strong>基本语法</strong></p><ul><li><strong>选项式 API（Vue 2&#x2F;3）</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html">watch: &#123;<br>  // 监听简单数据<br>  count(newVal, oldVal) &#123;<br>    console.log(`count 从 $&#123;oldVal&#125; 变为 $&#123;newVal&#125;`);<br>  &#125;,<br><br>  // 监听对象属性（深度监听）<br>  &#x27;user.name&#x27;: &#123;<br>    handler(newVal) &#123;<br>      console.log(&#x27;用户名变化:&#x27;, newVal);<br>    &#125;,<br>    immediate: true // 立即触发一次<br>  &#125;,<br><br>  // 监听对象（深度监听）<br>  user: &#123;<br>    handler(newVal) &#123;<br>      console.log(&#x27;用户信息变化:&#x27;, newVal);<br>    &#125;,<br>    deep: true<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>组合式 API   (Vue 3)</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html">import &#123; ref, watch &#125; from &#x27;vue&#x27;;<br><br>const count = ref(0);<br>const user = ref(&#123; name: &#x27;Alice&#x27;, age: 25 &#125;);<br><br>// 监听单个 ref<br>watch(count, (newVal, oldVal) =&gt; &#123;<br>  console.log(`count 变化: $&#123;oldVal&#125; → $&#123;newVal&#125;`);<br>&#125;);<br><br>// 监听对象（需开启 deep）<br>watch(<br>  user,<br>  (newVal) =&gt; &#123;<br>    console.log(&#x27;用户变化:&#x27;, newVal);<br>  &#125;,<br>  &#123; deep: true &#125;<br>);<br><br>// 监听多个源<br>watch([count, user], ([newCount, newUser], [oldCount, oldUser]) =&gt; &#123;<br>  console.log(&#x27;多个数据变化&#x27;);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>配置项</strong></p><p><strong>immediate</strong></p><ul><li><strong>立即触发回调</strong>：在侦听器创建时立即执行一次。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">watch(<br>  source,<br>  (newVal) =&gt; &#123; /* 逻辑 */ &#125;,<br>  &#123; immediate: true &#125;<br>);<br></code></pre></td></tr></table></figure><p><strong>deep</strong></p><ul><li><strong>深度监听</strong>：监听对象&#x2F;数组内部嵌套值的变化。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">watch(<br>  () =&gt; state.obj,<br>  (newVal) =&gt; &#123; /* 逻辑 */ &#125;,<br>  &#123; deep: true &#125;<br>);<br></code></pre></td></tr></table></figure><hr><p><strong>watch 和 computed 区别</strong></p><table><thead><tr><th><strong>特性</strong></th><th><code>**watch**</code></th><th><code>**computed**</code></th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>监听数据变化并执行副作用</td><td>派生新值（无副作用）</td></tr><tr><td><strong>返回值</strong></td><td>无</td><td>必须有返回值</td></tr><tr><td><strong>缓存</strong></td><td>无</td><td>有（依赖不变时复用）</td></tr><tr><td><strong>异步支持</strong></td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="BOaV2">vue模板语法</h4><h5 id="KUPpp">基础模板语法</h5><p><strong>插值语法(Mustache)</strong></p><ul><li>使用它会将表达式的值替换到模板中</li><li>Mustache可以是data中的属性, 也可以是Js表达式, 不支持语句（如 if）或作用域操作。</li></ul><hr><p><strong>v-once</strong></p><ul><li>只渲染一次，元素或组件及其子元素将视为静态内容不在进行变化渲染。</li><li>可以应用于性能优化</li></ul><hr><p><strong>v-test</strong></p><ul><li>直接使用v-test的内容替换标签内容</li></ul><hr><p><strong>v-html</strong></p><ul><li>使用 v-html 指令输出解析后的 HTML</li><li>存在 XSS 攻击风险，仅信任内容使用</li></ul><hr><p><strong>v-pre</strong></p><ul><li>跳过该元素编译，直接输出原始内容</li></ul><hr><p><strong>v-cloak</strong></p><ul><li>隐藏未编译的模板（需配合 CSS <code>[v-cloak] &#123; display: none &#125;</code>）。</li></ul><hr><p><strong>v-memo</strong></p><ul><li>缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 仅当依赖项中发生变化,才会触发更新 --&gt;</span><br>     <span class="hljs-comment">&lt;!-- 点击事件依旧触发,不触发更新 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-memo</span>=<span class="hljs-string">&quot;[name]&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateInfo&quot;</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">         <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">             <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                 <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;MirZ&quot;</span>,</span><br><span class="language-javascript">                 <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">                 <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;China&#x27;</span></span><br><span class="language-javascript">             &#125;</span><br><span class="language-javascript">         &#125;,</span><br><span class="language-javascript">         <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">             <span class="hljs-title function_">updateInfo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                 <span class="hljs-comment">// this.name = &#x27;Mir&#x27;</span></span><br><span class="language-javascript">                 <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">20</span></span><br><span class="language-javascript">                 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发函数&#x27;</span>);</span><br><span class="language-javascript">             &#125;</span><br><span class="language-javascript">         &#125;</span><br><span class="language-javascript">     &#125;)</span><br><span class="language-javascript">     app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="FY3Xk">v-bind</h5><p>在 Vue 中，<code>v-bind</code> 是用于动态绑定 HTML 属性（如 <code>href</code>、<code>class</code>、<code>style</code> 等）或组件 props 到 Vue 实例数据的关键指令。</p><hr><p><strong>基本用法</strong></p><ul><li><strong>完整写法</strong>：<code>v-bind:属性名=&quot;表达式&quot;</code></li><li><strong>缩写</strong>：<code>:</code>（冒号）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 绑定 href 属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imageSrc&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;isInputDisabled&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>绑定class</strong></p><ul><li><strong>对象语法</strong>：根据条件动态切换类名</li><li><strong>数组语法</strong>：应用多个类名</li><li><strong>混合写法</strong>：数组和对象结合</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClassName()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>绑定style</strong></p><ul><li><strong>对象语法</strong>：绑定内联样式对象</li><li><strong>数组语法</strong>：应用多个样式对象</li><li><strong>混合写法</strong>：数组和对象结合</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 动态绑定style,后面跟上对象,&#123;&#x27;font-size&#x27;:&#x27;30px&#x27;&#125;加引号,否则尽量使用驼峰写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; color: textColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[baseStyles, overrideStyles]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>动态属性名</strong></p><ul><li>使用方括号 <code>[]</code> 实现动态属性名：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">dynamicAttr</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 示例：动态绑定属性名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:aria-expanded</span>=<span class="hljs-string">&quot;isExpanded ? &#x27;true&#x27; : &#x27;false&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>绑定对象</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 两种写法等价 --&gt;</span><br><span class="hljs-comment">&lt;!-- 可以用于组件通信 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;propsObject.id&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;propsObject.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;propsObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Ih2w8">v-on</h5><p>在 Vue 中，<code>v-on</code> 是用于绑定事件监听器的核心指令，允许开发者监听 DOM 事件或自定义事件，并执行对应的 JavaScript 逻辑</p><hr><p><strong>基本语法</strong></p><ul><li><strong>完整写法</strong>：<code>v-on:事件名=&quot;处理函数或表达式&quot;</code></li><li><strong>缩写</strong>：<code>@</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>核心用法</strong></p><ul><li><strong>直接绑定方法名</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleMouseOver&quot;</span>&gt;</span>鼠标移动<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>直接执行内联表达式</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>增加计数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>调用方法并传递参数</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 如果不传入参数,会默认传入event,函数中接收event --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSubmit&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 传入参数,处理函数中接收参数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSubmit(args)&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 传入参数,函数中可以接收参数,也可手动使用$event传event参数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSubmit(args, $event)&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>修饰符</strong></p><p>修饰符是以 <code>.</code> 开头的后缀，用于控制事件行为。</p><p><strong>1. 事件修饰符</strong></p><ul><li><code>.stop</code>：阻止事件冒泡</li><li><code>.prevent</code>：阻止默认行为</li><li><code>.capture</code>：使用捕获模式触发事件</li><li><code>.self</code>：仅当事件从元素自身触发时执行</li><li><code>.once</code>：事件只触发一次</li><li><code>.passive</code>：提升滚动性能（适用于 <code>touch</code> 事件）</li></ul><p><strong>2. 按键&#x2F;鼠标修饰符</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- Enter 键 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.esc</span>=<span class="hljs-string">&quot;cancel&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Esc 键 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.space</span>=<span class="hljs-string">&quot;jump&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 空格键 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.left</span>=<span class="hljs-string">&quot;leftClick&quot;</span>&gt;</span>左键<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.right</span>=<span class="hljs-string">&quot;rightClick&quot;</span>&gt;</span>右键<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.middle</span>=<span class="hljs-string">&quot;middleClick&quot;</span>&gt;</span>中键<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Ctrl + Click --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;handleCtrlClick&quot;</span>&gt;</span>Ctrl + 点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Alt + Enter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.alt.enter</span>=<span class="hljs-string">&quot;handleAltEnter&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h5 id="Gc6lM">条件渲染</h5><p><strong>v-if</strong></p><ul><li><strong>功能</strong>：根据条件<strong>销毁&#x2F;重建</strong> DOM 元素（惰性渲染）</li><li><strong>特点</strong>：<ul><li>初始渲染成本低（条件为 <code>false</code> 时不会渲染）</li><li>切换成本高（涉及 DOM 的销毁和重建）</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span>&gt;</span>条件为真时渲染<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>v-else</strong></p><ul><li><strong>功能</strong>：必须与 <code>v-if</code> 或 <code>v-else-if</code> 搭配使用，表示其他情况</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isRain&quot;</span>&gt;</span>带伞出门<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>不用带伞<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>v-else-if</strong></p><ul><li><strong>功能</strong>：链式条件判断</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;score &gt;= 90&quot;</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;score &gt;= 60&quot;</span>&gt;</span>及格<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>不及格<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>template元素</strong></p><p><code>template</code> 元素本身不会被渲染到 DOM 中，它主要作为一个包装元素，用于容纳多个子元素或指令，起到分组的作用，方便在模板中组织代码。</p><hr><p><strong>v-show</strong></p><ul><li><strong>功能</strong>：通过 CSS <code>display: none</code> 控制显示&#x2F;隐藏（元素始终存在）</li><li><strong>特点</strong>：<ul><li>初始渲染成本高（无论条件如何都会渲染）</li><li>切换成本低（仅修改 CSS 属性）</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span>显示/隐藏内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>v-if vs v-show</strong></p><table><thead><tr><th><strong>特性</strong></th><th><code>**v-if**</code></th><th><code>**v-show**</code></th></tr></thead><tbody><tr><td><strong>DOM 操作</strong></td><td>销毁&#x2F;重建元素</td><td>切换 <code>display: none</code></td></tr><tr><td><strong>初始渲染成本</strong></td><td>低（条件为 <code>false</code>不渲染）</td><td>高（总是渲染）</td></tr><tr><td><strong>切换性能</strong></td><td>高开销（适合条件不频繁变化）</td><td>低开销（适合频繁切换）</td></tr><tr><td><strong>结合</strong>** **<code>**&lt;template&gt;**</code></td><td>支持（多元素分组）</td><td>不支持</td></tr><tr><td><strong>生命周期</strong></td><td>触发组件的 <code>created</code>&#x2F;<code>destroyed</code></td><td>不触发</td></tr></tbody></table><h5 id="AJjC3">v-for</h5><p>在 Vue 中，<code>v-for</code> 是用于<strong>循环渲染列表</strong>的核心指令，支持遍历数组、对象、数字范围，并动态生成 DOM 元素或组件。</p><hr><p><strong>基本语法</strong></p><ul><li><strong>语法</strong>：<code>v-for=&quot;(item, index) in items&quot;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>  &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>语法</strong>：<code>v-for=&quot;(value, key, index) in object&quot;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, key, index) in userInfo&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span><br>  &#123;&#123; index &#125;&#125;-&#123;&#123; key &#125;&#125;-&#123;&#123; value &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>数组更新检测</strong></p><ul><li><strong>响应式方法</strong>：以下方法会触发视图更新：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br><span class="hljs-comment">&lt;!-- 本质上要修改原数组,map,filter等方法生成新数组则不行 --&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>key</strong></p><ul><li><strong>必要性</strong>：为每个元素绑定唯一标识，帮助 Vue 高效更新 DOM。</li><li><strong>正确用法</strong>：使用稳定唯一值（如 <code>id</code>），避免索引或随机数。</li><li><strong>官方解释</strong><ul><li>key属性主要用在Vue的<strong>虚拟DOM</strong>算法，在<strong>新旧nodes</strong>对比时辨识<strong>VNodes</strong></li><li>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地<strong>修改&#x2F;复用相同类型元素的算法</strong></li><li>而使用key时，它会基于key的<strong>变化重新排列元素顺序</strong>，并且会<strong>移除&#x2F;销毁key不存在的元素</strong></li></ul></li><li><strong>原理</strong><ul><li>Vue 的虚拟 DOM 是一种轻量级的 JavaScript 对象，它是真实 DOM 的抽象表示。在更新 DOM 时，Vue 会通过比较新旧虚拟 DOM 的差异( VNode与真实Node的区别 )，只更新需要更新的真实 DOM 节点，以提高性能。<code>key</code> 就是用来帮助 Vue 识别哪些元素发生了变化，从而更高效地进行 DOM 更新。<ul><li>虚拟 DOM 可以做跨平台</li><li>虚拟 DOM 做Diff算法</li></ul></li><li><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#virtual-dom">https://cn.vuejs.org/guide/extras/rendering-mechanism.html#virtual-dom</a></li></ul></li></ul><hr><p><strong>Diff算法-Vue</strong></p><p>Diff 算法是一种用于比较两个虚拟 DOM 树差异的算法，它的目标是找出最少的 DOM 操作来更新真实 DOM，从而提高性能。</p><p>Vue 的 Diff 算法采用了<strong>双指针法和同层比较</strong>的策略。它只比较同一层级的节点，不会跨层级比较，这样可以将时间复杂度从指数级降低到线性级（(O(n))）。Diff 算法会对新旧虚拟 DOM 树的<strong>同一层级节点</strong>进行比较，根据节点的不同情况进行相应的处理，如创建新节点、更新节点属性、移动节点或删除节点等。</p><p>在比较同一层级的节点时，会根据节点的 <code>key</code>、标签名、属性等信息进行判断</p><ul><li>如果新旧节点的标签名不同，直接用新节点<strong>替换</strong>旧节点</li><li>如果新旧节点的标签名相同，但 <code>key</code> 不同，也会用新节点<strong>替换</strong>旧节点</li><li>如果新旧节点的标签名和 <code>key</code> 都相同，则会<strong>复用旧节点</strong>，只更新节点的属性和内容。</li></ul><p>当比较列表节点时，会使用 <code>key</code> 来提高比较效率。<code>key</code> 可以帮助 Vue 准确地识别哪些节点是新增的、哪些节点是需要移除的、哪些节点只是位置发生了变化。</p><h5 id="dfqQ0">v-model</h5><p>在 Vue 中，<code>**v-model**</code> 是用于实现<strong>表单元素</strong>和<strong>自定义组件</strong>的双向数据绑定的核心指令。</p><hr><p><strong>基本使用</strong></p><ul><li><strong>文本输入（</strong><code>**&lt;input&gt;**</code>** 和 **<code>**&lt;textarea&gt;**</code><strong>）</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//v-model双向绑定</span><br>&lt;input v-model=<span class="hljs-string">&quot;message&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>输入的内容：&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><br><span class="hljs-comment">//等价于:value(v-bind:value)和@input(v-on:input)的写法(手动实现双向绑定)</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;inputChange&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>输入的内容：&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">inputChange(event) &#123;</span><br><span class="language-xml">this.message = event.target.value</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>复选框 ( 单选 )</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">//isChecked 为布尔值<br>&lt;input v-model=&quot;isChecked&quot; type=&quot;checkbox&quot;&gt;<br>&lt;span&gt;&#123;&#123; isChecked ? &#x27;选中&#x27; : &#x27;未选中&#x27; &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>复选框 ( 多选 )</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">// checkedList为数组<br>&lt;input type=&quot;checkbox&quot; value=&quot;A&quot; v-model=&quot;checkedList&quot;&gt;<br>&lt;input type=&quot;checkbox&quot; value=&quot;B&quot; v-model=&quot;checkedList&quot;&gt;<br>&lt;span&gt;选中项：&#123;&#123; checkedList &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>单选按钮（ Radio ）</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>性别：&#123;&#123; gender &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>下拉框 ( Select )</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span>选项A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>&gt;</span>选项B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>选中项：&#123;&#123; selected &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p><strong>修饰符</strong></p><ul><li><code>.**lazy**</code><ul><li>将 <code>input</code> 事件改为 <code>change</code> 事件（失焦后更新）</li></ul></li><li><code>**.number**</code><ul><li>将输入值转为数字</li></ul></li><li><code>**.trim**</code><ul><li>自动去除首尾空格</li></ul></li></ul><hr><p><strong>自定义组件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 自定义组件：CustomInput.vue --&gt;<br>&lt;template&gt;<br>  &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: [&#x27;modelValue&#x27;],<br>  emits: [&#x27;update:modelValue&#x27;]<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;!-- 使用自定义组件 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;CustomInput v-model=&quot;customInputValue&quot;&gt;&lt;/CustomInput&gt;<br>    &lt;!-- 等价于 --&gt;<br>    &lt;CustomInput :modelValue=&quot;customInputValue&quot; @update:modelValue=&quot;customInputValue=$event&quot;&gt;&lt;/CustomInput&gt;<br>    &lt;p&gt;自定义组件输入的值是：&#123;&#123; customInputValue &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import CustomInput from &#x27;./CustomInput.vue&#x27;;<br><br>export default &#123;<br>  components: &#123;<br>    CustomInput<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      customInputValue: &#x27;&#x27;<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>在自定义组件中，通过 <code>props</code> 接收 <code>modelValue</code> 属性，通过 <code>$emit(&#39;update:modelValue&#39;, ...)</code> 触发 <code>update:modelValue</code> 事件来更新父组件中的值。</li><li>在父组件中，使用 <code>v-model</code> 绑定自定义组件，实际上是将 <code>customInputValue</code> 传递给子组件的 <code>modelValue</code> 属性，并监听子组件的 <code>update:modelValue</code> 事件。</li></ul><h3 id="JKQ3q">组件化开发</h3><h4 id="aSmqm">组件化</h4><p>在 Vue 中，<strong>组件化</strong>是构建复杂应用的核心思想，通过将 UI 拆分为独立、可复用的代码单元，提升代码可维护性和复用性。</p><hr><p>组件的注册分为<strong>全局注册</strong>和<strong>局部注册</strong></p><ul><li><strong>全局注册</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; createApp &#125; from &#x27;vue&#x27;;<br>import App from &#x27;./App.vue&#x27;;<br>import MyComponent from &#x27;./MyComponent.vue&#x27;;<br><br>  const app = createApp(App);<br>  app.component(&#x27;my-component&#x27;, MyComponent);<br><br>  app.mount(&#x27;#app&#x27;);<br></code></pre></td></tr></table></figure><ul><li><strong>局部注册</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">import MyComponent from &#x27;./MyComponent.vue&#x27;;<br>export default &#123;<br>  components: &#123; <br>  &quot;my-component&quot;:MyComponent <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>组件命名</strong></p><ul><li><strong>kebab-case (短横线分隔符)</strong></li><li><strong>pascalCase (驼峰标识符)</strong></li></ul><hr><h4 id="T7vt7">Vue-CLI</h4><p>Vue 脚手架是快速搭建 Vue 项目的工具，它可以帮助开发者快速创建一个具有基本项目结构和配置的 Vue 项目，提高开发效率。</p><p><strong>安装Vue-CLI</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm install -g @vue/cli<br># 或者使用 yarn 安装<br>yarn global add @vue/cli<br># 查看版本<br>vue --version<br></code></pre></td></tr></table></figure><hr><p><strong>创建Vue项目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">vue create my-vue-project<br></code></pre></td></tr></table></figure><p>执行上述命令后，会出现一个交互式界面，让你选择项目的预设配置：</p><ul><li>**Default ([Vue 3] babel, eslint)**：默认预设，使用 Vue 3 并包含 Babel 和 ESLint 配置。</li><li>**Default ([Vue 2] babel, eslint)**：使用 Vue 2 的默认预设。</li><li><strong>Manually select features</strong>：手动选择项目特性，如 Babel、TypeScript、Router、Vuex 等。</li></ul><p><strong>CLI生成的配置文件</strong></p><ul><li>browserslistrc浏览器适配</li><li>.gitignore配置git忽略文件</li><li>babel.conig.jsbabel相关配置</li><li>jsconfig.js辅助编辑器提供提示</li><li>package.json包管理工具npm生成 管理项目元数据、依赖管理、脚本定义</li><li>package-lock.json辅助package.json 锁定依赖包的版本</li><li>README.md说明</li><li>vue.config.js项目隐藏了webpack.config.js ,可以在vue.config.js进行配置,提供了configureWebpack, 最后会进行合并webpack配置文件</li></ul><hr><p><strong>jsconfig</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;<br>  &quot;compilerOptions&quot;: &#123;<br>    &quot;target&quot;: &quot;es5&quot;,<br>    &quot;module&quot;: &quot;esnext&quot;,<br>    &quot;baseUrl&quot;: &quot;./&quot;,<br>    &quot;moduleResolution&quot;: &quot;node&quot;,<br>    &quot;paths&quot;: &#123;<br>      &quot;@/*&quot;: [<br>        &quot;src/*&quot;<br>      ]<br>    &#125;,<br>    &quot;lib&quot;: [<br>      &quot;esnext&quot;,<br>      &quot;dom&quot;,<br>      &quot;dom.iterable&quot;,<br>      &quot;scripthost&quot;<br>    ]<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>jsconfig.js</code> 可以帮助编辑器更好地理解项目结构和 JavaScript 代码，从而提供更智能的代码提示、导航和错误检查等功能</p><p>通过 <code>target</code> 字段，你可以指定项目所使用的 ECMAScript 版本，这有助于编辑器根据指定的版本提供更准确的代码提示和错误检查。</p><p><code>**baseUrl**</code>：指定解析非相对模块名的基础目录。</p><p><code>**paths**</code>：一个对象，用于定义模块路径的别名映射</p><p><code>**moduleResolution**</code>：指定文件查找使用 node 查找规则</p><p><code>lib</code> 配置项用于指定要包含在 JavaScript 项目编译环境中的库文件，也就是告诉 VS Code 编辑器在进行代码分析、智能提示和类型检查时，要考虑哪些 JavaScript 内置对象和 API 的类型定义。</p><hr><p><strong>浏览器内模板编译注意事项</strong></p><p>当以无构建步骤方式使用 Vue 时，组件模板要么是写在页面的 HTML 中，要么是内联的 JavaScript 字符串。在这些场景中，为了执行动态模板编译，Vue 需要将模板编译器运行在浏览器中。相对的，如果我们使用了构建步骤，由于提前编译了模板，那么就无须再在浏览器中运行了。为了减小打包出的客户端代码体积，Vue 提供了<a href="https://unpkg.com/browse/vue@3/dist/">多种格式的“构建文件”</a>以适配不同场景下的优化需求。</p><ul><li>前缀为 <code>vue.runtime.*</code> 的文件是<strong>只包含运行时的版本</strong>：不包含编译器，当使用这个版本时，所有的模板都必须由构建步骤预先编译。</li><li>名称中不包含 <code>.runtime</code> 的文件则是<strong>完全版</strong>：即包含了编译器，并支持在浏览器中直接编译模板。然而，体积也会因此增长大约 14kb。</li></ul><p>默认的工具链中都会使用仅含运行时的版本，因为所有单文件组件中的模板都已经被预编译了。如果因为某些原因，在有构建步骤时，你仍需要浏览器内的模板编译，你可以更改构建工具配置，将 <code>vue</code> 改为相应的版本 <code>vue/dist/vue.esm-bundler.js</code>。<br>     简单来说使用vue文件,vue-loader会预先进行编译compile,所以可以引入更轻量的vue,如果使用对象形式,那么就需要使用<code>vue/dist/vue.esm-bundler.js</code>里面的compile进行编译vue文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">const App = &#123;<br>    template: `&lt;h1&gt;hello&lt;/h1&gt;`,<br>    data() &#123;<br>        return &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>scoped</strong></p><p>vue文件中的<code>scoped</code> 可以让样式只作用于当前组件，实现样式的隔离，避免不同组件之间的样式相互影响。</p><p>在编译模板时，Vue 会为组件的每个 DOM 节点添加一个唯一的属性，例如 <code>data-v-xxxxxx</code>，其中 <code>xxxxxx</code> 是一个唯一的标识符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;example&quot; data-v-123456&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>在编译 CSS 时，Vue 会为每个 CSS 选择器添加对应的属性选择器，以确保样式只应用到具有该属性的节点上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">.example[data-v-123456] &#123;<br>  color: red;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>vite创建vue</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">#默认安装vue-create,使用vue-create初始化vue项目<br>npm create vue@latest<br>#使用vite初始化项目,指定为vue模板<br>npm create vite@latest my-vue-app -- --template vue<br></code></pre></td></tr></table></figure><ul><li><code>my-vue-project</code> 是你要创建的项目名称，你可以根据需要进行修改。</li><li><code>--template vue</code> 表示使用 Vue 模板来创建项目。如果你想创建 Vue 3 + TypeScript 项目，可以使用 <code>--template vue-ts</code>。</li></ul><h4 id="aqslu">组件通信</h4><h5 id="An1C6">父子组件通信</h5><p>**父组件向子组件通信：通过 **<code>**props**</code></p><p><code>props</code> 是 Vue 中用于父组件向子组件传递数据的方式。子组件通过定义 <code>props</code> 来接收父组件传递的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;vue+vite&lt;/div&gt;<br>  //动态传入<br>  &lt;show-info :name=&quot;Myname&quot; :age=&quot;18&quot; :address=&quot;&#x27;河南&#x27;&quot; /&gt;<br>  //传入固定值<br>  &lt;!-- &lt;show-info name=&quot;李卓&quot; age=18 address=&quot;China&quot; /&gt; --&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ShowInfo from &#x27;./components/showInfo.vue&#x27;;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      Myname:&#x27;MirZ&#x27;<br>    &#125;<br>  &#125;,<br>  components: &#123;<br>    ShowInfo<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;infoContainer&quot;&gt;<br>        &lt;h3&gt;name: &#123;&#123; name &#125;&#125;&lt;/h3&gt;<br>        &lt;h3&gt;age: &#123;&#123; age &#125;&#125;&lt;/h3&gt;<br>        &lt;h3&gt;address: &#123;&#123; address &#125;&#125;&lt;/h3&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>    data() &#123;<br>        return &#123;<br><br>        &#125;<br>    &#125;,<br>    // 可以使用数组写法<br>    // props: [&quot;name&quot;, &quot;age&quot;, &quot;address&quot;]<br><br>    //可以使用对象写法<br>    props: &#123;<br>        name: &#123;<br>            type: String,<br>            default: &quot;name&quot;<br>        &#125;,<br>        age: &#123;<br>            type: Number,<br>            default: 0<br>        &#125;,<br>        address: &#123;<br>            type: String,<br>            default: &quot;China&quot;<br>        &#125;,<br>      friend: &#123;<br>            //如果类型是对象类型,默认值要是函数去返回对象<br>            type: Object,<br>            default() &#123;<br>                return &#123; name: &#x27;李卓&#x27;, age: &#x27;3&#x27; &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li>父组件使用 <code>v-bind</code>（缩写为 <code>:</code>）将 数据 传递给子组件的  <code>prop</code>。</li><li>子组件使用  <code>props</code> 接收传递的数据</li></ul><p>:::tips<br><strong>非Prop的Attribute (了解)</strong></p><ul><li>当我们传递给一个组件某个属性，但是该属性并没有定义对应的props或者emits时，就称之为 非Prop的Attribute</li><li>常见的包括class、style、id属性等</li><li>当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中</li></ul><p>如果我们不希望组件的根元素继承attribute，可以在组件中设置inheritAttrs: false</p><ul><li>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素;</li><li>我们可以通过 $attrs来访问所有的 非props的attribute</li><li>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动指定要绑定到哪一个属性上</li></ul><p>:::</p><hr><p><strong>子组件向父组件通信：通过自定义事件</strong></p><p>子组件可以通过触发自定义事件向父组件发送数据，父组件监听这些事件并处理数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &#123;&#123; count &#125;&#125;<br>    &lt;!-- 使用v-on绑定子组件的自定义事件与父组件要触发的事件函数 --&gt;<br>    &lt;ShowInfo v-on:add=&quot;addClick&quot; @remove=&quot;removeClick&quot;/&gt;<br>  &lt;/div&gt;<br><br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ShowInfo from &#x27;./components/showInfo.vue&#x27;;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count:10<br>    &#125;<br>  &#125;,<br>  components: &#123;<br>    ShowInfo<br>  &#125;,<br>  methods: &#123;<br>    addClick(num) &#123;<br>      this.count=this.count+num<br>    &#125;,<br>    removeClick(num) &#123;<br>      this.count=this.count-num<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;infoContainer&quot;&gt;<br>       &lt;button @click=&quot;add(1)&quot;&gt;+1&lt;/button&gt;<br>       &lt;button @click=&quot;add(5)&quot;&gt;+5&lt;/button&gt;<br>       &lt;button @click=&quot;remove(1)&quot;&gt;-1&lt;/button&gt;<br>       &lt;button @click=&quot;remove(5)&quot;&gt;-5&lt;/button&gt;<br><br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>    data() &#123;<br>        return &#123;<br>        &#125;<br>    &#125;,<br>  //收集自定义事件,方便阅读,辅助编写  (可省略)<br>  emits:[&quot;add&quot;,&quot;remove&quot;],<br>    methods: &#123;<br>        add(num) &#123;<br>            // 自定义事件<br>            this.$emit(&quot;add&quot;,num)<br>        &#125;,<br>        remove(num) &#123;<br>            this.$emit(&quot;remove&quot;,num)<br>        &#125;<br>    &#125;<br>&#125;<br><br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><ul><li>子组件通过 <code>emits</code> 方法触发 自定义 事件，并传递数据。</li><li>父组件使用 <code>v-on</code>（缩写为 <code>@</code>）监听 子组件的自定义 事件，并处理接收到的数据。</li></ul><h5 id="J7oAc">插槽</h5><p>插槽（Slot）是一种非常强大且实用的特性，它允许你在组件中灵活地插入内容，实现组件的复用和定制。</p><hr><p><strong>默认插槽 (匿名插槽)</strong></p><p>默认插槽是最基本的插槽类型，当父组件向子组件传递内容时，如果没有指定插槽名称，内容将被插入到默认插槽中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--子组件  --&gt;<br>&lt;template&gt;<br>    &lt;div class=&quot;infoContainer&quot;&gt;<br>        &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;<br>        &lt;slot&gt;当未传入内容时&lt;/slot&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;!--父组件  --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;ShowInfo&gt;<br>      &lt;button&gt;内容1-按钮&lt;/button&gt;<br>    &lt;/ShowInfo&gt;<br>    &lt;ShowInfo&gt;<br>      &lt;h3&gt;内容2-h3&lt;/h3&gt;<br>    &lt;/ShowInfo&gt;<br>    &lt;ShowInfo&gt;&lt;/ShowInfo&gt;<br>  &lt;/div&gt;<br><br></code></pre></td></tr></table></figure><hr><p><strong>具名插槽</strong></p><p>具名插槽允许你在一个组件中定义多个插槽，并通过名称来区分它们。父组件可以根据插槽名称将内容插入到指定的插槽中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--子组件  --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;layout&quot;&gt;<br>    &lt;header&gt;<br>      &lt;slot name=&quot;header&quot;&gt;默认header&lt;/slot&gt;<br>    &lt;/header&gt;<br>    &lt;main&gt;<br>      &lt;slot name=&quot;main&quot;&gt;默认main&lt;/slot&gt; <br>    &lt;/main&gt;<br>    &lt;footer&gt;<br>      &lt;slot name=&quot;footer&quot;&gt;footer&lt;/slot&gt;<br>    &lt;/footer&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;!--父组件  --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>   &lt;showInfo&gt;<br>    &lt;template v-slot:header&gt;<br>      MyHeader<br>    &lt;/template&gt;<br>    &lt;!-- &lt;template v-slot:main&gt;<br>      MyMain<br>    &lt;/template&gt; --&gt;<br>    &lt;template v-slot:footer&gt;<br>      MyFooter<br>    &lt;/template&gt;<br>   &lt;/showInfo&gt;<br>  &lt;/div&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>默认插槽的<code>name</code> 属性为 <code>default</code> </li><li>在子组件中，通过 <code>name</code> 属性为 <code>&lt;slot&gt;</code> 标签指定名称，定义了具名插槽。</li><li>在父组件中，使用 <code>&lt;template&gt;</code> 标签并通过 <code>#</code> 语法（<code>v-slot</code> 的缩写）指定插槽名称，将内容插入到对应的插槽中。未指定名称的内容将被插入到默认插槽中。</li></ul><hr><p><strong>动态插槽名</strong></p><p>动态插槽名，允许你在运行时动态决定要使用的插槽名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;MyComponent&gt;<br>      &lt;template v-slot:[dynamicSlotName]&gt;<br>        &lt;p&gt;这是动态插槽的内容&lt;/p&gt;<br>      &lt;/template&gt;<br>    &lt;/MyComponent&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import MyComponent from &#x27;./MyComponent.vue&#x27;;<br><br>export default &#123;<br>  components: &#123;<br>    MyComponent<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      dynamicSlotName: &#x27;header&#x27;<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>在父组件中，使用 <code>v-slot:[dynamicSlotName]</code> 语法，<code>dynamicSlotName</code> 是一个动态变量，它的值决定了要使用的插槽名称。</li></ul><hr><p><strong>作用域插槽</strong></p><p>作用域插槽允许子组件向父组件传递数据，父组件可以在插入内容时使用这些数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 子组件：MyComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;slot :items=&quot;items&quot;&gt;<br>      &lt;!-- 后备内容 --&gt;<br>      &lt;ul&gt;<br>        &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;<br>      &lt;/ul&gt;<br>    &lt;/slot&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      return &#123;<br>        items: [<br>          &#123; id: 1, name: &#x27;Item 1&#x27; &#125;,<br>          &#123; id: 2, name: &#x27;Item 2&#x27; &#125;,<br>          &#123; id: 3, name: &#x27;Item 3&#x27; &#125;<br>        ]<br>      &#125;;<br>    &#125;<br>  &#125;;<br>&lt;/script&gt;<br><br>&lt;!-- 父组件 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;MyComponent&gt;<br>      &lt;!-- &lt;template #default=&quot;props&quot;&gt;,所有传递的数据保存在props对象中 --&gt;<br>      &lt;template #default=&quot;&#123; items &#125;&quot;&gt;<br>        &lt;ol&gt;<br>          &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;<br>        &lt;/ol&gt;<br>      &lt;/template&gt;<br>    &lt;/MyComponent&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>  &lt;script&gt;<br>  import MyComponent from &#x27;./MyComponent.vue&#x27;;<br><br>  export default &#123;<br>  components: &#123;<br>  MyComponent<br>  &#125;<br>  &#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>在子组件中，通过 <code>:</code> 语法将 <code>items</code> 数据绑定到 <code>&lt;slot&gt;</code> 标签上，向父组件传递数据。</li><li>在父组件中，使用 <code>&lt;template&gt;</code> 标签并通过 <code>#default</code> 指定默认插槽，同时使用解构赋值接收子组件传递的数据，然后在插入内容时使用这些数据。</li></ul><h5 id="elZx1">非父子组件通信</h5><p><strong>provide和inject</strong></p><ul><li><strong>适用场景</strong>：祖先向后代传递数据（非响应式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 祖先组件<br>export default &#123;<br>  provide() &#123;<br>    return &#123; theme: this.theme &#125;<br>  &#125;<br>&#125;<br><br>// 后代组件<br>export default &#123;<br>  inject: [&#x27;theme&#x27;]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 祖先组件<br>export default &#123;<br> provide() &#123;<br>    return &#123;<br>      message: computed(() =&gt; &#123;<br>        return this.message<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br>// 后代组件,被computed计算过的属性被包装成一个ref对象,使用需要使用message.value<br>export default &#123;<br>  inject: [&#x27;message&#x27;]<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>事件总线 (EventBus)</strong></p><p>Vue3从实例中移除了$on、$off 和 $once 方法,所以我们如果希望继续使用全局事件总线，要通过第三方的库: mitt 或者tiny-emitter 或者自定义事件总线</p><p><a href="https://www.yuque.com/wudibawanglong-gbppc/ipvaxi/bo9vbqnf3cdqm9a8#Duq4L">Js高级(部分)–事件总线</a></p><hr><h4 id="IroMz">生命周期</h4><p>Vue 组件的生命周期是理解组件行为的关键，它描述了组件从创建到销毁的整个过程。每个生命周期阶段都提供了特定的钩子函数（Hooks），允许开发者在不同时机执行自定义逻辑。</p><hr><p><strong>Vue 生命周期流程</strong></p><ol><li><strong>初始化阶段</strong><br><code>beforeCreate</code> → <code>created</code></li><li><strong>挂载阶段</strong><br><code>beforeMount</code> → <code>mounted</code></li><li><strong>更新阶段</strong><br><code>beforeUpdate</code> → <code>updated</code></li><li><strong>销毁阶段</strong><br><code>beforeDestroy</code> → <code>destroyed</code></li></ol><hr><p><strong>初始化阶段</strong></p><ul><li><code>**beforeCreate**</code><ul><li><strong>触发时机</strong>：实例初始化之后，数据观测（<code>data</code>）和事件配置（<code>methods</code>）之前。</li><li><strong>特点</strong>：<ul><li>无法访问 <code>data</code>、<code>computed</code>、<code>methods</code> 等属性。</li><li>常用于插件初始化（如 Vuex、Vue Router）。</li></ul></li></ul></li><li><code>**created**</code><ul><li><strong>触发时机</strong>：实例创建完成，数据观测和事件配置已初始化。</li><li><strong>特点</strong>：<ul><li>可以访问 <code>data</code>、<code>methods</code>，但 DOM 未生成（无法操作 DOM）。</li><li>适合发起异步请求、初始化数据。</li></ul></li></ul></li></ul><hr><p><strong>2. 挂载阶段</strong></p><ul><li><code>**beforeMount**</code><ul><li><strong>触发时机</strong>：模板编译完成，但尚未挂载到 DOM。</li><li><strong>特点</strong>：<ul><li>虚拟 DOM 已生成，但页面还未渲染。</li></ul></li></ul></li><li><code>**mounted**</code><ul><li><strong>触发时机</strong>：实例挂载到 DOM 后触发。</li><li><strong>特点</strong>：<ul><li>可以操作 DOM，适合初始化第三方库（如图表、地图）。</li><li>注意：子组件的 <code>mounted</code> 可能未完成，需用 <code>this.$nextTick</code> 确保全部渲染完成。</li></ul></li></ul></li></ul><hr><p><strong>3. 更新阶段</strong></p><ul><li><code>**beforeUpdate**</code><ul><li><strong>触发时机</strong>：数据变化导致虚拟 DOM 重新渲染前。</li><li><strong>特点</strong>：<ul><li>数据已更新，但 DOM 尚未重新渲染。</li><li>可在此处获取更新前的 DOM 状态。</li></ul></li></ul></li><li><code>**updated**</code><ul><li><strong>触发时机</strong>：虚拟 DOM 重新渲染并应用到 DOM 后。</li><li><strong>特点</strong>：<ul><li>避免在此钩子中修改数据，可能导致无限循环。</li><li>需要操作更新后的 DOM 时，建议使用 <code>this.$nextTick</code>。</li></ul></li></ul></li></ul><hr><p><strong>4. 销毁阶段</strong></p><ul><li><code>**beforeDestroy**</code><ul><li><strong>触发时机</strong>：实例销毁前。</li><li><strong>特点</strong>：<ul><li>组件仍完全可用。</li><li>适合清理定时器、解绑事件、取消网络请求等资源释放操作。</li></ul></li></ul></li><li><code>**destroyed**</code><ul><li><strong>触发时机</strong>：实例销毁后。</li><li><strong>特点</strong>：<ul><li>所有子实例和事件监听器已被移除。</li></ul></li></ul></li></ul><hr><p><strong>Vue 3 的变化</strong></p><p><strong>组合式 API 的钩子</strong></p><pre><code class="hljs">- 钩子名称前加 `on`，如 `onMounted`、`onUpdated`。- `beforeCreate` 和 `created` 被 `setup()` 替代。</code></pre><hr><h4 id="l0zN5">ref</h4><p>在 Vue 中，<code>ref</code> 提供了一种直接访问 DOM 元素或子组件实例的方式。<code>ref</code> 是一个特殊的属性，可以被添加到 DOM 元素或子组件上。当在模板中使用 <code>ref</code> 为元素或组件指定一个名称后，Vue 会在实例的 <code>$refs</code> 对象中创建一个对应的属性，该属性的值就是对应的 DOM 元素或子组件实例。</p><hr><ul><li><strong>操作 DOM 元素</strong>：当你需要直接对 DOM 元素执行一些操作，如获取元素的尺寸、滚动位置，或者调用元素的原生方法（如 <code>focus()</code>、<code>scrollIntoView()</code> 等）时，可以使用 <code>ref</code>。</li><li><strong>调用子组件方法</strong>：在父组件中，如果需要调用子组件的方法或访问子组件的数据，<code>ref</code> 可以帮助你实现这一需求。</li><li><strong>动态生成元素时</strong>，<code>this.$refs</code>（Vue 2）或引用变量（Vue 3）会返回一个数组。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;!-- 为 input 元素添加 ref 属性 --&gt;<br>    &lt;input ref=&quot;myInput&quot; type=&quot;text&quot; /&gt;<br>    &lt;button @click=&quot;focusInput&quot;&gt;聚焦输入框&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  methods: &#123;<br>    focusInput() &#123;<br>      // 通过 $refs 访问 input 元素并调用 focus 方法<br>      this.$refs.myInput.focus();<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- ChildComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &#x27;这是子组件的消息&#x27;<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    showMessage() &#123;<br>      alert(this.message);<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;!-- ParentComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;!-- 为子组件添加 ref 属性 --&gt;<br>    &lt;ChildComponent ref=&quot;childRef&quot; /&gt;<br>    &lt;button @click=&quot;callChildMethod&quot;&gt;调用子组件方法&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br><br>export default &#123;<br>  components: &#123;<br>    ChildComponent<br>  &#125;,<br>  methods: &#123;<br>    callChildMethod() &#123;<br>      // 通过 $refs 获取组件实例  this.$refs.childRef<br>      // 通过 $refs 访问子组件实例并调用其方法<br>      this.$refs.childRef.showMessage();<br>      // this.$refs.childRef.$el 子组件的元素<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div v-for=&quot;item in list&quot; :key=&quot;item.id&quot; ref=&quot;items&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;<br><br>const items = ref([]); // 存储所有 div 元素的引用<br><br>onMounted(() =&gt; &#123;<br>  console.log(items.value); // 所有 div 的 DOM 对象数组<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><ul><li>$parent获取父元素</li><li>$root获取根元素</li></ul><hr><h4 id="gOrxq">动态组件</h4><p>在 Vue 中，<strong>动态组件</strong> 允许根据数据的变化动态切换不同的组件，常用于实现标签页、步骤向导、条件渲染不同 UI 等场景。</p><hr><p><strong>基本用法</strong></p><ul><li>通过 <code>:is</code> 属性绑定组件名或组件选项对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;<br><br> data() &#123;<br>  return &#123;<br>    currentComponent: &#x27;ComponentA&#x27; // 可以是注册的组件名或导入的组件对象<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改 <code>currentComponent</code> 的值即可切换组件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;currentComponent = &#x27;ComponentA&#x27;&quot;&gt;显示 A&lt;/button&gt;<br>&lt;button @click=&quot;currentComponent = &#x27;ComponentB&#x27;&quot;&gt;显示 B&lt;/button&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>keep-alive</strong></p><p>在切换动态组件时，默认情况下，组件会被销毁并重新创建，这可能会导致一些状态丢失。为了避免这种情况，可以使用 <code>&lt;keep-alive&gt;</code> 组件来缓存动态组件。</p><ul><li><code>&lt;keep-alive&gt;</code> 是 Vue 提供的一个内置组件，用于缓存包裹在其中的动态组件。</li><li>当组件被 <code>&lt;keep-alive&gt;</code> 包裹时，切换组件时不会销毁组件实例，而是将其缓存起来，下次再显示时直接从缓存中取出，从而保留组件的状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive&gt;<br>  &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><ul><li><code>**include**</code>：只缓存指定组件（组件名或正则）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive :include=&quot;[&#x27;ComponentA&#x27;, /ComponentB/]&quot; :max=&quot;3&quot;&gt;<br>  &lt;component :is=&quot;currentComponent&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br>//组件名来自子组件导出时的name<br>  export default &#123;<br>   name:&#x27;ComponentA&#x27;<br>  data() &#123;<br>    return &#123;<br>      currentComponent: &#x27;ComponentA&#x27;<br>    &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>**exclude**</code>：排除指定组件</li><li><code>**max**</code>：最大缓存实例数（LRU 策略）</li></ul><hr><ul><li><strong>生命周期钩子</strong>：被 <code>&lt;keep-alive&gt;</code> 包裹的组件会有额外的生命周期钩子 <code>activated</code> 和 <code>deactivated</code>，分别在组件被激活和失活时触发。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    这是组件 A<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  activated() &#123;<br>    console.log(&#x27;组件 A 被激活&#x27;);<br>  &#125;,<br>  deactivated() &#123;<br>    console.log(&#x27;组件 A 失活&#x27;);<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><ul><li>结合 <code>defineAsyncComponent</code>（Vue 3）实现按需加载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">//使用异步组件加载会进行分包<br>const ComponentA = defineAsyncComponent(() =&gt; <br>  import(&#x27;./ComponentA.vue&#x27;)<br>);<br><br>  data() &#123;<br>  return &#123;<br>    currentComponent: ComponentA // 直接绑定组件对象<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;component :is=&quot;currentComponent&quot; v-if=&quot;isComponentLoaded&quot;&gt;&lt;/component&gt;<br>//确保异步组件加载完成后再渲染<br>data() &#123;<br>  return &#123;<br>    currentComponent: null,<br>    isComponentLoaded: false<br>  &#125;<br>&#125;,<br>async created() &#123;<br>  this.currentComponent = await import(&#x27;./AsyncComponent.vue&#x27;);<br>  this.isComponentLoaded = true;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="bZ7jd">组件绑定v-model</h4><p><strong>基本用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 自定义组件：CustomInput.vue --&gt;<br>&lt;template&gt;<br>  &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: [&#x27;modelValue&#x27;],<br>  emits: [&#x27;update:modelValue&#x27;]<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;!-- 使用自定义组件 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;CustomInput v-model=&quot;customInputValue&quot;&gt;&lt;/CustomInput&gt;<br>    &lt;!-- 等价于 --&gt;<br>    &lt;CustomInput :modelValue=&quot;customInputValue&quot; @update:modelValue=&quot;customInputValue=$event&quot;&gt;&lt;/CustomInput&gt;<br>    &lt;p&gt;自定义组件输入的值是：&#123;&#123; customInputValue &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import CustomInput from &#x27;./CustomInput.vue&#x27;;<br><br>export default &#123;<br>  components: &#123;<br>    CustomInput<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      customInputValue: &#x27;&#x27;<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>在自定义组件中，通过 <code>props</code> 接收 <code>modelValue</code> 属性，通过 <code>$emit(&#39;update:modelValue&#39;, ...)</code> 触发 <code>update:modelValue</code> 事件来更新父组件中的值。</li><li>在父组件中，使用 <code>v-model</code> 绑定自定义组件，实际上是将 <code>customInputValue</code> 传递给子组件的 <code>modelValue</code> 属性，并监听子组件的 <code>update:modelValue</code> 事件。</li></ul><hr><p><strong>自定义 <strong><code>**v-model**</code></strong> 的参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 子组件：CustomSelect.vue --&gt;<br>&lt;template&gt;<br>  &lt;select <br>    :value=&quot;selected&quot;<br>    @change=&quot;$emit(&#x27;update:selected&#x27;, $event.target.value)&quot;<br>  &gt;<br>    &lt;option value=&quot;A&quot;&gt;选项A&lt;/option&gt;<br>    &lt;option value=&quot;B&quot;&gt;选项B&lt;/option&gt;<br>  &lt;/select&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    selected: &#123;<br>      type: String,<br>      default: &#x27;A&#x27;<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;!-- 父组件使用自定义组件 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;!-- 使用自定义参数 `selected` --&gt;<br>    &lt;CustomSelect v-model:selected=&quot;parentOption&quot; /&gt;<br>    &lt;p&gt;父组件选项：&#123;&#123; parentOption &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="Fd01y">混入Mixin</h4><p>混入（mixin）提供了一种灵活的方式，来分发组件中的可复用功能。一个混入对象可以包含任意组件选项，例如 <code>data</code>、<code>methods</code>、<code>computed</code> 等。当一个组件使用混入对象时，混入对象的选项会被合并到组件本身的选项中。</p><hr><p><strong>全局混入</strong></p><p>全局混入会影响每一个之后创建的 Vue 实例。使用 <code>Vue.mixin()</code> 来全局注册混入对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">// main.js<br>import Vue from &#x27;vue&#x27;;<br>import App from &#x27;./App.vue&#x27;;<br><br>// 定义混入对象<br>const myMixin = &#123;<br>  created() &#123;<br>    console.log(&#x27;混入对象的 created 钩子被调用&#x27;);<br>  &#125;<br>&#125;;<br><br>// 全局注册混入<br>Vue.mixin(myMixin);<br><br>new Vue(&#123;<br>  render: h =&gt; h(App)<br>&#125;).$mount(&#x27;#app&#x27;);<br></code></pre></td></tr></table></figure><hr><p><strong>局部混入</strong></p><p>局部混入只会影响使用该混入对象的组件。在组件中使用 <code>mixins</code> 选项来引入混入对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>// 定义混入对象<br>const myMixin = &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &#x27;这是混入对象的数据&#x27;<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    showMessage() &#123;<br>      console.log(this.message);<br>    &#125;<br>  &#125;,<br>  created() &#123;<br>    this.showMessage();<br>  &#125;<br>&#125;;<br><br>export default &#123;<br>  // 局部引入混入对象<br>  mixins: [myMixin]<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>当组件和混入对象包含同名选项时，会根据选项类型进行不同的合并规则：</strong></p><ul><li>如果数据对象在组件和混入对象中都存在，它们会进行递归合并，并且组件的数据会覆盖混入对象的数据</li><li>同名的钩子函数会被合并成一个数组，因此都会被调用。混入对象的钩子函数会在组件自身钩子函数之前调用。</li><li>值为对象的选项，如 <code>methods</code>、<code>computed</code>、<code>watch</code> 等，会进行合并。如果键名冲突，组件的选项会覆盖混入对象的选项。</li></ul><h3 id="wXDB1">组合式 API (Composition API)</h3><p>Vue 3 引入了组合式 API（Composition API），它是一种新的组织和复用代码的方式，相较于选项式 API 提供了更灵活、更高效的代码组织方式。</p><p>组合式 API 允许你使用函数来组织逻辑，而不是像选项式 API 那样将逻辑分散在不同的选项（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等）中。主要通过 <code>setup</code> 函数来使用组合式 API，<code>setup</code> 函数在组件初始化时执行，在 <code>data</code> 和 <code>props</code> 被解析之后，<code>beforeCreate</code> 钩子之前调用。</p><h4 id="R6efM">setup函数</h4><p><code>**setup**</code>** 函数**</p><p><code>setup</code>函数是一个新的组件选项，它在组件初始化时，<code>props</code>解析之后，<code>data</code>和<code>computed</code>等选项之前执行。该函数接收两个参数：<code>props</code>和<code>context</code>，并且可以返回一个对象，对象中的属性和方法可以在模板中使用。</p><ul><li><strong>注意</strong>：<code>setup</code> 内无法访问 <code>this</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123;<br>  setup(props, context) &#123;<br>    // 逻辑代码<br>    return &#123; /* 暴露给模板的数据和方法 */ &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><code>props</code>是一个响应式对象，包含了父组件传递给子组件的所有属性。需要注意的是，不能使用 ES6 解构，因为解构会破坏<code>props</code>的响应式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    title: String<br>  &#125;,<br>  setup(props) &#123;<br>    // 直接使用props对象<br>    console.log(props.title);<br><br>    return &#123;&#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>context</code>是一个普通对象，包含了三个属性：<code>attrs</code>、<code>slots</code>和<code>emit</code>。</p><ul><li><code>attrs</code>：包含了所有未在<code>props</code>选项中声明的属性。</li><li><code>slots</code>：用于访问组件的插槽内容。</li><li><code>emit</code>：用于触发自定义事件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;handleClick&quot;&gt;Click me&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  setup(props, context) &#123;<br>    const handleClick = () =&gt; &#123;<br>      // 触发自定义事件<br>      context.emit(&#x27;custom-event&#x27;);<br>    &#125;;<br><br>    return &#123;<br>      handleClick<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>setup</code>函数可以返回一个对象，对象中的属性和方法可以在模板中直接使用。此外，<code>setup</code>函数还可以返回一个渲染函数，用于手动创建虚拟 DOM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- 此模板不会被使用，因为返回了渲染函数 --&gt;<br>  &lt;div&gt;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; h &#125; from &#x27;vue&#x27;;<br><br>export default &#123;<br>  setup() &#123;<br>    return () =&gt; h(&#x27;div&#x27;, &#x27;This is a render function&#x27;);<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><ul><li><code>**this**</code><strong>的使用</strong>：在<code>setup</code>函数中，<code>this</code>不会指向当前组件实例，因此不能使用<code>this</code>来访问组件的属性和方法。</li><li><strong>执行时机</strong>：<code>setup</code>函数在组件实例初始化之前执行，因此不能在<code>setup</code>函数中访问<code>data</code>、<code>computed</code>等选项。</li><li><strong>生命周期钩子</strong>：如果需要使用生命周期钩子，可以在<code>setup</code>函数中使用组合式 API 提供的生命周期函数，如<code>onMounted</code>、<code>onUpdated</code>等。</li></ul><h4 id="CGeL0">响应式数据</h4><h5 id="IuCiS">reactive 函数</h5><p><code>reactive</code> 函数用于创建一个响应式的对象或数组。它基于 ES6 的 Proxy 实现，能够深度监听对象属性的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;&#123;&#123; state.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import &#123; reactive &#125; from &#x27;vue&#x27;<br>export default &#123;<br>    setup() &#123;<br>        const state = reactive(&#123;<br>            count: 0<br>        &#125;);<br>        const increment = () =&gt; &#123;<br>            state.count++;<br>        &#125;;<br>        return &#123;<br>            state, increment<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>只能用于对象和数组</strong>：<code>reactive</code> 只能处理对象和数组，不能处理基本数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code> 等）。</li><li><strong>深层响应式</strong>：<code>reactive</code> 会递归地将对象的所有属性转换为响应式的，因此可以深度监听对象的变化。</li></ul><h5 id="GVtZc">ref 函数</h5><p><code>ref</code> 函数用于创建一个响应式的引用，它可以处理基本数据类型和对象。<code>ref</code> 创建的对象有一个 <code>.value</code> 属性，用于访问和修改其内部的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import &#123; reactive,ref &#125; from &#x27;vue&#x27;<br>export default &#123;<br>    setup() &#123;<br>        const count = ref(0);<br><br>        const increment = () =&gt; &#123;<br>            count.value++;<br>        &#125;;<br>        return &#123;<br>            count, increment<br>        &#125;<br>    &#125;<br><br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>在模板中自动解包</strong>：在模板中使用 <code>ref</code> 对象时，不需要手动访问 <code>.value</code> 属性，Vue 会自动解包。但在 JavaScript 代码中，需要使用 <code>.value</code> 来访问和修改其值。</li><li><strong>可以处理基本数据类型</strong>：<code>ref</code> 可以处理基本数据类型，这是它与 <code>reactive</code> 的主要区别之一。</li></ul><h5 id="O3GrY">响应式原理</h5><p>**Vue 3 使用 Proxy 替代 Vue 2 的 **<code>**Object.defineProperty**</code><strong>，解决了以下问题：</strong></p><ol><li><strong>对数组的深度监听</strong>：无需重写数组方法（如 <code>push</code>, <code>pop</code>）。</li><li><strong>动态新增&#x2F;删除属性</strong>：直接通过 <code>obj.newProp = value</code> 即可触发响应。</li><li><strong>更细粒度的依赖追踪</strong>：基于属性的依赖收集，而非整个对象。</li></ol><p><strong>响应式流程：</strong></p><ol><li><strong>依赖收集</strong>：当访问响应式数据时，触发 <code>getter</code>，将当前副作用（<code>effect</code>）收集为依赖。</li><li><strong>触发更新</strong>：当修改数据时，触发 <code>setter</code>，通知所有关联的副作用重新执行。</li></ol><h5 id="Ie8CF">toRef和 toRefs </h5><p><code>**t**oRef</code> 和 <code>toRefs</code> 用于从响应式对象中创建单独的响应式引用。</p><h6 id="u8mo9">`toRef`</h6><p><code>toRef</code> 用于创建一个指向响应式对象某个属性的单独引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; countRef &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; reactive, toRef &#125; from &#x27;vue&#x27;;<br><br>const state = reactive(&#123;<br>  count: 0<br>&#125;);<br><br>// 创建一个指向 state.count 的单独引用<br>const countRef = toRef(state, &#x27;count&#x27;);<br><br>const increment = () =&gt; &#123;<br>  countRef.value++;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用 <code>toRef</code> 函数创建了一个指向 <code>state.count</code> 的单独引用 <code>countRef</code>，修改 <code>countRef.value</code> 会同步更新 <code>state.count</code> 的值。</p><h6 id="Sa3Pq">`toRefs`</h6><p><code>toRefs</code> 用于将一个响应式对象的所有属性转换为单独的响应式引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; reactive, toRefs &#125; from &#x27;vue&#x27;;<br><br>const state = reactive(&#123;<br>  count: 0<br>&#125;);<br><br>// 将 state 的所有属性转换为单独的响应式引用<br>const &#123; count &#125; = toRefs(state);<br><br>const increment = () =&gt; &#123;<br>  count.value++;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用 <code>toRefs</code> 函数将 <code>state</code> 的所有属性转换为单独的响应式引用，然后通过解构赋值获取 <code>count</code> 引用，修改 <code>count.value</code> 会同步更新 <code>state.count</code> 的值。</p><h5 id="JxGDl">readonly函数</h5><p><code>readonly</code> 函数用于创建一个只读的响应式对象，对该对象的修改操作会被忽略，并且不会触发更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; readonlyState.count &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;tryUpdate&quot;&gt;Try Update&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; reactive, readonly &#125; from &#x27;vue&#x27;;<br><br>const state = reactive(&#123;<br>  count: 0<br>&#125;);<br><br>// 创建一个只读的响应式对象<br>const readonlyState = readonly(state);<br><br>const tryUpdate = () =&gt; &#123;<br>  readonlyState.count++; // 这行代码不会生效<br>  console.log(readonlyState.count); // 仍然输出 0<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用 <code>readonly</code> 函数创建了一个只读的响应式对象 <code>readonlyState</code>，尝试修改 <code>readonlyState.count</code> 的值不会生效。</p><h5 id="hXkOf">单项数据流</h5><p>单项数据流指的是数据的流动是单向的，数据的状态只能通过一个明确的方向进行传递和修改。在 Vue 应用中，数据通常是从父组件流向子组件，子组件不能直接修改从父组件接收到的数据，而是应该通过触发自定义事件通知父组件进行修改。</p><hr><p>Vue 的单项数据流基于组件化的架构实现。每个组件都有自己独立的状态（数据），父组件可以通过 <code>props</code> 向子组件传递数据。当父组件的数据发生变化时，传递给子组件的 <code>props</code> 也会相应更新，从而触发子组件的重新渲染。但子组件对 <code>props</code> 的修改不会直接影响父组件的数据，这样就保证了数据流动的单向性。</p><hr><ol><li><strong>避免数据混乱</strong><br>如果子组件可以直接修改父组件数据，多个子组件可能同时修改同一数据源，导致状态难以追踪。</li><li><strong>明确数据所有权</strong><br>数据由父组件管理，子组件仅负责展示或触发操作，职责清晰。</li><li><strong>提高可维护性</strong><br>数据流向单一，调试时更容易定位问题。</li></ol><hr><p>Vue 的单向数据流通过 <code>props</code> 和 <code>emit</code> 的强制约束，确保了组件之间的数据流动清晰可控。遵循这一原则可以大幅提升代码的可维护性，减少不可预知的副作用。在复杂场景中，合理使用状态管理工具（如 Pinia）是更好的选择。</p><h4 id="ufRV7">computed</h4><p>在 Vue 3 的组合式 API 中，<code>computed</code> 函数从 <code>vue</code> 包中导入，它接收一个 getter 函数作为参数，返回一个只读的响应式引用对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;First name: &#123;&#123; firstName &#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;Last name: &#123;&#123; lastName &#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;Full name: &#123;&#123; fullName &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, computed &#125; from &#x27;vue&#x27;;<br><br>export default &#123;<br>  setup() &#123;<br>    // 使用 ref 创建响应式数据<br>    const firstName = ref(&#x27;John&#x27;);<br>    const lastName = ref(&#x27;Doe&#x27;);<br><br>    // 使用 computed 创建计算属性<br>    const fullName = computed(() =&gt; &#123;<br>      return `$&#123;firstName.value&#125; $&#123;lastName.value&#125;`;<br>    &#125;);<br><br>    return &#123;<br>      firstName,<br>      lastName,<br>      fullName<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>fullName</code> 是一个计算属性，它依赖于 <code>firstName</code> 和 <code>lastName</code>。当 <code>firstName</code> 或 <code>lastName</code> 的值发生变化时，<code>fullName</code> 会自动更新。</p><hr><p><code>computed</code> 不仅可以只有一个 getter 函数，还可以传入一个包含 <code>get</code> 和 <code>set</code> 方法的对象，从而创建一个可读写的计算属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;First name: &#123;&#123; firstName &#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;Last name: &#123;&#123; lastName &#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;Full name: &#123;&#123; fullName &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;updateFullName&quot;&gt;Update Full Name&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, computed &#125; from &#x27;vue&#x27;;<br><br>export default &#123;<br>  setup() &#123;<br>    const firstName = ref(&#x27;John&#x27;);<br>    const lastName = ref(&#x27;Doe&#x27;);<br><br>    const fullName = computed(&#123;<br>      get() &#123;<br>        return `$&#123;firstName.value&#125; $&#123;lastName.value&#125;`;<br>      &#125;,<br>      set(newValue) &#123;<br>        const names = newValue.split(&#x27; &#x27;);<br>        firstName.value = names[0];<br>        lastName.value = names[1];<br>      &#125;<br>    &#125;);<br><br>    const updateFullName = () =&gt; &#123;<br>      fullName.value = &#x27;Jane Smith&#x27;;<br>    &#125;;<br><br>    return &#123;<br>      firstName,<br>      lastName,<br>      fullName,<br>      updateFullName<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当调用 <code>fullName.value = &#39;Jane Smith&#39;</code> 时，会触发 <code>set</code> 方法，更新 <code>firstName</code> 和 <code>lastName</code> 的值。</p><hr><h4 id="lT3LU">watch</h4><p><code>watch</code> 函数用于监听一个或多个响应式数据源的变化，并在数据变化时执行回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, watch &#125; from &#x27;vue&#x27;;<br><br>export default &#123;<br>  setup() &#123;<br>    const count = ref(0);<br>    const increment = () =&gt; &#123;<br>      count.value++;<br>    &#125;;<br><br>    // 监听 count 的变化<br>    watch(count, (newValue, oldValue) =&gt; &#123;<br>      console.log(`Count changed from $&#123;oldValue&#125; to $&#123;newValue&#125;`);<br>    &#125;);<br><br>    return &#123;<br>      count,<br>      increment<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>import &#123; ref, watch &#125; from &#x27;vue&#x27;;<br><br>export default &#123;<br>  setup() &#123;<br>    const firstName = ref(&#x27;John&#x27;);<br>    const lastName = ref(&#x27;Doe&#x27;);<br><br>    // 监听多个数据源<br>    watch([firstName, lastName], ([newFirstName, newLastName], [oldFirstName, oldLastName]) =&gt; &#123;<br>      console.log(`Name changed from $&#123;oldFirstName&#125; $&#123;oldLastName&#125; to $&#123;newFirstName&#125; $&#123;newLastName&#125;`);<br>    &#125;);<br><br>    return &#123;<br>      firstName,<br>      lastName<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li><code>immediate</code>：设置为 <code>true</code> 时，回调函数会在 <code>watch</code> 被创建时立即执行一次。</li><li><code>deep</code>：设置为 <code>true</code> 时，会深度监听对象内部属性的变化。</li></ul><hr><p><code>watchEffect</code> 会立即执行传入的回调函数，并响应式地追踪回调函数中使用的所有响应式数据源，当这些数据源中的任何一个发生变化时，回调函数会再次执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>      &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>      &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>    &lt;/div&gt;<br>  &lt;/template&gt;<br>  <br>  &lt;script&gt;<br>  import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;<br>  <br>  export default &#123;<br>    setup() &#123;<br>      const count = ref(0);<br>      const increment = () =&gt; &#123;<br>        count.value++;<br>      &#125;;<br>  <br>      // 立即执行回调函数，并追踪 count 的变化<br>      watchEffect(() =&gt; &#123;<br>        console.log(`Count is now $&#123;count.value&#125;`);<br>      &#125;);<br>  <br>      return &#123;<br>        count,<br>        increment<br>      &#125;;<br>    &#125;<br>  &#125;;<br>  &lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>watchEffect</code> 会返回一个停止监听的函数，调用该函数可以停止对响应式数据源的监听。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;<br><br>export default &#123;<br>  setup() &#123;<br>    const count = ref(0);<br><br>    const stop = watchEffect(() =&gt; &#123;<br>      console.log(`Count is now $&#123;count.value&#125;`);<br>    &#125;);<br><br>    // 停止监听<br>    stop();<br><br>    return &#123;<br>      count<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>**watch**</code>** 和 <strong><code>**watchEffect**</code></strong> 的区别**</p><ul><li><strong>触发时机</strong>：<code>watch</code> 默认不会立即执行回调函数，除非设置了 <code>immediate: true</code>；而 <code>watchEffect</code> 会立即执行回调函数。</li><li><strong>依赖追踪方式</strong>：<code>watch</code> 需要明确指定要监听的数据源；而 <code>watchEffect</code> 会自动追踪回调函数中使用的所有响应式数据源。</li><li><strong>回调参数</strong>：<code>watch</code> 的回调函数会接收新值和旧值作为参数；而 <code>watchEffect</code> 的回调函数不接收任何参数。</li></ul><h4 id="fytVv">setup语法糖</h4><p>Vue 3 的 <code>setup</code> 语法糖（即 <code>&lt;script setup&gt;</code>）是 Composition API 的一种更简洁的写法，它让组件的逻辑组织更加灵活，同时减少了模板代码。</p><ul><li>在单文件组件（SFC）中，通过 <code>&lt;script setup&gt;</code> 替代传统的 <code>&lt;script&gt;</code>，可以直接编写 Composition API 代码，无需显式导出 <code>setup</code> 函数。</li><li>使用 <code>ref</code> 或 <code>reactive</code> 声明响应式数据，无需手动返回。</li><li>导入的子组件无需在 <code>components</code> 选项中注册，直接在模板中使用。</li><li>使用 <code>defineProps</code> 和 <code>defineEmits</code> 定义属性和事件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>// 定义 Props<br>const props = defineProps(&#123;<br>  title: String,<br>  value: &#123; type: Number, default: 0 &#125;<br>&#125;);<br><br>// 定义 Emits<br>const emit = defineEmits([&#x27;update&#x27;]);<br><br>const handleClick = () =&gt; &#123;<br>  emit(&#x27;update&#x27;, props.value + 1);<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>defineExpose</code> 暴露子组件的属性或方法，供父组件通过 <code>ref</code> 调用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">//子组件<br>&lt;script setup&gt;<br>const childMethod = () =&gt; console.log(&#x27;Child method called&#x27;);<br>defineExpose(&#123; childMethod &#125;);<br>&lt;/script&gt;<br><br>//父组件<br>&lt;template&gt;<br>  &lt;ChildComponent ref=&quot;childRef&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const childRef = ref(null);<br><br>const callChildMethod = () =&gt; &#123;<br>  childRef.value.childMethod(); // 调用子组件方法<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="lovk5">Vue Router</h3><p>Vue Router是Vue.js官方的路由管理器，用于构建单页面应用（SPA）。它允许通过不同的URL映射到不同的组件，实现页面间的无刷新切换。</p><h4 id="oRs3B">基本使用</h4><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm install vue-router<br># 或者<br>yarn add vue-router<br></code></pre></td></tr></table></figure><ol><li>首先，你需要创建一个路由实例，并定义路由配置。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain">// src/router/index.js<br>import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;<br>import Home from &#x27;../views/Home.vue&#x27;;<br>import About from &#x27;../views/About.vue&#x27;;<br><br>const routes = [<br>  &#123;<br>    path: &#x27;/&#x27;,<br>    name: &#x27;Home&#x27;,<br>    component: Home<br>  &#125;,<br>  &#123;<br>    path: &#x27;/about&#x27;,<br>    name: &#x27;About&#x27;,<br>    component: About<br>  &#125;<br>];<br><br>const router = createRouter(&#123;<br>  history: createWebHistory(),<br>  routes<br>&#125;);<br><br>export default router;<br></code></pre></td></tr></table></figure><ol start="2"><li>在 <code>main.js</code> 中引入并使用路由实例</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">// src/main.js<br>import &#123; createApp &#125; from &#x27;vue&#x27;;<br>import App from &#x27;./App.vue&#x27;;<br>import router from &#x27;./router&#x27;;<br><br>const app = createApp(App);<br>app.use(router);<br>app.mount(&#x27;#app&#x27;);<br></code></pre></td></tr></table></figure><ol start="3"><li>在 <code>App.vue</code> 中使用 <code>&lt;router-link&gt;</code> 组件来创建导航链接，使用 <code>&lt;router-view&gt;</code> 组件来显示当前路由对应的组件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;<br>    &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="eKYHC">路由配置</h4><p><code>**path**</code></p><p>路由的路径，用于匹配 URL。可以使用动态路径参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  path: &#x27;/user/:id&#x27;,<br>  name: &#x27;User&#x27;,<br>  component: () =&gt; import(&#x27;../views/User.vue&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><code>**name**</code></p><p>路由的名称，用于通过名称来导航</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;router-link :to=&quot;&#123; name: &#x27;User&#x27;, params: &#123; id: 1 &#125; &#125;&quot;&gt;User 1&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><hr><p><code>**component**</code></p><p>路由对应的组件。可以使用静态导入或动态导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 静态导入<br>import User from &#x27;../views/User.vue&#x27;;<br>&#123;<br>  path: &#x27;/user&#x27;,<br>  component: User<br>&#125;<br><br>// 动态导入（懒加载）<br>&#123;<br>  path: &#x27;/user&#x27;,<br>  component: () =&gt; import(&#x27;../views/User.vue&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用路由懒加载 , 提升首屏加载速度，动态导入组件(动态导入,会进行分包处理)</p><hr><p><code>**redirect**</code></p><p>用于重定向路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  path: &#x27;/&#x27;,<br>  redirect: &#x27;/home&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><code>meta</code> </p><p>添加路由元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  path: &#x27;/dashboard&#x27;,<br>  component: Dashboard,<br>  meta: &#123; requiresAuth: true, title: &#x27;控制台&#x27; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>to属性</strong></p><p>路由跳转链接,可以是oath,也可以是对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;router-link :to=&quot;&#123; name:&#x27;User&#x27;, path:&#x27;/user&#x27;,params: &#123; id: 1 &#125; &#125;&quot;&gt;User 1&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>replace属性</strong></p><p>路由跳转链接配置,调用router.replace,不会记录历史,直接替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 调用router.replace,不会记录历史,直接替换(一般不使用)<br>&lt;router-link to=&quot;/home&quot; replace&gt;Home&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>active-class属性</strong></p><p>设置激活元素后应用的class，默认是router-link-active</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;router-link to=&quot;/&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt;<br>&lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>exact-active-class属性</strong></p><p>链接精准激活时，应用于渲染元素的 class，默认是router-link-exact-active</p><hr><p><strong>Not Found</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 输入notfound/notfound<br>//[&#x27;notfound&#x27;,&#x27;notfound&#x27;]<br>&#123; path: &#x27;/:pathMatch(.*)*&#x27;, name: &#x27;NotFound&#x27;, component: NotFound &#125;,<br>//  notfound/notfound<br>&#123; path: &#x27;/:pathMatch(.*)&#x27;, name: &#x27;NotFound&#x27;, component: NotFound &#125;,<br></code></pre></td></tr></table></figure><h4 id="hS90y">路由模式</h4><p><strong>Hash 模式（</strong><code>**createWebHashHistory**</code><strong>）</strong></p><p>Hash 模式使用 URL 的哈希值（<code>#</code> 后面的部分）来模拟一个完整的 URL，当哈希值发生变化时，浏览器不会向服务器发送请求，而是触发 <code>hashchange</code> 事件，Vue Router 监听这个事件并根据哈希值的变化来渲染相应的组件。</p><ul><li><strong>优点</strong>：兼容性好，支持所有浏览器，不需要服务器端进行任何配置。</li><li><strong>缺点</strong>：URL 中带有 <code>#</code> 符号，不够美观，而且在一些需要使用锚点功能的场景下可能会产生冲突。</li></ul><hr><p><strong>History 模式（</strong><code>**createWebHistory**</code><strong>）</strong></p><p>History 模式使用 HTML5 的 <code>History API</code> 来实现路由功能，通过 <code>pushState</code> 和 <code>replaceState</code> 方法改变浏览器的历史记录，从而实现无刷新的页面切换。当用户访问不同的 URL 时，浏览器会向服务器发送请求，因此需要服务器端进行相应的配置，以确保所有请求都能正确返回单页面应用的 HTML 文件。</p><ul><li><strong>优点</strong>：URL 更加美观，没有 <code>#</code> 符号，符合传统的 URL 格式。</li><li><strong>缺点</strong>：需要服务器端进行配置，否则在刷新页面时可能会出现 404 错误。</li></ul><hr><p><strong>3. Abstract 模式（</strong><code>**createMemoryHistory**</code><strong>）</strong></p><p>Abstract 模式不依赖于浏览器的历史记录，它适用于非浏览器环境，如 Node.js 服务器端渲染（SSR）或小程序开发。在这种模式下，路由的切换通过内存中的历史记录来管理。</p><ul><li><strong>优点</strong>：适用于非浏览器环境，提供了一种通用的路由管理方式。</li><li><strong>缺点</strong>：不能在浏览器中直接使用，主要用于特定的开发场景。</li></ul><h4 id="OZVip">动态路由</h4><p><strong>通过 : 定义动态参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">routes: [<br>  &#123; path: &#x27;/user/:id&#x27;, component: User &#125;<br>]<br></code></pre></td></tr></table></figure><hr><p><strong>获取路由信息</strong></p><p>使用useRoute获取当前路由中的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; useRoute &#125; from &#x27;vue-router&#x27;;<br>const route = useRoute()<br>console.log(route.params);<br></code></pre></td></tr></table></figure><hr><p>在当前路由改变，但是该组件被复用时调用 , 获取路由信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">//选项式<br> beforeRouteUpdate(to, from) &#123;<br>    // 在当前路由改变，但是该组件被复用时调用<br>    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，<br>    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`<br>  &#125;,<br>//组合式<br>onBeforeUpdate((to,from) =&gt; &#123;<br>        console.log(to.params);<br>        console.log(from.params);<br>    &#125;)<br></code></pre></td></tr></table></figure><h4 id="tep9g">嵌套路由</h4><p>使用 <code>children</code> 定义子路由，父组件需包含 <code>&lt;router-view&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const routes = [<br>  &#123;<br>    path: &#x27;/user&#x27;,<br>    component: User,<br>    children: [<br>      &#123; path: &#x27;profile&#x27;, component: Profile &#125;, // 匹配 /user/profile<br>      &#123; path: &#x27;posts&#x27;, component: Posts &#125;      // 匹配 /user/posts<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h4 id="YAVml">命名视图</h4><p>在路由配置中，使用 <code>components</code>（注意是复数形式）选项来定义多个命名视图，每个视图对应一个组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">// router/index.js<br>import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;<br>import Home from &#x27;../views/Home.vue&#x27;;<br>import Sidebar from &#x27;../views/Sidebar.vue&#x27;;<br>import MainContent from &#x27;../views/MainContent.vue&#x27;;<br><br>const routes = [<br>  &#123;<br>    path: &#x27;/&#x27;,<br>    components: &#123;<br>      default: Home,<br>      sidebar: Sidebar,<br>      main: MainContent<br>    &#125;<br>  &#125;<br>];<br><br>const router = createRouter(&#123;<br>  history: createWebHistory(),<br>  routes<br>&#125;);<br><br>export default router;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>default</code> 是默认的命名视图，当没有指定视图名称时，会渲染这个组件。<code>sidebar</code> 和 <code>main</code> 是自定义的命名视图，分别对应 <code>Sidebar</code> 和 <code>MainContent</code> 组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;!-- 默认视图 --&gt;<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>    &lt;!-- 侧边栏视图 --&gt;<br>    &lt;router-view name=&quot;sidebar&quot;&gt;&lt;/router-view&gt;<br>    &lt;!-- 主内容视图 --&gt;<br>    &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><h4 id="qCKnP">编程式路由跳转</h4><p>编程式导航通过调用 Vue Router 实例的方法来实现路由跳转，常用于在事件处理函数或生命周期钩子中进行导航。</p><p><strong>创建useRouter实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; useRouter &#125; from &#x27;vue-router&#x27;<br>const router = useRouter()<br><br></code></pre></td></tr></table></figure><hr><p><code>**router.push**</code></p><p>跳转到新页面，保留历史记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 路径字符串<br>router.push(&#x27;/about&#x27;)<br><br>// 对象形式（推荐）<br>router.push(&#123; path: &#x27;/user/123&#x27; &#125;)<br><br>// 命名路由 + 参数<br>router.push(&#123;<br>  name: &#x27;user&#x27;,<br>  params: &#123; id: 123 &#125;, // 动态参数<br>  query: &#123; name: &#x27;John&#x27; &#125; // URL 查询参数 ?name=John<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>**router.replace**</code></p><p>替换当前页面，不保留历史记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">router.replace(&#x27;/login&#x27;) // 替换当前路由<br></code></pre></td></tr></table></figure><p><code>**router.go**</code></p><p>在历史记录中前进&#x2F;后退指定步数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">router.go(1)  // 前进一步<br>router.go(-1) // 后退一步<br></code></pre></td></tr></table></figure><p><code>**router.back()**</code>** 和 **<code>**router.forward()**</code></p><p>直接后退&#x2F;前进一步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">router.back()    // 等价于 router.go(-1)<br>router.forward() // 等价于 router.go(1)<br></code></pre></td></tr></table></figure><hr><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script setup&gt;<br>import &#123; useRouter &#125; from &#x27;vue-router&#x27;<br><br>const router = useRouter()<br><br>const navigateToUser = () =&gt; &#123;<br>// 使用 path 时，params 会被忽略，需用 name<br>// URL 结果: /user/456?role=role<br>  router.push(&#123;<br>    name: &#x27;user&#x27;,<br>    params: &#123; id: 456 &#125;,<br>    query: &#123; role: &#x27;role&#x27; &#125;<br>  &#125;)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;navigateToUser&quot;&gt;跳转到用户页&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="qUwVD">动态添加路由</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 用户登录后调用<br>async function generateRoutes() &#123;<br>  try &#123;<br>    // 从接口获取菜单数据<br>    const &#123; data &#125; = await axios.get(&#x27;/api/getRoutes&#x27;)<br>    <br>    // 转换数据格式（示例结构）<br>    const asyncRoutes = [<br>      &#123;<br>        path: &#x27;/dashboard&#x27;,<br>        component: () =&gt; import(&#x27;@/views/dashboard&#x27;),<br>        meta: &#123; title: &#x27;控制台&#x27;, icon: &#x27;dashboard&#x27; &#125;,<br>        children: [<br>          &#123;<br>            path: &#x27;analysis&#x27;,<br>            component: () =&gt; import(&#x27;@/views/analysis&#x27;),<br>            meta: &#123; title: &#x27;分析页&#x27; &#125;<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>    <br>    return asyncRoutes<br>  &#125; catch (error) &#123;<br>    console.error(&#x27;获取路由失败&#x27;, error)<br>    return []<br>  &#125;<br>&#125;<br><br><br>// 在权限验证后调用<br>async function addRoutes() &#123;<br>  // 获取动态路由配置<br>  const accessRoutes = await generateRoutes()<br>  <br>  // 逐个添加路由<br>  accessRoutes.forEach(route =&gt; &#123;<br>    router.addRoute(route) <br>  &#125;)<br>  <br>  // 最后添加404通配路由<br>  router.addRoute(&#123; path: &#x27;/:pathMatch(.*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>添加路由</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">//添加顶层路由<br>router.addRoute(&#123;<br>    path: &#x27;&#x27;, name: &#x27;&#x27;, component: &#x27;&#x27;<br>&#125;)<br>//添加user/a<br>router.addRoute(&#x27;user&#x27;,&#123;<br>    path: &#x27;a&#x27;, name: &#x27;&#x27;, component: &#x27;&#x27;<br>&#125;)<br>//添加RouteData<br>const RouteData = &#123;<br>    &quot;path&quot;: &quot;/system&quot;,<br>      &quot;component&quot;: &quot;Layout&quot;,<br>      &quot;meta&quot;: &#123;<br>        &quot;title&quot;: &quot;系统管理&quot;,<br>        &quot;icon&quot;: &quot;system&quot;<br>      &#125;,<br>      &quot;children&quot;: [<br>        &#123;<br>          &quot;path&quot;: &quot;user&quot;,<br>          &quot;component&quot;: &quot;system/user&quot;,<br>          &quot;meta&quot;: &#123;<br>            &quot;title&quot;: &quot;用户管理&quot;,<br>            &quot;permissions&quot;: [&quot;admin&quot;]<br>          &#125;<br>        &#125;<br>      ]<br>&#125;<br>router.addRoute(RouteData)<br></code></pre></td></tr></table></figure><ul><li>删除路由</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">//添加一个name同名路由会覆盖上一个<br>router.addRoute(&#123;<br>    path: &#x27;/user1&#x27;, name: &#x27;user&#x27;, component: &#x27;&#x27;<br>&#125;)<br>router.addRoute(&#123;<br>    path: &#x27;user2&#x27;, name: &#x27;user&#x27;, component: &#x27;&#x27;<br>&#125;)<br>// 传入name<br>router.removeRoute(&#x27;user&#x27;)<br>// router.addRoute会返回一个删除函数<br>const removeRoute= router.addRoute(&#123;<br>    path: &#x27;user2&#x27;, name: &#x27;user&#x27;, component: &#x27;&#x27;<br>&#125;)<br>removeRoute()<br></code></pre></td></tr></table></figure><ul><li>检查路由是否存在<code>router.hasRoute()</code></li><li>获取一个包含所有路由记录的数组<code>router.getRouters()</code></li></ul><h4 id="EMynj">路由导航 </h4><p>路由导航守卫是 Vue Router 提供的一种机制，用于在路由切换前后进行一些控制和处理，比如身份验证、权限检查、页面加载前的数据预获取等。Vue Router 提供了全局守卫、路由独享守卫和组件内守卫三种类型的导航守卫。</p><h5 id="h7yFD">全局守卫</h5><p><strong>全局前置守卫</strong></p><p>在路由跳转之前执行，可用于身份验证、权限检查等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router/index.js</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Login.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span> &#125; <span class="hljs-comment">// 标记该路由需要身份验证</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span><br>  &#125;<br>];<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>),<br>  routes<br>&#125;);<br><br><span class="hljs-comment">// 全局前置守卫</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// to: 即将要进入的目标路由对象</span><br>  <span class="hljs-comment">// from: 当前导航正要离开的路由对象</span><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span>) &#123;<br>    <span class="hljs-keyword">const</span> isAuthenticated = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;isAuthenticated&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (isAuthenticated) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-comment">// 允许访问</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;/login&#x27;</span>); <span class="hljs-comment">// 重定向到登录页</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 不需要身份验证，直接放行</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><ul><li><code>to</code>：即将要进入的目标路由对象。</li><li><code>from</code>：当前导航正要离开的路由对象。</li><li><code>next</code>：一个函数，用于控制路由的跳转行为，必须调用该方法来 resolve 这个钩子。(已经不推荐)</li><li>使用返回值<ul><li>false : 取消当前导航</li><li>默认或者undefined : 默认导航</li><li>返回路由地址<ul><li>string类型的path</li><li>对象( path , query , params)</li></ul></li></ul></li></ul><hr><p><strong>全局解析守卫</strong></p><p>和 <code>beforeEach</code> 类似，但在导航被确认之前，同时所有组件内守卫和异步路由组件被解析之后调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeResolve</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在这里可以进行一些数据预获取等操作</span><br>  <br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>全局后置钩子</strong></p><p>在路由跳转之后执行，不接收 <code>next</code> 函数，不能改变导航本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 可以在这里进行一些页面统计、日志记录等操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`从 <span class="hljs-subst">$&#123;<span class="hljs-keyword">from</span>.name&#125;</span> 页面跳转到了 <span class="hljs-subst">$&#123;to.name&#125;</span> 页面`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="vt6h9">路由独享守卫</h5><p>路由独享守卫只作用于某个特定的路由配置，在路由配置中直接定义 <code>beforeEnter</code> 钩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dashboard&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Dashboard.vue&#x27;</span>),<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> hasPermission = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;hasPermission&#x27;</span>);<br>      <span class="hljs-keyword">if</span> (hasPermission) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-comment">// 允许访问</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 重定向到首页</span><br>      &#125;<br>    &#125;<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><h5 id="Rqyno">**组件内守卫**</h5><p>组件内守卫定义在路由组件内部，用于在组件层面进行导航控制。</p><p><code>**beforeRouteEnter**</code></p><p>在渲染该组件的对应路由被确认前调用，不能访问 <code>this</code>，因为组件实例还未创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h1&gt;Product Detail&lt;/h1&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  beforeRouteEnter(to, from,next) &#123;<br>    // 在渲染该组件的对应路由被验证前调用<br>    // 不能获取组件实例 `this` ！<br>    // 因为当守卫执行时，组件实例还没被创建！<br><br>    next(vm =&gt; &#123;<br>    // 通过 `vm` 访问组件实例,可以通过传一个回调给 next 来访问组件实例。<br>    // 在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数<br>  &#125;)<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>**beforeRouteUpdate**</code></p><p>在当前路由改变，但是该组件被复用时调用，比如 <code>/product/1</code> 跳转到 <code>/product/2</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h1&gt;Product Detail&lt;/h1&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  beforeRouteUpdate(to, from) &#123;<br>    // 在当前路由改变，但是该组件被复用时调用<br>    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，<br>    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>**beforeRouteLeave**</code></p><p>在导航离开该组件的对应路由时调用，可用于阻止用户离开，比如表单未保存时提示用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;form&gt;<br>      &lt;input v-model=&quot;message&quot; /&gt;<br>      &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt;<br>    &lt;/form&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &#x27;&#x27;<br>    &#125;;<br>  &#125;,<br>  beforeRouteLeave(to, from) &#123;<br>    if (this.message) &#123;<br>      if (confirm(&#x27;表单还未保存，确定要离开吗？&#x27;)) &#123;<br>       return // 允许离开<br>      &#125; else &#123;<br>        return false // 阻止离开<br>      &#125;<br>    &#125; else &#123;<br>      return // 没有数据，直接离开<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="T6x2H">导航解析流程</h5><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子,</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ol><h3 id="KhYDH">状态管理</h3><h4 id="V108E">VueX</h4><p>在 Vue  中，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h5 id="ZB1JN">安装和基本使用</h5><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue"># 使用 npm<br>npm install vuex@next --save<br><br># 使用 yarn<br>yarn add vuex@next<br></code></pre></td></tr></table></figure><hr><p><strong>基本使用</strong></p><p>在项目中创建一个 <code>store</code> 目录，并在其中创建 <code>index.js</code> 文件，用于配置和导出 Vuex store。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br><br>const store = createStore(&#123;<br>  // 状态（state）：用于存储应用的所有数据<br>  state() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;;<br>  &#125;,<br>  // 突变（mutations）：是唯一可以修改 state 的地方，必须是同步函数<br>  mutations: &#123;<br>    increment(state) &#123;<br>      state.count++;<br>    &#125;<br>  &#125;,<br>  // 动作（actions）：用于处理异步操作，最终通过提交 mutations 来修改 state<br>  actions: &#123;<br>    incrementAsync(context) &#123;<br>      setTimeout(() =&gt; &#123;<br>        context.commit(&#x27;increment&#x27;);<br>      &#125;, 1000);<br>    &#125;<br>  &#125;,<br>  // 获取器（getters）：类似于计算属性，用于获取 state 中的数据并进行计算<br>  getters: &#123;<br>    doubleCount(state) &#123;<br>      return state.count * 2;<br>    &#125;<br>  &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>在 <code>main.js</code> 中引入并使用创建好的 store。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">// main.js<br>import &#123; createApp &#125; from &#x27;vue&#x27;;<br>import App from &#x27;./App.vue&#x27;;<br>import store from &#x27;./store&#x27;;<br><br>const app = createApp(App);<br>app.use(store);<br>app.mount(&#x27;#app&#x27;);<br></code></pre></td></tr></table></figure><p>在模板中直接使用<code>$store.state</code>获取数据</p><p>在组合式api中使用<code>useStore</code>获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &#123;&#123; $store.state.count &#125;&#125;<br>        &lt;button @click=&quot;addClick&quot;&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore()<br>console.log(store.state.count);<br>//不能直接修改stata的数据,需要使用mutation(commit)进行提交<br>function addClick() &#123;<br>    store.commit(&#x27;add&#x27;)<br>&#125;<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>Vuex 使用单一状态树:</strong></p><ul><li>用一个对象就包含了全部的应用层级的状态 , 采用的是SSOT，Single Source of Truth，也可以翻译成单一数据源</li><li>这也意味着，每个应用将仅仅包含一个 store 实例: 单状态树和模块化并不冲突,store中存在module</li></ul><p><strong>单一状态树的优势:</strong></p><ul><li>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难;所以Vuex也使用了单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们最直接的方式找到某个状态的片段:而且在之后的维护和调试过程中，也可以非常方便的管理和维护</li></ul><hr><p><strong>Vuex-Store状态映射</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h3&gt;<br>            &#123;&#123; name &#125;&#125;<br>            &#123;&#123; age &#125;&#125;<br>        &lt;/h3&gt;<br>        &lt;h3&gt;<br>            &#123;&#123; zName &#125;&#125;<br>            &#123;&#123; zAge &#125;&#125;<br>        &lt;/h3&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br><br>&lt;/script&gt;<br>&lt;script&gt;<br>import &#123; mapState &#125; from &#x27;vuex&#x27;;<br>export default &#123;<br>    data() &#123;<br>    &#125;,<br>    computed: &#123;<br>        //数组写法<br>        ...mapState([&quot;name&quot;, &quot;age&quot;]),<br>        //对象写法,命名重复<br>        ...mapState(&#123;<br>            zName: state =&gt; state.name,<br>            zAge: state =&gt; state.age<br>        &#125;)<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &#123;&#123; $store.state.count &#125;&#125;<br>        &lt;button @click=&quot;addClick&quot;&gt;+&lt;/button&gt;<br>        &lt;h3&gt;<br>            &#123;&#123; Zname &#125;&#125;<br>            &#123;&#123; age &#125;&#125;<br>        &lt;/h3&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; toRefs,computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br>const store = useStore()<br>console.log(store.state.count);<br>//不能直接修改stata的数据,需要使用mutation(commit)进行提交<br>function addClick() &#123;<br>    store.commit(&#x27;add&#x27;)<br>&#125;<br>//也可以使用映射<br>//const &#123;name:Zname&#125;=mapState([&quot;name&quot;]),<br>//const name=computed(name.bind(&#123;$store:store&#125;)  <br>const &#123; name:Zname, age &#125; = toRefs(store.state) <br><br>&lt;/script&gt;<br><br><br>&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h5 id="oRMVl">Getters</h5><ul><li><strong>概念</strong>：<code>getters</code> 是 <code>store</code> 中的计算属性，用于获取 <code>state</code> 中的数据并进行处理，返回一个新的值。</li><li><strong>作用</strong>：可以对 <code>state</code> 中的数据进行封装和计算，避免在组件中重复编写相同的逻辑，提高代码的可维护性和复用性。</li></ul><hr><p>在创建 <code>store</code> 时，可以在 <code>getters</code> 对象中定义获取器函数。每个获取器函数接收 <code>state</code> 作为第一个参数，还可以接收其他 <code>getters</code> 作为第二个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br><br>const store = createStore(&#123;<br>  state() &#123;<br>    return &#123;<br>      todos: [<br>        &#123; id: 1, text: &#x27;Learn Vue 3&#x27;, done: true &#125;,<br>        &#123; id: 2, text: &#x27;Learn Vuex&#x27;, done: false &#125;<br>      ]<br>    &#125;;<br>  &#125;,<br>  getters: &#123;<br>    // 获取已完成的 todos<br>    doneTodos(state) &#123;<br>      return state.todos.filter(todo =&gt; todo.done);<br>    &#125;,<br>    // 获取已完成 todos 的数量<br>    doneTodosCount(state, getters) &#123;<br>      return getters.doneTodos.length;<br>    &#125;<br>  &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>组合式 API 中，可以使用 <code>useStore</code> 函数来访问 <code>store</code>，进而访问 <code>getters</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;Done Todos Count: &#123;&#123; doneTodosCount &#125;&#125;&lt;/p&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;todo in doneTodos&quot; :key=&quot;todo.id&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore();<br>const doneTodos = computed(() =&gt; store.getters.doneTodos);<br>const doneTodosCount = computed(() =&gt; store.getters.doneTodosCount);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>有时候，我们需要根据不同的条件来获取数据，这时可以让 <code>getters</code> 返回一个函数，从而实现接收参数的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br><br>const store = createStore(&#123;<br>  state() &#123;<br>    return &#123;<br>      todos: [<br>        &#123; id: 1, text: &#x27;Learn Vue 3&#x27;, done: true &#125;,<br>        &#123; id: 2, text: &#x27;Learn Vuex&#x27;, done: false &#125;<br>      ]<br>    &#125;;<br>  &#125;,<br>  getters: &#123;<br>    // 根据 id 获取 todo<br>    getTodoById: (state) =&gt; (id) =&gt; &#123;<br>      return state.todos.find(todo =&gt; todo.id === id);<br>    &#125;<br>  &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><hr><p><strong>getter的映射</strong></p><p>在选项式 API 中，可以通过 <code>this.$store.getters</code> 访问 <code>getters</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;Done Todos Count: &#123;&#123; $store.getters.doneTodosCount &#125;&#125;&lt;/p&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;todo in $store.getters.doneTodos&quot; :key=&quot;todo.id&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;TodoList&#x27;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>也可以使用 <code>mapGetters</code> 辅助函数来简化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;Done Todos Count: &#123;&#123; doneTodosCount &#125;&#125;&lt;/p&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;todo in doneTodos&quot; :key=&quot;todo.id&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mapGetters &#125; from &#x27;vuex&#x27;;<br><br>export default &#123;<br>  name: &#x27;TodoList&#x27;,<br>  computed: &#123;<br>    ...mapGetters([&#x27;doneTodos&#x27;, &#x27;doneTodosCount&#x27;])<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="hNhTF">Mutation</h5><p><code>mutation</code> 是用于修改 <code>store</code> 中 <code>state</code> 的唯一途径，并且它必须是<strong>同步函数</strong>，这保证了状态变化的可追踪性和可预测性。</p><ul><li><strong>概念</strong>：<code>mutation</code> 本质上是一个包含修改 <code>state</code> 逻辑的函数，它接收 <code>state</code> 作为第一个参数，还可以接收一个可选的 <code>payload</code>（即传递给 <code>mutation</code> 的额外参数）</li><li><strong>作用</strong>：集中管理状态的修改操作，使得状态的变化可追踪，方便调试和维护代码</li></ul><hr><p>在创建 <code>store</code> 时，在 <code>mutations</code> 对象中定义具体的 <code>mutation</code> 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br><br>const store = createStore(&#123;<br>    state() &#123;<br>        return &#123;<br>            count: 0<br>        &#125;;<br>    &#125;,<br>    mutations: &#123;<br>        // 定义一个简单的 mutation 来增加 count 的值<br>        increment(state) &#123;<br>            state.count++;<br>        &#125;,<br>        // 定义一个接收 payload 的 mutation，用于设置 count 为指定的值<br>        setCount(state, payload) &#123;<br>            state.count = payload;<br>        &#125;<br>    &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>组合式 API 中，借助 <code>useStore</code> 函数访问 <code>store</code>，再使用 <code>commit</code> 方法触发 <code>mutation</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>        &lt;button @click=&quot;setCount(10)&quot;&gt;Set Count to 10&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore();<br>const count = computed(() =&gt; store.state.count);<br><br>const increment = () =&gt; store.commit(&#x27;increment&#x27;);<br>const setCount = (value) =&gt; store.commit(&#x27;setCount&#x27;, value);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p>为了增强代码的可读性和可维护性，通常会采用常量来定义 <code>mutation</code> 的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/mutation-types.js<br>export const INCREMENT = &#x27;INCREMENT&#x27;;<br>export const SET_COUNT = &#x27;SET_COUNT&#x27;;<br><br>// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br>import &#123; INCREMENT, SET_COUNT &#125; from &#x27;./mutation-types&#x27;;<br><br>const store = createStore(&#123;<br>    state() &#123;<br>        return &#123;<br>            count: 0<br>        &#125;;<br>    &#125;,<br>    mutations: &#123;<br>        [INCREMENT](state) &#123;<br>            state.count++;<br>        &#125;,<br>        [SET_COUNT](state, payload) &#123;<br>            state.count = payload;<br>        &#125;<br>    &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>在组件中使用常量触发 <code>mutation</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>        &lt;button @click=&quot;setCount(10)&quot;&gt;Set Count to 10&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br>import &#123; INCREMENT, SET_COUNT &#125; from &#x27;../store/mutation-types&#x27;;<br><br>const store = useStore();<br>const count = computed(() =&gt; store.state.count);<br><br>const increment = () =&gt; store.commit(INCREMENT);<br>const setCount = (value) =&gt; store.commit(SET_COUNT, value);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>Mutation的映射</strong></p><p>在选项式 API 里，可以通过 <code>this.$store.commit</code> 方法来触发 <code>mutation</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;$store.commit(&#x27;increment&#x27;)&quot;&gt;Increment&lt;/button&gt;<br>        &lt;button @click=&quot;$store.commit(&#x27;setCount&#x27;, 10)&quot;&gt;Set Count to 10&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>    name: &#x27;Counter&#x27;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>使用 <code>mapMutations</code> 辅助函数来简化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>        &lt;button @click=&quot;setCount(10)&quot;&gt;Set Count to 10&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mapMutations &#125; from &#x27;vuex&#x27;;<br><br>export default &#123;<br>    name: &#x27;Counter&#x27;,<br>    methods: &#123;<br>        ...mapMutations([&#x27;increment&#x27;, &#x27;setCount&#x27;])<br>    &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="LgNMW">Actions</h5><p><code>actions</code> 是用来处理异步操作并最终提交 <code>mutations</code> 以修改 <code>state</code> 的。由于 <code>mutations</code> 必须是同步的，而异步操作（如网络请求）无法保证其同步性，所以就需要 <code>actions</code> 来处理这类情况</p><ul><li><strong>概念</strong>：<code>actions</code> 是一些包含异步操作逻辑的函数，它不直接修改 <code>state</code>，而是通过提交 <code>mutations</code> 来间接修改 <code>state</code>。<code>actions</code> 接收一个与 <code>store</code> 实例具有相同方法和属性的 <code>context</code> 对象，通过它可以访问 <code>state</code>、<code>getters</code> 以及提交 <code>mutations</code>。</li><li><strong>作用</strong>：处理异步操作，如发起网络请求、定时器操作等，确保 <code>state</code> 的修改是可追踪和可预测的。</li></ul><hr><p>在创建 <code>store</code> 时，在 <code>actions</code> 对象中定义具体的 <code>action</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br><br>const store = createStore(&#123;<br>    state() &#123;<br>        return &#123;<br>            count: 0<br>        &#125;;<br>    &#125;,<br>    mutations: &#123;<br>        increment(state) &#123;<br>            state.count++;<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>        // 定义一个异步 action，1 秒后提交 increment mutation<br>        incrementAsync(context) &#123;<br>            setTimeout(() =&gt; &#123;<br>                context.commit(&#x27;increment&#x27;);<br>            &#125;, 1000);<br>        &#125;,<br>        // 使用 ES6 参数解构简化代码<br>        anotherIncrementAsync(&#123; commit &#125;) &#123;<br>            setTimeout(() =&gt; &#123;<br>                commit(&#x27;increment&#x27;);<br>            &#125;, 1500);<br>        &#125;<br>    &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>组合式 API 中，利用 <code>useStore</code> 函数访问 <code>store</code>，再使用 <code>dispatch</code> 方法触发 <code>action</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;incrementAsync&quot;&gt;Increment Async&lt;/button&gt;<br>        &lt;button @click=&quot;anotherIncrementAsync&quot;&gt;Another Increment Async&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore();<br>const count = computed(() =&gt; store.state.count);<br><br>const incrementAsync = () =&gt; store.dispatch(&#x27;incrementAsync&#x27;);<br>const anotherIncrementAsync = () =&gt; store.dispatch(&#x27;anotherIncrementAsync&#x27;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>action</code> 函数可以接收第二个参数作为 <code>payload</code>，用于传递额外的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br><br>const store = createStore(&#123;<br>    state() &#123;<br>        return &#123;<br>            count: 0<br>        &#125;;<br>    &#125;,<br>    mutations: &#123;<br>        incrementByAmount(state, amount) &#123;<br>            state.count += amount;<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>        incrementByAmountAsync(&#123; commit &#125;, amount) &#123;<br>            setTimeout(() =&gt; &#123;<br>                commit(&#x27;incrementByAmount&#x27;, amount);<br>            &#125;, 1000);<br>        &#125;<br>    &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>组件中触发接收参数的 <code>action</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;incrementByAmountAsync(5)&quot;&gt;Increment by 5 Async&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore();<br>const count = computed(() =&gt; store.state.count);<br><br>const incrementByAmountAsync = (amount) =&gt; store.dispatch(&#x27;incrementByAmountAsync&#x27;, amount);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>actions的映射</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;$store.dispatch(&#x27;incrementAsync&#x27;)&quot;&gt;Increment Async&lt;/button&gt;<br>        &lt;button @click=&quot;$store.dispatch(&#x27;anotherIncrementAsync&#x27;)&quot;&gt;Another Increment Async&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>    name: &#x27;Counter&#x27;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>使用 <code>mapActions</code> 辅助函数来简化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;incrementAsync&quot;&gt;Increment Async&lt;/button&gt;<br>        &lt;button @click=&quot;anotherIncrementAsync&quot;&gt;Another Increment Async&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mapActions &#125; from &#x27;vuex&#x27;;<br><br>export default &#123;<br>    name: &#x27;Counter&#x27;,<br>    methods: &#123;<br>        ...mapActions([&#x27;incrementAsync&#x27;, &#x27;anotherIncrementAsync&#x27;])<br>    &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="BkD7v">Modules</h5><p>Vuex 的 <code>module</code>（模块）允许将 <code>store</code> 分割成多个小模块，每个模块拥有自己独立的 <code>state</code>、<code>mutations</code>、<code>actions</code> 和 <code>getters</code>，使代码结构更加清晰、易于管理</p><ul><li><strong>模块</strong>：模块是 Vuex 中用于组织代码的一种方式，将一个大的 <code>store</code> 拆分成多个小的模块，每个模块有自己独立的状态管理逻辑。</li><li><strong>命名空间</strong>：通过设置 <code>namespaced: true</code>，可以为模块开启命名空间，避免不同模块之间的命名冲突。</li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/modules/user.js<br>const userModule = &#123;<br>    // 开启命名空间<br>    namespaced: true,<br>    state() &#123;<br>        return &#123;<br>            username: &#x27;Guest&#x27;,<br>            age: 0<br>        &#125;;<br>    &#125;,<br>    mutations: &#123;<br>        setUsername(state, newUsername) &#123;<br>            state.username = newUsername;<br>        &#125;,<br>        setAge(state, newAge) &#123;<br>            state.age = newAge;<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>        updateUserInfo(&#123; commit &#125;, &#123; username, age &#125;) &#123;<br>            commit(&#x27;setUsername&#x27;, username);<br>            commit(&#x27;setAge&#x27;, age);<br>        &#125;<br>    &#125;,<br>    getters: &#123;<br>        userFullInfo(state) &#123;<br>            return `Name: $&#123;state.username&#125;, Age: $&#123;state.age&#125;`;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>export default userModule;<br></code></pre></td></tr></table></figure><p>在store中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">// store/index.js<br>import &#123; createStore &#125; from &#x27;vuex&#x27;;<br>import userModule from &#x27;./modules/user&#x27;;<br><br>const store = createStore(&#123;<br>    modules: &#123;<br>        user: userModule<br>    &#125;<br>&#125;);<br><br>export default store;<br></code></pre></td></tr></table></figure><p>在组件中使用模块时，需要根据模块是否开启命名空间来决定访问方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;User Info: &#123;&#123; userFullInfo &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;updateUser(&#x27;John&#x27;, 25)&quot;&gt;Update User&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore();<br>// 获取模块中的 getters<br>const userFullInfo = computed(() =&gt; store.getters[&#x27;user/userFullInfo&#x27;]);<br>// 触发模块中的 actions<br>const updateUser = (username, age) =&gt; &#123;<br>    store.dispatch(&#x27;user/updateUserInfo&#x27;, &#123; username, age &#125;);<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p>有时候，一个模块的 <code>action</code> 可能需要调用另一个模块的 <code>action</code> 或 <code>mutation</code>。可以通过 <code>context.rootState</code>、<code>context.rootGetters</code>、<code>context.rootCommit</code> 和 <code>context.rootDispatch</code> 来访问根 <code>store</code> 的状态和方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;User Info: &#123;&#123; userFullInfo &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;updateUser(&#x27;John&#x27;, 25)&quot;&gt;Update User&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;;<br>import &#123; useStore &#125; from &#x27;vuex&#x27;;<br><br>const store = useStore();<br>// 获取模块中的 getters<br>const userFullInfo = computed(() =&gt; store.getters[&#x27;user/userFullInfo&#x27;]);<br>// 触发模块中的 actions<br>const updateUser = (username, age) =&gt; &#123;<br>    store.dispatch(&#x27;user/updateUserInfo&#x27;, &#123; username, age &#125;);<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="Mr9zj">Pinia</h4><p>Pinia 是一个轻量级的状态管理库，它提供了直观且可扩展的方式来管理应用程序的状态。</p><h5 id="QGmeo">vuex与pinia区别</h5><table><thead><tr><th align="left">****</th><th align="left"><strong>Vuex</strong></th><th align="left"><strong>Pinia</strong></th></tr></thead><tbody><tr><td align="left"><strong>设计理念</strong></td><td align="left">遵循 Flux 架构，强调严格单向数据流，通过 <code>mutations</code>同步修改 <code>state</code>，异步操作使用 <code>actions</code></td><td align="left">更轻量灵活，弱化 <code>mutations</code><br> 概念，允许在 <code>actions</code>中进行同步和异步操作</td></tr><tr><td align="left"><strong>API 风格</strong></td><td align="left">需要定义 <code>state</code>、<code>mutations</code><br>、<code>actions</code> 和 <code>getters</code>，使用 <code>commit</code>触发 <code>mutations</code>，<code>dispatch</code>触发 <code>actions</code></td><td align="left">仅需定义 <code>state</code>、<code>actions</code><br> 和 <code>getters</code>，可直接调用 <code>actions</code>修改状态</td></tr><tr><td align="left"><strong>类型支持</strong></td><td align="left">Vue 2 中对 TypeScript 支持弱，Vue 3 有改进但仍需额外配置</td><td align="left">从设计上对 TypeScript 有良好支持，减少手动编写类型声明工作量</td></tr><tr><td align="left"><strong>代码结构和模块化</strong></td><td align="left">项目变大时 <code>store</code>文件庞大，需用 <code>modules</code>拆分，模块交互和命名空间管理较复杂</td><td align="left">本身模块化，通过 <code>defineStore</code><br> 定义独立 <code>store</code>，代码结构清晰，无命名空间问题</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">状态变化需经过 <code>mutations</code>，处理大量数据或频繁更新状态时可能有性能开销</td><td align="left">无 <code>mutations</code>限制，状态变化可直接在 <code>actions</code>中进行，性能可能更优</td></tr><tr><td align="left"><strong>生态系统和社区支持</strong></td><td align="left">是 Vue.js 官方推荐，发展历史长，生态丰富，社区支持强大</td><td align="left">较新但获 Vue.js 核心团队支持，社区受欢迎，生态在不断发展完善</td></tr></tbody></table><h5 id="oCSG2">安装和基本使用</h5><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm install pinia<br># 或者<br>yarn add pinia<br></code></pre></td></tr></table></figure><hr><p><strong>基本使用</strong></p><p>创建并初始化 Pinia 实例，然后将其挂载到 Vue 应用上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; createPinia &#125; from &quot;pinia&quot;;<br><br>const pinia = createPinia()<br><br>export default pinia<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; createApp &#125; from &#x27;vue&#x27;<br>import router from &#x27;./router&#x27;<br>import App from &#x27;./App.vue&#x27;<br>import store from &#x27;./store&#x27;<br>createApp(App).use(router).use(store).mount(&#x27;#app&#x27;)<br><br></code></pre></td></tr></table></figure><p>可以通过<code>defineStore</code>函数来创建一个 store</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &quot;pinia&quot;;<br>//返回值为一个函数,defineStore第一个参数为唯一标识<br>export const useCountStore = defineStore(&#x27;count&#x27;, &#123;<br>    state() &#123;<br>        return &#123;<br>            count:10<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h2&gt;App&lt;/h2&gt;<br>        &lt;h3&gt;计数-&#123;&#123; store.count  &#125;&#125;&lt;/h3&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useCountStore &#125; from &#x27;./store/count&#x27;;<br>const store = useCountStore()<br><br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p>直接解构 store 获取数据会丢失响应式 , 需要使用 storeToRefs 使结构的数据保持响应式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h2&gt;App&lt;/h2&gt;<br>        &lt;router-view&gt;&lt;/router-view&gt;<br>        &lt;h3&gt;计数-&#123;&#123; store.count &#125;&#125;&lt;/h3&gt;<br>        &lt;h3&gt;计数-&#123;&#123; count &#125;&#125;&lt;/h3&gt;<br>        &lt;button @click=&quot;addCount&quot;&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useCountStore &#125; from &#x27;./store/count&#x27;;<br>import &#123; toRefs &#125; from &#x27;vue&#x27;;<br>import &#123; storeToRefs &#125; from &#x27;pinia&#x27;;<br>const store = useCountStore()<br>//直接使用解构会丢失响应式<br>// const &#123; count &#125; = store<br>//使用toRefs/storeToRefs保持响应式<br>const &#123; count &#125; = storeToRefs(store) <br><br>function addCount() &#123;<br>    store.count++<br>&#125;<br><br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="ld1TN">State</h5><p><code>state</code> 是一个函数，它返回一个包含状态属性的对象。在使用 <code>defineStore</code> 函数创建 store 时，需要定义 <code>state</code></p><hr><ul><li>你需要从 store 中解构出状态属性时，为了保持响应式，需要使用 <code>storeToRefs</code> 函数</li></ul><hr><p><strong>修改state</strong></p><ul><li>可以直接在组件中修改 <code>state</code> 的属性。Pinia 会自动跟踪这些变化并触发组件的重新渲染</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; counterStore.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useCounterStore &#125; from &#x27;../stores/counter&#x27;;<br><br>const counterStore = useCounterStore();<br><br>const increment = () =&gt; &#123;<br>    counterStore.count++;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>为了更好地组织代码和管理状态变化，建议使用 <code>actions</code> 来修改 <code>state</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">// stores/counter.js<br>import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br><br>export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        count: 0<br>    &#125;),<br>    actions: &#123;<br>        increment() &#123;<br>            this.count++;<br>        &#125;,<br>        decrement() &#123;<br>            this.count--;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; counterStore.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;counterStore.increment&quot;&gt;Increment&lt;/button&gt;<br>        &lt;button @click=&quot;counterStore.decrement&quot;&gt;Decrement&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useCounterStore &#125; from &#x27;../stores/counter&#x27;;<br><br>const counterStore = useCounterStore();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p>**重置 **<code>**state**</code></p><p>可以使用 <code>$reset</code> 方法将 <code>state</code> 重置为初始值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../stores/counter&#x27;</span>;<br><br><span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>();<br>counterStore.$reset();<br></code></pre></td></tr></table></figure><hr><p>**批量修改 **<code>**state**</code></p><p>可以使用 <code>$patch</code> 方法批量修改 <code>state</code>，这样可以减少不必要的重新渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../stores/counter&#x27;</span>;<br><br><span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>();<br><br><span class="hljs-comment">// 方式一：对象形式</span><br>counterStore.$patch(&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;New message&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">// 方式二：函数形式</span><br>counterStore.$patch(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br>    state.<span class="hljs-property">count</span> += <span class="hljs-number">5</span>;<br>    state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>持久化state</strong></p><p>如果你希望 <code>state</code> 在页面刷新后仍然保留，可以使用 <code>pinia-plugin-persistedstate</code> 插件。</p><p><strong>安装插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm install pinia-plugin-persistedstate<br></code></pre></td></tr></table></figure><p><strong>使用插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; createPinia &#125; from &quot;pinia&quot;;<br>import piniaPluginPersistedstate from &#x27;pinia-plugin-persistedstate&#x27;;<br><br><br>const pinia = createPinia()<br>pinia.use(piniaPluginPersistedstate)<br>export default pinia<br></code></pre></td></tr></table></figure><p><strong>启用持久化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">// stores/counter.js<br>import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br><br>export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        count: 0<br>    &#125;),<br>    persist: true // 开启持久化<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="U84R6">Getters</h5><p><code>getters</code> 类似于 Vue 组件中的计算属性，用于从 <code>state</code> 中派生数据。它们可以提供一种简洁且高效的方式来获取基于 <code>state</code> 的计算值，并且会自动响应 <code>state</code> 的变化。</p><hr><p>在使用 <code>defineStore</code> 创建 store 时，可以通过 <code>getters</code> 选项来定义获取器。<code>getters</code> 是一个对象，其中每个属性都是一个函数，该函数接收 <code>state</code> 作为第一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br><br>export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        count: 0<br>    &#125;),<br>    getters: &#123;<br>        // 简单的 getter，返回 count 的两倍<br>        doubleCount: (state) =&gt; state.count * 2,<br>        // 可以使用 this 来访问其他 getter 或 state<br>        doubleCountPlusOne() &#123;<br>            return this.doubleCount + 1;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>组件中访问 <code>getters</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; counterStore.count &#125;&#125;&lt;/p&gt;<br>        &lt;p&gt;Double Count: &#123;&#123; counterStore.doubleCount &#125;&#125;&lt;/p&gt;<br>        &lt;p&gt;Double Count Plus One: &#123;&#123; counterStore.doubleCountPlusOne &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useCounterStore &#125; from &#x27;../stores/counter&#x27;;<br><br>const counterStore = useCounterStore();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><strong>getters接收参数</strong></p><p><code>getters</code> 也可以返回一个函数，从而实现接收参数的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br><br>export const useUserStore = defineStore(&#x27;user&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        users: [<br>            &#123; id: 1, name: &#x27;Alice&#x27;, age: 25 &#125;,<br>            &#123; id: 2, name: &#x27;Bob&#x27;, age: 30 &#125;,<br>            &#123; id: 3, name: &#x27;Charlie&#x27;, age: 35 &#125;<br>        ]<br>    &#125;),<br>    getters: &#123;<br>        // 返回一个函数，根据用户 ID 获取用户信息<br>        getUserById: (state) =&gt; (id) =&gt; &#123;<br>            return state.users.find(user =&gt; user.id === id);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>组件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;User with ID 2: &#123;&#123; userStore.getUserById(2)?.name &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useUserStore &#125; from &#x27;../stores/user&#x27;;<br><br>const userStore = useUserStore();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="D7C6T">Actions</h5><p><code>actions</code> 用于定义修改 <code>state</code> 的方法，它类似于 Vue 组件中的方法。<code>actions</code> 可以包含同步或异步操作，比如数据的获取、状态的更新等。</p><hr><p>在使用 <code>defineStore</code> 创建 store 时，可以通过 <code>actions</code> 选项来定义行为。<code>actions</code> 是一个对象，其中每个属性都是一个函数，在函数内部可以使用 <code>this</code> 来访问 <code>state</code>、<code>getters</code> 以及其他 <code>actions</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br><br>export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        count: 0<br>    &#125;),<br>    actions: &#123;<br>        // 同步：增加计数<br>        increment() &#123;<br>            this.count++;<br>        &#125;,<br>        // 同步：减少计数<br>        decrement() &#123;<br>            this.count--;<br>        &#125;,<br>        // 带参数的同步：将计数增加指定的值<br>        incrementBy(value) &#123;<br>            this.count += value;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>组件中，可以直接调用 store 中的 <code>actions</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;Count: &#123;&#123; counterStore.count &#125;&#125;&lt;/p&gt;<br>        &lt;button @click=&quot;counterStore.increment&quot;&gt;Increment&lt;/button&gt;<br>        &lt;button @click=&quot;counterStore.decrement&quot;&gt;Decrement&lt;/button&gt;<br>        &lt;button @click=&quot;counterStore.incrementBy(5)&quot;&gt;Increment by 5&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useCounterStore &#125; from &#x27;../stores/counter&#x27;;<br><br>const counterStore = useCounterStore();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p><code>actions</code> 可以包含异步操作，比如发起网络请求。在 <code>actions</code> 中使用 <code>async/await</code> 语法可以方便地处理异步逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br>import axios from &#x27;axios&#x27;;<br><br>export const useUserStore = defineStore(&#x27;user&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        user: null,<br>        isLoading: false,<br>        error: null<br>    &#125;),<br>    actions: &#123;<br>        async fetchUser() &#123;<br>            this.isLoading = true;<br>            this.error = null;<br>            try &#123;<br>                const response = await axios.get(&#x27;https://api.example.com/user&#x27;);<br>                this.user = response.data;<br>            &#125; catch (error) &#123;<br>                this.error = error.message;<br>            &#125; finally &#123;<br>                this.isLoading = false;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;div v-if=&quot;userStore.isLoading&quot;&gt;Loading...&lt;/div&gt;<br>        &lt;div v-else-if=&quot;userStore.error&quot;&gt;&#123;&#123; userStore.error &#125;&#125;&lt;/div&gt;<br>        &lt;div v-else&gt;<br>            &lt;p&gt;User Name: &#123;&#123; userStore.user?.name &#125;&#125;&lt;/p&gt;<br>            &lt;button @click=&quot;userStore.fetchUser&quot;&gt;Fetch User&lt;/button&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; useUserStore &#125; from &#x27;../stores/user&#x27;;<br><br>const userStore = useUserStore();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><hr><p>在一个 <code>action</code> 中可以调用同一个 store 中的其他 <code>actions</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br><br>export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        count: 0<br>    &#125;),<br>    actions: &#123;<br>        increment() &#123;<br>            this.count++;<br>        &#125;,<br>        incrementTwice() &#123;<br>            this.increment();<br>            this.increment();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><code>actions</code> 可以返回值，这在需要处理异步操作的结果或者链式调用 <code>actions</code> 时非常有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; defineStore &#125; from &#x27;pinia&#x27;;<br>import axios from &#x27;axios&#x27;;<br><br>export const useUserStore = defineStore(&#x27;user&#x27;, &#123;<br>    state: () =&gt; (&#123;<br>        user: null<br>    &#125;),<br>    actions: &#123;<br>        async fetchUser() &#123;<br>            try &#123;<br>                const response = await axios.get(&#x27;https://api.example.com/user&#x27;);<br>                this.user = response.data;<br>                return response.data;<br>            &#125; catch (error) &#123;<br>                console.error(&#x27;Error fetching user:&#x27;, error);<br>                return null;<br>            &#125;<br>        &#125;,<br>        async fetchUserAndLog() &#123;<br>            const user = await this.fetchUser();<br>            if (user) &#123;<br>                console.log(&#x27;Fetched user:&#x27;, user);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包管理工具</title>
    <link href="/2025/03/01/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/03/01/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 的包管理工具是管理项目依赖的核心，常见的工具包括 <strong>npm</strong>、<strong>Yarn</strong> 和 <strong>pnpm</strong>等</p><h6 id="Zos5l">npm</h6><ul><li><strong>定位</strong>：Node.js 官方包管理器，生态最成熟，跟随 Node.js 安装。</li><li><strong>核心功能</strong>：<ul><li>安装、更新、删除依赖（<code>dependencies</code> 和 <code>devDependencies</code>）。</li><li>通过 <code>package.json</code> 管理项目元数据和脚本。</li><li>支持全局安装（<code>npm install -g</code>）和本地安装。</li></ul></li><li><strong>依赖存储结构</strong>：<ul><li><strong>嵌套结构</strong>（旧版）：依赖层层嵌套，导致 <code>node_modules</code> 体积庞大。</li><li><strong>扁平化结构</strong>（v3+）：提升重复依赖到顶层，减少体积，但可能引发版本冲突。</li></ul></li><li><strong>常见命令</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm init                  # 初始化项目（生成 package.json）<br>npm init -y                  # 初始化项目默认yes（生成 package.json）<br>npm install               # 安装所有依赖<br>npm install &lt;pkg&gt; -g      # 全局安装所有依赖<br>npm install &lt;pkg&gt;         # 安装生产依赖<br>npm install &lt;pkg&gt; --save-dev/-D  # 安装开发依赖<br>npm list &lt;pkg&gt;   # 列出安装包信息,无&lt;pkg&gt;列出本地所有<br>npm uninstall &lt;pkg&gt;       # 卸载依赖<br>npm uninstall &lt;pkg&gt; -g# 全局卸载依赖<br>npm update &lt;pkg&gt;          # 更新依赖<br>npm info &lt;package-name&gt;   # 查看远程仓库包信息<br>npm audit                 # 检查安全漏洞<br>npm publish               # 发布包到 npm 仓库<br>npm run &lt;script&gt;# 执行 package 配置文件的 script 脚本<br></code></pre></td></tr></table></figure><ul><li><strong>锁文件</strong>：<code>package-lock.json</code>，记录依赖树和精确版本，确保安装一致性。</li><li>**缓存管理 :**npm 会将下载的包缓存到本地，以提高后续安装的速度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm config get cache  # 查看缓存目录<br>npm cache clean --force  # 清除缓存<br></code></pre></td></tr></table></figure><ul><li><strong>配置管理</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm config list    # 查看配置<br>npm config set &lt;key&gt; &lt;value&gt;  # 设置配置项<br>npm config get &lt;key&gt;    # 获取配置项<br>npm config delete &lt;key&gt;   # 删除配置项<br></code></pre></td></tr></table></figure><ul><li><strong>npm i 原理</strong></li></ul><p><img src="1740818851464-26ed664f-923c-4746-893d-87c068a4ca0d.png"></p><h6 id="lBLRo">npx</h6><ul><li><strong>定位</strong>：npm 的附属工具，用于<strong>临时执行</strong>包命令，无需全局安装。并不是一个真正的包管理工具，而是 npm 5.2.0 引入的一个命令行工具</li><li><strong>核心功能</strong>：<ul><li>直接<strong>运行****本地</strong>或<strong>远程</strong>的包（如 <code>npx create-react-app</code>）。<ul><li>直接执行远程 npm 包，而无需事先将其安装到本地</li><li>要执行本地安装的包的命令，需要使用相对复杂的路径，而 npx 简化了这个过程</li></ul></li><li>执行不同版本的包（如 <code>npx node@14 -v</code>）。</li><li>避免全局安装污染环境。</li></ul></li><li><strong>执行原理</strong>:当你运行 <code>npx &lt;command&gt;</code> 时，npx 会按照以下步骤工作：<ol><li><strong>检查本地可执行文件</strong>：首先，npx 会检查当前项目的 <code>node_modules/.bin</code> 目录中是否存在对应的可执行文件。如果存在，它会直接执行该文件。</li><li><strong>检查全局安装的包</strong>：如果本地 <code>node_modules/.bin</code> 目录中没有找到可执行文件，npx 会检查全局安装的包中是否有该命令。</li><li><strong>临时下载并执行</strong>：如果在本地和全局都没有找到对应的包，npx 会从 npm 注册表中临时下载该包到一个临时目录，然后执行其中的可执行文件。执行完成后，临时下载的包会被删除。</li></ol></li><li><strong>常用命令</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 运行本地已安装的包<br>npx eslint .<br><br># 临时运行远程包（未安装时自动下载并执行）<br>npx create-react-app my-app<br><br># 指定版本运行<br>npx webpack@4.44.1<br></code></pre></td></tr></table></figure><ul><li><strong>与 npm 的关系</strong>：<ul><li><code>npm run</code> 运行 <code>package.json</code> 中的脚本。</li><li><code>npx</code> 直接执行包的可执行文件。</li></ul></li></ul><h6 id="Azt52">package.json配置文件</h6><ul><li><strong>作用</strong>：项目元数据、依赖管理、脚本定义。</li><li><strong>核心字段</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;name&quot;: &quot;my-project&quot;,       // 包名（必填）<br>  &quot;version&quot;: &quot;1.0.0&quot;,         // 版本号（必填）<br>  &quot;description&quot;: &quot;项目描述&quot;,<br>  &quot;main&quot;: &quot;index.js&quot;,         // 入口文件<br>  &quot;scripts&quot;: &#123;                // 自定义脚本<br>    &quot;start&quot;: &quot;node index.js&quot;,<br>    &quot;build&quot;: &quot;webpack --mode production&quot;<br>  &#125;,<br>  &quot;dependencies&quot;: &#123;          // 生产依赖（如 React）<br>    &quot;react&quot;: &quot;^18.2.0&quot;<br>  &#125;,<br>  &quot;devDependencies&quot;: &#123;       // 开发依赖（如 ESLint）<br>    &quot;eslint&quot;: &quot;^8.30.0&quot;<br>  &#125;,<br>  &quot;peerDependencies&quot;: &#123;      // 同伴依赖（如插件依赖 Webpack）<br>    &quot;webpack&quot;: &quot;^5.0.0&quot;<br>  &#125;,<br>  &quot;engines&quot;: &#123;               // 环境要求<br>    &quot;node&quot;: &quot;&gt;=16.0.0&quot;,<br>    &quot;npm&quot;: &quot;&gt;=7.0.0&quot;<br>  &#125;,<br>  &quot;workspaces&quot;: [            // Monorepo 工作区（Yarn/pnpm）<br>    &quot;packages/*&quot;             //这里 packages/* 表示 packages 目录下的所有子目录都是工作区。使用工作区可以方便地在不同子项目之间共享依赖，并且可以一次性安装所有子项目的依赖<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>项目元数据</strong><ul><li><code>**name**</code>：项目的名称，必须是唯一的，只能包含小写字母、数字、连字符和下划线，不能包含空格。</li><li><code>**version**</code>：项目的版本号，遵循语义化版本号规则（MAJOR.MINOR.PATCH），例如 <code>1.2.3</code>。</li><li><code>**description**</code>：项目的简要描述，通常用于在 npm 仓库中展示。</li><li><code>**keywords**</code>：项目的关键词数组，有助于其他开发者在搜索时找到该项目。</li><li><code>**author**</code>：项目的作者信息，可以是字符串（如 <code>&quot;John Doe&quot;</code>）或对象</li><li><code>**license**</code>：项目的开源许可证，如 <code>&quot;MIT&quot;</code>、<code>&quot;Apache-2.0&quot;</code> 等。</li><li><code>**private**</code>：如果设置为 <code>true</code>，则该项目不能被发布到 npm 仓库，通常用于私有项目。</li></ul></li><li><strong>入口文件</strong><ul><li><code>**main**</code>：指定项目的入口文件，当其他项目引入该项目时，默认会加载该文件。</li></ul></li><li>** 脚本命令**<ul><li><code>**scripts**</code>：一个对象，用于定义项目的脚本命令。例如，<code>&quot;start&quot;: &quot;node index.js&quot;</code> 定义了一个名为 <code>start</code> 的脚本，通过 <code>npm run start</code> 或 <code>yarn start</code> 可以执行该脚本。常见的脚本命令还有 <code>test</code>、<code>build</code> 等。</li></ul></li><li><strong>依赖管理</strong><ul><li><code>**dependencies**</code>：项目生产环境的依赖项，这些依赖是项目运行所必需的。例如，<code>&quot;express&quot;: &quot;^4.17.1&quot;</code> 表示项目依赖 <code>express</code> 包，并且版本要求是 <code>4.x.x</code> 系列的最新版本。</li><li><code>**devDependencies**</code>：项目开发环境的依赖项，这些依赖仅在开发和测试阶段使用，如测试框架、构建工具等。</li><li><strong>关联文件:</strong><code>**package-lock.json**</code>** 或 **<code>**yarn.lock**</code>：这些文件用于锁定依赖包的版本，确保在不同环境中安装的依赖版本一致。<code>npm</code> 会自动生成 <code>package-lock.json</code>，<code>yarn</code> 会自动生成 <code>yarn.lock</code>。</li></ul></li><li><strong>版本语法</strong>（SemVer）：<ul><li><code>^1.2.3</code>：允许次版本号和补丁号更新（<code>1.x.x</code>）。</li><li><code>~1.2.3</code>：仅允许补丁号更新（<code>1.2.x</code>）。</li><li><code>1.2.3</code>：固定版本。</li></ul></li></ul><h6 id="eI2jz">yarn</h6><ul><li><strong>定位</strong>：由 Facebook 推出的高性能包管理器，解决早期 npm 的痛点。如安装速度慢、版本不一致等</li><li><strong>核心特性</strong>：<ul><li><strong>并行下载</strong>：依赖安装速度更快。</li><li><strong>确定性安装</strong>：通过 <code>yarn.lock</code> 确保依赖一致性。</li><li><strong>工作区（Workspaces）</strong>：原生支持 Monorepo。</li><li><strong>离线模式</strong>：利用缓存离线安装依赖。</li></ul></li><li><strong>常用命令</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">yarn init                 # 初始化项目<br>yarn add &lt;pkg&gt;            # 安装生产依赖<br>yarn add &lt;pkg&gt; -D         # 安装开发依赖<br>yarn global add &lt;pkg&gt;# 全局安装依赖<br>yarn remove &lt;pkg&gt;         # 卸载依赖<br>yarn global remove &lt;pkg&gt;# 全局卸载依赖<br>yarn upgrade &lt;pkg&gt;        # 更新依赖<br>yarn why &lt;pkg&gt;            # 查看依赖被谁引入<br>yarn workspace &lt;pkg&gt; &lt;cmd&gt; # Monorepo 中运行子包命令<br>yarn &lt;script&gt;             # 执行 package 中的 script 脚本<br>yarn cache clean# 清除缓存<br>yarn install              # 安装依赖<br></code></pre></td></tr></table></figure><h6 id="RvW9d">pnpm</h6><p><strong>硬链接和软连接</strong></p><ul><li><strong>硬链接</strong>(hard link)是电脑文件系统中的多个文件平等地共享同一个文件存储单元 , 删除一个文件名字后，还可以用其它名字继续访问该文件;</li><li>**符号链接(**软链接、Symbolic link)是一类特殊的文件 , 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用</li></ul><hr><p><strong>pnpm</strong></p><ul><li><strong>定位</strong>：高效、节省磁盘的包管理器，通过硬链接和符号链接复用依赖。</li><li><strong>核心原理</strong>：<ul><li><strong>全局存储（Store）</strong>：<ul><li>所有依赖包统一存储在本地磁盘的全局目录（如 <code>~/.pnpm-store</code>）。</li><li>通过 <strong>硬链接（Hard Link）</strong> 复用相同的依赖文件，避免重复下载。</li></ul></li><li><strong>符号链接（Symlink）</strong>：<ul><li>项目的 <code>node_modules</code> 目录中仅包含直接依赖，子依赖通过符号链接指向全局存储。</li><li>严格隔离依赖树，解决“幽灵依赖”问题（未声明的依赖不可访问）。</li></ul></li></ul></li></ul><hr><p><strong>依赖解析流程</strong></p><ol><li><strong>下载依赖</strong>：首次安装时，依赖包下载到全局存储。</li><li><strong>硬链接创建</strong>：项目中通过硬链接复用全局存储的文件（节省磁盘空间）。</li><li><strong>符号链接组织</strong>：<code>node_modules</code> 中通过符号链接指向全局存储的依赖，形成严格的依赖树。</li></ol><p><img src="1740840040590-c934bf65-d976-4c1c-ad61-6782cb89c054.png"></p><hr><ul><li><strong>常用命令</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">pnpm init                  # 初始化项目<br>pnpm add &lt;pkg&gt;             # 安装生产依赖<br>pnpm add -D &lt;pkg&gt;          # 安装开发依赖<br>pnpm remove &lt;pkg&gt;          # 卸载依赖<br>pnpm update                # 更新所有依赖<br>pnpm update &lt;pkg&gt;          # 更新指定依赖<br>pnpm install               # 安装所有依赖（等同于 pnpm i）<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">pnpm why &lt;pkg&gt;             # 查看依赖被谁引入<br>pnpm list                  # 查看项目依赖树<br>pnpm outdated              # 检查过时的依赖<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">pnpm store path            # 查看全局存储路径<br>pnpm store prune           # 清理未使用的依赖<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">pnpm run &lt;script&gt;          # 运行 package.json 中的脚本<br>pnpm dlx &lt;pkg&gt;             # 临时执行远程包（类似 npx）<br></code></pre></td></tr></table></figure><hr><p><strong>1. 独特的存储机制</strong></p><p>pnpm 使用硬链接和符号链接来管理 <code>node_modules</code>。它将包存储在全局存储中，当项目需要某个包时，会在项目的 <code>node_modules</code> 目录中创建指向全局存储中该包的硬链接和符号链接，而不是将包完整地复制到每个项目的 <code>node_modules</code> 中。这种方式带来了以下优势：</p><ul><li><strong>节省磁盘空间</strong>：避免了相同包在不同项目中重复安装，大大减少了磁盘空间的占用。例如，多个项目都依赖 <code>lodash</code>，只需要在全局存储中存储一份 <code>lodash</code> 包，各个项目通过链接引用即可。</li><li><strong>安装速度快</strong>：由于不需要重复下载和复制相同的包，pnpm 的安装速度通常比 npm 和 yarn 更快，尤其是在处理大型项目和复杂依赖关系时，优势更为明显。</li></ul><p><strong>2. 依赖隔离与一致性</strong></p><p>pnpm 能够更好地实现依赖隔离，确保每个项目使用的依赖版本是一致的。它会严格按照 <code>pnpm-lock.yaml</code> 文件（类似于 <code>package-lock.json</code> 或 <code>yarn.lock</code>）中的版本信息进行安装，避免了因版本不一致导致的问题。</p><p><strong>3. 扁平化依赖管理</strong></p><p>pnpm 对依赖进行了更有效的扁平化处理，使得 <code>node_modules</code> 目录结构更加清晰，减少了依赖嵌套过深带来的问题。</p><hr>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>包管理工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript高级</title>
    <link href="/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/"/>
    <url>/2025/02/25/JavaScript%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h4><h5 id="this绑定的三种方式"><a href="#this绑定的三种方式" class="headerlink" title="this绑定的三种方式"></a>this绑定的三种方式</h5><ol><li>默认绑定:独立调用,this指向window</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// &quot;use strict&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//普通函数的独立调用,window</span></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo的this&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">foo</span>()</span><br><span class="language-javascript">        <span class="hljs-comment">//定义在对象中,独立调用,window</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> obj=&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">bar</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar的this&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> baz=obj.<span class="hljs-property">bar</span></span><br><span class="language-javascript">        <span class="hljs-title function_">baz</span>()</span><br><span class="language-javascript">        <span class="hljs-comment">//函数互相调用,window</span></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params">fn</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">fn</span>()</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">foo1</span>(baz)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//在严格模式下,独立调用函数的this,为undefined</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>隐式绑定,通过某个对象进行调用的,this指向调用对象</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//隐式绑定</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> obj=&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;obj&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bar</span>:foo</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj.<span class="hljs-title function_">bar</span>()</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>new绑定,this指向创建的空对象(函数当做一个类的构造函数来使用，也就是使用new关键字)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;script&gt;<br>    /* <br>    1.创建空对象<br>    2.将this指向空对象,将函数的显式原型赋值给对象的隐式原型<br>    3.执行函数体的代码<br>    4.无显示返回非空对象时,会默认显示这个对象<br>     */<br><br>     function foo()&#123;<br>        console.log(&#x27;foo&#x27;,this);<br>        this.name=&#x27;MirZ&#x27;<br>     &#125;<br>     new foo()<br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ol><li>显式绑定,this指向要绑定的对象</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">var</span> obj=&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;MirZ&#x27;</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-comment">//将foo函数的this指向obj,使用call/apply</span></span><br><span class="language-javascript">   foo.<span class="hljs-title function_">call</span>(obj)</span><br><span class="language-javascript">   foo.<span class="hljs-title function_">apply</span>(obj)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h5><p><strong>call&#x2F;apply</strong></p><p>如果我们不希望在对象内部包含这个函数的引用同时又希望在这个对象上进行强制调用可以使用call和apply方法</p><ul><li>第一个参数传入指定绑定的对象;</li><li>后面的参数，apply为数组，call为参数列表;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo调用&#x27;</span>, <span class="hljs-variable language_">this</span>);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;参数&#x27;</span>, name, age);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> obj=&#123;&#125;</span><br><span class="language-javascript">        <span class="hljs-comment">//使用call/apply,将foo函数指向obj</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.apply(obj)</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.call(obj)</span></span><br><span class="language-javascript">        <span class="hljs-comment">//传入原始类型,会指向原始类型封装的对应包装类型对象</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.call(123)</span></span><br><span class="language-javascript">        <span class="hljs-comment">// foo.apply(&#x27;Mir&#x27;)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">//传参</span></span><br><span class="language-javascript">        foo.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;MirZ&#x27;</span>, <span class="hljs-number">18</span>)</span><br><span class="language-javascript">        foo.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&#x27;1&#x27;</span>,[<span class="hljs-string">&#x27;MirZ&#x27;</span>,<span class="hljs-number">18</span>])</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>bind</strong></p><p>如果我们希望一个函数总是显示的绑定到一个对象上，可以使用bind绑定函数</p><ul><li>使用bind方法，bind()方法创建一个新的绑定函数(bound function，BF)</li><li>绑定函数是一个 exotic function object(怪异函数对象，ECMAScript 2015 中的术语)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;script&gt;<br>        function foo(name, age) &#123;<br>            console.log(&#x27;foo调用&#x27;, this);<br>            console.log(&quot;参数&quot;,name,age);<br>            <br>        &#125;<br>        var obj=&#123;&#125;<br>        //需求:调用foo时，总是绑定到obj对象身上<br>        // var bar=foo.bind(obj) //yhis-&gt;obj<br>        // bar()<br>        // bar()<br>        // bar()<br>        //传参<br>        var bar=foo.bind(obj,&#x27;Mir&#x27;)<br>        bar()<br>        bar(18)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h5><ul><li>默认规则的优先级最低,存在其他规则时，就会通过其他规则的方式绑定this</li><li>显示绑定优先级高于隐式绑定</li><li>new绑定优先级高于隐式绑定</li><li>new绑定优先级高于bind<ul><li>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</li><li>new绑定可以和bind一起使用，new绑定优先级更高</li><li>bind和apply&#x2F;call同时使用,bind优先级更高</li></ul></li></ul><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁:</p><ul><li>箭头函数不会绑定this、arguments属性,</li><li>箭头函数不能作为构造函数来使用(不能和new一起来使用，会抛出错误):</li></ul><p>箭头函数的简写</p><ul><li>优化一: 如果只有一个参数()可以省略</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><ul><li>优化二: 如果函数执行体中只有一行代码,那么可以省略大括号并且这行代码的返回值会作为整个函数的返回值</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">nums.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item))<br>nums.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><ul><li>优化三: 如果函数执行体只有返回一个对象，那么需要给这个对象加上()</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> foo=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-keyword">return</span>&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;abc&quot;</span>&#125;<br><span class="hljs-keyword">var</span>. bar=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;abc&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>*<em>箭头函数不使用this的四种标准规则(也就是不绑定this)，而是根据*<em><strong>外层作用域</strong></em></em>来决定this.**</p><p><strong>this指向面试题:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><br><span class="hljs-comment">// &#123;&#125; -&gt; 对象</span><br><span class="hljs-comment">// &#123;&#125; -&gt; 代码块</span><br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person1&#x27;</span>,<br>  <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-attr">foo2</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-attr">foo3</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">foo4</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// console.log(this) // 第一个表达式this -&gt; person1</span><br>    <span class="hljs-comment">// console.log(this) // 第二个表达式this -&gt; person2</span><br>    <span class="hljs-comment">// console.log(this) // 第三个表达式this -&gt; person1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;person2&#x27;</span> &#125;<br><br><br><span class="hljs-comment">// 开始题目:</span><br>person1.<span class="hljs-title function_">foo1</span>(); <span class="hljs-comment">// 隐式绑定: person1</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo2</span>(); <span class="hljs-comment">// 上层作用域: window</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// 上层作用域: window</span><br><br>person1.<span class="hljs-title function_">foo3</span>()(); <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo4</span>()(); <span class="hljs-comment">// person1</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)(); <span class="hljs-comment">// person2</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2); <span class="hljs-comment">// person1</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  1.创建一个空的对象</span><br><span class="hljs-comment">  2.将这个空的对象赋值给this</span><br><span class="hljs-comment">  3.执行函数体中代码</span><br><span class="hljs-comment">  4.将这个新的对象默认返回</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// person1/person都是对象(实例instance)</span><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br><br><span class="hljs-comment">// 面试题目:</span><br>person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// 隐式绑定: person1</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">// 上层作用域查找: person1</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 上层作用域查找: person1</span><br><br>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">// 上层作用域查找: person1(隐式绑定)</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">//  上层作用域查找: person2(显式绑定)</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 上层作用域查找: person1(隐式绑定)</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  1.创建一个空的对象</span><br><span class="hljs-comment">  2.将这个空的对象赋值给this</span><br><span class="hljs-comment">  3.执行函数体中代码</span><br><span class="hljs-comment">  4.将这个新的对象默认返回</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    <span class="hljs-attr">foo1</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">foo2</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person1&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;person2&#x27;</span>)<br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>()() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// 默认绑定: window</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo1</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 显式绑定: person2</span><br><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>()() <span class="hljs-comment">// 上层作用域查找: obj(隐式绑定)</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// 上层作用域查找: person2(显式绑定)</span><br>person1.<span class="hljs-property">obj</span>.<span class="hljs-title function_">foo2</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// 上层作用域查找: obj(隐式绑定)</span><br></code></pre></td></tr></table></figure><h4 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h4><h5 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h5><p><strong>浏览器渲染页面过程:</strong> </p><p><a href="https://www.yuque.com/wudibawanglong-gbppc/frgahd/cet8sqz7nv0gkvda">浏览器渲染原理</a></p><p>在解析JS是堵塞也往往会带来新的问题，特别是现代页面开发中:</p><p>目前的开发模式中(比如Vue、React)，脚本往往比HTML页面更“重”处理时间需要更长所以会造成页面的解析阻塞，在脚本下载、执行完成之前，用户在界面上什么都看不到;</p><p>为了解决这个问题，script元素给我们提供了两个属性(attribute):defer和async。</p><p><strong>defer</strong></p><p>defer 属性告诉浏览器不要等待脚本下载，而继续解析HTML，构建DOM Tree</p><ul><li>脚本会由浏览器来进行下载，但是不会阻塞DOM Tree的构建过程;</li><li>如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码</li></ul><p>多个带defer的脚本是可以保持正确的顺序执行的。</p><p>从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中;</p><p>注意:defer仅适用于外部脚本，对于script默认内容会被忽略</p><p><strong>async</strong></p><p>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。</p><p>async是让一个脚本完全独立的:</p><ul><li>浏览器不会因 async 脚本而阻塞(与 defer 类似);</li><li>async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本</li><li>async不会能保证在DOMContentLoaded之前或者之后执行</li></ul><p>:::info defer通常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求的;</p><p>async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的;</p><p>:::</p><h4 id="Js原理"><a href="#Js原理" class="headerlink" title="Js原理"></a>Js原理</h4><h5 id="JS执行原理"><a href="#JS执行原理" class="headerlink" title="JS执行原理"></a>JS执行原理</h5><p><strong>初始化全局对象</strong></p><p>js引擎会在执行代码之前，会在堆内存中创建一个**全局对象:**GlobalObject(GO)</p><p>该对象所有的作用域(scope)都可以访问;里面会包含Date、Array、String、Number、setTimeout、setlnterval等等.其中还有一个window属性指向自己</p><p><strong>全局代码如何被执行?</strong></p><p>js引擎内部有一个<strong>执行上下文栈</strong>(Execution Context Stack，简称ECS)它是用于<strong>执行代码的调用栈</strong></p><p>那么现在它要执行谁呢?执行的是全局的代码块</p><ul><li>全局的代码块为了执行会构建一个 Global Execution Context(GEC)</li><li>GEC会 被放入到ECS中执行;</li></ul><p>每一个执行上下文会关联一个<strong>VO(Variable Object，变量对象)*</strong>*,**<strong>变量和函数声明</strong>会被添加到这个VO对象中</p><p><strong>当全局代码被执行的时候，VO就是GO对象了</strong></p><p>GEC被放入到ECS中里面包含两部分内容:</p><ul><li>第一部分:在代码执行前，在parser转成AST的过程中，会将全局定义的变量、函数等加入等加入到GlobalObject中，但是并不会赋值;<ul><li>这个过程也称之为变量的作用域提升(hoisting)</li></ul></li><li>第二部分:在代码执行中，对变量赋值，或者执行其他的函数;</li></ul><p><strong>函数如何被执行?</strong></p><p>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文(FunctionalExecutionContext，简称FEC)并且压入到<strong>EC Stack</strong>中。</p><p>因为每个执行上下文都会关联一个VO，那么函数执行上下文关联的VO是什么呢?</p><ul><li>当进入一个函数执行上下文时，会创建一个AO对象(Activation Object)</li><li>这个AO对象会使用arguments作为初始化，并且初始值是传入的参数;</li><li>这个AO对象会作为执行上下文的VO来存放变量的初始化;</li></ul><p><strong>作用域链</strong></p><p>当进入到一个执行上下文时，执行上下文也会关联一个作用域链(Scope Chain)</p><p>作用域链是一个对象列表，用于变量标识符的求值;当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    // 1.面试题一:<br>    // var n = 100<br>    // function foo() &#123;<br>    //   n = 200<br>    // &#125;<br>    // foo()<br><br>    // console.log(n)<br><br>    // 2.面试题二:<br>    // var n = 100<br>    // function foo() &#123;<br>    //   console.log(n)<br>    //   var n = 200<br>    //   console.log(n)<br>    // &#125;<br><br>    // foo()<br><br>    // 3.面试题三:<br>    // var n = 100<br><br>    // function foo1() &#123;<br>    //   console.log(n)<br>    // &#125;<br>    // function foo2() &#123;<br>    //   var n = 200<br>    //   console.log(n)<br>    //   foo1()<br>    // &#125;<br>    // foo2()<br><br>    // 4.面试题四:<br>    // var n = 100<br>    // function foo() &#123;<br>    //   console.log(n) <br>    //   return<br>    //   var n = 200   //var a是在编译解析阶段,已经声明,return是在执行阶段结束<br>    // &#125;<br>    // foo()<br><br>    // 5.在开发中可能会出现这样错误的写法<br>    // function foo() &#123;<br>    //   message = &quot;Hello World&quot; //没有声明,会被放到全局<br>    // &#125;<br>    // foo()<br>    // console.log(message)<br><br>    // 6.面试题五:<br>    function foo() &#123;<br>      var a = b = 100<br>    &#125;<br>    foo()<br>    console.log(b)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>词法环境是一种规范类型，用于在词法嵌套结构中定义关联的变量、函数等标识符;</strong></p><p>一个词法环境是由环境记录(Environment Record)和一个外部词法环境(oute;rLexicalEnvironment)组成:</p><p>一个词法环境经常用于关联一个函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出来;</p><p><strong>全局词法环境</strong></p><p>全局词法环境是最外层的词法环境，它在 JavaScript 程序开始执行时就被创建，并且在整个程序的生命周期内都存在。全局词法环境的外部引用为 <code>null</code>。</p><p><strong>函数词法环境</strong></p><p>每当调用一个函数时，就会为该函数创建一个新的词法环境。函数词法环境的外部引用指向创建该函数时所在的词法环境。</p><p><img src="1740029840980-ac7611b5-e2ba-41e7-be31-28ae8c61ca8e.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">- <span class="hljs-title class_">LexicalEnvironment</span>用于处理<span class="hljs-keyword">let</span>、<span class="hljs-keyword">const</span>声明的标识符<br>- <span class="hljs-title class_">VariableEnyionment</span>用于处理<span class="hljs-keyword">var</span>和<span class="hljs-keyword">function</span>声明的标识符:<br></code></pre></td></tr></table></figure><p><strong>环境记录</strong></p><p>在这个规范中有两种主要的环境记录值:声明式环境记录和对象环境记录。</p><ul><li>声明式环境记录:声明性环境记录用于定义ECMAScript语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定</li><li>对象式环境记录:对象环境记录用于定义ECMAScript元素的效果，例如WithStatement，它将标识符绑定与某些对象的属</li></ul><p>关联起来。</p><h5 id="JS内存管理"><a href="#JS内存管理" class="headerlink" title="JS内存管理"></a>JS内存管理</h5><p>不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要我们自己手动的管理内存,某些编程语言会可以自动帮助我们管理内存:</p><p>不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期:</p><ul><li>第一步:分配申请你需要的内存(申请);</li><li>第二步:使用分配的内存(存放一些东西，比如对象等);</li><li>第三步:不需要使用时，对其进行释放;</li></ul><p>不同的编程语言对于第一步和第三步会有不同的实现:</p><ul><li>手动管理内存:比如C、C++，包括早期的OC都是需要手动来管理内存的申请和释放的(malloc和free函数)</li><li>自动管理内存:比如Java、JavaScript、Python、Swift、Dart等，它们有自动帮助我们管理内存;</li></ul><p>对于开发者来说，JavaScript的内存管理是自动的、无形的。我们创建的原始值、对象、函数.…这一切都会占用内存,但是我们并不需要手动来对它们进行管理JavaScript引l擎会帮助我们处理好它;</p><p>JavaScript会在定义数据时为我们分配内存。</p><ul><li>JS对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配;</li><li>JS对于复杂数据类型内存分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用;</li></ul><h6 id="JS的垃圾回收机制"><a href="#JS的垃圾回收机制" class="headerlink" title="JS的垃圾回收机制"></a>JS的垃圾回收机制</h6><p>** **因为内存的大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放，以便腾出更多的内存空间。</p><p>在手动管理内存的语言中，我们需要通过一些方式自己来释放不再需要的内存，比如free函数:</p><ul><li>这种管理的方式其实非常的低效，影响我们编写逻辑的代码的效率，</li><li>这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露，</li></ul><p>所以大部分现代的编程语言都是有自己的垃圾回收机制:</p><p>垃圾回收的英文是Garbage Collection，简称GC;对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间;而我们的语言运行环境，比如java的运行环境IM，JavaScript的运行环境js引擎都会内存 垃圾回收器</p><p><strong>GC算法-标记-清除算法</strong></p><p>标记-清除是最基础的垃圾回收算法。它的工作原理如下</p><p>标记清除的核心思路是可达性,这个算法是设置根对象(root object)垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象</p><ul><li>标记阶段：垃圾回收器会遍历所有的对象，从根对象（如全局对象）开始，将所有可达对象标记为活动的。</li><li>清除阶段：对于那些没有被标记为活动的对象，垃圾回收器会将其内存释放。</li></ul><p>优点</p><ul><li>可靠性：确保所有不再需要的对象都会被正确回收。</li><li>简单性：实现相对简单，易于维护。</li></ul><p>缺点</p><ul><li>暂停程序执行：在垃圾回收期间需要暂停程序执行（Stop-the-world），可能会影响性能。</li><li>遍历整个对象图：需要遍历整个对象图，处理大对象图时效率较低。</li></ul><p><strong>GC算法-引用计数</strong></p><p>引用计数是一种较早的垃圾回收算法。它的工作原理如下：</p><p>计数：每个对象维护一个引用计数器，用于记录有多少其他对象引用它。</p><ul><li>增加引用：当有一个新的引用指向该对象时，计数器加1。</li><li>减少引用：当一个引用不再指向该对象时，计数器减1。</li></ul><p>释放内存：当计数器变为0时，该对象可以被回收，因为没有任何引用指向它。</p><p>优点</p><ul><li>即时回收：一旦对象的引用计数变为0，可以立即回收，不需要等待垃圾回收的周期。</li><li>简单：实现相对简单，不需要复杂的标记和清除过程。</li></ul><p>缺点</p><ul><li>循环引用问题：如果两个对象互相引用，即使它们没有其他引用指向它们，引用计数器永远不会变为0，从而导致内存泄漏。</li><li>性能开销：每次引用增加或减少都需要更新计数器，会带来一定的性能开销。</li></ul><p><strong>GC算法-分代收集</strong></p><p>分代收集基于对象的生命周期假设：大多数对象是短命的，少数对象是长命的。它将堆内存划分为两代：新生代和老年代。</p><ul><li>新生代：存放生命周期短的对象。垃圾回收器会频繁地检查并清理新生代，因为新对象的创建和销毁非常频繁。</li><li>老年代：存放生命周期长的对象。垃圾回收器对老年代的检查和清理频率较低，因为这些对象大多长期存在。</li></ul><p>优点</p><ul><li>效率高：新生代对象的清理操作较为快速，整体垃圾回收效率高。</li><li>减少暂停时间：新生代的清理操作时间较短，减少了程序暂停时间。</li></ul><p>缺点</p><ul><li>复杂性：实现和维护较为复杂，需要有效区分和管理新生代和老年代对象。</li><li>内存占用：需要更多的内存来维护新生代和老年代的分代结构。</li></ul><p><strong>V8 的垃圾回收机制</strong></p><p>V8 使用了分代垃圾回收，结合了标记-清除、标记-压缩和增量标记（Incremental Marking）等技术。</p><p>标记-清除：对新生代对象进行快速标记和清除。</p><p>标记-压缩：对老年代对象进行标记和压缩，以减少内存碎片。</p><p>增量标记：将垃圾回收过程拆分成多个小步骤，穿插在正常的程序执行过程中，减少程序暂停时间。</p><p>闲时收集: 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</p><h5 id="JS闭包"><a href="#JS闭包" class="headerlink" title="JS闭包"></a>JS闭包</h5><h6 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h6><p>在计算机科学中对闭包的定义(维基百科):</p><ul><li>闭包(英语:Closure)，又称<strong>词法闭包</strong>(LexicalClosure)或<strong>函数闭包</strong>(function closures);</li><li>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术;</li><li>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境((相当于一个符号查找表):</li><li>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行。</li></ul><p>MDN对JavaScript闭包的解释:</p><p>一个函数和对其周围状态(<strong>lexical environment</strong>，<strong>词法环境</strong>)的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是<strong>闭包</strong>(cosure)也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域;在JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来;</p><ul><li>一个普通函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包;</li><li>从广义的角度来说:Javascript中的函数都是闭包;</li><li>从狭义的角度来说:Javascript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包;</li></ul><h6 id="闭包的访问过程"><a href="#闭包的访问过程" class="headerlink" title="闭包的访问过程"></a>闭包的访问过程</h6><p><strong>作用域链（Scope Chain）</strong></p><ul><li><strong>定义</strong>：作用域链是 JavaScript 中变量查找的机制。每个函数在执行时都会创建一个作用域链，这个链由当前执行上下文的变量对象（Variable Object）和所有外层（父级）执行上下文的变量对象组成。</li><li><strong>作用</strong>：当访问一个变量时，JavaScript 引擎会沿着作用域链<strong>逐层向上查找</strong>变量，直到找到变量或到达全局作用域（若未找到则报错）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function outer() &#123;<br>  const a = 10;<br>  function inner() &#123;<br>    console.log(a); // 通过作用域链找到 outer 中的 a<br>  &#125;<br>  inner();<br>&#125;<br>outer(); // 输出 10<br></code></pre></td></tr></table></figure><p>在 <code>inner</code> 函数中访问 <code>a</code> 时，作用域链会依次查找 <code>inner</code> → <code>outer</code> → 全局作用域。</p><p><strong>2. 闭包（Closure）</strong></p><ul><li><strong>定义</strong>：闭包是函数能够访问其词法作用域外的变量的能力，即使这个函数在其词法作用域外被调用。闭包的实现依赖于作用域链。</li><li><strong>本质</strong>：闭包是作用域链的一种应用结果。当一个函数引用了外层作用域的变量，且该函数被传递到其他作用域执行时，闭包会保留对外层作用域的引用，从而避免变量被垃圾回收。</li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function outer() &#123;<br>  const a = 10;<br>  return function inner() &#123;<br>    console.log(a); // 闭包保留了对外层 a 的引用<br>  &#125;;<br>&#125;<br>const innerFunc = outer();<br>innerFunc(); // 输出 10（即使 outer 已执行完毕，仍能访问 a）<br></code></pre></td></tr></table></figure><p>这里，<code>inner</code> 函数通过闭包保留了 <code>outer</code> 的作用域，即使 <code>outer</code> 已经执行完毕。</p><p><strong>3. 区别与联系</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>作用域链</strong></th><th><strong>闭包</strong></th></tr></thead><tbody><tr><td><strong>角色</strong></td><td>变量查找的规则和路径</td><td>基于作用域链实现的一种现象（函数保留对外层作用域的引用）</td></tr><tr><td><strong>存在时机</strong></td><td>函数执行时自动创建</td><td>当函数引用了外层变量，并在其他作用域被调用时形成</td></tr><tr><td><strong>内存管理</strong></td><td>作用域链在函数执行完毕后通常会被销毁（除非有闭包）</td><td>闭包会导致外层作用域的变量对象无法被垃圾回收，可能引起内存泄漏</td></tr><tr><td><strong>核心目的</strong></td><td>确定变量的可访问性</td><td>让函数“记住”并访问其词法作用域外的变量</td></tr></tbody></table><p><strong>总结</strong></p><ul><li><strong>作用域链是底层机制</strong>，决定了变量如何被查找。</li><li><strong>闭包是上层现象</strong>，是作用域链在特定场景（函数跨作用域执行）下的表现。</li><li>可以说，闭包的实现依赖于作用域链，但两者不是同一个概念。</li></ul><h6 id="内存泄漏及释放内存"><a href="#内存泄漏及释放内存" class="headerlink" title="内存泄漏及释放内存"></a>内存泄漏及释放内存</h6><p><strong>内存泄漏（Memory Leak）</strong> 指的是程序运行过程中不再需要的内存没有被及时释放，导致内存占用持续增长，最终可能引发性能问题甚至程序崩溃。</p><p><strong>二、常见内存泄漏场景及解决方案</strong></p><p>以下是 JavaScript 中常见的内存泄漏场景及其解决方法：</p><p><strong>1. 意外的全局变量</strong></p><p><strong>问题</strong>：未使用 <code>var</code>&#x2F;<code>let</code>&#x2F;<code>const</code> 声明的变量会成为全局变量，无法被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">function leak() &#123;<br>  globalVar = &quot;I am a global variable!&quot;; // 意外创建全局变量<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解决</strong>：始终使用 <code>&#39;use strict&#39;</code> 严格模式，或显式声明变量。</li></ul><p><strong>2. 未清理的定时器（Timers）或回调函数</strong></p><p><strong>问题</strong>：<code>setInterval</code> 或事件监听未及时清除，导致回调函数及其依赖的变量无法释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const intervalId = setInterval(() =&gt; &#123;<br>  // 长期运行的定时器<br>&#125;, 1000);<br><br>// 未调用 clearInterval(intervalId) 会导致内存泄漏<br></code></pre></td></tr></table></figure><ul><li><strong>解决</strong>：在不需要时手动清除定时器或事件监听。</li></ul><p><strong>3. 闭包滥用</strong></p><p><strong>问题</strong>：闭包保留了对外部变量的引用，导致外部作用域的变量无法释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createClosure() &#123;<br>  const largeData = new Array(1000000).fill(&quot;data&quot;);<br>  return function() &#123;<br>    // 闭包引用了 largeData，即使不再需要，largeData 也无法被回收<br>  &#125;;<br>&#125;<br>const closure = createClosure();<br></code></pre></td></tr></table></figure><ul><li><strong>解决</strong>：在闭包中避免保留不必要的大对象，或在不需要时手动解除引用（如 <code>closure = null</code>）。</li></ul><p><strong>4. 未释放的 DOM 引用</strong></p><p><strong>问题</strong>：保留对已移除 DOM 元素的引用，导致 DOM 元素无法被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const elements = &#123;<br>  button: document.getElementById(&quot;myButton&quot;),<br>&#125;;<br><br>// 即使从页面移除了按钮，elements.button 仍保留引用<br>document.body.removeChild(document.getElementById(&quot;myButton&quot;));<br></code></pre></td></tr></table></figure><ul><li><strong>解决</strong>：在移除 DOM 元素后，手动解除引用（如 <code>elements.button = null</code>）。</li></ul><p><strong>5. 事件监听未移除</strong></p><p><strong>问题</strong>：为 DOM 元素添加事件监听后未移除，导致元素无法被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const button = document.getElementById(&quot;myButton&quot;);<br>button.addEventListener(&quot;click&quot;, handleClick);<br><br>// 未调用 removeEventListener 会导致元素和事件处理函数无法释放<br></code></pre></td></tr></table></figure><ul><li><strong>解决</strong>：在移除元素前手动移除事件监听。</li></ul><h4 id="函数增强"><a href="#函数增强" class="headerlink" title="函数增强"></a>函数增强</h4><h5 id="函数的arguments和剩余参数"><a href="#函数的arguments和剩余参数" class="headerlink" title="函数的arguments和剩余参数"></a>函数的arguments和剩余参数</h5><p>在 JavaScript 中，<code>** arguments **</code> 是函数内部的一个特殊对象，用于表示函数被调用时传入的所有参数（无论是否在形参列表中声明）。</p><ul><li><strong>类数组对象</strong>：<code>arguments</code> 是一个类数组对象（Array-like Object），具有数字索引和 <code>length</code> 属性，但<strong>不支持数组方法</strong>（如 <code>push</code>、<code>map</code> 等）。</li><li><strong>动态绑定</strong>：<code>arguments</code> 的内容会随着函数参数的变化而动态更新（非严格模式下）。</li><li><strong>非箭头函数独有</strong>：箭头函数（Arrow Function）没有自己的 <code>arguments</code> 对象。</li></ul><p><strong>类数组转数组</strong></p><p>如果需要使用数组方法，需将 <code>arguments</code> 转换为真正的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function logArgs() &#123;<br>  //使用 slice截取<br>  //const newArr=Array.prototype.slice.apply(arguments)<br>  // 使用 Array.from() 或扩展运算符<br>  const argsArray = Array.from(arguments);<br>  // 或者 const argsArray = [...arguments];<br><br>  argsArray.forEach(arg =&gt; console.log(arg));<br>&#125;<br>logArgs(&quot;a&quot;, &quot;b&quot;); // 输出 &quot;a&quot;, &quot;b&quot;<br></code></pre></td></tr></table></figure><p><strong>严格模式下的行为</strong></p><p>在严格模式（<code>&#39;use strict&#39;</code>）中，<code>arguments</code> 与形参<strong>解耦</strong>，修改 <code>arguments</code> 不会影响形参，反之亦然：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">function strictExample(a, b) &#123;<br>  &#x27;use strict&#x27;;<br>  arguments[0] = 100;<br>  console.log(a); // 输出原始的 a 值（非严格模式下会输出 100）<br>&#125;<br>strictExample(1, 2);<br></code></pre></td></tr></table></figure><p>**  **<code>** arguments **</code> <strong>与箭头函数</strong></p><p>箭头函数没有自己的 <code>arguments</code> 对象，但可以访问外层函数的 <code>arguments</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">function outer() &#123;<br>  const inner = () =&gt; &#123;<br>    console.log(arguments); // 输出 outer 的 arguments<br>  &#125;;<br>  inner();<br>&#125;<br>outer(1, 2); // 输出 &#123; 0: 1, 1: 2 &#125;<br></code></pre></td></tr></table></figure><p><strong>替代方案：剩余参数（Rest Parameters）</strong></p><p>ES6 引入了 <strong>剩余参数（</strong><code>** ...args **</code><strong>）</strong>，它是真正的数组，更推荐使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function sum(...args) &#123;<br>  return args.reduce((acc, val) =&gt; acc + val, 0);<br>&#125;<br>console.log(sum(1, 2, 3)); // 输出 6<br></code></pre></td></tr></table></figure><p><strong>优势对比：</strong></p><table><thead><tr><th><strong>特性</strong></th><th><code>**arguments**</code></th><th><strong>剩余参数（</strong><code>**...args**</code><br><strong>）</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>类数组对象</td><td>真正的数组</td></tr><tr><td><strong>与形参的绑定</strong></td><td>动态绑定（非严格模式）</td><td>独立</td></tr><tr><td><strong>箭头函数支持</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>可读性</strong></td><td>低（隐式传递参数）</td><td>高（显式声明参数）</td></tr></tbody></table><h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p><strong>纯函数的维基百科定义:</strong></p><p>在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数:</p><ul><li>此函数在相同的输入值时，需产生相同的输出。</li><li>函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I&#x2F;0设备产生的外部输出无关。</li><li>该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。</li></ul><p>:::tips 计算机科学中，也引用了副作用的概念，表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响,比如修改了全局变量，修改参数或者改变外部的存储;</p><p>:::</p><p><strong>纯函数作用</strong></p><ul><li>在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改;</li><li>输入内容不会被任意篡改，并且确定的输入，一定会有确定的输出;</li></ul><p>:::tips React中就要求我们无论是函数还是class声明一个组件，这个组件都必须像纯函数一样，保护它们的props不被修改</p><p>:::</p><h5 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h5><p><strong>函数柯里化定义</strong></p><p>在计算机科学中，柯里化(英语:Currying)，又译为卡瑞化或加里化:</p><ul><li>是把接收多个参数的函数变成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数，而且返回结果的新函数的技术;</li><li>柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数</li></ul><p>柯里化箭头函数写法:<code>var foo=x=&gt;y=&gt;z=&gt;console.log(x + y + z)</code></p><p><strong>自动柯里化函数</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y, z</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y + z)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> num1 + num2</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">logInfo</span>(<span class="hljs-params">date, type, message</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`时间:<span class="hljs-subst">$&#123;date&#125;</span> 类型:<span class="hljs-subst">$&#123;type&#125;</span> 内容:<span class="hljs-subst">$&#123;message&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 手动转化</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 封装函数: 自动转化柯里化过程(有一点难度)</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hyCurrying</span>(<span class="hljs-params">fn</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">curryFn</span>(<span class="hljs-params">...args</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 两类操作:</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 第一类操作: 继续返回一个新的函数, 继续接受参数</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 第二类操作: 直接执行fn的函数</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= fn.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">// 执行第二类</span></span><br><span class="language-javascript">          <span class="hljs-comment">// return fn(...args)</span></span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)</span><br><span class="language-javascript">        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 执行第一类</span></span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// return curryFn(...args.concat(newArgs))</span></span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> curryFn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(newArgs))</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> curryFn</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 对其他的函数进行柯里化</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> fooCurry = <span class="hljs-title function_">hyCurrying</span>(foo)</span><br><span class="language-javascript">    <span class="hljs-title function_">fooCurry</span>(<span class="hljs-number">10</span>)(<span class="hljs-number">20</span>)(<span class="hljs-number">30</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">fooCurry</span>(<span class="hljs-number">55</span>, <span class="hljs-number">12</span>, <span class="hljs-number">56</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> sumCurry = <span class="hljs-title function_">hyCurrying</span>(sum)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> sum5 = <span class="hljs-title function_">sumCurry</span>(<span class="hljs-number">5</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum5</span>(<span class="hljs-number">10</span>))</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum5</span>(<span class="hljs-number">15</span>))</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum5</span>(<span class="hljs-number">18</span>))</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> logInfoCurry = <span class="hljs-title function_">hyCurrying</span>(logInfo)</span><br><span class="language-javascript">    <span class="hljs-title function_">logInfoCurry</span>(<span class="hljs-string">&quot;2022-06-01&quot;</span>)(<span class="hljs-string">&quot;DEBUG&quot;</span>)(<span class="hljs-string">&quot;我发现一个bug, 哈哈哈哈&quot;</span>)</span><br><span class="language-javascript"> </span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 第一步对数字*2</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">num</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 第二步对数字**2</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">num</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> num ** <span class="hljs-number">2</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 封装的函数: 你传入多个函数, 我自动的将多个函数组合在一起挨个调用</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">composeFn</span>(<span class="hljs-params">...fns</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1.边界判断(edge case)</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> length = fns.<span class="hljs-property">length</span></span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span></span><br><span class="language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> fn = fns[i]</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`index position <span class="hljs-subst">$&#123;i&#125;</span> must be function`</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 2.返回的新函数</span></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> result = fns[<span class="hljs-number">0</span>].<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">var</span> fn = fns[i]</span><br><span class="language-javascript">          result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [result])</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> result</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> newFn = <span class="hljs-title function_">composeFn</span>(double, pow, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFn</span>(<span class="hljs-number">100</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFn</span>(<span class="hljs-number">55</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFn</span>(<span class="hljs-number">22</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(newFn(100))</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(newFn(55))</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(newFn(22))</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>JavaScript 的严格模式（Strict Mode）是 ES5 引入的重要特性，通过限制某些不安全或易出错的语法，提升代码的安全性和可维护性。以下是严格模式的核心要点：</p><h6 id="启用方式"><a href="#启用方式" class="headerlink" title="启用方式"></a>启用方式</h6><ol><li><strong>全局启用</strong>：在脚本或 <code>&lt;script&gt;</code> 标签的<strong>最顶部</strong>添加 <code>&quot;use strict&quot;;</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>// 整个脚本遵循严格模式<br></code></pre></td></tr></table></figure><ol><li><strong>函数作用域启用</strong>：在函数体的<strong>最顶部</strong>添加 <code>&quot;use strict&quot;;</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function strictFunc() &#123;<br>  &quot;use strict&quot;;<br>  // 函数内部遵循严格模式<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="核心变化与限制"><a href="#核心变化与限制" class="headerlink" title="核心变化与限制"></a>核心变化与限制</h6><p><strong>1. 变量必须声明</strong></p><ul><li>未声明的变量赋值会报错（非严格模式会隐式创建全局变量）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>x = 10; // ReferenceError: x is not defined<br></code></pre></td></tr></table></figure><p><strong>2. 禁止重复参数</strong></p><ul><li>函数参数名不可重复。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>function dupParam(a, a) &#123; &#125; // SyntaxError: Duplicate parameter name<br></code></pre></td></tr></table></figure><p><strong>3. 禁用</strong> <code>** with **</code> <strong>语句</strong></p><ul><li><code>with</code> 会导致作用域混乱，严格模式直接禁用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>with (obj) &#123; &#125; // SyntaxError: Strict mode code may not include a with statement<br></code></pre></td></tr></table></figure><p><strong>4. 只读属性不可修改</strong></p><ul><li>对只读属性（如 <code>Object.prototype</code>）赋值会报错。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>Object.prototype = &#123;&#125;; // TypeError: Cannot assign to read-only property<br></code></pre></td></tr></table></figure><p><strong>5. 不可删除不可配置的属性</strong></p><ul><li>删除变量、函数或不可配置的属性会报错。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>delete Object.prototype; // TypeError: Cannot delete property &#x27;prototype&#x27;<br></code></pre></td></tr></table></figure><p><strong>6.</strong> <code>** arguments **</code> <strong>对象限制</strong></p><ul><li><code>arguments</code> 与形参解耦，修改互不影响。</li><li>禁用 <code>arguments.callee</code> 和 <code>arguments.caller</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>function func(a) &#123;<br>  arguments[0] = 100;<br>  console.log(a); // 非严格模式输出 100，严格模式输出原值<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7.</strong> <code>** this **</code> <strong>的默认值为</strong> <code>** undefined **</code></p><ul><li>普通函数调用时，<code>this</code> 不再指向全局对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>function test() &#123;<br>  console.log(this); // undefined（非严格模式为 window）<br>&#125;<br>test();<br>test.apply(&#x27;123&#x27;) //&#x27;123&#x27; (非严格模式为对应的包装对象)<br>test()<br></code></pre></td></tr></table></figure><p><strong>8. 保留字限制</strong></p><ul><li>不可使用 <code>implements</code>, <code>interface</code>, <code>let</code>, <code>yield</code> 等作为变量名。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>let interface = 10; // SyntaxError: Unexpected strict mode reserved word<br></code></pre></td></tr></table></figure><p><strong>9.</strong> <code>** eval **</code> <strong>独立作用域</strong></p><ul><li><code>eval</code> 内部声明的变量不会泄露到外部。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>eval(&quot;var x = 10;&quot;);<br>console.log(x); // ReferenceError: x is not defined<br></code></pre></td></tr></table></figure><p><strong>10. 八进制字面量语法</strong></p><ul><li>禁止使用旧式 <code>0</code> 前缀的八进制，必须用 <code>0o</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>let num = 0123; // SyntaxError: Octal literals are not allowed<br>let correct = 0o123; // 正确写法<br></code></pre></td></tr></table></figure><p><strong>11. 对象字面量重复属性</strong></p><ul><li>ES5 严格模式禁止重复属性（ES6 已放宽此限制）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;use strict&quot;;<br>let obj = &#123; a: 1, a: 2 &#125;; // ES5 严格模式报错，ES6 不报错<br></code></pre></td></tr></table></figure><h6 id="严格模式的优势"><a href="#严格模式的优势" class="headerlink" title="严格模式的优势"></a>严格模式的优势</h6><ul><li><strong>减少隐藏错误</strong>：通过报错暴露潜在问题（如变量未声明）。</li><li><strong>优化代码</strong>：帮助引擎优化执行（如固定作用域）。</li><li><strong>兼容未来语法</strong>：保留关键字为 ES6+ 铺路（如 <code>class</code>, <code>let</code>）。</li></ul><p><strong>注意事项</strong></p><ul><li>旧代码启用严格模式需逐步迁移，避免报错。</li><li>合并脚本时，若全局启用严格模式，需确保合并后的脚本开头无非严格代码。</li></ul><h4 id="对象增强"><a href="#对象增强" class="headerlink" title="对象增强"></a>对象增强</h4><h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><p>JavaScript 中的属性描述符用于定义或描述对象属性的特性，分为<strong>数据属性</strong>和<strong>访问器属性</strong>两种类型。以下是关键点总结：</p><p><strong>1. 属性描述符的组成</strong></p><ul><li><strong>数据属性</strong>：包含以下特性：<ul><li><code>value</code>：属性的值。</li><li><code>writable</code>：是否可修改值（默认为<code>false</code>，若通过赋值创建则默认为<code>true</code>）。</li><li><code>enumerable</code>：是否可被枚举（如 <code>for...in</code> 或 <code>Object.keys</code>，默认为<code>false</code>）。</li><li><code>configurable</code>：是否可删除属性或修改特性（默认为<code>false</code>）。</li></ul></li><li><strong>访问器属性</strong>：包含 <code>get</code> 和 <code>set</code> 函数：<ul><li><code>get()</code>：读取属性时调用。</li><li><code>set(value)</code>：写入属性时调用。</li><li>不能与 <code>value</code> 或 <code>writable</code> 共存。</li></ul></li></ul><p><strong>2. 获取属性描述符</strong></p><ul><li><code>Object.getOwnPropertyDescriptor(obj, &#39;prop&#39;)</code>：获取对象<strong>自身属性</strong>的描述符。</li><li><code>Object.getOwnPropertyDescriptors(obj)</code>：获取对象所有自身属性的描述符。</li></ul><p><strong>3. 定义&#x2F;修改属性</strong></p><ul><li><code>Object.defineProperty(obj, &#39;prop&#39;, descriptor)</code>：定义单个属性。</li><li><code>Object.defineProperties(obj, descriptors)</code>：批量定义属性。</li><li><strong>默认值</strong>：若未显式设置，<code>writable</code>、<code>enumerable</code>、<code>configurable</code> 默认为 <code>false</code>。</li></ul><p><strong>4. 特性规则</strong></p><ul><li><code>** configurable: false **</code>：<ul><li>禁止删除属性。</li><li>禁止修改除 <code>writable</code> 以外的特性（<code>writable</code> 仅允许从 <code>true</code> 改为 <code>false</code>）。</li></ul></li><li><code>** writable: false **</code>：禁止通过赋值修改值（严格模式报错）。</li><li><code>** enumerable: false **</code>：属性不会出现在 <code>for...in</code> 或 <code>Object.keys</code> 中。</li></ul><p><strong>5. 示例</strong></p><p><strong>数据属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123;&#125;;<br>Object.defineProperty(obj, &#x27;a&#x27;, &#123;<br>  value: 1,<br>  writable: true,<br>  enumerable: true,<br>  configurable: true<br>&#125;);<br><br>// 修改为不可写<br>Object.defineProperty(obj, &#x27;a&#x27;, &#123; writable: false &#125;);<br>obj.a = 2; // 静默失败（严格模式报错）<br></code></pre></td></tr></table></figure><p><strong>访问器属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">Object.defineProperty(obj, &#x27;fullName&#x27;, &#123;<br>  get() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;,<br>  set(value) &#123; [this.firstName, this.lastName] = value.split(&#x27; &#x27;); &#125;,<br>  enumerable: true,<br>  configurable: true<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>6. 默认行为</strong></p><p><strong>通过赋值创建的属性</strong>：<code>writable</code>、<code>enumerable</code>、<code>configurable</code> 默认为 <code>true</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; a: 1 &#125;;<br>const desc = Object.getOwnPropertyDescriptor(obj, &#x27;a&#x27;);<br>// &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;<br></code></pre></td></tr></table></figure><p><strong>通过</strong> <code>** defineProperty **</code> <strong>创建的属性</strong>：未指定的特性默认为 <code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Object.defineProperty(obj, &#x27;b&#x27;, &#123; value: 2 &#125;);<br>const desc = Object.getOwnPropertyDescriptor(obj, &#x27;b&#x27;);<br>// &#123; value: 2, writable: false, enumerable: false, configurable: false &#125;<br></code></pre></td></tr></table></figure><p><strong>7. 实用方法</strong></p><ul><li><code>Object.freeze(obj)</code>：设置所有属性为 <code>writable: false</code> 且 <code>configurable: false</code>。</li><li><code>Object.seal(obj)</code>：设置所有属性为 <code>configurable: false</code>，但保留 <code>writable</code>。</li><li><code>Object.preventExtensions(obj)</code>：不允许对象添加新属性(严格模式报错)</li></ul><p><strong>总结</strong></p><p>属性描述符允许精确控制对象属性的行为，适用于实现不可变性、隐藏内部属性或定义动态计算的属性（如访问器）。使用时需注意特性之间的依赖关系（如 <code>configurable</code> 的限制），避免潜在错误。</p><h4 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h4><h5 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h5><p>JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。当我们通过引用对象的属性key来获取一个value时，它会触发[[Get]]的操作:这个操作会首先检查该对象是否有对应的属性，如果有的话就使用它;如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性</p><p><strong>获取原型方式:</strong></p><ul><li>方式一:通过对象的_proto 属性可以获取到(但是这个是早期浏览器自己添加的，存在一定的兼容性问题)</li><li>方式二:通过 Object.getPrototypeOf 方法可以获取到;</li></ul><h5 id="函数原型prototype-显式原型"><a href="#函数原型prototype-显式原型" class="headerlink" title="函数原型prototype(显式原型)"></a>函数原型prototype(显式原型)</h5><p>每个函数都有一个 <code>prototype</code> 属性，它是一个对象，用于实现基于构造函数的继承。使用 <code>new</code> 关键字调用函数创建对象时，新对象的 <code>[[Prototype]]</code> 会指向该函数的 <code>prototype</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一：使用对象字面量创建对象</span><br><span class="hljs-keyword">const</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 方式二：使用构造函数创建对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">runing</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>obj2.<span class="hljs-title function_">runing</span>()<br><br><span class="hljs-comment">// 查看对象的原型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>函数原型上的constructor</strong></p><p>事实上原型对象上面是有一个属性的:constructor ,默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br>    // 非常重要的属性: constructor, 指向Person函数对象<br>    function Person() &#123;<br><br>    &#125;<br><br>    // 1.对constructor在prototype上的验证<br>    var PersonPrototype = Person.prototype<br>    console.log(PersonPrototype)<br>    console.log(PersonPrototype.constructor)<br>    console.log(PersonPrototype.constructor === Person)<br><br>    console.log(Person.name)<br>    console.log(PersonPrototype.constructor.name)<br><br>    // 2.实例对象p<br>    var p = new Person()<br>    console.log(p.__proto__.constructor)<br>    console.log(p.__proto__.constructor.name)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p> 面向对象有三大特性:<strong>封装、继承、多态</strong></p><ul><li>封装:我们前面将属性和方法封装到一个类中，可以称之为封装的过程;</li><li>继承:继承是面向对象中非常重要的，不仅仅可以减少重复代码的数量，也是多态前提(纯面向对象中);</li><li>多态:不同的对象在执行时表现出不同的形态;</li></ul><h6 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h6><p>首先，原型链是JavaScript实现继承的机制，对吧？每个对象都有一个原型对象，而原型对象也可能有它自己的原型，这样一层层链接起来就形成了原型链。当访问一个对象的属性时，如果对象本身没有这个属性，就会沿着原型链向上查找，直到找到或者到达原型链的末端（null）。这是原型链的基本概念。</p><p><strong>一、默认原型链</strong></p><p><strong>对象字面量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">let obj = &#123;&#125;;<br>// 原型链：obj -&gt; Object.prototype -&gt; null<br>- ` obj.__proto__ === Object.prototype `<br>- ` Object.prototype.__proto__ === null `<br></code></pre></td></tr></table></figure><p><strong>构造函数创建对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Person() &#123;&#125;<br>let person = new Person();<br>// 原型链：person -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br>- ` person.__proto__ === Person.prototype `<br>- ` Person.prototype.__proto__ === Object.prototype `<br></code></pre></td></tr></table></figure><p><strong>函数的原型链</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Foo() &#123;&#125;<br>// 原型链：Foo -&gt; Function.prototype -&gt; Object.prototype -&gt; null<br>- ` Foo.__proto__ === Function.prototype `<br>- ` Function.prototype.__proto__ === Object.prototype `<br></code></pre></td></tr></table></figure><p><strong>二、自定义原型链</strong></p><p><strong>使用</strong> <code>** Object.create **</code></p><p><code>Object.create()</code> 方法创建一个新对象，该对象继承自指定的原型对象。通过这种方式，<code>proto</code> 对象就拥有了 <code>Parent</code> 构造函数原型上的所有属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const parent = &#123; name: &quot;parent&quot; &#125;;<br>const child = Object.create(parent);<br>// 原型链：child -&gt; parent -&gt; Object.prototype -&gt; null<br>- ` child.__proto__ === parent `<br></code></pre></td></tr></table></figure><p><strong>手动修改原型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Parent() &#123;&#125;<br>function Child() &#123;&#125;<br>Child.prototype = new Parent(); // 不推荐（可能调用父类构造函数两次）<br>Child.prototype.constructor = Child; // 修复 constructor<br></code></pre></td></tr></table></figure><p><strong>推荐方式：寄生组合继承</strong></p><p><code>call</code> 方法允许在指定的 <code>this</code> 值和参数的情况下调用函数。通过这种方式，<code>Child</code> 对象可以继承 <code>Parent</code> 对象的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">function inheritPrototype(Child, Parent) &#123;<br>  const proto = Object.create(Parent.prototype);<br>  proto.constructor = Child;<br>  Child.prototype = proto;<br>&#125;<br>//或者使用 Object.defineProperty设置constructor<br>//function inheritPrototype(Child, Parent) &#123;<br>        //     Child.prototype=Object.create(Parent.prototype)<br>        //     Object.defineProperty(Child.prototype,&#x27;constructor&#x27;,&#123;<br>        //         enumerable:false,<br>        //         configurable:true,<br>        //         writable:true,<br>        //         value:Child<br>        //     &#125;)<br>        // &#125;<br></code></pre></td></tr></table></figure><p><strong>三、继承的实现</strong></p><p><strong>组合继承（借用构造函数 + 原型链）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Parent(name) &#123;<br>  this.name = name;<br>&#125;<br>Parent.prototype.sayName = function() &#123; console.log(this.name) &#125;;<br><br>function Child(name, age) &#123;<br>  Parent.call(this, name);  // 继承属性<br>  this.age = age;<br>&#125;<br>Child.prototype = new Parent();     // 继承方法（不推荐）<br>Child.prototype.constructor = Child;<br></code></pre></td></tr></table></figure><p><strong>寄生组合继承（优化版）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function Child(name, age) &#123;<br>  Parent.call(this, name);<br>  this.age = age;<br>&#125;<br>inheritPrototype(Child, Parent); // 使用上述工具函数<br></code></pre></td></tr></table></figure><p><strong>ES6</strong> <code>** class **</code> <strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Parent &#123;<br>  constructor(name) &#123; this.name = name; &#125;<br>  sayName() &#123; console.log(this.name) &#125;<br>&#125;<br><br>class Child extends Parent &#123;<br>  constructor(name, age) &#123;<br>    super(name); // 必须先调用 super()<br>    this.age = age;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h6 id="对象原型判断方法"><a href="#对象原型判断方法" class="headerlink" title="对象原型判断方法"></a>对象原型判断方法</h6><ul><li>hasOwnProperty:对象是否有某一个属于自己的属性(不是在原型上的属性)</li><li>in&#x2F;for in 操作符:判断某个属性是否在某个对象或者对象的原型上</li><li>instanceof:用于检测构造函数(Person、Student类)的prototype是否出现在某个实例对象的原型链上</li><li>isPrototypeOf:用于检测某个对象，是否出现在某个实例对象的原型链上</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/inherit_utils.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> info = <span class="hljs-title function_">createObject</span>(obj)</span><br><span class="language-javascript">    info.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;中国&quot;</span></span><br><span class="language-javascript">    info.<span class="hljs-property">intro</span> = <span class="hljs-string">&quot;中国大好河山&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">name</span>, info.<span class="hljs-property">address</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.hasOwnProperty</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(info.hasOwnProperty(&quot;name&quot;)) // false</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(info.hasOwnProperty(&quot;address&quot;)) // true</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2.in操作符</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> info)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-keyword">in</span> info)</span><br><span class="language-javascript">    <span class="hljs-comment">// 注意: for in遍历不仅仅是自己对象上的内容, 也包括原型对象上的内容</span></span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> info) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 3.instanceof</span></span><br><span class="language-javascript">    <span class="hljs-comment">// instanceof用于判断对象和类(构造函数)之间的关系</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;&#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// stu实例(instance)对象</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>()</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Student</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 4.isPrototypeOf</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(stu))</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(stu))</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 可以用于判断对象之间的继承</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">isPrototypeOf</span>(info))</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="原型继承关系"><a href="#原型继承关系" class="headerlink" title="原型继承关系"></a>原型继承关系</h5><p><img src="1739109824352-f8b3988e-849b-4b9c-a57f-4e235b002cfb.png" alt="img"></p><p><strong>核心概念</strong></p><ol><li><strong>构造函数</strong>（如 <code>Foo</code>、<code>Object</code>）：通过 <code>new Function()</code> 创建的函数对象。</li><li><strong>原型对象</strong>（<code>prototype</code>）：每个构造函数都有一个 <code>prototype</code> 属性，指向其原型对象。</li><li><strong>实例对象</strong>（如 <code>f1</code>、<code>o1</code>）：通过 <code>new 构造函数()</code> 创建的对象。</li><li><strong>原型链</strong>：通过 <code>__proto__</code> 属性连接，形成对象的继承链。</li></ol><p>关键关系</p><ol><li><strong>构造函数与原型对象</strong>：<ul><li><strong>构造函数的*</strong>* **<code>** prototype **</code> 属性指向其原型对象（如 <code>Foo.prototype</code>）。</li><li><strong>原型对象的*</strong>* **<code>** constructor **</code> 属性指回构造函数（如 <code>Foo.prototype.constructor === Foo</code>）。</li></ul></li><li><strong>实例对象与原型链</strong>：<ul><li><strong>实例的*</strong>* **<code>** __proto__ **</code> 指向其构造函数的原型对象（如 <code>f1.__proto__ === Foo.prototype</code>）。</li><li><strong>原型链终点</strong>：所有原型链最终指向 <code>Object.prototype</code>，其 <code>__proto__</code> 为 <code>null</code>。</li></ul></li><li><strong>函数对象的特殊链</strong>：<ul><li><strong>构造函数的*</strong>* **<code>** __proto__ **</code> 指向 <code>Function.prototype</code>（如 <code>Foo.__proto__ === Function.prototype</code>）。</li><li><code>** Function **</code> ****<strong>自身</strong>：<code>Function.__proto__ === Function.prototype</code>（因为 <code>Function</code> 是自身的构造函数）。</li><li><code>** Function.prototype **</code> ****<strong>的原型</strong>：<code>Function.prototype.__proto__ === Object.prototype</code>。</li></ul></li></ol><p><strong>图示总结</strong></p><p><code>** Foo **</code> <strong>的继承链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">f1（实例） → Foo.prototype → Object.prototype → null<br>↑<br>Foo（构造函数） → Function.prototype → Object.prototype → null<br></code></pre></td></tr></table></figure><p><code>** Object **</code> <strong>的继承链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">o1（实例） → Object.prototype → null<br>↑<br>Object（构造函数） → Function.prototype → Object.prototype → null<br></code></pre></td></tr></table></figure><p><code>** Function **</code> ****<strong>的继承链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Function（构造函数） → Function.prototype → Object.prototype → null<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><strong>构造函数*</strong>* **<code>** prototype **</code>：定义原型，供实例继承。</li><li><strong>实例*</strong>* **<code>** __proto__ **</code>：顺着链找，继承属性和方法。</li><li><strong>函数皆*</strong>* <strong><code>\** Function \**</code></strong> **<strong>生</strong>：所有构造函数的 <code>__proto__</code> 指向 <code>Function.prototype</code>。</li><li><strong>终点</strong> <code>** Object.prototype **</code>：万物归宗，原型链尽头是 <code>null</code>。</li></ul><p><strong>通过这张图，可以清晰理解 JavaScript 中对象、构造函数、原型之间的层级关系与继承机制。</strong></p><p><img src="1739111638539-e85b5bdb-11ca-4ee9-ab9f-fcbcd1d9680d.png" alt="img"></p><h4 id="ES6新增特性"><a href="#ES6新增特性" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h4><h5 id="class定义类"><a href="#class定义类" class="headerlink" title="class定义类"></a>class定义类</h5><p>ES6 引入了 <code>class</code> 关键字，提供了更清晰的语法糖来实现面向对象编程，其底层仍基于原型继承。</p><h6 id="1-类定义与构造函数"><a href="#1-类定义与构造函数" class="headerlink" title="1. 类定义与构造函数"></a>1. 类定义与构造函数</h6><ul><li><strong>定义类</strong>：使用 <code>class</code> 关键字，后跟类名和 <code>&#123;&#125;</code>。</li><li><strong>构造函数</strong>：<code>constructor</code> 方法用于初始化实例，未显式定义则默认生成空构造函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Person &#123;<br>  constructor(name) &#123;<br>    this.name = name; // 实例属性<br>  &#125;<br>  sayHello() &#123;<br>    console.log(`Hello, $&#123;this.name&#125;!`);<br>  &#125;<br>&#125;<br>const alice = new Person(&quot;Alice&quot;);<br>alice.sayHello(); // Hello, Alice!<br></code></pre></td></tr></table></figure><p>当我们通过new关键字操作类的时候，会调用这个constructor函数，并且执行如下操作:</p><ul><li>1.在内存中创建一个新的对象(空对象);</li><li>2.这个对象内部的[[prototype]]属性会被赋值为该类的prototype属性;</li><li>3.构造函数内部的this，会指向创建出来的新对象;</li><li>4.执行构造函数的内部代码(函数体代码)</li><li>5.如果构造函数没有返回非空对象，则返回创建出来的新对象;</li></ul><h6 id="2-继承（extends-和-super）"><a href="#2-继承（extends-和-super）" class="headerlink" title="2. 继承（extends 和 super）"></a>2. 继承（extends 和 super）</h6><ul><li><strong>继承父类</strong>：通过 <code>extends</code> 实现继承。</li><li><strong>调用父类构造函数</strong>：子类构造函数必须调用 <code>super()</code> 后才能使用 <code>this</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Student extends Person &#123;<br>  constructor(name, grade) &#123;<br>    super(name);<br>    this.grade = grade;<br>  &#125;<br>  study() &#123;<br>    console.log(`$&#123;this.name&#125; is studying in grade $&#123;this.grade&#125;.`);<br>  &#125;<br>&#125;<br>const bob = new Student(&quot;Bob&quot;, 10);<br>bob.study(); // Bob is studying in grade 10.<br></code></pre></td></tr></table></figure><h6 id="3-静态方法与属性（static）"><a href="#3-静态方法与属性（static）" class="headerlink" title="3. 静态方法与属性（static）"></a>3. 静态方法与属性（static）</h6><ul><li><strong>静态成员</strong>：属于类本身，通过类名访问，实例无法调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">class MathUtils &#123;<br>  static PI = 3.14159; // 静态属性（ES2022+）<br>  static square(x) &#123;<br>    return x * x;<br>  &#125;<br>&#125;<br>console.log(MathUtils.square(5)); // 25<br></code></pre></td></tr></table></figure><h6 id="4-Getter-和-Setter"><a href="#4-Getter-和-Setter" class="headerlink" title="4. Getter 和 Setter"></a>4. Getter 和 Setter</h6><ul><li><strong>访问器属性</strong>：通过 <code>get</code> 和 <code>set</code> 定义，控制属性的读取和赋值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Circle &#123;<br>  constructor(radius) &#123;<br>    this._radius = radius;<br>  &#125;<br>  get area() &#123;<br>    return Math.PI * this._radius ** 2;<br>  &#125;<br>  set radius(value) &#123;<br>    if (value &gt; 0) this._radius = value;<br>  &#125;<br>&#125;<br>const c = new Circle(5);<br>console.log(c.area); // 78.54...<br>c.radius = 10; // 调用 setter<br></code></pre></td></tr></table></figure><h6 id="5-私有字段（ES2022-）"><a href="#5-私有字段（ES2022-）" class="headerlink" title="5. 私有字段（ES2022+）"></a>5. 私有字段（ES2022+）</h6><ul><li><strong>私有成员</strong>：以 <code>#</code> 开头，仅在类内部访问。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Counter &#123;<br>  #count = 0; // 私有字段<br>  increment() &#123;<br>    this.#count++;<br>  &#125;<br>  get value() &#123;<br>    return this.#count;<br>  &#125;<br>&#125;<br>const counter = new Counter();<br>counter.increment();<br>console.log(counter.value); // 1<br></code></pre></td></tr></table></figure><h6 id="6-类表达式"><a href="#6-类表达式" class="headerlink" title="6. 类表达式"></a>6. 类表达式</h6><ul><li><strong>匿名类</strong>：类可作为表达式赋值给变量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Animal = class &#123;<br>  constructor(name) &#123;<br>    this.name = name;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h6><ul><li><strong>无函数提升</strong>：类声明不会提升，需先定义后使用。</li><li><strong>方法无逗号</strong>：类方法间无需逗号分隔。</li><li><strong>原型方法</strong>：类方法定义在原型上，实例共享方法以节省内存。</li></ul><h6 id="总结对比（ES6-vs-ES5）"><a href="#总结对比（ES6-vs-ES5）" class="headerlink" title="总结对比（ES6 vs ES5）"></a>总结对比（ES6 vs ES5）</h6><table><thead><tr><th><strong>特性</strong></th><th><strong>ES6 Class</strong></th><th><strong>ES5 实现方式</strong></th></tr></thead><tbody><tr><td>定义</td><td><code>class MyClass &#123;&#125;</code></td><td>构造函数 <code>function MyClass() &#123;&#125;</code></td></tr><tr><td>继承</td><td><code>extends</code><br> 和 <code>super</code></td><td><code>prototype</code><br> 和 <code>Object.create</code></td></tr><tr><td>静态方法</td><td><code>static</code><br> 关键字</td><td>直接赋值：<code>MyClass.staticMethod</code></td></tr><tr><td>私有性（ES2022+）</td><td><code>#</code><br> 前缀</td><td>闭包或约定（如 <code>_name</code><br>）</td></tr></tbody></table><p>ES6 类语法更简洁直观，但本质仍是基于原型的继承，熟悉原型链有助于深入理解类的工作机制。</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态是面向对象编程中的一个概念,多态的定义应该是指同一个方法在不同对象中有不同的实现。也就是说，不同的对象可以对同一个方法调用做出不同的响应。JS中的多态可以通过两种方式实现：基于原型链继承的方法重写，以及基于类型的方法调用。这两种方式都允许不同对象对同一方法调用做出不同响应，体现了多态性。</p><p><strong>1. 基于原型链继承的方法重写（ES6类语法）</strong></p><p>通过继承父类并重写方法，子类实例调用方法时执行自身的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Animal &#123;<br>  speak() &#123;<br>    console.log(&#x27;动物叫&#x27;);<br>  &#125;<br>&#125;<br><br>class Dog extends Animal &#123;<br>  speak() &#123;<br>    console.log(&#x27;汪汪&#x27;); // 重写父类方法<br>  &#125;<br>&#125;<br><br>class Cat extends Animal &#123;<br>  speak() &#123;<br>    console.log(&#x27;喵喵&#x27;); // 重写父类方法<br>  &#125;<br>&#125;<br><br>const animals = [new Dog(), new Cat()];<br>animals.forEach(animal =&gt; animal.speak()); // 输出：汪汪 喵喵<br></code></pre></td></tr></table></figure><p><strong>2. 基于类型的灵活多态</strong></p><p>只要对象具有所需方法，无论是否继承同一父类，均可实现多态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">const duck = &#123;<br>  speak() &#123;<br>    console.log(&#x27;嘎嘎&#x27;); // 独立对象的方法<br>  &#125;<br>&#125;;<br><br>const robot = &#123;<br>  speak() &#123;<br>    console.log(&#x27;哔哔&#x27;); // 独立对象的方法<br>  &#125;<br>&#125;;<br><br>function makeSound(entity) &#123;<br>  entity.speak(); // 依赖鸭子类型<br>&#125;<br><br>makeSound(duck);  // 嘎嘎<br>makeSound(robot); // 哔哔<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><strong>继承与重写</strong>：子类覆盖父类方法，调用时根据实例类型执行对应方法。</li><li><strong>基于类型的灵活多态</strong>：关注对象是否具备方法而非继承关系，提升灵活性。</li><li><strong>动态特性</strong>：JavaScript的动态类型系统天然支持多态，无需显式接口定义。</li></ul><p><strong>优势</strong>：增强代码扩展性和复用性，新增类型时无需修改调用方代码，符合开闭原则。</p><h5 id="apply-call和bind的实现和封装"><a href="#apply-call和bind的实现和封装" class="headerlink" title="apply,call和bind的实现和封装"></a>apply,call和bind的实现和封装</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// new Function()</span></span><br><span class="language-javascript">    <span class="hljs-comment">// foo.__proto__ === Function.prototype</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>, name, age)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// foo函数可以通过apply/call</span></span><br><span class="language-javascript">    <span class="hljs-comment">// foo.apply(&quot;aaa&quot;, [&quot;why&quot;, 18])</span></span><br><span class="language-javascript">    <span class="hljs-comment">// foo.call(&quot;bbb&quot;, &quot;kobe&quot;, 30)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.封装思想</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.1.封装到独立的函数中</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">execFn</span>(<span class="hljs-params">thisArg, otherArgs, fn</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1.获取thisArg, 并且确保是一个对象类型</span></span><br><span class="language-javascript">      thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// thisArg.fn = this</span></span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, <span class="hljs-string">&quot;fn&quot;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: fn</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 执行代码</span></span><br><span class="language-javascript">      thisArg.<span class="hljs-title function_">fn</span>(...otherArgs)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.2. 封装原型中</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyexec</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 1.获取thisArg, 并且确保是一个对象类型</span></span><br><span class="language-javascript">      thisArg = (thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span>)? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// thisArg.fn = this</span></span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, <span class="hljs-string">&quot;fn&quot;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span></span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">      thisArg.<span class="hljs-title function_">fn</span>(...otherArgs)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.给函数对象添加方法: hyapply</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hyapply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hyexec</span>(thisArg, otherArgs)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">// 2.给函数对象添加方法: hycall</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hycall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hyexec</span>(thisArg, otherArgs)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hyapply</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span> &#125;, [<span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-number">25</span>])</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hyapply</span>(<span class="hljs-number">123</span>, [<span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>])</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hyapply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>])</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hycall</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span> &#125;, <span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-number">25</span>)</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hycall</span>(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>)</span><br><span class="language-javascript">    foo.<span class="hljs-title function_">hycall</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// apply/call</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, age, height, address</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>, name, age, height, address)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// Function.prototype</span></span><br><span class="language-javascript">    <span class="hljs-comment">// var newFoo = foo.bind(&#123; name: &quot;why&quot; &#125;, &quot;why&quot;, 18)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// newFoo(1.88)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 实现hybind函数</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hybind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...otherArgs</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// console.log(this) // -&gt; foo函数对象</span></span><br><span class="language-javascript">      thisArg = thisArg === <span class="hljs-literal">null</span> || thisArg === <span class="hljs-literal">undefined</span> ? <span class="hljs-attr">window</span>: <span class="hljs-title class_">Object</span>(thisArg)</span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(thisArg, <span class="hljs-string">&quot;fn&quot;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span></span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...newArgs</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// var allArgs = otherArgs.concat(newArgs)</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> allArgs = [...otherArgs, ...newArgs]</span><br><span class="language-javascript">        thisArg.<span class="hljs-title function_">fn</span>(...allArgs)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> newFoo = foo.<span class="hljs-title function_">hybind</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-number">30</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">newFoo</span>(<span class="hljs-number">1.88</span>, <span class="hljs-string">&quot;广州市&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="const和let"><a href="#const和let" class="headerlink" title="const和let"></a>const和let</h5><p>在JavaScript中，<code>const</code>和<code>let</code>是ES6引入的两种变量声明方式，提供了更清晰的变量作用域和更严格的语法规则，取代了传统的<code>var</code>。</p><p><strong>1. 作用域</strong></p><p><code>** let **</code> <strong>和</strong> <code>** const **</code> <strong>是块级作用域</strong>：   在<code>&#123;&#125;</code>（如<code>if</code>、<code>for</code>、函数等代码块）内部声明的变量，仅在块内有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (true) &#123;<br>  let a = 10;<br>  const b = 20;<br>&#125;<br>console.log(a); // 报错：a未定义<br>console.log(b); // 报错：b未定义<br></code></pre></td></tr></table></figure><ul><li><code>** var **</code> ****<strong>是函数作用域</strong>：   变量在整个函数内有效，容易导致变量泄漏到外部作用域。</li></ul><p><strong>2. 变量提升与暂时性死区（TDZ）</strong></p><p><strong>变量提升存在，但存在暂时性死区</strong>：   <code>let</code>和<code>const</code>声明的变量会提升到作用域顶部，但在声明前访问会触发<strong>TDZ</strong>（报错）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">console.log(a); // 报错（TDZ）<br>let a = 10;<br></code></pre></td></tr></table></figure><p><code>** var **</code> <strong>的变量提升</strong>：   <code>var</code>声明的变量会初始化为<code>undefined</code>，无TDZ。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">console.log(b); // 输出undefined<br>var b = 10;<br></code></pre></td></tr></table></figure><p><strong>3. 重复声明</strong></p><p><code>** let **</code> <strong>和</strong> <code>** const **</code> <strong>禁止重复声明</strong>：   同一作用域内不可重复声明同名变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">let x = 1;<br>let x = 2; // 报错：x已声明<br></code></pre></td></tr></table></figure><p><code>** var **</code> <strong>允许重复声明</strong>：   后续声明会覆盖前者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">var y = 1;<br>var y = 2; // 合法<br></code></pre></td></tr></table></figure><p><strong>4.</strong> <code>** const **</code> <strong>的特殊性</strong></p><p><strong>声明时必须初始化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const PI = 3.14; // 正确<br>const PI; // 报错：未初始化<br></code></pre></td></tr></table></figure><p><strong>不可重新赋值</strong>：   基本类型值不可变，引用类型（对象、数组）的属性可修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const arr = [1, 2, 3];<br>arr.push(4); // 允许<br>arr = [5]; // 报错：不可重新赋值<br><br>const obj = &#123; name: &quot;Alice&quot; &#125;;<br>obj.name = &quot;Bob&quot;; // 允许<br></code></pre></td></tr></table></figure><p><strong>5. 使用场景</strong></p><p><strong>优先使用*</strong>* **<code>** const **</code>：   默认用<code>const</code>声明变量，除非需要重新赋值。</p><ul><li><code>const API_KEY = &quot;abc123&quot;; // 常量</code></li></ul><p><strong>需要重新赋值时用</strong> <code>** let **</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">let count = 0;<br>count = 1; // 合法<br></code></pre></td></tr></table></figure><ul><li><strong>避免使用*</strong>* **<code>** var **</code>：   <code>var</code>的作用域和提升行为容易导致错误。</li></ul><p><strong>6. 循环中的表现</strong></p><p><code>** let **</code> <strong>在循环中绑定每次迭代</strong>：   解决<code>var</code>在循环中共享变量的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (let i = 0; i &lt; 3; i++) &#123;<br>  setTimeout(() =&gt; console.log(i), 100); // 输出0,1,2<br>&#125;<br></code></pre></td></tr></table></figure><p><code>** const **</code> <strong>在循环中的特殊行为</strong>：   每次迭代创建一个新变量（适用于<code>for...of</code>&#x2F;<code>for...in</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (const num of [1, 2, 3]) &#123;<br>  console.log(num); // 输出1,2,3<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><code>** const **</code>：声明常量，不可重新赋值，引用类型属性可变。</li><li><code>** let **</code>：声明可变的块级变量。</li><li><strong>块级作用域</strong>、<strong>TDZ</strong>、<strong>禁止重复声明</strong>使代码更安全、可维护。</li><li><strong>替代</strong><code>** var **</code>：推荐始终使用<code>const</code>和<code>let</code>，避免<code>var</code>。</li></ul><h4 id="ES6-ES13"><a href="#ES6-ES13" class="headerlink" title="ES6~ES13"></a>ES6~ES13</h4><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>JavaScript 中的模板字符串和标签模板字符串是 ES6 引入的重要特性，极大提升了字符串处理的灵活性和功能性。</p><h6 id="模板字符串（Template-Strings）"><a href="#模板字符串（Template-Strings）" class="headerlink" title="模板字符串（Template Strings）"></a>模板字符串（Template Strings）</h6><p><strong>基本语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-  使用反引号（ <span class="hljs-string">`   `</span> ）包裹字符串，支持多行内容和插值表达式。 <br>-  插值通过  <span class="hljs-string">` <span class="hljs-subst">$&#123;expression&#125;</span> `</span>  实现，表达式结果自动转换为字符串并嵌入。 <br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>; <span class="hljs-comment">// &quot;Hello, Alice!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>多行字符串</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">-  直接换行编写，保留换行符和缩进。 <br>const html = `<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>`;<br></code></pre></td></tr></table></figure><p><strong>表达式求值</strong>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">-  支持任意 JavaScript 表达式，包括函数调用、运算等。 <br>const <span class="hljs-built_in">sum</span> = <span class="hljs-string">`3 + 5 = <span class="hljs-subst">$&#123;<span class="hljs-number">3</span> + <span class="hljs-number">5</span>&#125;</span>`</span>; <span class="hljs-comment">// &quot;3 + 5 = 8&quot;</span><br></code></pre></td></tr></table></figure><h6 id="标签模板字符串（Tagged-Templates）"><a href="#标签模板字符串（Tagged-Templates）" class="headerlink" title="标签模板字符串（Tagged Templates）"></a>标签模板字符串（Tagged Templates）</h6><ol><li><strong>基本概念</strong>：<ul><li>通过标签函数处理模板字符串，语法为：<code>tagFunction</code>string text ${expression}…&#96;&#96;。</li><li>标签函数接收字符串数组和插值参数，返回自定义结果。</li></ul></li><li><strong>参数解析</strong>：<ul><li><strong>第一个参数</strong>：字符串数组（按插值位置分割）。</li><li><strong>后续参数</strong>：按顺序传入插值表达式的计算结果。</li></ul></li></ol><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function tag(strings, ...values) &#123;<br>  console.log(strings); // [&quot;Hello &quot;, &quot;, age &quot;, &quot;&quot;]<br>  console.log(values);  // [&quot;Alice&quot;, 30]<br>&#125;<br>tag`Hello $&#123;&quot;Alice&quot;&#125;, age $&#123;30&#125;`;<br></code></pre></td></tr></table></figure><ol><li><strong>应用场景</strong>：</li></ol><p><strong>HTML 转义</strong>：防止 XSS 攻击。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">function safeHtml(strings, ...values) &#123;<br>  let result = &quot;&quot;;<br>  for (let i = 0; i &lt; strings.length; i++) &#123;<br>    result += strings[i];<br>    if (i &lt; values.length) &#123;<br>      result += String(values[i])<br>        .replace(/&amp;/g, &quot;&amp;amp;&quot;)<br>        .replace(/&lt;/g, &quot;&amp;lt;&quot;);<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br>const userInput = &quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;<br>safeHtml`&lt;div&gt;$&#123;userInput&#125;&lt;/div&gt;`; // 转义后输出<br></code></pre></td></tr></table></figure><p><strong>国际化（i18n）</strong>：动态翻译。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">i18n<span class="hljs-string">`Welcome to <span class="hljs-subst">$&#123;siteName&#125;</span>. You have <span class="hljs-subst">$&#123;<span class="hljs-built_in">count</span>&#125;</span> messages.`</span>;<br></code></pre></td></tr></table></figure><p><strong>样式组件</strong>（如 styled-components）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const Button = styled.button`<br>  color: $&#123;props =&gt; props.primary ? &#x27;white&#x27; : &#x27;black&#x27;&#125;;<br>`;<br></code></pre></td></tr></table></figure><p><strong>原始字符串</strong>：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">-  通过  ` strings.raw `  获取未转义的原始内容（如保留  ` \n `  而非换行）。 <br>function showRaw(strings) &#123;<br>  <span class="hljs-keyword">return</span> strings.raw[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br>&#125;<br>showRaw`Hello\nWorld`; // <span class="hljs-string">&quot;Hello\\nWorld&quot;</span>（实际输出包含两个反斜杠）<br></code></pre></td></tr></table></figure><ol><li><strong>返回值灵活性</strong>：<ul><li>可返回任意类型（字符串、对象、组件等）。</li></ul></li></ol><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><table><thead><tr><th><strong>特性</strong></th><th><strong>模板字符串</strong></th><th><strong>标签模板字符串</strong></th></tr></thead><tbody><tr><td><strong>语法</strong></td><td>反引号包裹 <code>$&#123;&#125;</code><br>插值</td><td>函数名后跟模板字符串</td></tr><tr><td><strong>多行支持</strong></td><td>是</td><td>是</td></tr><tr><td><strong>插值处理</strong></td><td>自动转换为字符串</td><td>由标签函数自定义处理</td></tr><tr><td><strong>应用场景</strong></td><td>动态字符串拼接、多行文本</td><td>HTML 转义、国际化、DSL、样式组件等</td></tr><tr><td><strong>原始字符串访问</strong></td><td>无</td><td>通过 <code>strings.raw</code><br>获取</td></tr><tr><td><strong>返回值</strong></td><td>字符串</td><td>任意类型（由标签函数决定）</td></tr></tbody></table><p><strong>总结</strong>：模板字符串简化了字符串拼接和多行处理，而标签模板字符串通过自定义函数扩展了其功能，适用于安全转义、国际化、DSL 等复杂场景。</p><h5 id="深浅拷贝理解"><a href="#深浅拷贝理解" class="headerlink" title="深浅拷贝理解"></a>深浅拷贝理解</h5><p>在JavaScript中，对象的拷贝分为<strong>浅拷贝</strong>和<strong>深拷贝</strong>，主要区别在于对引用类型数据的处理方式。</p><h6 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h6><p><strong>特点</strong>：仅复制对象的顶层属性，若属性是引用类型（如对象、数组），则拷贝的是内存地址（新旧对象共享嵌套的引用类型数据）。</p><p><strong>实现方式：</strong></p><ol><li><strong>展开运算符</strong> <code>** ... **</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;<br>const shallowCopy = &#123; ...obj &#125;;<br></code></pre></td></tr></table></figure><ol><li><code>** Object.assign() **</code></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">const shallowCopy = Object.assign(&#123;&#125;, obj);<br></code></pre></td></tr></table></figure><ol><li><strong>数组方法</strong>（如 <code>slice()</code>、<code>concat()</code>、展开运算符）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const arr = [1, &#123; x: 2 &#125;];<br>const shallowArr = arr.slice();<br>const shallowArr2 = [...arr];<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>修改嵌套的引用类型数据会影响原对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">shallowCopy.b.c = 3;<br>console.log(obj.b.c); // 3（原对象被修改）<br></code></pre></td></tr></table></figure><h6 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h6><p><strong>特点</strong>：完全复制对象及其嵌套的引用类型数据，新旧对象完全独立。</p><p><strong>实现方式：</strong></p><ol><li><code>** JSON.parse(JSON.stringify(obj)) **</code>   局限：<ol><li>无法处理函数、<code>undefined</code>、<code>Symbol</code>。</li><li>日期对象会被转为字符串。</li><li>循环引用会报错。</li></ol></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">const deepCopy = JSON.parse(JSON.stringify(obj));<br></code></pre></td></tr></table></figure><ol><li><strong>递归实现</strong>   基础版本（未处理特殊对象和循环引用）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs plain">function deepClone(obj) &#123;<br>      if (obj === null || typeof obj !== &quot;object&quot;) return obj;<br>      const clone = Array.isArray(obj) ? [] : &#123;&#125;<br>      for (const key in obj) &#123;<br>        if(obj.hasOwnProperty(key))&#123;<br>          clone[key] = deepClone(obj[key])<br>        &#125;<br>      &#125;<br>      return clone<br>    &#125;<br><br>    const info = &#123;<br>      name: &#x27;MirZ&#x27;,<br>      age: 18,<br>      friend: &#123;<br>        name: &#x27;LadyJ&#x27;,<br>        address: &#123;<br>          detail: &#x27;郑州&#x27;,<br>          goHome: function () &#123;<br>            console.log(&#x27;go郑州&#x27;);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    const newInfo = deepClone(info)<br>    newInfo.friend.name = &#x27;LadyY&#x27;<br>    newInfo.friend.address.detail = &#x27;安徽&#x27;<br>    //此处函数未被深拷贝,而是指向了一个新的函数,所以不影响原函数的指向<br>    newInfo.friend.address.goHome = function () &#123;<br>      console.log(&#x27;go安徽&#x27;);<br>    &#125;<br><br>    console.log(info);<br>    info.friend.address.goHome()<br>    console.log(newInfo);<br>    newInfo.friend.address.goHome()<br>    //如有set,map,symbol需进一步处理<br> function deepClone(obj) &#123;<br>      // 如果值是Symbol的类型<br>      if (typeof obj === &quot;symbol&quot;) &#123;<br>        return Symbol(obj.description)<br>      &#125;<br>      // 如果是set类型,map也进行类似处理<br>      if (obj instanceof Set) &#123;<br>        const newSet = new Set()<br>        for (const setItem of obj) &#123;<br>          newSet.add(deepCopy(setItem))<br>        &#125;<br>        return newSet<br>      &#125;<br>      if (obj === null || typeof obj !== &quot;object&quot;) return obj;<br>      const clone = Array.isArray(obj) ? [] : &#123;&#125;<br>      //此处只会遍历key,不会遍历symbol[key]<br>      for (const key in obj) &#123;<br>        if (obj.hasOwnProperty(key)) &#123;<br>          clone[key] = deepClone(obj[key])<br>        &#125;<br>      &#125;<br>      // 单独遍历symbol<br>      const symbolKeys = Object.getOwnPropertySymbols(obj)<br>      for (const symbolKey of symbolKeys) &#123;<br>        clone[Symbol(symbolKey.description)] = deepCopy(obj[symbolKey])<br>      &#125;<br><br>      return clone<br>    &#125;<br><br>    const info = &#123;<br>      name: &#x27;MirZ&#x27;,<br>      age: 18,<br>      friend: &#123;<br>        name: &#x27;LadyJ&#x27;,<br>        address: &#123;<br>          detail: &#x27;郑州&#x27;,<br>          goHome: function () &#123;<br>            console.log(&#x27;go郑州&#x27;);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    const newInfo = deepClone(info)<br>    newInfo.friend.name = &#x27;LadyY&#x27;<br>    newInfo.friend.address.detail = &#x27;安徽&#x27;<br>    //此处函数未被深拷贝,而是指向了一个新的函数,所以不影响原函数的指向<br>    newInfo.friend.address.goHome = function () &#123;<br>      console.log(&#x27;go安徽&#x27;);<br>    &#125;<br><br>    console.log(info);<br>    info.friend.address.goHome()<br>    console.log(newInfo);<br>    newInfo.friend.address.goHome()<br></code></pre></td></tr></table></figure><p><strong>处理循环引用和特殊对象</strong>   使用 <code>WeakMap</code> 缓存已拷贝对象，并处理 <code>Date</code>、<code>RegExp</code> 等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">function deepClone(obj, hash = new WeakMap()) &#123;<br>     if (obj === null || typeof obj !== &quot;object&quot;) return obj;<br>     //判断此次深拷贝的对象是否在hash中存在,如果存在直接返回<br>     if (hash.has(obj)) return hash.get(obj);<br><br>     let clone;<br>     if (obj instanceof Date) &#123;<br>       clone = new Date(obj.getTime());<br>     &#125; else if (obj instanceof RegExp) &#123;<br>       clone = new RegExp(obj.source, obj.flags);<br>     &#125; else &#123;<br>       clone = Array.isArray(obj) ? [] : &#123;&#125;;<br>     &#125;<br>     //根据obj存储clone<br>     hash.set(obj, clone);<br>     for (let key in obj) &#123;<br>       if (obj.hasOwnProperty(key)) &#123;<br>         clone[key] = deepClone(obj[key], hash);<br>       &#125;<br>     &#125;<br>     return clone;<br>   &#125;<br><br>   const info = &#123;<br>     name: &#x27;MirZ&#x27;,<br>     age: 18<br>   &#125;<br>   info.self = info<br>   console.log(info);<br>   const newInfo = deepClone(info)<br>   newInfo.name = &#x27;MIRZ&#x27;<br>   console.log(newInfo);<br></code></pre></td></tr></table></figure><ol><li><strong>第三方库</strong>   使用 <code>lodash</code> 的 <code>_.cloneDeep()</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">import _ from &quot;lodash&quot;;<br>const deepCopy = _.cloneDeep(obj);<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ul><li><strong>浅拷贝</strong>：适用于对象结构简单，无嵌套引用或明确无需隔离的场景。</li><li><strong>深拷贝</strong>：适用于对象结构复杂，需完全隔离新旧对象的场景（如状态管理、数据持久化）。</li></ul><p><strong>注意事项</strong></p><ol><li><strong>循环引用</strong>：递归深拷贝需使用缓存（如 <code>WeakMap</code>）避免无限递归。</li><li><strong>特殊对象</strong>：如 <code>Date</code>、<code>RegExp</code>、<code>Set</code>、<code>Map</code> 等需单独处理。</li><li><strong>性能</strong>：深拷贝对大型对象可能有性能开销，需权衡使用。</li></ol><h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h5><p>JavaScript 中的 <strong>Symbol</strong> 是 ES6 引入的一种新的原始数据类型，用于表示唯一的标识符。</p><p><strong>1. Symbol 的基本特性</strong></p><p><strong>唯一性</strong>：每个 Symbol 都是唯一的，即使描述相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">let sym1 = Symbol(&#x27;key&#x27;);<br>let sym2 = Symbol(&#x27;key&#x27;);<br>console.log(sym1 === sym2); // false<br></code></pre></td></tr></table></figure><p><strong>原始类型</strong>：不能使用 <code>new</code> 创建，直接调用 <code>Symbol()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">let sym = Symbol(); // 正确<br>let err = new Symbol(); // TypeError<br></code></pre></td></tr></table></figure><p><strong>描述参数</strong>：用于调试，不影响唯一性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">console.log(Symbol(&#x27;desc&#x27;).toString()); // Symbol(desc)<br></code></pre></td></tr></table></figure><p><strong>2. Symbol 作为对象属性</strong></p><p><strong>定义属性</strong>：用方括号语法 <code>[]</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const sym = Symbol(&#x27;key&#x27;);<br>const obj = &#123;<br>    [sym]: &#x27;value&#x27;<br>&#125;;<br>console.log(obj[sym]); // &#x27;value&#x27;<br></code></pre></td></tr></table></figure><ul><li><strong>不可枚举性</strong>：Symbol 属性不会被常规方法遍历（如 <code>for...in</code>、<code>Object.keys()</code>）。<ul><li>获取 Symbol 属性：使用 <code>Object.getOwnPropertySymbols()</code>。</li><li>反射方法：<code>Reflect.ownKeys()</code> 返回所有键（包括 Symbol）。</li></ul></li></ul><p><strong>3. 全局 Symbol 注册表</strong></p><p><strong>共享 Symbol</strong>：通过 <code>Symbol.for(key)</code> 创建或获取全局 Symbol。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const sym1 = Symbol.for(&#x27;globalKey&#x27;);<br>const sym2 = Symbol.for(&#x27;globalKey&#x27;);<br>console.log(sym1 === sym2); // true<br></code></pre></td></tr></table></figure><p><strong>查询全局键</strong>：<code>Symbol.keyFor(sym)</code> 返回 Symbol 的全局键。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">console.log(Symbol.keyFor(sym1)); // &#x27;globalKey&#x27;<br></code></pre></td></tr></table></figure><p><strong>4. 内置 Symbol 值</strong></p><p>用于修改对象的默认行为，常见内置 Symbol：</p><p><strong>Symbol.iterator</strong>：定义对象的迭代器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const iterable = &#123;<br>    [Symbol.iterator]: function* () &#123; yield 1; yield 2; &#125;<br>&#125;;<br>console.log([...iterable]); // [1, 2]<br></code></pre></td></tr></table></figure><p><strong>Symbol.toStringTag</strong>：定制 <code>toString()</code> 输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; [Symbol.toStringTag]: &#x27;MyObject&#x27; &#125;;<br>console.log(obj.toString()); // [object MyObject]<br></code></pre></td></tr></table></figure><ul><li><strong>Symbol.hasInstance</strong>：自定义 <code>instanceof</code> 行为。</li></ul><p><strong>5. 应用场景</strong></p><p><strong>唯一属性名</strong>：避免对象属性名冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const cacheKey = Symbol(&#x27;cache&#x27;);<br>function getData(obj) &#123;<br>    if (!obj[cacheKey]) &#123;<br>        obj[cacheKey] = computeExpensiveValue();<br>    &#125;<br>    return obj[cacheKey];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模拟私有属性</strong>：通过 Symbol 隐藏属性（非绝对私有，但需主动获取)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const _private = Symbol(&#x27;private&#x27;);<br>class MyClass &#123;<br>    constructor() &#123; this[_private] = &#x27;secret&#x27;; &#125;<br>    getSecret() &#123; return this[_private]; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义语言行为</strong>：如迭代、类型转换等。</p><p><strong>6. 注意事项</strong></p><ul><li><strong>类型转换</strong>：<ul><li>Symbol 不能隐式转字符串（需显式调用 <code>.toString()</code> 或 <code>String()</code>）。</li><li>可转换为布尔值（始终为 <code>true</code>）。</li></ul></li><li><strong>序列化</strong>：Symbol 属性不会被 <code>JSON.stringify()</code> 处理。</li><li><strong>兼容性</strong>：ES6+ 支持，旧环境需通过 Babel 等工具转译。</li></ul><p><strong>总结</strong></p><p>Symbol 的主要用途是提供唯一的标识符，解决命名冲突，并允许开发者介入 JavaScript 的内部行为。合理使用 Symbol 可以提升代码的健壮性和扩展性，但需注意其不可枚举性和转换规则。</p><h5 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set-Map"></a>Set-Map</h5><p>Set和Map都是ES6引入的，用来处理复杂的数据集合</p><h6 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h6><p><strong>基本特性</strong></p><ul><li><strong>成员唯一性</strong>：自动去重，值不能重复（基于 <code>===</code>，但 <code>NaN</code> 视为相等）。</li><li><strong>无序性</strong>：元素无插入顺序概念，但实际迭代时按插入顺序遍历。</li><li><strong>键与值相同</strong>：<code>Set</code> 的键和值相等，即 <code>key === value</code>。</li></ul><p><strong>创建与操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const set = new Set();<br>set.add(1);       // 添加元素<br>set.add(2).add(3); // 链式调用<br>set.delete(1);    // 删除元素，返回布尔值表示是否成功<br>set.has(2);       // 检查存在性，返回 true/false<br>set.size;         // 获取元素数量<br>set.clear();      // 清空集合<br></code></pre></td></tr></table></figure><p><strong>迭代方法</strong></p><ul><li><code>keys()</code>、<code>values()</code>：返回迭代器（因为键值相同，两者等价）。</li><li><code>entries()</code>：返回 <code>[value, value]</code> 的迭代器。</li><li><code>forEach()</code>：遍历元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (const item of set) &#123; /* 直接迭代 */ &#125;<br>set.forEach(v =&gt; console.log(v));<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li><strong>数组去重</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const arr = [1, 2, 2, 3];<br>//const uniqueArr = Array.from(new Set(arr)) // [1, 2, 3]<br>const uniqueArr = [...new Set(arr)]; // [1, 2, 3]<br></code></pre></td></tr></table></figure><ul><li><strong>集合运算</strong>（交集、并集、差集）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 交集<br>const intersection = new Set([...setA].filter(x =&gt; setB.has(x)));<br>// 并集<br>const union = new Set([...setA, ...setB]);<br>// 差集（A - B）<br>const difference = new Set([...setA].filter(x =&gt; !setB.has(x)));<br></code></pre></td></tr></table></figure><ul><li><strong>临时存储唯一值</strong>：用于快速检查元素是否存在。</li></ul><h6 id="2-Map（映射）"><a href="#2-Map（映射）" class="headerlink" title="2. Map（映射）"></a>2. Map（映射）</h6><p><strong>基本特性</strong></p><ul><li><strong>键值对结构</strong>：存储键值对的集合，键可以是任意类型（对象、函数等）。</li><li><strong>有序性</strong>：元素按插入顺序迭代。</li><li><strong>高效查找</strong>：基于哈希表实现，查找速度接近 O(1)。</li></ul><p><strong>创建与操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const map = new Map();<br>map.set(&#x27;key1&#x27;, &#x27;value1&#x27;); // 添加键值对<br>map.set(&#123;&#125;, &#x27;objectKey&#x27;);  // 对象作为键<br>map.get(&#x27;key1&#x27;);           // 获取值，若不存在返回 undefined<br>map.has(&#x27;key1&#x27;);           // 检查键是否存在<br>map.delete(&#x27;key1&#x27;);        // 删除键值对<br>map.size;                  // 获取键值对数量<br>map.clear();               // 清空映射<br></code></pre></td></tr></table></figure><p><strong>迭代方法</strong></p><ul><li><code>keys()</code>：返回键的迭代器。</li><li><code>values()</code>：返回值的迭代器。</li><li><code>entries()</code>：返回 <code>[key, value]</code> 的迭代器（默认迭代方式）。</li><li><code>forEach()</code>：遍历键值对。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (const [key, value] of map) &#123; /* 迭代键值对 */ &#125;<br>map.forEach((value, key) =&gt; &#123; /* ... */ &#125;);<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li><strong>复杂键存储</strong>：当键需要是非字符串类型时（如对象、函数）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const domNode = document.getElementById(&#x27;node&#x27;);<br>const map = new Map();<br>map.set(domNode, &#123; clickCount: 0 &#125;); // DOM 节点作为键<br></code></pre></td></tr></table></figure><ul><li><strong>数据关联</strong>：维护键值对的动态关联关系（如缓存计算结果）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const cache = new Map();<br>function computeExpensiveValue(key) &#123;<br>    if (cache.has(key)) return cache.get(key);<br>    const result = /* 复杂计算 */;<br>    cache.set(key, result);<br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>有序存储</strong>：需要保留插入顺序的键值对集合。</li></ul><h6 id="3-WeakSet-与-WeakMap"><a href="#3-WeakSet-与-WeakMap" class="headerlink" title="3. WeakSet 与 WeakMap"></a>3. WeakSet 与 WeakMap</h6><p><strong>WeakSet</strong></p><ul><li><strong>弱引用集合</strong>：元素必须是对象，且不计入引用计数（不影响垃圾回收）。</li><li><strong>不可迭代</strong>：没有 <code>size</code>、<code>clear()</code> 或迭代方法。</li></ul><p><strong>用途</strong>：临时存储对象，避免内存泄漏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const weakSet = new WeakSet();<br>let obj = &#123;&#125;;<br>weakSet.add(obj);<br></code></pre></td></tr></table></figure><p><strong>WeakMap</strong></p><ul><li><strong>弱引用键</strong>：键必须是对象，值可以是任意类型。</li><li><strong>不可迭代</strong>：同样没有 <code>size</code>、<code>clear()</code> 或迭代方法。</li></ul><p><strong>用途</strong>：存储对象的私有数据或元数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const weakMap = new WeakMap();<br>const obj = &#123;&#125;;<br>weakMap.set(obj, &#x27;privateData&#x27;);<br></code></pre></td></tr></table></figure><h6 id="4-Set-和-Map-的对比"><a href="#4-Set-和-Map-的对比" class="headerlink" title="4. Set 和 Map 的对比"></a>4. Set 和 Map 的对比</h6><table><thead><tr><th><strong>特性</strong></th><th><strong>Set</strong></th><th><strong>Map</strong></th></tr></thead><tbody><tr><td>存储内容</td><td>唯一值</td><td>键值对</td></tr><tr><td>键类型</td><td>值即键（任意类型）</td><td>键可以是任意类型</td></tr><tr><td>查找方式</td><td>直接检查值的存在性</td><td>通过键查找值</td></tr><tr><td>典型用途</td><td>去重、集合运算</td><td>复杂键存储、有序关联</td></tr></tbody></table><h6 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h6><p><strong>引用类型键的陷阱</strong>：对象作为键时，引用不同则视为不同键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const map = new Map();<br>map.set(&#123;&#125;, &#x27;value&#x27;);<br>console.log(map.get(&#123;&#125;)); // undefined（两个空对象引用不同）<br></code></pre></td></tr></table></figure><ol><li><strong>性能优化</strong>：<code>Set</code> 和 <code>Map</code> 的查找速度（<code>has()</code>、<code>get()</code>）远快于数组的 <code>includes()</code>。</li><li><strong>序列化限制</strong>：<code>JSON.stringify()</code> 无法序列化 <code>Set</code> 和 <code>Map</code>，需手动转换。</li><li><strong>兼容性</strong>：ES6+ 支持，旧环境需使用 Babel 或 Polyfill（如 <code>core-js</code>）。</li></ol><p><strong>总结</strong></p><ul><li><strong>Set</strong>：处理唯一值集合，适合去重、集合运算。</li><li><strong>Map</strong>：处理键值对，适合复杂键类型或需要有序的场景。</li><li><strong>WeakSet&#x2F;WeakMap</strong>：弱引用特性适合临时存储或避免内存泄漏。</li></ul><h5 id="padStart和padEnd"><a href="#padStart和padEnd" class="headerlink" title="padStart和padEnd"></a>padStart和padEnd</h5><p><code>padStart</code> 和 <code>padEnd</code> 是 JavaScript 中用于字符串填充的方法，允许在字符串的开头或结尾添加字符，直到达到指定长度。以下是它们的详细说明和示例：</p><p><strong>1.</strong> <code>** padStart(targetLength, padString) **</code></p><ul><li><strong>作用</strong>：在字符串<strong>开头</strong>填充字符，直到字符串达到目标长度。</li><li><strong>参数</strong>：<ul><li><code>targetLength</code>：填充后的目标长度。</li><li><code>padString</code>（可选）：用于填充的字符串，默认为空格。</li></ul></li><li><strong>规则</strong>：<ul><li>若原字符串长度 ≥ <code>targetLength</code>，直接返回原字符串。</li><li>填充字符串 <code>padString</code> 会被重复使用，超出部分被截断。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;5&#x27;.padStart(3, &#x27;0&#x27;);       // &#x27;005&#x27;（填充到开头）<br>&#x27;hi&#x27;.padStart(5, &#x27;ab&#x27;);     // &#x27;abahi&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;abc&#x27;.padStart(6, &#x27;123&#x27;);   // &#x27;123abc&#x27;（填充 &#x27;123&#x27;）<br>&#x27;7&#x27;.padStart(4, &#x27;ab&#x27;);      // &#x27;aba7&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;test&#x27;.padStart(6);         // &#x27;  test&#x27;（默认用空格填充）<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <code>** padEnd(targetLength, padString) **</code></p><ul><li><strong>作用</strong>：在字符串<strong>结尾</strong>填充字符，直到字符串达到目标长度。</li><li><strong>参数</strong>：同 <code>padStart</code>。</li><li><strong>规则</strong>：与 <code>padStart</code> 类似，但填充方向相反。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;5&#x27;.padEnd(3, &#x27;0&#x27;);         // &#x27;500&#x27;（填充到结尾）<br>&#x27;hi&#x27;.padEnd(5, &#x27;ab&#x27;);       // &#x27;hiaba&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;abc&#x27;.padEnd(6, &#x27;123&#x27;);     // &#x27;abc123&#x27;（填充 &#x27;123&#x27;）<br>&#x27;7&#x27;.padEnd(4, &#x27;ab&#x27;);        // &#x27;7aba&#x27;（填充 &#x27;aba&#x27;）<br>&#x27;test&#x27;.padEnd(6);           // &#x27;test  &#x27;（默认用空格填充）<br></code></pre></td></tr></table></figure><p><strong>关键注意事项：</strong></p><p><strong>填充字符串的重复与截断</strong>：   若 <code>padString</code> 长度不足，会重复拼接直到满足目标长度，超出部分被截断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;12&#x27;.padStart(5, &#x27;abc&#x27;);  // &#x27;abc12&#x27;（填充 &#x27;abc&#x27;）<br>&#x27;12&#x27;.padEnd(5, &#x27;abc&#x27;);    // &#x27;12abc&#x27;（填充 &#x27;abc&#x27;）<br></code></pre></td></tr></table></figure><p><strong>空字符串或省略参数</strong>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-  省略    <span class="hljs-string">` padString `</span>    时，默认用空格填充。 <br>-  若  <span class="hljs-string">` padString `</span>  为空字符串，无法填充，直接返回原字符串。 <br><span class="hljs-string">&#x27;5&#x27;</span>.padStart(<span class="hljs-number">3</span>);          <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;  5&#x27;</span>（默认空格）<br><span class="hljs-string">&#x27;5&#x27;</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;&#x27;</span>);      <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;5&#x27;</span>（无填充）<br></code></pre></td></tr></table></figure><p><strong>目标长度小于原字符串</strong>：   直接返回原字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x27;hello&#x27;.padStart(3, &#x27;0&#x27;); // &#x27;hello&#x27;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p><strong>场景 1：隐藏手机号中间四位</strong></p><p>将手机号 <code>13812341234</code> 转换为 <code>138****1234</code>，保留前 3 位和后 4 位，中间填充 <code>****</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizePhone(phone) &#123;<br>  const visiblePrefix = 3; // 显示前 3 位<br>  const visibleSuffix = 4; // 显示后 4 位<br>  const prefix = phone.slice(0, visiblePrefix);<br>  const suffix = phone.slice(-visibleSuffix);<br>  // 中间填充 *，总长度与原手机号一致<br>  return prefix + suffix.padStart(phone.length - visiblePrefix, &#x27;*&#x27;);<br>&#125;<br><br>desensitizePhone(&#x27;13812341234&#x27;); // &#x27;138****1234&#x27;<br></code></pre></td></tr></table></figure><p><strong>场景 2：隐藏身份证号前 14 位</strong></p><p>将身份证号 <code>110101199003077654</code> 转换为 <code>************7654</code>，只显示后 4 位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizeID(id) &#123;<br>  const visibleDigits = 4; // 显示后 4 位<br>  const suffix = id.slice(-visibleDigits);<br>  // 前部填充 *，总长度与原身份证号一致<br>  return suffix.padStart(id.length, &#x27;*&#x27;);<br>&#125;<br><br>desensitizeID(&#x27;110101199003077654&#x27;); // &#x27;************7654&#x27;<br></code></pre></td></tr></table></figure><p><strong>场景 3：隐藏银行卡号中间部分</strong></p><p>将银行卡号 <code>6225880134567890</code> 转换为 <code>622588******7890</code>，保留前 6 位和后 4 位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizeBankCard(card) &#123;<br>  const visiblePrefix = 6; // 显示前 6 位<br>  const visibleSuffix = 4; // 显示后 4 位<br>  const prefix = card.slice(0, visiblePrefix);<br>  const suffix = card.slice(-visibleSuffix);<br>  // 中间填充 *，总长度与原卡号一致<br>  return prefix + &#x27;*&#x27;.repeat(card.length - visiblePrefix - visibleSuffix) + suffix;<br>&#125;<br><br>desensitizeBankCard(&#x27;6225880134567890&#x27;); // &#x27;622588******7890&#x27;<br></code></pre></td></tr></table></figure><p><strong>场景 4：格式化短文本敏感信息</strong></p><p>将用户昵称 <code>Alice</code> 转换为 <code>**ice</code>，隐藏前 2 位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">function desensitizeShortText(text, hideLength = 2) &#123;<br>  const visiblePart = text.slice(hideLength);<br>  return visiblePart.padStart(text.length, &#x27;*&#x27;);<br>&#125;<br><br>desensitizeShortText(&#x27;Alice&#x27;, 2); // &#x27;**ice&#x27;<br></code></pre></td></tr></table></figure><p><strong>关键逻辑总结</strong></p><ol><li><strong>截取保留部分</strong>：通过 <code>slice</code> 截取需要显示的头&#x2F;尾部分。</li><li><strong>填充敏感符号</strong>：使用 <code>padStart</code> 或 <code>padEnd</code> 填充 <code>*</code>，确保总长度与原数据一致。</li><li><strong>动态适配长度</strong>：根据输入数据的实际长度动态计算填充位数，避免硬编码。</li></ol><p><strong>注意事项</strong></p><ul><li><strong>输入合法性校验</strong>：需确保输入是字符串且长度合法（如身份证 18 位、手机号 11 位）。</li><li><strong>边界处理</strong>：若保留位数超过原数据长度，直接返回全隐藏（如 <code>&#39;*&#39;.repeat(text.length)</code>）。</li><li><strong>扩展性</strong>：可通过参数控制隐藏的位数和填充符号，适配不同场景。</li></ul><p><strong>总结</strong></p><ul><li><code>** padStart **</code>：向前填充，适用于左对齐或补前置字符（如日期补零）。</li><li><code>** padEnd **</code>：向后填充，适用于右对齐或补后缀字符（如固定格式文本）。</li><li>处理填充字符串时，注意重复和截断逻辑，避免结果与预期不符。</li></ul><h5 id="flat和flatMap"><a href="#flat和flatMap" class="headerlink" title="flat和flatMap"></a>flat和flatMap</h5><p><code>flat()</code> 和 <code>flatMap()</code> 是 JavaScript 中用于处理数组的两种方法，专门用于简化嵌套数组的结构或结合映射（<code>map</code>）与扁平化（<code>flat</code>）操作。</p><p><strong>1.</strong> <code>** flat(depth) **</code></p><p><strong>作用</strong>：将嵌套的数组“扁平化”，返回一个包含所有子数组元素的新数组。   <strong>参数</strong>：</p><ul><li><code>depth</code>（可选）：指定要扁平化的嵌套层数，默认值为 <code>1</code>。若需完全扁平化，可设为 <code>Infinity</code>。   <strong>返回值</strong>：新数组（原数组不会被修改）。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 默认扁平化一层<br>const arr1 = [1, [2, 3], [4, [5]]];<br>console.log(arr1.flat());        // [1, 2, 3, 4, [5]]<br><br>// 完全扁平化（无限层）<br>console.log(arr1.flat(Infinity)); // [1, 2, 3, 4, 5]<br><br>// 处理空位（自动跳过空值）<br>const arr2 = [1, , 3];<br>console.log(arr2.flat());         // [1, 3]<br></code></pre></td></tr></table></figure><p><strong>2.</strong> <code>** flatMap(callback) **</code></p><p><strong>作用</strong>：先对数组的每个元素执行 <code>map</code> 操作，然后对结果扁平化一层。   <strong>参数</strong>：</p><ul><li><code>callback</code>：一个函数，用于处理每个元素，返回一个数组（或其他可迭代对象）。   <strong>返回值</strong>：新数组（原数组不会被修改）。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 基本用法（等效于 map + flat(1)）<br>const arr = [1, 2, 3];<br>const result = arr.flatMap((x) =&gt; [x, x * 2]);<br>console.log(result); // [1, 2, 2, 4, 3, 6]<br><br>// 处理非数组返回值（自动包装为数组）<br>const words = [&quot;hello&quot;, &quot;world&quot;];<br>console.log(words.flatMap(word =&gt; word.split(&quot;&quot;))); <br>// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]<br><br>// 过滤并展开数据<br>const data = [<br>  &#123; id: 1, values: [10, 20] &#125;,<br>  &#123; id: 2, values: [30] &#125;,<br>];<br>console.log(data.flatMap(item =&gt; item.values)); // [10, 20, 30]<br></code></pre></td></tr></table></figure><p><strong>对比</strong> <code>** flatMap **</code> <strong>与</strong> <code>** map + flat **</code></p><p>以下两种写法等价，但 <code>flatMap</code> 更简洁高效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 使用 flatMap<br>arr.flatMap((x) =&gt; [x, x * 2]);<br><br>// 等效于 map + flat<br>arr.map((x) =&gt; [x, x * 2]).flat();<br></code></pre></td></tr></table></figure><p><strong>关键注意事项</strong></p><ol><li><strong>扁平化层级</strong>：<ul><li><code>flat()</code> 可指定层级，默认 <code>1</code>；<code>flatMap()</code> 仅扁平化一层。</li></ul></li></ol><p>若需完全扁平化 <code>flatMap</code> 的结果，需额外调用 <code>flat()</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> <span class="hljs-code">`arr.flatMap(fn).flat(Infinity);`</span><br></code></pre></td></tr></table></figure><ol><li><strong>空值处理</strong>：<ul><li><code>flat()</code> 会自动跳过数组中的空位（如 <code>[1, , 3]</code>）。</li></ul></li></ol><p><code>flatMap()</code> 的回调函数若返回空数组 <code>[]</code>，会直接过滤该元素：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">- `[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].flatMap(<span class="hljs-variable language_">x</span> =&gt; <span class="hljs-variable language_">x</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? [] : [<span class="hljs-variable language_">x</span>]); <span class="hljs-comment">// [1, 3]`</span><br></code></pre></td></tr></table></figure><ol><li><strong>性能优化</strong>：<ul><li><code>flatMap()</code> 比先 <code>map</code> 后 <code>flat</code> 更高效，因为它减少了一次完整数组遍历。</li></ul></li></ol><p><strong>使用场景</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>flat()</code></td><td>多层嵌套数组的扁平化（如树形结构数据、API 返回的嵌套结果）。</td></tr><tr><td><code>flatMap()</code></td><td>需要同时映射并扁平化的场景（如展开子数组、过滤后展开、拆分字符串等）。</td></tr></tbody></table><p><strong>总结</strong></p><ul><li><code>** flat() **</code>：专为简化嵌套数组设计，支持指定层级。</li><li><code>** flatMap() **</code>：结合 <code>map</code> 和 <code>flat</code>，适合需要“映射后立即扁平化”的场景。</li><li>两者均返回新数组，不会修改原数组。</li></ul><h5 id="FinalizationRegistry"><a href="#FinalizationRegistry" class="headerlink" title="FinalizationRegistry"></a>FinalizationRegistry</h5><p>FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调。</p><p>FinalizationRegistry 提供了这样的一种方法:当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。(清理回调有时被称为-fnalizer);</p><p>你可以通过调用register方法，注册任何你想要清理回调的对象传入该对象和所含的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br>    let obj = &#123; name: &quot;why&quot;, age: 18 &#125;<br>    let info = &#123; name: &quot;kobe&quot;, age: 30 &#125;<br><br>    const finalRegistry = new FinalizationRegistry((value) =&gt; &#123;<br>      console.log(&quot;某一个对象被回收了:&quot;, value)<br>    &#125;)<br><br>    finalRegistry.register(obj, &quot;why&quot;)<br>    finalRegistry.register(info, &quot;kobe&quot;)<br><br>    // obj = null<br>    info = null<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="WeakRefs"><a href="#WeakRefs" class="headerlink" title="WeakRefs"></a>WeakRefs</h5><p>如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用:</p><p>如果我们希望是一个弱引用的话可以使用WeakRef;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> info = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(info)</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(info)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> finalRegistry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;对象被回收~&quot;</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    finalRegistry.<span class="hljs-title function_">register</span>(info, <span class="hljs-string">&quot;info&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      info = <span class="hljs-literal">null</span></span><br><span class="language-javascript">    &#125;, <span class="hljs-number">2000</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">deref</span>().<span class="hljs-property">name</span>, obj.<span class="hljs-title function_">deref</span>().<span class="hljs-property">age</span>)</span><br><span class="language-javascript">    &#125;, <span class="hljs-number">8000</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy-Reflect"></a>Proxy-Reflect</h4><p><strong>Proxy</strong> 和 <strong>Reflect</strong> 是 ES6 引入的元编程工具，允许开发者拦截和自定义对象的基本操作。</p><h5 id="监听对象属性操作方法"><a href="#监听对象属性操作方法" class="headerlink" title="监听对象属性操作方法"></a>监听对象属性操作方法</h5><p>使用Object.defineProperty(vue2响应式原理),存储数据描述符设计的初衷并不是为了去监听一个完整的对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 需求: 监听对象属性的所有操作</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 监听属性的操作</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.针对一个属性</span></span><br><span class="language-javascript">    <span class="hljs-comment">// let _name = obj.name</span></span><br><span class="language-javascript">    <span class="hljs-comment">// Object.defineProperty(obj, &quot;name&quot;, &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   set: function(newValue) &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     console.log(&quot;监听: 给name设置了新的值:&quot;, newValue)</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     _name = newValue</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   &#125;,</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   get: function() &#123;</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     console.log(&quot;监听: 获取name的值&quot;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     return _name</span></span><br><span class="language-javascript">    <span class="hljs-comment">//   &#125;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// &#125;)</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2.监听所有的属性: 遍历所有的属性, 对每一个属性使用defineProperty</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> value = obj[key]</span><br><span class="language-javascript">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 给<span class="hljs-subst">$&#123;key&#125;</span>设置了新的值:`</span>, newValue)</span><br><span class="language-javascript">          value = newValue</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 获取<span class="hljs-subst">$&#123;key&#125;</span>的值`</span>)</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> value</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(obj.name)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// obj.name = &quot;kobe&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)</span><br><span class="language-javascript">    obj.<span class="hljs-property">age</span> = <span class="hljs-number">17</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 什么是响应式?</span></span><br><span class="language-javascript">    <span class="hljs-comment">// const nameEl = document.querySelector(&quot;.name&quot;)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// nameEl.textContent = obj.name</span></span><br><span class="language-javascript">    <span class="hljs-comment">// obj.name = &quot;kobe&quot;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// obj.name = &quot;james&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建一个代理对象(Proxy对象)之后对该对象的所有操作，都通过代理对象来完成,代理对象可以监听我们想要对原对象进行哪些操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1.创建一个Proxy对象</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, newValue</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 监听<span class="hljs-subst">$&#123;key&#125;</span>的设置值: `</span>, newValue)</span><br><span class="language-javascript">        target[key] = newValue</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听: 监听<span class="hljs-subst">$&#123;key&#125;</span>的获取`</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> target[key]</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 2.对obj的所有操作, 应该去操作objProxy</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(objProxy.name)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// objProxy.name = &quot;kobe&quot;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(objProxy.name)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// objProxy.name = &quot;james&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    objProxy.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;广州市&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">address</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p><strong>Proxy</strong> 用于创建一个对象的代理，拦截并重新定义对象的底层操作（如属性读取、赋值等）。</p><p><strong>基本语法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> newProxy=<span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>,<span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>target</strong>：被代理的目标对象。</li><li><strong>handler</strong>：定义拦截行为的对象，包含一组“陷阱”（trap）方法。</li></ul><p><strong>常用拦截方法</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>触发场景</strong></th></tr></thead><tbody><tr><td><code>get(target, prop, receiver)</code></td><td>读取属性时（如 <code>proxy.prop</code>）</td></tr><tr><td><code>set(target, prop, value, receiver)</code></td><td>设置属性时（如 <code>proxy.prop = value</code>）</td></tr><tr><td><code>has(target, prop)</code></td><td><code>in</code>操作符（如 <code>&#39;prop&#39; in proxy</code>）</td></tr><tr><td><code>deleteProperty(target, prop)</code></td><td><code>delete</code> 操作符（如 <code>delete proxy.prop</code>）</td></tr><tr><td><code>apply(target, thisArg, args)</code></td><td>函数调用（如 <code>proxy()</code>）</td></tr><tr><td><code>construct(target, args, newTarget)</code></td><td><code>new</code>操作符（如 <code>new Proxy()</code>）</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">const target = &#123; name: &quot;Alice&quot; &#125;;<br>const handler = &#123;<br>  get(target, prop) &#123;<br>    console.log(`读取属性：$&#123;prop&#125;`);<br>    return target[prop];<br>  &#125;,<br>  set(target, prop, value) &#123;<br>    console.log(`设置属性：$&#123;prop&#125; = $&#123;value&#125;`);<br>    target[prop] = value;<br>    return true; // 表示成功<br>  &#125;<br>&#125;;<br>const proxy = new Proxy(target, handler);<br><br>proxy.name; // 输出 &quot;读取属性：name&quot;，返回 &quot;Alice&quot;<br>proxy.age = 30; // 输出 &quot;设置属性：age = 30&quot;<br></code></pre></td></tr></table></figure><h5 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h5><p><strong>Reflect</strong> 是一个内置对象，提供与 Proxy 方法一一对应的方法，用于执行对象的默认行为。它的设计目的是简化 Proxy 的实现，并提供更规范的底层操作。</p><p><strong>常用方法</strong></p><table><thead><tr><th><strong>Reflect 方法</strong></th><th><strong>对应 Proxy 陷阱</strong></th></tr></thead><tbody><tr><td><code>Reflect.get(target, prop, receiver)</code></td><td><code>get</code></td></tr><tr><td><code>Reflect.set(target, prop, value, receiver)</code></td><td><code>set</code></td></tr><tr><td><code>Reflect.has(target, prop)</code></td><td><code>has</code></td></tr><tr><td><code>Reflect.deleteProperty(target, prop)</code></td><td><code>deleteProperty</code></td></tr><tr><td><code>Reflect.apply(func, thisArg, args)</code></td><td><code>apply</code></td></tr><tr><td><code>Reflect.construct(target, args)</code></td><td><code>construct</code></td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123; a: 1 &#125;;<br>// 通过 Reflect 操作对象<br>Reflect.set(obj, &quot;b&quot;, 2); // obj 变为 &#123; a: 1, b: 2 &#125;<br>console.log(Reflect.get(obj, &quot;a&quot;)); // 输出 1<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  &lt;script&gt;<br>    function Person(name, age) &#123;<br>      this.name = name<br>      this.age = age<br>    &#125;<br><br>    function Student(name, age) &#123;<br>      // Person.call(this, name, age)<br><br>    &#125;<br>    // 属于Student类,实现自Person<br>    const stu = Reflect.construct(Person, [&#x27;MirZ&#x27;, 18], Student)<br>    console.log(stu)<br>    console.log(stu.__proto__ === Student.prototype)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="Proxy-和-Reflect-的配合"><a href="#Proxy-和-Reflect-的配合" class="headerlink" title="Proxy 和 Reflect 的配合"></a>Proxy 和 Reflect 的配合</h5><p>在 Proxy 的方法中调用 Reflect 的对应方法，可确保保留对象的默认行为，同时添加自定义逻辑。</p><ul><li>不去直接操作原对象</li><li>reflect会返回boolean判断操作是否成功</li><li>reflect可以使用<code>receiver</code>正确传递this</li></ul><p><strong>典型模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const handler = &#123;<br>  get(target, prop, receiver) &#123;<br>    console.log(`读取属性：$&#123;prop&#125;`);<br>    return Reflect.get(...arguments); // 等效于 Reflect.get(target, prop, receiver)<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="this-绑定问题"><a href="#this-绑定问题" class="headerlink" title="this 绑定问题"></a>this 绑定问题</h5><p>直接操作 <code>target[prop]</code> 可能导致 <code>this</code> 指向错误，而 <code>Reflect.get(target, prop, receiver)</code> 能正确传递 <code>receiver</code>（通常是代理对象）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">const target = &#123;<br>  name: &quot;Alice&quot;,<br>  greet() &#123;<br>    console.log(`Hello, $&#123;this.name&#125;!`);<br>  &#125;<br>&#125;;<br>const handler = &#123;<br>  get(target, prop, receiver) &#123;<br>    return Reflect.get(target, prop, receiver); // 确保 this 指向代理<br>  &#125;<br>&#125;;<br>const proxy = new Proxy(target, handler);<br>proxy.greet(); // Hello, Alice!（若 name 被代理修改，此处会反映变化）<br></code></pre></td></tr></table></figure><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol><li><strong>数据校验</strong>：拦截 <code>set</code> 操作，验证属性值。</li><li><strong>日志记录</strong>：跟踪对象的读写操作。</li><li><strong>自动填充属性</strong>：访问不存在的属性时返回默认值。</li><li><strong>观察者模式</strong>：属性变化时触发回调。</li><li><strong>函数调用劫持</strong>：统计函数执行时间。</li></ol><p><strong>数据校验示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const validator = &#123;<br>  set(target, prop, value) &#123;<br>    if (prop === &quot;age&quot; &amp;&amp; typeof value !== &quot;number&quot;) &#123;<br>      throw new TypeError(&quot;Age must be a number!&quot;);<br>    &#125;<br>    return Reflect.set(target, prop, value);<br>  &#125;<br>&#125;;<br>const proxy = new Proxy(&#123;&#125;, validator);<br>proxy.age = 30; // 成功<br>proxy.age = &quot;30&quot;; // 抛出错误<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>性能</strong>：频繁拦截可能影响性能，需谨慎使用。</li><li><strong>兼容性</strong>：现代浏览器支持良好，旧环境可能需要 polyfill。</li></ul><p><strong>可撤销代理</strong>：通过 <code>Proxy.revocable()</code> 创建可取消的代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);<br>revoke(); // 后续操作 proxy 将报错<br></code></pre></td></tr></table></figure><p>通过结合 <strong>Proxy</strong> 和 <strong>Reflect</strong>，开发者可以实现高度灵活的对象操作，增强代码的可控性和可维护性。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是 JavaScript 中处理异步操作的核心机制。</p><p><strong>1. 三种状态</strong></p><ul><li><strong>Pending（待定）</strong>：初始状态，未完成或被拒绝。</li><li><strong>Fulfilled（已兑现）</strong>：操作成功完成，调用 <code>resolve(value)</code>。</li><li><strong>Rejected（已拒绝）</strong>：操作失败，调用 <code>reject(error)</code>。</li><li><strong>状态不可逆</strong>：一旦状态变为 Fulfilled 或 Rejected，将不再改变。</li></ul><p><strong>基本用法</strong></p><p>通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor,这个回调函数会被立即执行，并且给传入另外两个回调函数(resolve、reject)当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数:当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs plain">const promise = new Promise((resolve, reject) =&gt; &#123;<br>  // 异步操作（如 API 请求、定时器等）<br>  if (/* 成功 */) &#123;<br>    resolve(value); // 状态变为 Fulfilled<br>  &#125; else &#123;<br>    reject(error);  // 状态变为 Rejected<br>  &#125;<br>&#125;);<br>&lt;script&gt;<br>    const p = new Promise((resolve) =&gt; &#123;<br>      // setTimeout(resolve, 2000)<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;p的resolve&quot;)<br>      &#125;, 2000)<br>    &#125;)<br><br>    const promise = new Promise((resolve, reject) =&gt; &#123;<br>      // 1.普通值<br>      // resolve([<br>      //   &#123;name: &quot;macbook&quot;, price: 9998, intro: &quot;有点贵&quot;&#125;,<br>      //   &#123;name: &quot;iPhone&quot;, price: 9.9, intro: &quot;有点便宜&quot;&#125;,<br>      // ])<br><br>      // 2.resolve(promise)<br>      // 如果resolve的值本身Promise对象, 那么当前的Promise的状态会有传入的Promise来决定<br>      // resolve(p)<br><br>      // 3.resolve(thenable对象)<br>      resolve(&#123;<br>        name: &quot;kobe&quot;,<br>        //由then来决定<br>        then: function(resolve) &#123;<br>          resolve(11111)<br>        &#125;<br>      &#125;)<br>    &#125;)<br><br>    promise.then(res =&gt; &#123;<br>      console.log(&quot;then中拿到结果:&quot;, res)<br>    &#125;)<br><br>  &lt;/script&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    const promise = new Promise((resolve, reject) =&gt; &#123;<br>      resolve(&quot;aaaaaaa&quot;)<br>      // reject()<br>    &#125;)<br><br>    // 1.then方法是返回一个新的Promise, 这个新Promise的决议是等到then方法传入的回调函数有返回值时, 进行决议<br>    // Promise本身就是支持链式调用<br>    // then方法是返回一个新的Promise, 链式中的then是在等待这个新的Promise有决议之后执行的<br>    // promise.then(res =&gt; &#123;<br>    //   console.log(&quot;第一个then方法:&quot;, res)<br>    //   return &quot;bbbbbbbb&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;第二个then方法:&quot;, res)<br>    //   return &quot;cccccccc&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;第三个then方法:&quot;, res)<br>    // &#125;)<br><br>    // promise.then(res =&gt; &#123;<br>    //   console.log(&quot;添加第二个then方法:&quot;, res)<br>    // &#125;)<br><br>    // 2.then方法传入回调函数的返回值类型<br>    const newPromise = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;why&quot;)<br>      &#125;, 3000)<br>    &#125;)<br><br>    promise.then(res =&gt; &#123;<br>      console.log(&quot;第一个Promise的then方法:&quot;, res)<br>      // 1.普通值<br>      // return &quot;bbbbbbb&quot;<br>      // 2.新的Promise<br>      // return newPromise<br>      // 3.thenable的对象<br>      return &#123;<br>        then: function(resolve) &#123;<br>          resolve(&quot;thenable&quot;)<br>        &#125;<br>      &#125;<br>    &#125;).then(res =&gt; &#123;<br>      console.log(&quot;第二个Promise的then方法:&quot;, res) <br>    &#125;)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    const promise = new Promise((resolve, reject) =&gt; &#123;<br>      // reject(&quot;error: aaaaa&quot;)<br>      resolve(&quot;aaaaaa&quot;)<br>    &#125;)<br><br>    // 1.catch方法也会返回一个新的Promise<br>    // promise.catch(err =&gt; &#123;<br>    //   console.log(&quot;catch回调:&quot;, err)<br>    //   return &quot;bbbbb&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;then第一个回调:&quot;, res)<br>    //   return &quot;ccccc&quot;<br>    // &#125;).then(res =&gt; &#123;<br>    //   console.log(&quot;then第二个回调:&quot;, res)<br>    // &#125;)<br><br>    // 2.catch方法的执行时机<br>    promise.then(res =&gt; &#123;<br>      console.log(&quot;then第一次回调:&quot;, res)<br>      // throw new Error(&quot;第二个Promise的异常error&quot;) <br>      return &quot;bbbbbb&quot;<br>    &#125;).then(res =&gt; &#123;<br>      console.log(&quot;then第二次回调:&quot;, res)<br>      throw new Error(&quot;第三个Promise的异常error&quot;)<br>    &#125;).then(res =&gt; &#123;<br>      console.log(&quot;then第三次回调:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;catch回调被执行:&quot;, err)<br>    &#125;)<br><br>    // 中断函数继续执行:<br>    // 方式一: return<br>    // 方式二: throw new Error()<br>    // 方式三: yield 暂停(暂时性的中断)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>2. 链式调用</strong></p><ul><li><code>** .then() **</code>：处理成功结果，可返回新值或 Promise。</li><li><code>** .catch() **</code>：捕获链中所有错误。</li><li><code>** .finally() **</code>：无论成功或失败都会执行，通常用于清理。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">doSomething()<br>  .then(result =&gt; doSomethingElse(result))<br>  .then(newResult =&gt; doThirdThing(newResult))<br>  .catch(error =&gt; console.error(error))<br>  .finally(() =&gt; stopLoading());<br></code></pre></td></tr></table></figure><p><strong>3. 静态方法</strong></p><ul><li><code>** Promise.resolve(value) **</code>：返回一个已解决的 Promise。</li><li><code>** Promise.reject(error) **</code>：返回一个已拒绝的 Promise。</li><li><code>** Promise.all([p1, p2, ...]) **</code>：所有成功时返回结果数组；任一失败立即拒绝。</li><li><code>** Promise.race([p1, p2, ...]) **</code>：采用第一个完成（成功或失败）的 Promise 结果。</li><li><code>** Promise.allSettled([p1, p2, ...]) **</code>：等待所有完成，返回状态和结果数组。</li><li><code>** Promise.any([p1, p2, ...]) **</code>：任一成功则返回其值，全部失败则抛出 <code>AggregateError</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    // 创建三个Promise<br>    const p1 = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        // resolve(&quot;p1 resolve&quot;)<br>        reject(&quot;p1 reject error&quot;)<br>      &#125;, 3000)<br>    &#125;)<br><br>    const p2 = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;p2 resolve&quot;)<br>      &#125;, 2000)<br>    &#125;)<br>    <br>    const p3 = new Promise((resolve, reject) =&gt; &#123;<br>      setTimeout(() =&gt; &#123;<br>        resolve(&quot;p3 resolve&quot;)<br>      &#125;, 5000)<br>    &#125;)<br><br>    // all:全部/所有 所有成功时返回结果数组；任一失败立即拒绝。<br>    Promise.all([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;all promise res:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;all promise err:&quot;, err)<br>    &#125;)<br><br>    <br>    //allSettled 等待所有完成，返回状态和结果数组。<br>    Promise.allSettled([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;all settled:&quot;, res)<br>    &#125;)<br><br>    // 类方法: race方法<br>    // 特点: 会等到一个Promise有结果(无论这个结果是fulfilled还是rejected)<br>    Promise.race([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;race promise:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;race promise err:&quot;, err)<br>    &#125;)<br><br>    <br>   // 类方法: any方法 任一成功则返回其值，全部失败则抛出 AggregateError。<br>    Promise.any([p1, p2, p3]).then(res =&gt; &#123;<br>      console.log(&quot;any promise res:&quot;, res)<br>    &#125;).catch(err =&gt; &#123;<br>      console.log(&quot;any promise err:&quot;, err)<br>    &#125;)<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>4. 错误处理</strong></p><ul><li><strong>隐式冒泡</strong>：链中未处理的错误会传递到最近的 <code>.catch()</code>。</li><li><strong>同步错误捕获</strong>：执行器函数中的同步错误自动触发拒绝。</li><li><strong>异步错误需显式拒绝</strong>：在异步回调（如 <code>setTimeout</code>）中需手动调用 <code>reject()</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 正确捕获异步错误<br>new Promise((resolve, reject) =&gt; &#123;<br>  setTimeout(() =&gt; &#123;<br>    reject(new Error(&quot;Async error&quot;));<br>  &#125;, 1000);<br>&#125;).catch(error =&gt; console.log(error));<br></code></pre></td></tr></table></figure><p><strong>5. 常见陷阱</strong></p><ul><li><strong>返回值缺失</strong>：<code>.then()</code> 中未 <code>return</code> 将导致后续接收 <code>undefined</code>。</li><li><strong>嵌套 Promise</strong>：避免嵌套，改用链式调用。</li><li><strong>未处理的拒绝</strong>：始终添加 <code>.catch()</code> 防止未捕获错误。</li></ul><p><strong>6. 与 async&#x2F;await 结合</strong></p><ul><li><code>** async **</code> ****<strong>函数</strong>：返回 Promise，可用 <code>await</code> 等待异步操作。</li><li><strong>错误处理</strong>：结合 <code>try/catch</code> 捕获异常。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function fetchData() &#123;<br>  try &#123;<br>    const data = await apiCall();<br>    const processed = await processData(data);<br>    console.log(processed);<br>  &#125; catch (error) &#123;<br>    console.error(&quot;Fetch failed:&quot;, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7. 应用场景</strong></p><ul><li><strong>并行任务</strong>：<code>Promise.all</code> 处理多个独立异步操作。</li><li><strong>竞速请求</strong>：<code>Promise.race</code> 实现超时控制。</li><li><strong>顺序执行</strong>：链式调用逐个处理依赖任务的结果。</li></ul><p>掌握 Promise 的关键在于理解状态流转、链式调用机制及错误处理策略。结合 <code>async/await</code> 可进一步提升代码可读性，有效管理异步流程。</p><h4 id="Iterator-Generator-迭代器-生成器"><a href="#Iterator-Generator-迭代器-生成器" class="headerlink" title="Iterator-Generator(迭代器-生成器)"></a>Iterator-Generator(迭代器-生成器)</h4><p>在 JavaScript 中，<strong>迭代器（Iterator）</strong>、<strong>生成器</strong>（Generator）<strong>和可迭代对象</strong>（Iterable）是处理数据集合和异步编程的重要概念。</p><h5 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h5><p>迭代器_(iteratbr)，使用户在容器对象(container，例如链表或数组)上遍访的对象，使用该接口无需关心对象的内部实现细节。</p><ol><li><strong>定义</strong>   一个对象，必须实现 <code>** next() **</code> 方法，返回 <code>&#123; value: any, done: boolean &#125;</code>。</li></ol><p><strong>手动创建迭代器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">function createCounter(max) &#123;<br>  let count = 0;<br>  return &#123;<br>    next() &#123;<br>      return count &lt; max <br>        ? &#123; value: count++, done: false &#125; <br>        : &#123; done: true &#125;;<br>    &#125;<br>  &#125;;<br>&#125;<br><br>const counter = createCounter(3);<br>console.log(counter.next().value); // 0<br>console.log(counter.next().value); // 1<br></code></pre></td></tr></table></figure><ol><li><strong>迭代器协议</strong>   任何对象只要实现了 <code>next()</code> 方法，符合返回 <code>&#123;value, done&#125;</code> 的规则，就是一个迭代器。</li></ol><h5 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象(Iterable)"></a>可迭代对象(Iterable)</h5><p><strong>定义</strong>   实现了 <code>** [Symbol.iterator]() **</code> 方法的对象，该方法返回一个<strong>迭代器</strong>。可被 <code>for...of</code> 遍历。</p><p><strong>常见内置可迭代对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>, <span class="hljs-title class_">String</span>, <span class="hljs-title class_">Map</span>, <span class="hljs-title class_">Set</span>, <span class="hljs-title class_">TypedArray</span>, <span class="hljs-variable language_">arguments</span>, <span class="hljs-title class_">NodeList</span> 等 <br></code></pre></td></tr></table></figure><p><strong>手动实现可迭代对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs plain">const obj = &#123;<br>      fri: [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;],<br>      [Symbol.iterator]() &#123;<br>        let num = 0;<br>        return &#123;<br>          next: () =&gt; &#123;<br>          //使用箭头函数,无this,上层作用域找this,找到顶层<br>            return num &lt;= this.fri.length ? &#123; done: false, value: this.fri[num++] &#125; : &#123; done: true &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    for (const o of obj) &#123;<br>      console.log(o);<br>    &#125;<br>    console.log(obj[Symbol.iterator]);<br>    console.log(obj[Symbol.iterator]());<br><br>    const iterFun = obj[Symbol.iterator]()<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>    console.log(iterFun.next());<br>  const obj=&#123;<br>    name:&#x27;MirZ&#x27;,<br>    age:&#x27;18&#x27;,<br>    address:&#x27;河南&#x27;,<br>    [Symbol.iterator]()&#123;<br>      // const keys=Object.keys(this)<br>      // const values=Object.values(this)<br>      const entries=Object.entries(this)<br>      let count=0<br>      return&#123;<br>        next:()=&gt;&#123;<br>          return count&lt;entries.length?&#123;done:false,value:entries[count++]&#125;:&#123;done:true&#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  for (const element of obj) &#123;<br>    console.log(element);<br>    <br>  &#125;<br>class Person &#123;<br>      constructor(name, age, height, friends) &#123;<br>        this.name = name<br>        this.age = age<br>        this.height = height<br>        this.friends = friends<br>      &#125;<br><br>      // 实例方法<br>      running() &#123;&#125;<br>      [Symbol.iterator]() &#123;<br>        let index = 0<br>        const iterator = &#123;<br>          next: () =&gt; &#123;<br>            if (index &lt; this.friends.length) &#123;<br>              return &#123; done: false, value: this.friends[index++] &#125;<br>            &#125; else &#123;<br>              return &#123; done: true &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>        return iterator<br>      &#125;<br>    &#125;<br><br>    const p1 = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])<br>    const p2 = new Person(&quot;kobe&quot;, 30, 1.98, [&quot;curry&quot;, &quot;james&quot;, &quot;aonier&quot;, &quot;weide&quot;])<br><br>    for (const item of p2) &#123;<br>      console.log(item)<br>    &#125;<br>class Person &#123;<br>      constructor(name, age, height, friends) &#123;<br>        this.name = name<br>        this.age = age<br>        this.height = height<br>        this.friends = friends<br>      &#125;<br><br>      // 实例方法<br>      running() &#123;&#125;<br>      [Symbol.iterator]() &#123;<br>        let index = 0<br>        const iterator = &#123;<br>          next: () =&gt; &#123;<br>            if (index &lt; this.friends.length) &#123;<br>              return &#123; done: false, value: this.friends[index++] &#125;<br>            &#125; else &#123;<br>              return &#123; done: true &#125;<br>            &#125;<br>          &#125;,<br>          return: () =&gt; &#123;<br>            console.log(&quot;监听到迭代器中断了&quot;)<br>            return &#123; done: true &#125;<br>          &#125;<br>        &#125;<br>        return iterator<br>      &#125;<br>    &#125;<br><br>    <br>    const p1 = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])<br><br>    for (const item of p1) &#123;<br>      console.log(item)<br>      if (item === &quot;kobe&quot;) &#123;<br>        break<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p><strong>定义</strong></p><p>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等   通过 <code>** function* **</code> 定义的函数，返回一个<strong>生成器对象</strong>（既是迭代器又是可迭代对象）。</p><p><strong>生成器和普通的函数区别:</strong></p><ul><li>首先，生成器函数需要在function的后面加一个符号:*</li><li>其次，生成器函数可以通过yield关键字来控制函数的执行流程</li><li>最后，生成器函数的返回值是一个Generator(生成器)</li><li>生成器是一种特殊的迭代器</li></ul><p><code>** yield **</code> ****<strong>关键字</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">-  暂停函数执行并返回一个值。 <br>-  通过  ` <span class="hljs-built_in">next</span>() `  恢复执行，可传递参数给生成器。 <br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>const generator = gen();<br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>()); // &#123; value: <span class="hljs-number">1</span>, done: <span class="hljs-literal">false</span> &#125;<br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>()); <br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>());<br>console.<span class="hljs-built_in">log</span>(generator.<span class="hljs-built_in">next</span>());<br></code></pre></td></tr></table></figure><p><strong>生成器的惰性求值</strong>   生成器按需生成值，适合处理大数据或无限序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">function* fibonacci() &#123;<br>  let a = 0, b = 1;<br>  while (true) &#123;<br>    yield a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生成器的高级用法</strong></p><ul><li><strong>传参给</strong> <code>** next() **</code>：向生成器内部传递值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain"> function* fibonacci() &#123;<br>  let a = 0, b = 1;<br>  while (true) &#123;<br>    yield a;<br>    [a, b] = [b, a + b];<br>  &#125;<br>&#125;<br>const gen=fibonacci()<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>// console.log(gen.return());<br>// console.log(gen.throw(new Error(&#x27;结束&#x27;)));<br>console.log(gen.next());<br>console.log(gen.next());<br>console.log(gen.next());<br>- ** 错误处理 ** ：使用    ` generator.throw(err) `    抛出错误。 <br>- ** 提前终止 ** ：使用  ` generator.return() `  结束生成器。 <br></code></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><strong>迭代器和生成器的关系</strong></p><ol><li><strong>生成器是迭代器的语法糖</strong>   生成器自动实现 <code>[Symbol.iterator]()</code> 和 <code>next()</code>，简化迭代器创建。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs plain"> const obj=&#123;<br>      names:[&#x27;李卓&#x27;,&#x27;叶茂华&#x27;,&#x27;MirZ&#x27;]<br>    &#125;<br>    function* creatItera(obj)&#123;<br>      for (let index = 0; index &lt; obj.names.length; index++) &#123;<br>        yield obj.names[index]        <br>      &#125;<br>    &#125;<br>    const objItera=creatItera(obj)<br>    console.log(objItera.next());<br>    console.log(objItera.next());<br>    console.log(objItera.next());<br>    console.log(objItera.next());<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>  &lt;script&gt;<br>   class Person &#123;<br>      constructor(name, age, height, friends) &#123;<br>        this.name = name<br>        this.age = age<br>        this.height = height<br>        this.friends = friends<br>      &#125;<br><br>      // 实例方法<br>      *[Symbol.iterator]() &#123;<br>        //yield* 用于委托给另一个可迭代对象。它会遍历这个可迭代对象，并逐个 yield 其中的元素，而不是将整个可迭代对象作为一个元素返回。<br>      yield* this.friends<br>      &#125;<br>    &#125;<br><br>    const p = new Person(&quot;why&quot;, 18, 1.88, [&quot;curry&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;tatumu&quot;])<br><br>    for (const item of p) &#123;<br>      console.log(item)<br>    &#125;<br>    // const pItera=p[Symbol.iterator]()<br>    // console.log(pItera.next());<br>    // console.log(pItera.next());<br>    // console.log(pItera.next());<br>    // console.log(pItera.next());<br>    <br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ol><li><strong>生成器对象的特性</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const genObj = gen();<br>console.log(genObj[Symbol.iterator]() === genObj); // true<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ol><li><code>** for...of **</code> <strong>循环</strong>   遍历可迭代对象：</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> of <span class="hljs-string">&#x27;Hello&#x27;</span>) console.log(<span class="hljs-keyword">char</span>); <span class="hljs-comment">// H, e, l, l, o</span><br></code></pre></td></tr></table></figure><ol><li><strong>解构赋值与扩展运算符</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">const [a, b] = [10, 20];      // 解构<br>const arr = [...&#x27;abc&#x27;];       // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]<br></code></pre></td></tr></table></figure><ol><li><strong>异步迭代器（Async Iterators）</strong>   与 <code>for await...of</code> 配合处理异步数据流：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function* asyncGen() &#123;<br>  yield await Promise.resolve(1);<br>  yield await Promise.resolve(2);<br>&#125;<br><br>(async () =&gt; &#123;<br>  for await (const num of asyncGen()) console.log(num); // 1, 2<br>&#125;)();<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>概念</strong></th><th><strong>关键点</strong></th></tr></thead><tbody><tr><td><strong>可迭代对象</strong></td><td>必须实现 <code>[Symbol.iterator]()</code>，返回迭代器。</td></tr><tr><td><strong>迭代器</strong></td><td>必须实现 <code>next()</code>，返回 <code>&#123; value, done &#125;</code>。</td></tr><tr><td><strong>生成器</strong></td><td>通过 <code>function*</code>定义，简化迭代器创建，支持暂停&#x2F;恢复执行和双向通信。</td></tr></tbody></table><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><h5 id="异步处理方式"><a href="#异步处理方式" class="headerlink" title="异步处理方式"></a>异步处理方式</h5><p>最早的异步处理方式可能是回调函数，比如在setTimeout或者事件监听中使用回调。但回调的问题在于容易导致回调地狱，代码难以维护。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <br>  &lt;script&gt;<br><br>    // 封装请求的方法: url -&gt; promise(result)<br>    function requestData(url) &#123;<br>      return new Promise((resolve, reject) =&gt; &#123;<br>        setTimeout(() =&gt; &#123;<br>          resolve(url)<br>        &#125;, 2000)<br>      &#125;)<br>    &#125;<br><br>    // 1.发送一次网络请求<br>    // requestData(&quot;http://why&quot;).then(res =&gt; &#123;<br>    //   console.log(&quot;res:&quot;, res)<br>    // &#125;)<br><br>    /*<br>      需求: <br>        1.发送一次网络请求, 等到这次网络请求的结果<br>        2.发送第二次网络请求, 等待这次网络请求的结果<br>        3.发送第三次网络请求, 等待这次网络请求的结果<br>    */<br>    // 方式一: 层层嵌套(回调地狱 callback hell)<br>    // function getData() &#123;<br>    //   // 1.第一次请求<br>    //   requestData(&quot;why&quot;).then(res1 =&gt; &#123;<br>    //     console.log(&quot;第一次结果:&quot;, res1)<br><br>    //     // 2.第二次请求<br>    //     requestData(res1 + &quot;kobe&quot;).then(res2 =&gt; &#123;<br>    //       console.log(&quot;第二次结果:&quot;, res2)<br><br>    //       // 3.第三次请求<br>    //       requestData(res2 + &quot;james&quot;).then(res3 =&gt; &#123;<br>    //         console.log(&quot;第三次结果:&quot;, res3)<br>    //       &#125;)<br>    //     &#125;)<br>    //   &#125;)<br>    // &#125;<br><br>    // 方式二: 使用Promise进行重构(解决回调地狱)<br>    // 链式调用<br>    // function getData() &#123;<br>    //   requestData(&quot;why&quot;).then(res1 =&gt; &#123;<br>    //     console.log(&quot;第一次结果:&quot;, res1)<br>    //     return requestData(res1 + &quot;kobe&quot;)<br>    //   &#125;).then(res2 =&gt; &#123;<br>    //     console.log(&quot;第二次结果:&quot;, res2)<br>    //     return requestData(res2 + &quot;james&quot;)<br>    //   &#125;).then(res3 =&gt; &#123;<br>    //     console.log(&quot;第三次结果:&quot;, res3)<br>    //   &#125;)<br>    // &#125;<br><br>    // 方式三: 最终代码<br>    // function* getData() &#123;<br>    //   const res1 = yield requestData(&quot;why&quot;)<br>    //   console.log(&quot;res1:&quot;, res1)<br><br>    //   const res2 = yield requestData(res1 + &quot;kobe&quot;)<br>    //   console.log(&quot;res2:&quot;, res2)<br><br>    //   const res3 = yield requestData(res2 + &quot;james&quot;)<br>    //   console.log(&quot;res3:&quot;, res3)<br>    // &#125;<br><br>    // const generator = getData()<br>    // generator.next().value.then(res1 =&gt; &#123;<br>    //   generator.next(res1).value.then(res2 =&gt; &#123;<br>    //     generator.next(res2).value.then(res3 =&gt; &#123;<br>    //       generator.next(res3)<br>    //     &#125;)<br>    //   &#125;)<br>    // &#125;)<br><br>    // 方式四: async/await的解决方案<br>    async function getData() &#123;<br>      const res1 = await requestData(&quot;why&quot;)<br>      console.log(&quot;res1:&quot;, res1)<br><br>      const res2 = await requestData(res1 + &quot;kobe&quot;)<br>      console.log(&quot;res2:&quot;, res2)<br><br>      const res3 = await requestData(res2 + &quot;james&quot;)<br>      console.log(&quot;res3:&quot;, res3)<br>    &#125;<br><br>    const generator = getData()<br><br>  &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br>    // 封装请求的方法: url -&gt; promise(result)<br>    function requestData(url) &#123;<br>      return new Promise((resolve, reject) =&gt; &#123;<br>        setTimeout(() =&gt; &#123;<br>          resolve(url)<br>        &#125;, 2000)<br>      &#125;)<br>    &#125;<br><br>    // 生成器的处理方案<br>    function* getData() &#123;<br>      const res1 = yield requestData(&quot;why&quot;)<br>      console.log(&quot;res1:&quot;, res1)<br><br>      const res2 = yield requestData(res1 + &quot;kobe&quot;)<br>      console.log(&quot;res2:&quot;, res2)<br><br>      const res3 = yield requestData(res2 + &quot;james&quot;)<br>      console.log(&quot;res3:&quot;, res3)<br><br>      const res4 = yield requestData(res3 + &quot;curry&quot;)<br>      console.log(&quot;res4:&quot;, res4)<br><br>      const res5 = yield requestData(res4 + &quot;tatumu&quot;)<br>      console.log(&quot;res5:&quot;, res5)<br>    &#125;<br><br>    // const generator = getData()<br>    // generator.next().value.then(res1 =&gt; &#123;<br>    //   generator.next(res1).value.then(res2 =&gt; &#123;<br>    //     generator.next(res2).value.then(res3 =&gt; &#123;<br>    //       generator.next(res3).value.then(res4 =&gt; &#123;<br>    //         generator.next(res4)<br>    //       &#125;)<br>    //     &#125;)<br>    //   &#125;)<br>    // &#125;)<br><br>    // 自动化执行生成器函数(了解)<br>    function execGenFn(genFn) &#123;<br>      // 1.获取对应函数的generator<br>      const generator = genFn()<br>      // 2.定义一个递归函数<br>      function exec(res) &#123;<br>        // result -&gt; &#123; done: true/false, value: 值/undefined &#125;<br>        const result = generator.next(res)<br>        if (result.done) return<br>        result.value.then(res =&gt; &#123;<br>          exec(res)<br>        &#125;)<br>      &#125;<br>      // 3.执行递归函数<br>      exec()<br>    &#125;<br><br>    execGenFn(getData)<br></code></pre></td></tr></table></figure><h5 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h5><p><strong>异步函数基础</strong></p><ul><li><strong>定义</strong>：通过 <code>async</code> 关键字声明的函数，内部可使用 <code>await</code> 等待 Promise 完成。</li><li><strong>返回值</strong>：<code>async</code> 函数<strong>始终返回一个 Promise</strong>：<ul><li>若函数返回非 Promise 值，会被隐式转换为 <code>Promise.resolve(值)</code>。</li><li>若抛出错误（<code>throw</code>），返回 <code>Promise.reject(错误)</code>。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function getData() &#123;<br>  return 42; // 等价于 Promise.resolve(42)<br>&#125;<br>getData().then(console.log); // 输出 42<br></code></pre></td></tr></table></figure><p>**  **<code>** await **</code> <strong>关键字的核心规则</strong></p><ul><li><strong>作用</strong>：暂停 <code>async</code> 函数执行，等待右侧的 Promise 完成。<ul><li>若 Promise 成功，<code>await</code> 返回解析后的值。</li><li>若 Promise 失败，<code>await</code> 抛出拒绝原因（可用 <code>try/catch</code> 捕获）。</li></ul></li><li><strong>限制</strong>：<code>await</code> <strong>只能在</strong> <code>** async **</code> <strong>函数内部使用</strong>，否则报语法错误。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">async function fetchUser() &#123;<br>  const response = await fetch(&#x27;/api/user&#x27;); // 等待网络请求完成<br>  const user = await response.json();        // 等待 JSON 解析<br>  return user;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错误处理</strong></p><ul><li><code>** try/catch **</code> ****<strong>捕获错误</strong>：同步风格处理异步错误。</li><li><code>** .catch() **</code> <strong>兜底</strong>：<code>async</code> 函数返回的 Promise 可链式调用 <code>.catch()</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 方式 1: try/catch<br>async function loadData() &#123;<br>  try &#123;<br>    const data = await fetchApi();<br>  &#125; catch (error) &#123;<br>    console.error(&#x27;加载失败:&#x27;, error);<br>  &#125;<br>&#125;<br><br>// 方式 2: .catch()<br>loadData().catch(error =&gt; console.error(&#x27;兜底捕获:&#x27;, error));<br></code></pre></td></tr></table></figure><h5 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h5><h6 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h6><p><strong>线程和进程是操作系统中的两个概念:</strong></p><p>进程(process):计算机已经运行的程序，是操作系统管理程序的一种方式:</p><p>线程(thread):操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中;</p><p>:::tips 听起来很抽象，这里还是给出我的解释:</p><ul><li>进程:我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程):</li><li>线程:每一个进程中，都会启动至少一个线程用来执行程序中的代码，这个线程被称之为主线程</li></ul><p>所以我们也可以说进程是线程的容器</p><p>:::</p><h6 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h6><p>JavaScript是单线程(可以开启workers)的，但是JavaScript的线程有自己的容器进程:浏览器或者Node.</p><p>目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出,每个进程中又有很多的线程，其中包括执行JavaScript代码的线程</p><p>JavaScript的代码执行是在一个单独的线程中执行的,这就意味着JavaScript的代码在同一个时刻只能做一件事,如果这件事是非常耗时的，就意味着当前的线程就会被阻塞</p><p><a href="https://www.yuque.com/wudibawanglong-gbppc/frgahd/rkcthgb5bpuwyui3">事件循环</a></p><p><strong>宏任务和微任务</strong></p><p>但是事件循环中并非只维护着一个队列，事实上是有两个队列:</p><ul><li>宏任务队列(macrotask queue):ajax、setTimeout、setlnterval、DOM监听、Ul Rendering等</li><li>微任务队列(microtask queue):Promise的then回调、Mutation Observer APl、queueMicrotask()等</li></ul><p><strong>那么事件循环对于两个队列的优先级是怎么样的呢?</strong></p><ul><li>1.main script中的代码优先执行(编写的顶层script代码);</li><li>2.在执行任何一个宏任务之前(不是队列，是一个宏任务)，都会先查看微任务队列中是否有任务需要执行, 也就是宏任务执行之前，必须保证微任务队列是空的;如果不为空，那么就优先执行微任务队列中的任务(回调):</li></ul><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>)          <span class="hljs-comment">//1</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout1&quot;</span>);  <span class="hljs-comment">//8</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>();<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then4&quot;</span>);  <span class="hljs-comment">//10</span><br>    &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then2&quot;</span>);  <span class="hljs-comment">//9</span><br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);  <span class="hljs-comment">//2</span><br>  <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then1&quot;</span>);  <span class="hljs-comment">//5</span><br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout2&quot;</span>);  <span class="hljs-comment">//11</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">//3</span><br><span class="hljs-comment">//直接将一个函数加入微队列</span><br><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;queueMicrotask1&quot;</span>)  <span class="hljs-comment">//6</span><br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then3&quot;</span>);  <span class="hljs-comment">//7</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script end&quot;</span>)  <span class="hljs-comment">//4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;requestData&quot;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>)<br>      <span class="hljs-title function_">resolve</span>(url)<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 2.await/async</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getData start&quot;</span>)<br>  <span class="hljs-comment">//await只有等到promise的结果返回才会执行后续代码</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">requestData</span>(<span class="hljs-string">&quot;why&quot;</span>)<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then1-res:&quot;</span>, res)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getData end&quot;</span>)<br>&#125;<br><br><span class="hljs-title function_">getData</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script end&quot;</span>)<br><br><span class="hljs-comment">// script start</span><br><span class="hljs-comment">// getData start</span><br><span class="hljs-comment">// requestData</span><br><span class="hljs-comment">// script end</span><br><br><span class="hljs-comment">// setTimeout</span><br><br><span class="hljs-comment">// then1-res: why</span><br><span class="hljs-comment">// getData end</span><br> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>)  <span class="hljs-comment">//2</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>      <span class="hljs-comment">// async2()执行完后会return undefined ==&gt; Promise.resolve(undefined) ,下面代码放入微任务队列</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)   <span class="hljs-comment">// 6</span><br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)  <span class="hljs-comment">//3</span><br>    &#125;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)  <span class="hljs-comment">//1</span><br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)   <span class="hljs-comment">//8</span><br>    &#125;, <span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-title function_">async1</span>(); <br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)  <span class="hljs-comment">//4</span><br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-property">then</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)  <span class="hljs-comment">//7</span><br>    &#125;)<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)   <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h4 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h4><p>Storage 用于在客户端存储数据，主要包括 <code>localStorage</code> 和 <code>sessionStorage</code>，属于 Web Storage API。</p><p><strong>1. 类型与区别</strong></p><ul><li><strong>localStorage</strong><ul><li><strong>生命周期</strong>：永久存储，需手动删除（代码或浏览器清除）。</li><li><strong>作用域</strong>：同源（协议、域名、端口相同）的所有标签页和窗口共享。</li></ul></li><li><strong>sessionStorage</strong><ul><li><strong>生命周期</strong>：仅限当前会话，关闭标签页或浏览器后清除。</li><li><strong>作用域</strong>：仅在当前标签页有效，同源其他标签页无法访问。</li></ul></li></ul><p><strong>2. 常用方法</strong></p><p><strong>存储数据</strong>：<code>setItem(key, value)</code></p><ul><li><code>localStorage.setItem(&#39;username&#39;, &#39;Alice&#39;);</code></li></ul><p><strong>读取数据</strong>：<code>getItem(key)</code></p><ul><li><code>const user = localStorage.getItem(&#39;username&#39;); // &#39;Alice&#39;</code></li></ul><p><strong>删除数据</strong>：<code>removeItem(key)</code></p><ul><li><code>localStorage.removeItem(&#39;username&#39;);</code></li></ul><p><strong>清空所有数据</strong>：<code>clear()</code></p><ul><li><code>localStorage.clear();</code></li></ul><p><strong>3. 数据格式</strong></p><p><strong>仅支持字符串</strong>：存储对象需序列化，读取时反序列化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;;<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));<br><span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>4. 存储事件（storage Event）</strong></p><ul><li><strong>触发条件</strong>：同源其他标签页修改 Storage 时触发。</li><li><strong>事件对象属性</strong>：<code>key</code>、<code>oldValue</code>、<code>newValue</code>、<code>url</code> 等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">window.addEventListener(&#x27;storage&#x27;, (e) =&gt; &#123;<br>  console.log(`$&#123;e.key&#125; 值从 $&#123;e.oldValue&#125; 变为 $&#123;e.newValue&#125;`);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>5. 容量限制</strong></p><ul><li><strong>大小</strong>：约 5MB（不同浏览器可能不同）。</li><li><strong>错误处理</strong>：超出限制会抛出 <code>QuotaExceededError</code>，需使用 <code>try...catch</code>处理。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">try &#123;<br>  localStorage.setItem(&#x27;bigData&#x27;, new Array(5 * 1024 * 1024).join(&#x27;a&#x27;));<br>&#125; catch (e) &#123;<br>  console.error(&#x27;存储失败：&#x27;, e);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6. 安全性与兼容性</strong></p><ul><li><strong>明文存储</strong>：避免保存敏感信息（如密码）。</li><li><strong>XSS 风险</strong>：若网站存在 XSS 漏洞，攻击者可读取 Storage 数据。</li><li><strong>兼容性</strong>：现代浏览器均支持，IE8+ 支持，但隐私模式可能受限。</li></ul><p><strong>检测支持</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">function isStorageSupported() &#123;<br>  try &#123;<br>    const testKey = &#x27;__test__&#x27;;<br>    localStorage.setItem(testKey, testKey);<br>    localStorage.removeItem(testKey);<br>    return true;<br>  &#125; catch (e) &#123;<br>    return false;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>7. 注意事项</strong></p><ul><li><strong>类型转换</strong>：非字符串数据会被自动转换（如 <code>true</code> 转为 <code>&quot;true&quot;</code>）。</li><li><strong>遍历键值</strong>：通过 <code>length</code> 和 <code>key(index)</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">for (let i = 0; i &lt; localStorage.length; i++) &#123;<br>  const key = localStorage.key(i);<br>  console.log(key, localStorage.getItem(key));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>隐私模式</strong>：部分浏览器在隐身模式下禁用 Storage，需异常处理。</li></ul><p><strong>8. 与 Cookie 对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>Cookie</strong></th><th><strong>Web Storage</strong></th></tr></thead><tbody><tr><td>容量</td><td>~4KB</td><td>~5MB</td></tr><tr><td>请求是否携带</td><td>每次 HTTP 请求自动携带</td><td>不参与通信</td></tr><tr><td>生命周期</td><td>可设置过期时间</td><td>永久或会话级</td></tr></tbody></table><p><strong>9. 封装工具函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">const storage = &#123;<br>  set(key, value) &#123;<br>    localStorage.setItem(key, JSON.stringify(value));<br>  &#125;,<br>  get(key) &#123;<br>    const data = localStorage.getItem(key);<br>    return data ? JSON.parse(data) : null;<br>  &#125;,<br>  remove(key) &#123;<br>    localStorage.removeItem(key);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p><h5 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h5><p>在 JavaScript 中有两种方式创建正则表达式：</p><ul><li>字面量方式</li></ul><p>使用斜杠（<code>/</code>）来界定正则表达式模式。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const pattern <span class="hljs-operator">=</span> /abc/<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>构造函数方式</li></ul><p>使用 <code>RegExp</code> 构造函数，传入模式字符串作为参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> pattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;abc&#x27;</span>); <br></code></pre></td></tr></table></figure><h5 id="正则表达式标志"><a href="#正则表达式标志" class="headerlink" title="正则表达式标志"></a>正则表达式标志</h5><p>标志可以改变正则表达式的匹配行为，标志可以单个使用，也可以组合使用。常用标志如下：</p><ul><li><code>i</code>：忽略大小写。(global)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/i</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>g</code>：全局匹配，找到所有匹配项，而不是在找到第一个匹配项后停止。(ignore)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-keyword">const</span> matches = str.<span class="hljs-title function_">match</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matches); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><code>m</code>：多行匹配，使 <code>^</code> 和 <code>$</code> 可以匹配每行的开头和结尾。(multiple)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc\nabc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/^abc/m</span>;<br><span class="hljs-keyword">const</span> matches = str.<span class="hljs-title function_">match</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matches); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br></code></pre></td></tr></table></figure><h5 id="常用的正则表达式元字符"><a href="#常用的正则表达式元字符" class="headerlink" title="常用的正则表达式元字符"></a>常用的正则表达式元字符</h5><h6 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h6><p><strong>元字符</strong></p><ul><li>基础：<code>^</code>（开头）、<code>$</code>（结尾）、<code>.</code>（任意字符，除换行符）、<code>|</code>（或）。</li><li>转义字符：<code>\d</code>（数字）、<code>\D</code>（非数字）、<code>\w</code>（单词字符）、<code>\W</code>（非单词字符）、<code>\s</code>（空白符）、<code>\S</code>（非空白符）。<code>**\. \* \? **</code> (转义特殊字符,如 . * ? [ ] \ &#x2F; ^ $ | + ( ))</li><li>边界：<code>\b</code>（单词边界）、<code>\B</code>（非单词边界）。</li></ul><p><strong>量词</strong></p><ul><li><code>*</code>（0次或多次）、<code>+</code>（1次或多次）、<code>?</code>（0或1次）。</li><li><code>&#123;n&#125;</code>（n次）、<code>&#123;n,&#125;</code>（至少n次）、<code>&#123;n,m&#125;</code>（n到m次）。</li><li><strong>非贪婪模式</strong>：在量词后加 <code>?</code>（如 <code>*?</code>、<code>+?</code>）。</li></ul><p><strong>字符集合</strong></p><ul><li><code>[abc]</code>：匹配 a、b、c 中的任意一个。</li><li><code>[^abc]</code>：匹配不在集合中的字符。</li><li><code>[a-z]</code>：匹配范围（如小写字母）。</li></ul><p><strong>分组与捕获</strong></p><ul><li><code>(abc)</code>：捕获组，通过 <code>\1</code> 或 <code>$1</code> 引用。</li><li><code>(?:abc)</code>：非捕获组，不保存匹配项。</li><li>前瞻：<code>(?=...)</code>（正向肯定）、<code>(?!=...)</code>（正向否定）。</li></ul><h6 id="元字符示例"><a href="#元字符示例" class="headerlink" title="元字符示例"></a>元字符示例</h6><ul><li><code>.</code>：匹配除换行符之外的任意单个字符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/a.c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>^</code>：匹配字符串的开头。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/^abc/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcdef&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>$</code>：匹配字符串的结尾。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc$/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;defabc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>*</code>：匹配前面的元素零次或多次。<code>&#123;0,&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab*c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abbbc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>+</code>：匹配前面的元素一次或多次。<code>&#123;1,&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab+c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abbbc&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>?</code>：匹配前面的元素零次或一次。<code>&#123;0,1&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab?c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ac&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abbbc&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><code>&#123;n,m&#125;</code>：匹配前面的元素至少 <code>n</code> 次，最多 <code>m</code> 次。<code>&#123;n&#125;</code>：匹配前面的元素恰好 <code>n</code> 次。<code>&#123;n,&#125;</code>：匹配前面的元素至少 <code>n</code> 次。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 匹配 2 到 4 个连续的数字</span><br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\d&#123;2,4&#125;/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>[]</code>：匹配方括号内的任意一个字符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/[abc]/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;d&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><code>()</code>：用于分组，将多个元素视为一个整体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/(ab)+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>|</code> :  用于表示or ,  或者</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &quot;1239891238732136321&quot;<br>const pattern=/(123|321)/ig<br>const res=message.match(pattern)<br>console.log(res);<br></code></pre></td></tr></table></figure><ul><li><code>\d</code>：匹配任意一个数字，等价于 <code>[0-9]</code>。(digit)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;cca2bc4af5cab12b&#x27;</span>;<br><span class="hljs-comment">//\d+匹配数字,将多个连续的数字也视为一个整体</span><br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\d+/ig</span>;<br><span class="hljs-keyword">const</span> newArr = str.<span class="hljs-title function_">match</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [&#x27;2&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;12&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><code>\D</code>：匹配任意非数字字符，等价于 <code>[^0-9]</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const str = &#x27;cca2bc4af5cab12b&#x27;;<br>const pattern = /\D+/ig;<br>const newArr = str.match(pattern);<br>console.log(newArr); //[&#x27;cca&#x27;, &#x27;bc&#x27;, &#x27;af&#x27;, &#x27;cab&#x27;, &#x27;b&#x27;]<br></code></pre></td></tr></table></figure><ul><li><code>\s</code>：匹配任意空白字符，包括空格、制表符、换行符等。(space)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\s/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27; &#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>\S</code>：匹配任意非空白字符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\S/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>\w</code>：匹配任意字母、数字或下划线，等价于 <code>[a-zA-Z0-9_]</code>。(word)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\w/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;x&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>\W</code>：匹配任意非字母、数字或下划线的字符，等价于 <code>[^a-zA-Z0-9_]</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/\W/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;!&#x27;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><code>\b</code>: 单词边界 , 匹配的单词两边必须是边界(不匹配\w)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &#x27;My name is MirZ&#x27;<br>    const pattern = /\bis\b/<br>    if (pattern.test(message)) &#123;<br>      console.log(&#x27;is 有边界&#x27;);<br>    &#125; else &#123;<br>      console.log(&#x27;is 无边界&#x27;);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><code>\B</code>: 单词边界 , 匹配的单词两边必须非边界</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &#x27;My name is MirZ&#x27;<br>    const pattern = /\Bis\B/<br>    if (pattern.test(message)) &#123;<br>      console.log(&#x27;is 有边界&#x27;);<br>    &#125; else &#123;<br>      console.log(&#x27;is 无边界&#x27;);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法"></a>正则表达式方法</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">test</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>用于测试字符串中是否存在匹配的模式，返回 <code>true</code> 或 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdef&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pattern.<span class="hljs-title function_">test</span>(str)); <span class="hljs-comment">// true</span><br>**<span class="hljs-title function_">exec</span>()**<br></code></pre></td></tr></table></figure><p>用于字符串中执行匹配操作，返回一个数组，包含匹配的结果和相关信息。没有匹配到，则返回 <code>null</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdef&#x27;</span>;<br><span class="hljs-keyword">const</span> result = pattern.<span class="hljs-title function_">exec</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// [&#x27;abc&#x27;, index: 0, input: &#x27;abcdef&#x27;, groups: undefined]</span><br>**<span class="hljs-title function_">match</span>()**<br></code></pre></td></tr></table></figure><p>在字符串中查找匹配的模式，返回一个数组，包含所有匹配的结果。如果没有使用 <code>g</code> 标志，则只返回第一个匹配结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern1 = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> pattern2 = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern1)); <span class="hljs-comment">// [&#x27;abc&#x27;, index: 0, input: &#x27;abc abc&#x27;, groups: undefined]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern2)); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br>**<span class="hljs-title function_">matchAll</span>()**<br></code></pre></td></tr></table></figure><p>在字符串中查找匹配的模式，返回一个迭代器。必须使用 <code>g</code> 标志</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern1 = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-keyword">const</span> pattern2 = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern1)); <span class="hljs-comment">// [&#x27;abc&#x27;, index: 0, input: &#x27;abc abc&#x27;, groups: undefined]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(pattern2)); <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br>**<span class="hljs-title function_">replace</span>()**<br></code></pre></td></tr></table></figure><p>用于替换字符串中匹配的模式，返回一个新的字符串。如果不加<code>g</code>标识符,则只替换搜索到的第一个符合的字符串,加<code>g</code>替换结果等同于<code>**replaceAll()**</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc abc&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-keyword">const</span> newStr = str.<span class="hljs-title function_">replace</span>(pattern, <span class="hljs-string">&#x27;def&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newStr); <span class="hljs-comment">// &#x27;def def&#x27;</span><br>**<span class="hljs-title function_">split</span>()**<br></code></pre></td></tr></table></figure><p>用于使用字符串中匹配的字符串进行分割字符串，返回一个新的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;ccabcabacafbcab12b&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/ab/</span>;<br><span class="hljs-keyword">const</span> newArr = str.<span class="hljs-title function_">split</span>(pattern);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [&#x27;cc&#x27;,&#x27;c&#x27;,&#x27;acefhc&#x27;,&#x27;12b&#x27;]</span><br>**<span class="hljs-title function_">search</span>()**<br></code></pre></td></tr></table></figure><p>用于查找字符串中第一个匹配的模式的索引，如果没有找到，则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc def&#x27;</span>;<br><span class="hljs-keyword">const</span> pattern = <span class="hljs-regexp">/abc/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">search</span>(pattern)); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h5 id="贪婪模式和惰性模式"><a href="#贪婪模式和惰性模式" class="headerlink" title="贪婪模式和惰性模式"></a>贪婪模式和惰性模式</h5><ul><li>贪婪匹配，它会从第一个匹配项开始，尽可能多地匹配字符，直到遇到最后一个匹配项 ，所以最终匹配的是整个字符串</li><li>惰性模式也称为非贪婪模式，通过在量词后面加上问号 <code>? </code> 来开启。在惰性模式下，量词会尽可能少地匹配符合条件的字符，一旦找到第一个匹配项就会停止匹配。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">// 1.贪婪模式/惰性模式<br>    const message = &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;<br><br>    // 默认.+采用贪婪模式<br>    // const nameRe = /《.+》/ig<br>    <br>    // const result1 = message.match(nameRe)<br>    // console.log(result1)<br><br>    // 使用惰性模式<br>    const nameRe = /《.+?》/ig<br>    <br>    const result1 = message.match(nameRe)<br>    console.log(result1)<br></code></pre></td></tr></table></figure><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p><code>() </code> 不单单可以当作一个整体 , 也可以定义捕获组。每一对括号就定义了一个捕获组，从左到右，括号的顺序决定了捕获组的编号，编号从 1 开始。第 0 个捕获组始终代表整个正则表达式匹配的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">const str = &#x27;John Smith&#x27;;<br>const pattern = /(\w+) (\w+)/;<br>const result = str.match(pattern);<br><br>console.log(result[0]); // 输出整个匹配结果：John Smith<br>console.log(result[1]); // 输出第一个捕获组：John<br>console.log(result[2]); // 输出第二个捕获组：Smith<br>const str = &#x27;Doe, John&#x27;;<br>const pattern = /(\w+), (\w+)/;<br>const newStr = str.replace(pattern, &#x27;$2 $1&#x27;);<br><br>console.log(newStr); // 输出：John Doe<br>//这里，$1 和 $2 分别代表第一个和第二个捕获组的内容，通过 replace 方法将它们的顺序进行了交换。<br>const str = &#x27;2023-10-15&#x27;;<br>const pattern = /(?<span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>\d&#123;4&#125;)-(?<span class="hljs-tag">&lt;<span class="hljs-name">month</span>&gt;</span>\d&#123;2&#125;)-(?<span class="hljs-tag">&lt;<span class="hljs-name">day</span>&gt;</span>\d&#123;2&#125;)/;<br>const result = str.match(pattern);<br><br>console.log(result.groups.year); // 输出：2023<br>console.log(result.groups.month); // 输出：10<br>console.log(result.groups.day); // 输出：15<br></code></pre></td></tr></table></figure><p><strong>非捕获组</strong></p><p>有时候，你可能只想使用括号来对正则表达式的一部分进行分组，但不想捕获匹配的内容，这时可以使用非捕获组，语法是 <code>(?:pattern)</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">const message = &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;<br><br>  //捕获组<br>// const nameRe = /(《)(?<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>.+?)(》)/ig<br>  //非捕获组<br>const nameRe = /(?:《)(?<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>.+?)(?:》)/ig<br>const iterator = message.matchAll(nameRe)<br>for (const item of iterator) &#123;<br>  console.log(item)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h5><ul><li>手机号码验证</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">const phone = &#x27;13800138000&#x27;;<br>const phonePattern = /^1[3-9]\d&#123;9&#125;$/;<br>console.log(phonePattern.test(phone)); // true<br></code></pre></td></tr></table></figure><ul><li>HTML标签匹配</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const htmlEle=&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#x27;<br>    const pattern=/&lt;\/?[a-z][a-z0-9]*&gt;/ig<br>    const res=htmlEle.match(pattern)<br>    console.log(res);<br></code></pre></td></tr></table></figure><ul><li>HTML标签内容匹配</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">const html = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#x27;;<br>const pattern = /&lt;[^&gt;]+&gt;([^&lt;]+)&lt;\/[^&gt;]+&gt;/;<br>const result = html.match(pattern);<br>if (result) &#123;<br>    console.log(result[1]); // &#x27;Hello, World!&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>格式化日期</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">const dateStr = &#x27;2023-10-15&#x27;;<br>const pattern = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;<br>const newDateStr = dateStr.replace(pattern, &#x27;$2/$3/$1&#x27;);<br>console.log(newDateStr); // &#x27;10/15/2023&#x27;<br></code></pre></td></tr></table></figure><ul><li>时间戳格式化时间</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html">// yyyy/MM/dd hh:mm:ss<br>// yyyy*MM*dd hh-mm-ss<br>// dayjs/moment<br>function formatTime(timestamp, fmtString) &#123;<br>  // 1.将时间戳转成Date<br>  const date = new Date(timestamp)<br><br>  // // 2.获取到值<br>  // const year = date.getFullYear()<br>  // const month = date.getMonth() + 1<br>  // const day = date.getDate()<br>  // const hour = date.getHours()<br>  // const minute = date.getMinutes()<br>  // const second = date.getSeconds()<br><br>  // 2.正则和值匹配起来<br>  const dateO = &#123;<br>    &quot;y+&quot;: date.getFullYear(),<br>    &quot;M+&quot;: date.getMonth() + 1,<br>    &quot;d+&quot;: date.getDate(),<br>    &quot;h+&quot;: date.getHours(),<br>    &quot;m+&quot;: date.getMinutes(),<br>    &quot;s+&quot;: date.getSeconds()<br>  &#125;<br><br>  // 3.for循环进行替换<br>  for (const key in dateO) &#123;<br>    const keyRe = new RegExp(key)<br>    if (keyRe.test(fmtString)) &#123;<br>      const value = (dateO[key] + &quot;&quot;).padStart(2, &quot;0&quot;)<br>      fmtString = fmtString.replace(keyRe, value)<br>    &#125;<br>  &#125;<br><br>  return fmtString<br>&#125;<br><br>// 某一个商品上架时间, 活动的结束时间<br>const timeEl = document.querySelector(&quot;.time&quot;)<br>const productJSON = &#123;<br>  name: &quot;iPhone16e&quot;,<br>  newPrice: 4999,<br>  oldPrice: 5999,<br>  endTime: Date.now()<br>&#125;<br><br>timeEl.textContent = formatTime(productJSON.endTime, &quot;hh:mm:ss yyyy:MM:dd&quot;)<br></code></pre></td></tr></table></figure><h4 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h4><p>在 JavaScript 中，<strong>防抖（Debounce）</strong> 和 <strong>节流（Throttle）</strong> 是两种常用的性能优化技术，用于控制高频事件的触发频率，避免过多的资源消耗（如频繁的 DOM 操作、网络请求等）。</p><h5 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h5><p>当事件被频繁触发时，<strong>只有在事件停止触发一段时间后</strong>，才会执行目标函数。如果在此期间再次触发事件，则重新计时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs plain">    function MyDebounce(fn, delay) &#123;<br>      //定义timer记录定时器<br>      let timer = null<br>      //返回一个防抖处理后新的函数,不能使用箭头函数(箭头函数无this,this会指向window)<br>      return function (...arg) &#123;<br>        //每次触发清除上一次定时器<br>        clearTimeout(timer)<br>        //延迟执行函数,...args事件触发时传递的参数        <br>        timer = setTimeout(() =&gt; &#123;<br>          //找到被防抖处理的函数应该绑定的this,进行绑定<br>          fn.apply(this, args)<br>        &#125;, delay)<br>      &#125;<br>    &#125;<br> function MyDebounce(fn, delay) &#123;<br>      let timer = null<br>      const _debounce=function(...args)&#123;<br>        clearTimeout(timer)<br>        timer = setTimeout(() =&gt; &#123;<br>          fn.apply(this, args)<br>        &#125;, delay)<br>      &#125;<br>      //在返回的_debounce函数上绑定一个取消函数<br>      _debounce.cancel=function()&#123;<br>        if(timer) clearTimeout(timer)<br>      &#125;<br>      return _debounce<br>      &#125;<br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    const buttonEle=document.querySelector(&#x27;button&#x27;)<br>    const MyDebounceFn = MyDebounce(function () &#123;<br>      console.log(this.value);<br>    &#125;, 5000)<br>    inputEle.oninput=MyDebounceFn<br>    buttonEle.onclick=function()&#123;<br>      MyDebounceFn.cancel()<br>    &#125;<br>    //immediate判断是否立即执行一次<br>    function MyDebounce(fn, delay, immediate = false) &#123;<br>      let timer = null<br>      //定义变量记录是否已经立即执行过<br>      let isInvoke = false<br>      const _debounce = function (...args) &#123;<br>        clearTimeout(timer)<br>        if (immediate &amp;&amp; !isInvoke)&#123;<br>          fn.apply(this,args)<br>          isInvoke=true<br>          return<br>        &#125; <br>        timer = setTimeout(() =&gt; &#123;<br>          fn.apply(this, args)<br>        &#125;, delay)<br>      &#125;<br>      //在返回的_debounce函数上绑定一个取消函数<br>      _debounce.cancel = function () &#123;<br>        if (timer) clearTimeout(timer)<br>      &#125;<br>      return _debounce<br>    &#125;<br><br><br><br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    const buttonEle = document.querySelector(&#x27;button&#x27;)<br>    const MyDebounceFn = MyDebounce(function () &#123;<br>      console.log(this.value);<br>    &#125;, 2000,true)<br>    inputEle.oninput = MyDebounceFn<br>    buttonEle.onclick = function () &#123;<br>      MyDebounceFn.cancel()<br>    &#125;<br>//immediate判断是否立即执行一次<br>    function MyDebounce(fn, delay, immediate = false) &#123;<br>      let timer = null<br>      //定义变量记录是否已经立即执行过<br>      let isInvoke = false<br>      //记录返回的结果<br>      let res = undefined<br>      const _debounce = function (...args) &#123;<br>        return new Promise((resolve, reject) =&gt; &#123;<br>          clearTimeout(timer)<br>          if (immediate &amp;&amp; !isInvoke) &#123;<br>            //获取返回的值,通过回调函数回调出去<br>            res = fn.apply(this, args)<br>            resolve(res)<br>            isInvoke = true<br>            return<br>          &#125;<br>          timer = setTimeout(() =&gt; &#123;<br>            //获取返回的值,通过回调函数回调出去<br>            res = fn.apply(this, args)<br>            resolve(res)<br>          &#125;, delay)<br>        &#125;)<br><br>      &#125;<br>      //在返回的_debounce函数上绑定一个取消函数<br>      _debounce.cancel = function () &#123;<br>        if (timer) clearTimeout(timer)<br>      &#125;<br>      return _debounce<br>    &#125;<br><br>    const MyFn = MyDebounce(function (name) &#123;<br>      console.log(name);<br>      return &#x27;promise返回值&#x27;<br>    &#125;, 2000, false)<br>    MyFn(&#x27;Mir&#x27;).then((res)=&gt;&#123;<br>      console.log(res);<br>    &#125;)<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ol><li>搜索框输入联想（用户停止输入后再发送请求）。</li><li>窗口大小调整（停止调整后再计算布局）。</li><li>表单验证（输入完成后验证一次）。</li></ol><h5 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h5><p>当事件被频繁触发时，<strong>每隔固定的时间间隔</strong>，执行一次目标函数。无论事件触发多频繁，函数的执行频率都会被限制。</p><ul><li>时间戳实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs plain">function throttle(func, delay) &#123;<br>  let lastTime = 0;<br>  return function (...args) &#123;<br>    const now = Date.now();<br>    //第一次立即执行,后续lastTime = now,等待每次间隔达到delay执行<br>    if (now - lastTime &gt;= delay) &#123;<br>      func.apply(this, args);<br>      lastTime = now;<br>    &#125;<br>  &#125;;<br>&#125;<br> function MyThrottle(fn, delay, immediate = true) &#123;<br>      let startTime = 0<br>      const _throttle = function (...arys) &#123;<br>        const nowTime = Date.now();<br>        //第一次startTime和now相等,不立即执行<br>        if (!immediate &amp;&amp; startTime === 0) startTime = nowTime<br>        if (nowTime - startTime &gt;= delay) &#123;<br>          fn.apply(this, arys)<br>          startTime = nowTime<br>        &#125;<br>      &#125;<br>      return _throttle<br>    &#125;<br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    inputEle.oninput = MyThrottle(function () &#123;<br>      console.log(this.value);<br>    &#125;, 1000, false)<br>    function MyThrottle(fn, delay, leading = true, trailing = false) &#123;<br>      let startTime = 0<br>      let timer = null<br>      const _throttle = function (...arys) &#123;<br>        const nowTime = Date.now();<br>        //定时器判断是否尾部执行<br>        //第一次startTime和now相等,不立即执行<br>        if (!leading &amp;&amp; startTime === 0) startTime = nowTime<br>        if (nowTime - startTime &gt;= delay) &#123;<br>          //极限情况,在这里执行完,清除定时器,防止下面重复执行<br>          if (timer) &#123;<br>            clearTimeout(timer)<br>            timer = null<br>          &#125;<br>          fn.apply(this, arys)<br>          startTime = nowTime<br>          //满足条件结束本次函数,nowTime - startTime不能达到delay,进入trailing的定时器判断<br>          return<br>        &#125;<br>        //存在误差,大多执行下面函数<br>        if (trailing &amp;&amp; !timer) &#123;<br>          //在下次该执行函数的时间执行函数<br>          timer = setTimeout(() =&gt; &#123;<br>            fn.apply(this, arys)<br>            // startTime = nowTime 不能使用nowTime作为下次开始,保存的为上次定义的nowTime,不是最新时间<br>            startTime=Date.now()<br>            timer = null<br>          &#125;, delay-(nowTime-startTime))<br>        &#125;<br>      &#125;<br>      return _throttle<br>    &#125;<br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    inputEle.oninput = MyThrottle(function () &#123;<br>      console.log(this.value);<br>    &#125;, 3000, false, true)<br>function MyThrottle(fn, delay, leading = true, trailing = false) &#123;<br>      let startTime = 0<br>      let timer = null<br>      //如果想获取返回值,使用回调函数,或者返回promise对象<br>      const _throttle = function (...arys) &#123;<br>        const nowTime = Date.now();<br>        //定时器判断是否尾部执行<br>        //第一次startTime和now相等,不立即执行<br>        if (!leading &amp;&amp; startTime === 0) startTime = nowTime<br>        if (nowTime - startTime &gt;= delay) &#123;<br>          //极限情况,在这里执行完,清除定时器,防止下面重复执行<br>          if (timer) &#123;<br>            clearTimeout(timer)<br>            timer = null<br>          &#125;<br>          fn.apply(this, arys)<br>          startTime = nowTime<br>          //满足条件结束本次函数,nowTime - startTime不能达到delay,进入trailing的定时器判断<br>          return<br>        &#125;<br>        //存在误差,大多执行下面函数<br>        if (trailing &amp;&amp; !timer) &#123;<br>          //在下次该执行函数的时间执行函数<br>          timer = setTimeout(() =&gt; &#123;<br>            fn.apply(this, arys)<br>            // startTime = nowTime 不能使用nowTime作为下次开始,保存的为上次定义的nowTime,不是最新时间<br>            startTime=Date.now()<br>            timer = null<br>          &#125;, delay-(nowTime-startTime))<br>        &#125;<br>      &#125;<br>      _throttle.cancel = function() &#123;<br>        if (timer) clearTimeout(timer)<br>        startTime = 0<br>        timer = null<br>      &#125;<br>      return _throttle<br>    &#125;<br><br>    const inputEle = document.querySelector(&#x27;input&#x27;)<br>    const buttonEle=document.querySelector(&#x27;button&#x27;)<br>    const MyThrottleFn=MyThrottle(function () &#123;<br>      console.log(this.value);<br>    &#125;, 3000, false, true)<br>    inputEle.oninput = MyThrottleFn<br>    buttonEle.onclick=function()&#123;<br>      MyThrottleFn.cancel()<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>定时器实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">function throttle(func, delay) &#123;<br>  let timer = null;<br>  return function (...args) &#123;<br>  //定时器状态为null重新注册定时器<br>    if (!timer) &#123;<br>      timer = setTimeout(() =&gt; &#123;<br>        func.apply(this, args);<br>        //当到达节流时间将timer赋值为null,才能开启下次定时<br>        timer = null;<br>      &#125;, delay);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两种实现的区别</strong></p><ul><li><strong>时间戳版</strong>：立即执行，停止触发后不再执行最后一次。</li><li><strong>定时器版</strong>：延迟执行，停止触发后会执行最后一次。</li></ul><p><strong>应用场景</strong></p><ol><li>页面滚动事件（如无限加载）。</li><li>鼠标移动事件（如拖拽）。</li><li>高频点击按钮（如提交表单）。</li></ol><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><table><thead><tr><th><strong>特性</strong></th><th><strong>防抖（Debounce）</strong></th><th><strong>节流（Throttle）</strong></th></tr></thead><tbody><tr><td><strong>执行时机</strong></td><td>事件停止触发后执行</td><td>固定时间间隔执行</td></tr><tr><td><strong>是否保留最后一次</strong></td><td>是（重新计时）</td><td>取决于实现方式</td></tr><tr><td><strong>适用场景</strong></td><td>输入联想、窗口调整</td><td>滚动事件、高频点击</td></tr></tbody></table><h4 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h4><p>事件总线是一种基于<strong>发布-订阅模式</strong>的通信机制，用于组件或模块间的解耦</p><p><strong>核心概念</strong></p><ul><li><strong>发布-订阅模型</strong>：发布者（Publisher）触发事件，订阅者（Subscriber）监听并响应事件，二者通过事件总线通信，无需直接依赖。</li><li><strong>事件中心</strong>：统一管理事件与回调函数，提供注册、触发、销毁等能力。</li></ul><p><strong>核心 API</strong></p><ul><li>**on(event, callback)**：订阅事件。</li><li>**once(event, callback)**：订阅事件（仅触发一次）。</li><li>**emit(event, …args)**：触发事件，传递参数。</li><li>**off(event, callback)**：取消事件订阅。</li></ul><p><strong>实现原理</strong></p><p><strong>事件存储</strong>：使用对象或 <code>Map</code> 存储事件名与回调函数列表的映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">class EventBus &#123;<br>  constructor() &#123;<br>    this.events = new Map(); // &#123; eventName: [callback1, callback2] &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>订阅事件</strong>：将回调添加到对应事件的数组中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">on(event, callback) &#123;<br>  if (!this.events.has(event)) &#123;<br>    this.events.set(event, []);<br>  &#125;<br>  this.events.get(event).push(callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>触发事件</strong>：遍历执行事件对应的所有回调。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">emit(event, ...args) &#123;<br>  const callbacks = this.events.get(event) || [];<br>  callbacks.forEach(cb =&gt; cb(...args)); // 注意复制数组避免循环时修改<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一次性订阅</strong>：包装回调，执行后自动取消。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">once(event, callback) &#123;<br>  const wrapper = (...args) =&gt; &#123;<br>    callback(...args);<br>    this.off(event, wrapper);<br>  &#125;;<br>  this.on(event, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>取消订阅</strong>：从回调数组中移除指定函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">off(event, callback) &#123;<br>  const callbacks = this.events.get(event) || [];<br>  const filtered = callbacks.filter(cb =&gt; cb !== callback);<br>  this.events.set(event, filtered);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>内存泄漏</strong>：未及时调用 <code>off</code> 可能导致回调堆积。</li><li><strong>命名冲突</strong>：全局事件名需统一管理（如使用前缀）。</li><li><strong>执行顺序</strong>：多个回调按注册顺序执行，但不应依赖此顺序。</li><li><strong>错误处理</strong>：使用 <code>try-catch</code> 避免单个回调崩溃影响整体。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>组件通信</strong>：Vue&#x2F;React 中非父子组件通信。</li><li><strong>模块解耦</strong>：插件间通信或异步任务完成通知。</li><li><strong>简易状态管理</strong>：小型项目中替代 Redux&#x2F;Vuex。</li></ul><p><strong>常见库与框架</strong></p><ul><li><strong>Node.js</strong>：内置 <code>EventEmitter</code> 模块。</li><li><strong>Vue</strong>：利用 <code>Vue.prototype.$bus = new Vue()</code> 实现。</li><li><strong>第三方库</strong>：<code>mitt</code>（轻量）、<code>PubSubJS</code>（跨平台）。</li></ul><p><strong>封装简易事件总线</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs plain">class MyEventBus &#123;<br>     constructor() &#123;<br>       this.events = new Map()<br>     &#125;<br>     //订阅函数<br>     on(event, callback) &#123;<br>       //第一次执行,初始化为&#123;event,[]&#125;的Map结构<br>       if (!this.events.has(event)) &#123;<br>         this.events.set(event, []);<br>       &#125;<br>       //每次订阅,添加到对应保存事件的[]中<br>       this.events.get(event).push(callback);<br>     &#125;<br>     //触发函数<br>     emit(event, ...args) &#123;<br>       //取出事件总线中对应的[],依次执行<br>       const callbacks = this.events.get(event) || [];<br>       callbacks.forEach(cb =&gt; cb(...args)); // 注意复制数组避免循环时修改<br>     &#125;<br>     //仅订阅一次<br>     once(event, callback) &#123;<br>       //创建包装函数,执行代码体,执行完后,执行off函数,取消订阅<br>       const wrapper = (...args) =&gt; &#123;<br>         callback(...args);<br>         this.off(event, wrapper);<br>       &#125;;<br>       //进行订阅<br>       this.on(event, wrapper);<br>     &#125;<br>     //取消订阅<br>     off(event, callback) &#123;<br>       const callbacks = this.events.get(event) || [];<br>       //filter过滤出要取消订阅的callback函数,将得到的数组重新设置set(event, filtered)<br>       const filtered = callbacks.filter(cb =&gt; cb !== callback);<br>       this.events.set(event, filtered);<br>     &#125;<br>   &#125;<br><br><br>   const myEventBus = new MyEventBus()<br>   myEventBus.on(&#x27;myClick&#x27;, () =&gt; &#123;<br>     console.log(&#x27;myClick,001&#x27;);<br>   &#125;)<br>   myEventBus.on(&#x27;myClick&#x27;, () =&gt; &#123;<br>     console.log(&#x27;myClick,002&#x27;);<br>   &#125;)<br>   myEventBus.on(&#x27;youClick&#x27;, () =&gt; &#123;<br>     console.log(&#x27;youClick,001&#x27;);<br>   &#125;)<br>   const buttonEle = document.querySelector(&#x27;button&#x27;)<br>   buttonEle.onclick = () =&gt; &#123;<br>     console.log(&#x27;自己监听&#x27;);<br>     myEventBus.emit(&#x27;myClick&#x27;)<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p><a href="https://www.yuque.com/wudibawanglong-gbppc/gbvyr0">前端网络</a></p><h5 id="一、HTTP-基础"><a href="#一、HTTP-基础" class="headerlink" title="一、HTTP 基础"></a>一、HTTP 基础</h5><ol><li><strong>请求方法</strong><ul><li><code>GET</code>：获取资源（幂等，参数在 URL 中）</li><li><code>POST</code>：提交数据（非幂等，参数在请求体）</li><li><code>PUT</code>：更新资源（幂等）</li><li><code>DELETE</code>：删除资源（幂等）</li><li><code>PATCH</code>：部分更新资源</li></ul></li><li><strong>状态码</strong><ul><li><code>200 OK</code>：请求成功</li><li><code>301/302</code>：重定向</li><li><code>400 Bad Request</code>：客户端错误</li><li><code>401 Unauthorized</code>：未认证</li><li><code>403 Forbidden</code>：无权限</li><li><code>404 Not Found</code>：资源不存在</li><li><code>500 Internal Server Error</code>：服务端错误</li></ul></li><li><strong>Header 常见字段</strong><ul><li><code>Content-Type</code>：数据类型（如 <code>application/json</code>）</li><li><code>Authorization</code>：身份验证（如 <code>Bearer Token</code>）</li><li><code>Cache-Control</code>：缓存策略（如 <code>max-age=3600</code>）</li><li><code>Accept-Encoding</code>：压缩方式（如 <code>gzip</code>）</li></ul></li></ol><h5 id="二、AJAX（Asynchronous-JavaScript-and-XML）"><a href="#二、AJAX（Asynchronous-JavaScript-and-XML）" class="headerlink" title="二、AJAX（Asynchronous JavaScript and XML）"></a>二、AJAX（Asynchronous JavaScript and XML）</h5><p><strong>核心对象</strong> <code>** XMLHttpRequest **</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs plain">const xhr = new XMLHttpRequest();<br>xhr.open(&#x27;GET&#x27;, &#x27;https://api.example.com/data&#x27;);<br>//监听状态的改变<br>xhr.onreadystatechange = function() &#123;<br>  if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;<br>    console.log(JSON.parse(xhr.responseText));<br>  &#125;<br>&#125;;<br>xhr.send();<br>// function myAjax(&#123;<br>    //   url,<br>    //   method = &#x27;get&#x27;,<br>    //   timeout = 5000,<br>    //   headers = &#123;&#125;,<br>    //   data = &#123;&#125;,<br>    //   success,<br>    //   failure<br>    // &#125; = &#123;&#125;) &#123;<br>    //   const xhr = new XMLHttpRequest()<br>    //   xhr.onload = function () &#123;<br>    //     //使用回调函数获取响应结果<br>    //     if (xhr.status == 200) &#123;<br>    //       success &amp;&amp; success(xhr.response)<br>    //     &#125; else &#123;<br>    //       failure &amp;&amp; failure(&#123; status: xhr.status, message: xhr.statusText &#125;)<br>    //     &#125;<br>    //   &#125;<br>    //   xhr.responseType = &#x27;json&#x27;<br>    //   if (method.toUpperCase() === &#x27;GET&#x27;) &#123;<br>    //     const queryStrings = []<br>    //     for (const key in data) &#123;<br>    //       queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)<br>    //     &#125;<br>    //     url = url + &#x27;?&#x27; + queryStrings.join(&#x27;&amp;&#x27;)<br>    //     xhr.open(method, url)<br>    //     xhr.send()<br>    //   &#125; else &#123;<br>    //     xhr.open(method, url)<br>    //     xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/json&#x27;)<br>    //     xhr.send(JSON.stringify(data))<br>    //   &#125;<br>    // &#125;<br><br><br>    function myAjax(&#123;<br>      url,<br>      method = &#x27;get&#x27;,<br>      timeout = 5000,<br>      headers = &#123;&#125;,<br>      data = &#123;&#125;,<br>    &#125; = &#123;&#125;) &#123;<br>      return new Promise((resolve, reject) =&gt; &#123;<br>        //使用Promise获取响应结果<br>        const xhr = new XMLHttpRequest()<br>        xhr.onload = function () &#123;<br>          if (xhr.status == 200) &#123;<br>            resolve(xhr.response)<br>          &#125; else &#123;<br>            reject(&#123; status: xhr.status, message: xhr.statusText &#125;)<br>          &#125;<br>        &#125;<br>        xhr.responseType = &#x27;json&#x27;<br>        xhr.timeout = timeout<br>        if (method.toUpperCase() === &#x27;GET&#x27;) &#123;<br>          const queryStrings = []<br>          for (const key in data) &#123;<br>            queryStrings.push(`$&#123;key&#125;=$&#123;data[key]&#125;`)<br>          &#125;<br>          url = url + &#x27;?&#x27; + queryStrings.join(&#x27;&amp;&#x27;)<br>          xhr.open(method, url)<br>          xhr.send()<br>        &#125; else &#123;<br>          xhr.open(method, url)<br>          xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/json&#x27;)<br>          xhr.send(JSON.stringify(data))<br>        &#125;<br>      &#125;)<br>    &#125;<br><br>    myAjax(&#123;<br>      url: &#x27;your url&#x27;,<br>      method: &#x27;get&#x27;,<br>      data: &#123;<br>        name: &#x27;Mir&#x27;,<br>        age: 18<br>      &#125;<br>    &#125;)<br>const uploadBtn = document.querySelector(&quot;.upload&quot;)<br>    uploadBtn.onclick = function() &#123;<br>      // 1.创建对象<br>      const xhr = new XMLHttpRequest()<br><br>      // 2.监听结果<br>      xhr.onload = function() &#123;<br>        console.log(xhr.response)<br>      &#125;<br><br>      xhr.onprogress = function(event) &#123;<br>        console.log(event)<br>      &#125;<br>      <br><br>      xhr.responseType = &quot;json&quot;<br>      xhr.open(&quot;post&quot;, &quot;http://123.207.32.32:1888/02_param/upload&quot;)<br><br>      const fileEl = document.querySelector(&quot;.file&quot;)<br>      const file = fileEl.files[0]<br><br>      const formData = new FormData()<br>      formData.append(&quot;avatar&quot;, file)<br><br>      xhr.send(formData)<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>优缺点</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">-  </span>优点：兼容性好，支持老浏览器。 <br><span class="hljs-bullet">-  </span>缺点：回调地狱，API 设计繁琐。 <br></code></pre></td></tr></table></figure><p><strong>1. 基本用法</strong></p><ul><li><strong>创建对象</strong>：<code>const xhr = new XMLHttpRequest();</code></li><li><strong>初始化请求</strong>：<code>xhr.open(method, url, async);</code><ul><li><code>method</code>：请求方法（<code>GET</code>、<code>POST</code> 等）。</li><li><code>url</code>：请求地址。</li><li><code>async</code>：是否异步（默认 <code>true</code>）。</li></ul></li><li><strong>发送请求</strong>：<code>xhr.send(body);</code><ul><li><code>body</code>：POST 请求的数据（如 <code>FormData</code> 或字符串）。</li></ul></li></ul><p><strong>2. 事件监听</strong></p><ul><li><strong>响应完成</strong>：<code>xhr.onload = () =&gt; &#123; ... &#125;</code></li><li><strong>错误处理</strong>：<code>xhr.onerror = () =&gt; &#123; ... &#125;</code></li><li><strong>进度监控</strong>：<code>xhr.onprogress = (event) =&gt; &#123; ... &#125;</code>（上传&#x2F;下载进度）。</li><li><strong>状态变化</strong>：<code>xhr.onreadystatechange</code>（通过 <code>xhr.readyState</code> 跟踪状态）。</li></ul><p><strong>3. 状态与响应</strong></p><ul><li><code>** readyState **</code> ****<strong>值</strong>：<ul><li><code>0</code>：未初始化(代理被创建,未调用open())</li><li><code>1</code>：已打开连接(open被调用)</li><li><code>2</code>：已接收请求头(send被调用)</li><li><code>3</code>：正在接收响应体(loading)</li><li><code>4</code>：请求完成</li></ul></li><li><strong>状态码</strong>：<code>xhr.status</code>（如 200、404）。</li><li><strong>响应数据</strong>：<ul><li><code>xhr.responseText</code>：文本格式。</li><li><code>xhr.response</code>：根据 <code>responseType</code> 解析（如 <code>json</code>、<code>blob</code>）。</li></ul></li></ul><p><strong>4. 其他特性</strong></p><ul><li><strong>设置请求头</strong>：<code>xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);</code></li><li><strong>超时设置</strong>：<code>xhr.timeout = 5000;</code>，通过 <code>xhr.ontimeout</code> 处理。</li><li><strong>中止请求</strong>：<code>xhr.abort();</code></li></ul><h5 id="三、Fetch-API"><a href="#三、Fetch-API" class="headerlink" title="三、Fetch API"></a>三、Fetch API</h5><p><strong>基于 Promise 的现代方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">fetch(&#x27;https://api.example.com/data&#x27;)<br>  .then(response =&gt; &#123;<br>    if (!response.ok) throw new Error(&#x27;Network error&#x27;);<br>    return response.json();<br>  &#125;) <br>  .then(data =&gt; console.log(data))<br>  .catch(error =&gt; console.error(error));<br>const uploadBtn = document.querySelector(&quot;.upload&quot;)<br>    uploadBtn.onclick = async function() &#123;<br>      const fileEl = document.querySelector(&quot;.file&quot;)<br>      const file = fileEl.files[0]<br><br>      const formData = new FormData()<br>      formData.append(&quot;avatar&quot;, file)<br><br>      // 发送fetch请求<br>      const response = await fetch(&quot;http://123.207.32.32:1888/02_param/upload&quot;, &#123;<br>        method: &quot;post&quot;,<br>        body: formData<br>      &#125;)<br>      const res = await response.json()<br>      console.log(&quot;res:&quot;, res)<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>关键特性</strong></p><ul><li>默认不携带 Cookie（需设置    <code>credentials: &#39;include&#39;</code> ） </li><li>支持流式数据处理（如    <code>response.body</code> ） </li><li>可通过    <code>AbortController</code>    中止请求。</li></ul><p><strong>1. 基本用法</strong></p><p><strong>发起请求</strong>：<code>fetch(url, options)</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">- <span class="hljs-string">` options `</span> ：配置对象（方法、头、体等）。 <br>fetch(url, &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">method</span>: &#x27;<span class="hljs-title">POST</span>&#x27;,</span><br><span class="hljs-function">  <span class="hljs-title">headers</span>: </span>&#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>  body: JSON.stringify(data),<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>返回 Promise</strong>：处理响应或错误。</li></ul><p><strong>2. 响应处理</strong></p><ul><li><strong>解析数据</strong>：<ul><li><code>response.json()</code>：解析为 JS ON。</li><li><code>response.text()</code>：解析为文本。</li><li><code>response.blob()</code>：解析为二进制数据。</li></ul></li></ul><p><strong>状态检查</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (response.ok) &#123; // 状态码 200-299<br>  // 处理成功<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 错误处理</strong></p><ul><li><strong>网络错误</strong>：自动触发 <code>catch</code>。</li><li><strong>HTTP 错误（如 404）</strong>：需手动检查 <code>response.ok</code>。</li></ul><p><strong>4. 高级功能</strong></p><p><strong>中止请求</strong>：使用 <code>AbortController</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">const controller = new AbortController();<br>fetch(url, &#123; signal: controller.signal &#125;);<br>controller.abort(); // 中止请求<br></code></pre></td></tr></table></figure><ul><li><strong>跨域请求</strong>：默认不携带凭据，需设置 <code>credentials: &#39;include&#39;</code>。</li></ul><h5 id="四、Axios（第三方库）"><a href="#四、Axios（第三方库）" class="headerlink" title="四、Axios（第三方库）"></a>四、Axios（第三方库）</h5><p><strong>功能丰富的 HTTP 客户端</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">axios.get(&#x27;https://api.example.com/data&#x27;)<br>  .then(response =&gt; console.log(response.data))<br>  .catch(error =&gt; console.error(error));<br><br>// POST 请求示例<br>axios.post(&#x27;/api/post&#x27;, &#123; data: &#x27;value&#x27; &#125;, &#123;<br>  headers: &#123; &#x27;X-Custom-Header&#x27;: &#x27;value&#x27; &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li><strong>核心优势</strong><ul><li>自动转换 JSON 数据。</li><li>拦截器（请求&#x2F;响应拦截）。</li><li>客户端防御 XSRF。</li><li>取消请求（通过 <code>CancelToken</code> 或 <code>AbortController</code>）。</li></ul></li></ol><h5 id="五、跨域问题（CORS）"><a href="#五、跨域问题（CORS）" class="headerlink" title="五、跨域问题（CORS）"></a>五、跨域问题（CORS）</h5><ol><li><strong>同源策略</strong>   协议、域名、端口一致才允许请求。</li><li><strong>解决方案</strong><ul><li><strong>CORS（跨域资源共享）</strong>   服务端设置响应头（如 <code>Access-Control-Allow-Origin: *</code>）。</li></ul></li></ol><p><strong>JSONP</strong>   利用 <code>&lt;script&gt;</code> 标签跨域（仅支持 GET）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">function handleResponse(data) &#123; console.log(data); &#125;<br>const script = document.createElement(&#x27;script&#x27;);<br>script.src = &#x27;https://api.example.com/data?callback=handleResponse&#x27;;<br>document.body.appendChild(script);<br>- ** 代理服务器 **   <br></code></pre></td></tr></table></figure><p> 通过后端或工具（如 Webpack DevServer）转发请求。</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><strong>XHR vs Fetch 对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>XHR</strong></th><th><strong>Fetch</strong></th></tr></thead><tbody><tr><td><strong>语法</strong></td><td>回调&#x2F;事件驱动，较冗长</td><td>Promise 链式调用，更简洁</td></tr><tr><td><strong>错误处理</strong></td><td>需监听 <code>onerror</code><br>和状态码</td><td>网络错误触发 <code>catch</code><br>，HTTP 错误需手动检查</td></tr><tr><td><strong>中止请求</strong></td><td><code>xhr.abort()</code></td><td><code>AbortController</code></td></tr><tr><td><strong>进度监控</strong></td><td>支持（<code>onprogress</code><br>）</td><td>不直接支持，需通过 Stream 处理</td></tr><tr><td><strong>默认携带 Cookie</strong></td><td>是</td><td>需设置 <code>credentials: &#39;include&#39;</code></td></tr><tr><td><strong>兼容性</strong></td><td>广泛支持（包括旧浏览器）</td><td>不支持 IE，需 polyfill</td></tr></tbody></table><ul><li><strong>传统 AJAX</strong> 适合兼容性要求高的场景。</li><li><strong>Fetch API</strong> 是现代化、轻量的选择。</li><li><strong>Axios</strong> 提供更全面的功能和企业级支持。</li><li><strong>跨域问题</strong> 需服务端配合或使用代理。</li><li><strong>WebSocket</strong> 实现实时双向通信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2025/02/24/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/02/24/JavaScript%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h4 id="Js-的定义"><a href="#Js-的定义" class="headerlink" title="Js 的定义"></a>Js 的定义</h4><p><strong>维基百科对 Js 的定义:</strong></p><p>JavaScript(通常缩写为 JS)是一种 高级的、解释型 的编程语言;JavaScript 是一门基于 原型、头等函数 的语言，是 一门多范式 的语言，它支持 面向对象程序设计，指令式编程，以及函数式编程 </p><h4 id="Js-基本使用"><a href="#Js-基本使用" class="headerlink" title="Js 基本使用"></a>Js 基本使用</h4><h5 id="noScript-元素"><a href="#noScript-元素" class="headerlink" title="noScript 元素"></a>noScript 元素</h5><p><strong>如果运行的浏览器不支持 JavaScript,那么我们如何给用户更好的提示呢?</strong></p><p>针对早期浏览器不支持 JavaScript 的问题，需要一个页面优雅降级的处理方案,最终，<noscript>元素出现，被用于给不支持 JavaScript 的浏览器提供替代内容;</noscript></p><p><code>&lt;noscript&gt;不支持JavaScript,请切换浏览器&lt;/noscript&gt;</code></p><h5 id="Js-注释"><a href="#Js-注释" class="headerlink" title="Js 注释"></a>Js 注释</h5><ul><li>单行注释 &#x2F;&#x2F;单行注释</li><li>多行注释 &#x2F;_多行注释 _&#x2F;</li><li>文档注释(VSCode 中需要在单独的 JavaScript 文件中编写才有效)</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/** </span><br><span class="hljs-comment">*某人年龄的函数</span><br><span class="hljs-comment">*@param &#123;string&#125; name 姓名</span><br><span class="hljs-comment">*@param &#123;number&#125; age 年龄</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">peopleAge</span>(name,age) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运算符和-运算符"><a href="#运算符和-运算符" class="headerlink" title="&#x3D;&#x3D;运算符和&#x3D;&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;运算符和&#x3D;&#x3D;&#x3D;运算符</h5><h6 id="运算符"><a href="#运算符" class="headerlink" title="&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;运算符</h6><p> &#x3D;&#x3D;运算符检查其两个操作对象是否相等，返回一个布尔值结果。当比较双方数据类型不同时，它会尝试转换不同类型的操作数，并进行比较 </p><p>** 类型相同时的特殊情况 **</p><ul><li>对象（Object）：仅当两个操作数引用同一个对象时返回 true。 </li><li>数字（Number）：如果两个操作数的值相同，则返回 true。+0 和 -0 被视为相同的值。如果任何一个操作数是 NaN，返回 false；所以，NaN 永远不等于 NaN。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">NaN</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">NaN</span>;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == b); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li>符号（Symbol）：仅当两个操作数引用相同的符号时返回 true。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">null</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">undefined</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">c</span> = <span class="hljs-selector-tag">null</span>;<br><span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">d</span> = <span class="hljs-selector-tag">undefined</span>;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == b); <span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == c); <span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(b == d); <span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a == d); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>类型不相同时</strong></p><ul><li>如果其中一个操作数为 null 或 undefined，另一个操作数也必须为 null 或 undefined 以返回 true。否则返回 false。 </li><li>如果其中一个操作数是对象，另一个是原始值，则将对象转换为原始值(ToPrimitive)。<br>  _  在这一步，两个操作数都被转换为原始值（字符串、数字、布尔值、符号和大整型中的一个）。剩余的转换将分情况完成。<br>  _  如果是相同的类型，使用步骤 1 进行比较。<br>  _  如果其中一个操作数是符号(Symbol)而另一个不是，返回 false。<br>  _  如果其中一个操作数是布尔值而另一个不是，则将布尔值转换为数字：  true 转换为 1，false 转换为 0  。然后再次对两个操作数进行宽松比较。<br>  _  数字与字符串：  将字符串转换为数字  。转换失败将导致 NaN，这将保证相等比较为 false。<br>  _  数字与大整型：按数值进行比较。如果数字的值为 ±∞ 或 NaN，返回 false。  *  字符串与大整型：使用与 BigInt() 构造函数相同的算法将字符串转换为大整型数。如果转换失败，返回 false。</li></ul><h6 id="运算符-1"><a href="#运算符-1" class="headerlink" title="&#x3D;&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;&#x3D;运算符</h6><p> &#x3D;&#x3D;&#x3D;运算符与 &#x3D;&#x3D; 运算符之间最显著的区别是，严格相等运算符不尝试类型转换。相反，严格相等运算符总是认为不同类型的操作数是不同的，即只要类型不同进行 <code>===</code> 操作时，结果即为 <code>false</code>。 </p><p>** &#x3D;&#x3D;&#x3D;比较规则 **</p><ul><li>如果操作数的类型不同，则返回 false。 </li><li>如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。 </li><li>如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。 </li><li>如果两个操作数有任意一个为 NaN，返回 false。 </li><li>否则，比较两个操作数的值</li></ul><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p><strong>在 ES5 之前没有块级作用域的概念,函数可以定义自己的作用域</strong></p><ul><li>全局作用域,全局可以使用</li><li>使用 var 定义的变量,无块级作用域(es5 之前 创建的变量都会作为  ** window 对象 ** 的属性保存</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-comment">//代码块</span><br>    &#123;<br>        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br>        <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">2</span><br>        <span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">c</span> = <span class="hljs-number">3</span><br>    &#125;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a);<span class="hljs-comment">//1</span><br><span class="hljs-comment">//es6的let,const声明的变量存在作用域</span><br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(b);<span class="hljs-comment">//is not defined</span><br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(c);<span class="hljs-comment">//is not defined</span><br><br></code></pre></td></tr></table></figure><ul><li>使用 var 关键字声明的 ** 变量 ** （ 比如  <code>var a = 1</code> ）， ** 会在所有的代码执行之前被声明 ** （但是不会赋值）。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a);<span class="hljs-comment">//undefined</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = &#x27;<span class="hljs-selector-tag">a</span>&#x27;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a);<span class="hljs-comment">//a</span><br></code></pre></td></tr></table></figure><ul><li>for 循环没有自己的作用域</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>     <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">foo</span>=&#x27;<span class="hljs-selector-tag">foo</span>&#x27;<br>  &#125;<br>  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(foo);<span class="hljs-comment">//foo</span><br>  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(i); <span class="hljs-comment">//3</span><br><br></code></pre></td></tr></table></figure><ul><li>function 函数存在自己的作用域</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">foo</span>() &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span>=&#x27;<span class="hljs-selector-tag">aa</span>&#x27;<br>&#125;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(a); <span class="hljs-comment">//a is not defined</span><br></code></pre></td></tr></table></figure><p><strong>作用域的上下关系</strong></p><p> 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（ ** 就近原则 ** ）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错 ReferenceError。 </p><p>** 函数的声明提前（函数提升） **</p><p> 使用 <code>函数声明</code> 的形式创建的函数 <code>function foo()&#123;&#125;</code> ， ** 会被声明提前 ** 。使用 <code>函数表达式</code> 创建的函数 <code>var foo = function()&#123;&#125;</code> ， ** 不会被声明提前 ** ，所以不能在声明前调用。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo1</span>(); <span class="hljs-comment">//foo1</span><br><span class="hljs-comment">// Uncaught TypeError: foo2 is not a function,由于var声明,被提前声明</span><br><span class="hljs-comment">// 所以foo2是一个已声明未赋值的变量</span><br><span class="hljs-title function_">foo2</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo2); <span class="hljs-comment">//undefined</span><br><span class="hljs-comment">//Uncaught ReferenceError:</span><br><span class="hljs-comment">//Cannot access &#x27;foo3&#x27; before initialization</span><br><span class="hljs-comment">//但该变量在被访问时尚未完成初始化。</span><br><span class="hljs-comment">//这通常发生在使用 let 或 const 声明的变量上，</span><br><span class="hljs-comment">//因为它们具有块级作用域和暂时性死区（Temporal Dead Zone）的特性</span><br><span class="hljs-title function_">foo3</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo2&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> foo3 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo3&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>**<br> ****   **</p><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><h6 id="Objerct-keys"><a href="#Objerct-keys" class="headerlink" title="Objerct.keys"></a>Objerct.keys</h6><p><strong>Objerct.keys 拿到对象的键的数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> people = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>&#125;;<br><span class="hljs-comment">//for in 遍历对象的每一项</span><br><span class="hljs-comment">// for (const key in people) &#123;</span><br><span class="hljs-comment">//   console.log(`key:$&#123;key&#125; value:$&#123;people[key]&#125;`);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//Object.keys拿到对象中键的集合,依次进行遍历</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(people);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; obj.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> key = obj[i];<br>  <span class="hljs-keyword">const</span> val = people[key];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`key:<span class="hljs-subst">$&#123;key&#125;</span> value:<span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h6><p>JavaScript 的原始类型并非对象类型，所以从理论上来说，它们是没有办法获取属性或者调用方法的,JavaScript 为了可以使其可以<strong>获取属性和调用方法</strong>对其封装了对应的<strong>包装类型</strong></p><ul><li>根据原始值，创建一个原始类型对应的包装类型对象</li><li>调用对应的属性或者方法，返回一个新的值;</li><li>创建的包装类对象被销毁;</li></ul><p>通常 JavaScript 引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p><strong>DOM</strong>:<strong>文档对象模型</strong>(DocumentObject Model),简称 DOM，将页面所有的内容表示为可以修改的对象</p><h5 id="DOM-类型继承图"><a href="#DOM-类型继承图" class="headerlink" title="DOM 类型继承图"></a>DOM 类型继承图</h5><p><img src="1737208199582-06e4f4a9-f4f0-4c40-a8e5-0c8627f8d7ef.png"></p><p>:::info<br>在 DOM 的继承体系中，<code>Document</code>和<code>Element</code>看似 “平级” 继承自<code>Node</code>，这和直观理解有所不同，原因如下：</p><p><strong>从 DOM 规范设计角度</strong></p><p>DOM 将文档结构抽象为树形结构，<code>Node</code>是所有节点的抽象基类，它定义了节点共有的属性（如<code>nodeName</code>、<code>nodeValue</code>等）和方法（如<code>appendChild</code>等） 。<code>Document</code>和<code>Element</code>都是不同类型的节点，它们虽然在文档中的角色和功能不同，但都是基于<code>Node</code>这个最基础的抽象概念进行派生的。</p><p><strong>从功能和用途角度</strong></p><ul><li><code>Document</code>代表整个文档，是 DOM 树的根，它主要用于从整体层面操作文档，比如创建新的<code>Element</code>、<code>Text</code>节点，通过<code>getElementById</code>等方法查找元素等。它是访问和操作整个文档结构的入口。</li><li><code>Element</code>表示文档中的具体元素，像<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;img&gt;</code>等 HTML 标签对应的对象，它侧重于定义元素相关的属性（如<code>className</code>、<code>id</code>等）和方法（如<code>setAttribute</code>等），用于操作元素自身的特性、样式和行为等。</li></ul><p>虽然在文档中<code>Document</code>包含了<code>Element</code>，但在 DOM 继承体系设计上，它们都是<code>Node</code>的具体派生类型，各自负责不同层面的功能，这种设计使得 DOM 结构更加清晰、模块化，便于开发者理解和使用。</p><p>:::</p><h5 id="document-对象"><a href="#document-对象" class="headerlink" title="document 对象"></a>document 对象</h5><p>Document 节点表示的整个载入的网页， 它的实例是全局的 document 对象 </p><ul><li>对 DOM 的所有操作都是从  document 对象 开始的;</li><li>它是 DOM 的 入口点 ，可以从 document 开始去访问任何节点元素;</li></ul><p>对于最顶层的 html、head、body 元素，我们可以直接在 document 对象中获取到:</p><ul><li>html 元素:<html>&#x3D;document.documentElement</html></li><li>body 元素:<body>&#x3D;document.body</body></li><li>head 元素:<head>&#x3D;document.head</head></li><li>文档声明:<!DOCTYPE html>&#x3D; document.doctype</li></ul><p><strong>如果我们获取到一个节点(Node)后，可以根据这个节点去获取其他的节点我们称之为节点之间的导航</strong></p><ul><li>父节点:parentNode</li><li>前兄弟节点:previousSibling</li><li>后兄弟节点:nextSibling</li><li>子节点:childNodes</li><li>第一个子节点:firstChild</li><li>最后一个子节点:lastChild</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bodyEl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bodyEl.<span class="hljs-property">childNodes</span>); <span class="hljs-comment">//所有子节点</span><br><span class="hljs-keyword">const</span> firstEl = bodyEl.<span class="hljs-property">firstChild</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstEl); <span class="hljs-comment">//第一个子节点</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstEl.<span class="hljs-property">nextSibling</span>); <span class="hljs-comment">//下一个子节点</span><br></code></pre></td></tr></table></figure><p><strong>element(元素)之间的导航</strong></p><ul><li>父元素:parentElement</li><li>前兄弟节点:previousElementSibling</li><li>后兄弟节点:nextElementSibling</li><li>子节点:children</li><li>第一个子节点:firstElementChild</li><li>最后一个子节点:lastElementChild</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bodyEl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>;<br><span class="hljs-keyword">const</span> ele = bodyEl.<span class="hljs-property">children</span>; <span class="hljs-comment">//获取body节点下的子元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ele);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bodyEl.<span class="hljs-property">firstElementChild</span>); <span class="hljs-comment">//第一个子元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bodyEl.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//第一个子元素</span><br></code></pre></td></tr></table></figure><h5 id="Element-元素"><a href="#Element-元素" class="headerlink" title="Element 元素"></a>Element 元素</h5><h6 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h6><p><strong>浏览器在解析 HTML 元素时，会将对应的 attribute 也创建出来放到对应的元素对象上</strong></p><ul><li>比如 id、class 就是全局的 attribute，会有对应的 id、class 属性</li><li>比如 href 属性是针对 a 元素的，type、value 属性是针对 input 元素的;</li></ul><p><strong>属性 attribute 的分类:</strong></p><ul><li>标准的 attribute:某些 attribute 属性是标准的，比如 id、class、href、type、value 等;( 在对应的对象模型中都有对应的 property )</li><li>非标准的 attribute:某些 attribute 属性是自定义的，比如 age、height 等</li></ul><p><strong>对于所有的 attribute 访问都支持如下的方法:</strong></p><ul><li>elem.hasAttribute(name)- 检查特性是否存在。</li><li>elem.getAttribute(name)- 获取这个特性值,</li><li>elem.setAttribute(name, value)- 设置这个特性值。</li><li>elem.removeAttribute(name)- 移除这个特性。</li><li>attributes:attr 对象的集合，具有 name、value 属性:</li></ul><p>:::info<br>attribute 具备以下特征:</p><ol><li>它们的名字是大小写不敏感的(id 与 ID 相同)。</li><li>它们的值总是字符串类型的。</li></ol><p>:::</p><h6 id="property"><a href="#property" class="headerlink" title="property"></a>property</h6><p><strong>对于标准的 attribute，会在 DOM 对象上创建与其对应的 property 属性</strong></p><p>在大多数情况下，它们是相互作用的</p><ul><li>改变 property，通过 attribute 获取的值，会随着改变;</li><li>通过 attribute 操作修改，property 的值会随着改变;</li></ul><p>除非特别情况，大多数情况下，设置、获取 attribute，推荐使用 property 的方式:</p><ul><li>这是因为它默认情况下是有类型的;</li></ul><h6 id="class-和-style"><a href="#class-和-style" class="headerlink" title="class 和 style"></a>class 和 style</h6><p>有时候我们会通过 JavaScript 来动态修改样式，这个时候我们有两个选择</p><ul><li>在 CSS 中编写好对应的样式,动态的添加 class</li><li>动态的修改 style 属性:</li></ul><p>elem.classList 是一个特殊的对象(可迭代,for of):</p><ul><li>添加一个类 elem.classList.add (class)</li><li>移除一个类 elem.classList.remove(class):</li><li>添加&#x2F;移除类,存在就移除它,如果类不存在就添加类 elem.classList.toggle(class)</li><li>检查给定类，返回 true&#x2F;false。elem.classList.contains(class)</li></ul><p>如果我们需要读取样式:</p><ul><li>对于内联样式，是可以通过 style.*的方式读取到的;</li><li>对于 style、css 文件中的样式，是读取不到的;这个时候，我们可以通过 getComputedstyle 的全局函数来实现:</li></ul><p><code> console.log(getComputedStyle(boxEl).backgroundColor);</code></p><h6 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h6><p>** 插入元素:**</p><ul><li>直接 innerHTML 插入</li><li>创建 DOM 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div class=&quot;box&quot;&gt;<br><br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const boxEl = document.querySelector(&#x27;.box&#x27;)<br>    // boxEl.innerHTML=`&lt;h2&gt;h2&lt;/h2&gt;`<br><br>    //创建DOM对象插入,可以对其进行系列操作,最后插入<br>    const H2El = document.createElement(&#x27;h2&#x27;)<br>    H2El.style.color = &#x27;red&#x27;<br>    H2El.innerHTML=&#x27;123&#x27;<br>    boxEl.append(H2El)<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>:::info<br>– 在 node 末尾 插入节点或字符串，</p><p>node.append(…nodes or strings)</p><p>– 在 node 开头 插入节点或字符串</p><p>node.prepend(…nodes or strings)</p><p>– 在 node 前面 插入节点或字符串,</p><p>node.before(…nodes or strings)</p><p>–在 node 后面 插入节点或字符串</p><p>node.after(…nodes or strings)</p><p>– 将 node 替换为给定的节点或字符串。</p><p>node.replaceWith(…nodes or strings)</p><p>:::</p><p><strong>移除和复制元素</strong></p><ul><li>移除元素我们可以调用元素本身的 remove 方法</li><li>如果我们想要复制一个现有的元素，可以通过 cloneNode 方法<ul><li>可以传入一个 Boolean 类型的值，来决定是否是深度克隆</li><li>深度克隆会克隆对应元素的子元素，否则不会克隆对应元素的子元素</li></ul></li></ul><h6 id="元素的大小-滚动"><a href="#元素的大小-滚动" class="headerlink" title="元素的大小,滚动"></a>元素的大小,滚动</h6><p><img src="1737438656840-4ad29814-3340-4a91-8e1e-1c1c435b29d7.png"></p><ul><li>clientWidth:contentWith+padding(不包含滚动条)</li><li>clientHeight: contentHeight+padding</li><li>clientTop:border-top 的宽度</li><li>clientLeft:border-left 的宽度</li><li>offsetWidth:元素完整的宽度</li><li>offsetHeight:元素完整的高度</li><li>offsetLeft:距离父元素的 x</li><li>offsetHeight:距离父元素的 y</li><li>scrollHeight:整个可滚动的区域高度</li><li>scrollTop:滚动部分的高度</li></ul><h6 id="window-的大小-滚动"><a href="#window-的大小-滚动" class="headerlink" title="window 的大小,滚动"></a>window 的大小,滚动</h6><p><strong>widow 的 width,height:</strong></p><ul><li>innerWidth、innerHeight:获取 window 窗囗的宽度和高度(包含滚动条)</li><li>outerWidth、outerHeight:获取 window 窗口的整个宽度和高度(包括调试工具、工具栏)</li><li>documentElement.clientHeight、documentElement.clientWidth:获取 html 的宽度和高度(不包含滚动条)</li></ul><p><strong>window 的滚动:</strong></p><ul><li>x 轴上滚动的位置:scrollX(pageXOffset)</li><li>y 轴上滚动的位置:scrollY(pageYOffset)</li><li>scrollBy(x,y):将页面滚动至 相对于当前位置的(x,y),位置;</li><li>scrollTo(pageX,pageY)将页面滚动至 绝对坐标;</li></ul><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><h6 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h6><p><strong>如何进行事件监听</strong></p><ul><li>事件监听方式一:在 script 中直接监听(很少使用)</li><li>事件监听方式二:DOM 属性，通过元素的 on 来监听事件;</li><li>事件监听方式三:通过 EventTarget 中的 addEventListener 来监听;</li></ul><p><strong>鼠标事件</strong></p><ul><li>click – 当鼠标点击一个元素时(触摸屏设备会在点击时生成)</li><li>mouseover&#x2F;mouseout –当鼠标指针移入&#x2F;离开一个元素时,</li><li>mousedown&#x2F;mouseup–当在元素上按下&#x2F;释放鼠标按钮时。</li><li>mousemove–当鼠标移动时。</li></ul><p><strong>键盘事件:</strong></p><ul><li>keydown 和 keyup – 当按下和松开一个按键时,</li></ul><p><strong>表单(form)元素事件:</strong></p><ul><li>submit – 当访问者提交了一个 <form>时。</form></li><li>focus – 当访问者聚焦于一个元素时，例如聚焦于 <em>input</em> 。</li></ul><p><strong>Document 事件:</strong></p><ul><li>DOMContentLoaded –当 HTML 的加载和处理均完成，DOM 被完全构建完成时。</li></ul><p><strong>CSS 事件:</strong></p><ul><li>transitionend–当一个 CSS 动画完成时。</li></ul><h6 id="事件冒泡-捕获"><a href="#事件冒泡-捕获" class="headerlink" title="事件冒泡,捕获"></a>事件冒泡,捕获</h6><p>事实上对于事件有一个概念叫做事件流，为什么会产生事件流呢?</p><p>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身,这是因为我们的 HTML 元素是存在 父子元素叠加层级 的;</p><ul><li>我们会发现默认情况下事件是从最内层的 span 向外依次传递的顺序，这个顺序我们称之为<strong>事件冒泡</strong>(EventBubble)</li><li>事实上，还有另外一种监听事件流的方式就是从外层到内层(body-&gt;span)，这种称之为<strong>事件捕获</strong>(Event Capture)</li></ul><h6 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象 Event"></a>事件对象 Event</h6><p>当一个事件发生时，就会有和这个事件相关的很多信息,那么这些信息会被封装到一个 Event 对象中，这个对象由浏览器创建，称之为<strong>event 对象</strong></p><p><strong>常见 event 的属性</strong></p><ul><li>type:事件的类型;</li><li>target:当前事件发生的元素</li><li>currentTarget:当前处理事件的元素;</li><li>eventPhase:事件所处的阶段</li><li>offsetX、offsetY:事件发生在元素内的位置;</li><li>clientX、clientY:事件发生在客户端内的位置</li><li>pageX、pageY:事件发生在客户端相对于 document 的位置:</li><li>screenX、screenY:事件发生相对于屏幕的位置,</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;parent&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">//当你点击 #child 按钮时，event.target 会指向 #child 按钮，因为它是实际触发点击事件的元素。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>);<br>  <span class="hljs-comment">//如果你点击 #child 按钮，event.currentTarget 会指向 #parent 元素，因为事件处理函数是绑定在 #parent 元素上的。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">currentTarget</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>常见的方法</strong></p><ul><li>preventDefault:取消事件的默认行为，</li><li>stopPropagation:阻止事件的进一步传递(冒泡或者捕获都可以阻止)</li></ul><p>在函数中，我们也可以通过 this 来获取当前的发生元素,这是因为在浏览器内部，调用 event handler 是绑定到当前的 curentTarget 上的</p><p>:::info<br>css 属性也可以禁止鼠标交互事件</p><p><code>pointer-events:none</code></p><p>:::</p><h6 id="EventTarget"><a href="#EventTarget" class="headerlink" title="EventTarget"></a>EventTarget</h6><ul><li>所有的节点、元素都继承自 EventTarget,事实上 Window 也继承自 EventTarget;</li><li>EventTarget 是一个 DOM 接口，主要用于添加、删除、派发 Event 事件</li></ul><p><strong>EventTarget 常见的方法</strong></p><ul><li>addEventListener:注册某个事件类型以及事件处理函数;</li><li>removeEventListener:移除某个事件类型以及事件处理函数;</li><li>dispatchEvent:派发某个事件类型到 EventTarget 上;</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;MirZ&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MirZ事件&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&quot;MirZ&quot;</span>));<br>&#125;, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure><h6 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h6><p>事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式  事件委托 模式(也是一种设计模式)</p><p>那么这个模式是怎么样的呢?</p><ul><li>因为当子元素被点击时，父元素可以通过冒泡可以监听到子元素的点击</li><li>并且可以通过 event.target 获取到当前监听的元素,</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>       .active&#123;<br>        color: red;<br>       &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>   &lt;ul&gt;<br>    &lt;li&gt;1&lt;/li&gt;<br>    &lt;li&gt;2&lt;/li&gt;<br>    &lt;li&gt;3&lt;/li&gt;<br>    &lt;li&gt;4&lt;/li&gt;<br>    &lt;li&gt;5&lt;/li&gt;<br>    &lt;li&gt;6&lt;/li&gt;<br>    &lt;li&gt;7&lt;/li&gt;<br>    &lt;li&gt;8&lt;/li&gt;<br>    &lt;li&gt;9&lt;/li&gt;<br>    &lt;li&gt;10&lt;/li&gt;<br>   &lt;/ul&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    // 遍历实现<br>//   const liEls=document.querySelectorAll(&#x27;li&#x27;)<br>//   for (let i = 0; i &lt; liEls.length; i++) &#123;<br>//     var liEl=liEls[i]<br>//     liEl.onclick=function(e)&#123;<br>//         console.log(e.currentTarget.classList.add(&#x27;active&#x27;));<br>//     &#125;<br>//   &#125;<br><br>    //ul监听<br>// const ulEl=document.querySelector(&#x27;ul&#x27;)<br>// ulEl.onclick=function(e)&#123;<br>//     e.target.classList.add(&#x27;active&#x27;)<br>// &#125;<br><br>  //记录变量<br>  //记录变量<br>  const ulEl=document.querySelector(&#x27;ul&#x27;)<br>  let activeEl=null<br>  ulEl.onclick=function(e)&#123;<br>    if(activeEl &amp;&amp; e.target!==ulEl)&#123;<br>        activeEl.classList.remove(&#x27;active&#x27;)<br>    &#125;<br>    //判断是否点击ul,点击ul不触发<br>    if(e.target!==ulEl)&#123;<br>        e.target.classList.add(&#x27;active&#x27;)<br>        activeEl=e.target<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br><br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div class=&quot;box&quot;&gt;<br>        &lt;button data-action=&quot;remove&quot;&gt;移除&lt;/button&gt;<br>        &lt;button data-action=&quot;create&quot;&gt;创建&lt;/button&gt;<br>        &lt;button data-action=&quot;updata&quot;&gt;更新&lt;/button&gt;<br>    &lt;/div&gt;<br><br>&lt;/body&gt;<br>&lt;script&gt;<br>  const boxEl=document.querySelector(&#x27;.box&#x27;)<br>  boxEl.onclick=function(e)&#123;<br>    //根据data-*,来从元素中获取到action来判断<br>    var action=e.target.dataset.action<br>    console.log(action);<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h6 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h6><p>MDN 文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p><p><strong>鼠标事件:</strong></p><p><img src="1737726011745-b34a55dc-b98e-4e40-a74d-b98dc13b5b15.png"></p><p>mouseenter 和 mouseleave</p><ul><li>不支持冒泡</li><li>进入子元素依然属于在该元素内，没有任何反应</li></ul><p>mouseover 和 mouseout</p><ul><li>支持冒泡</li><li>进入元素的子元素时先调用父元素的 mouseout,再调用子元素的 mouseover</li><li>因为支持冒泡，所以会将 mouseover 传递到父元素中:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>  &lt;style&gt;<br><br>  &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>  &lt;div class=&quot;box&quot; style=&quot;width: 200px; height: 200px; background-color: aquamarine;&quot;&gt;<br>    &lt;sapn class=&quot;sp&quot; style=&quot;display: inline-block; width: 100px; height: 100px; margin:50px;background-color:beige;&quot;&gt; &lt;/sapn&gt;<br>  &lt;/div&gt;<br><br>&lt;/body&gt;<br>&lt;script&gt;<br>  const boxEl = document.querySelector(&#x27;.box&#x27;)<br>  const spanEl=document.querySelector(&#x27;.sp&#x27;)<br><br><br>  boxEl.onmouseenter=function()&#123;<br>    console.log(&#x27;box onmouseenter&#x27;);<br>  &#125;<br>  boxEl.onmouseleave=function()&#123;<br>    console.log(&#x27;box onmouseleave&#x27;);<br>  &#125;<br>  spanEl.onmouseenter=function()&#123;<br>    console.log(&#x27;spanEl onmouseenter&#x27;);<br>  &#125;<br>  spanEl.onmouseleave=function()&#123;<br>    console.log(&#x27;spanEl onmouseleave&#x27;);<br>  &#125;<br><br><br><br><br>  // boxEl.onmouseover=function()&#123;<br>  //   console.log(&#x27;box onmouseover&#x27;);<br>  // &#125;<br>  // boxEl.onmouseout=function()&#123;<br>  //   console.log(&#x27;box onmouseout&#x27;);<br>  // &#125;<br>  // spanEl.onmouseover=function()&#123;<br>  //   console.log(&#x27;spanEl onmouseover&#x27;);<br>  // &#125;<br>  // spanEl.onmouseout=function()&#123;<br>  //   console.log(&#x27;spanEl onmouseout&#x27;);<br>  // &#125;<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>键盘事件</strong></p><p><img src="1737730438301-031debb6-216c-4117-8bc5-3ed6fdbcb783.png"></p><p>事件的执行顺序是 onkeydown、onkeypress、onkeyup</p><ul><li>down 事件先发生,发生在按键被按下.</li><li>press 发生在文本被输入;</li><li>up 发生在文本输入完成;</li></ul><p>我们可以通过 key 和 code 来区分按下的键:</p><ul><li>code:“按键代码”(“KeyA”，”ArrowLeft”等)，特定于键盘上按键的物理位置。</li><li>key:字符(“A”，“a”等)，对于非字符(non-character)的按键，通常具有与 code 相同的值。)</li></ul><p><strong>表单事件</strong></p><p><img src="1737788515123-6e071f21-a08a-4fe1-9575-18aff255ebf1.png"></p><p>** 文档加载事件**</p><ul><li>DOMContentLoaded:浏览器已完全加载 HTML，并构建了 DOM 树，但像 <img>和样式表之类的外部资源可能尚未加载完成。</li><li>load:浏览器不仅加载完成了 HTML，还加载完成了所有外部资源:图片，样式等。</li></ul><p><strong>动画结束事件</strong></p><p> transitionend:事件会在  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_transitions/Using_CSS_transitions">CSS 过渡</a> 完成的时候触发。如果过渡在完成前就被移除 </p><p>** 文档可见性 **</p><p> 当用户导航到新页面、切换标签页、关闭标签页、最小化或关闭浏览器，或者在移动设备上从浏览器切换到不同的应用程序时，该事件就以为的状态触发。(可用于轮播图等定时器的自动清除与创建) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">addEventListener(&quot;visibilitychange&quot;, (event) =&gt; &#123;<br>console.log(document.visibilityState)<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p><strong>BOM</strong> :浏览器对象模型(Browser Object Model)简称 BOM，由浏览器提供的用于处理文档(document)之外的所有内容的其他对象,比如 navigator、location、history 等对象;我们可以将 BOM 看成是连接 JavaScript 脚本与浏览器窗口的桥梁 </p><p><strong>BOM 主要包括的对象模型</strong></p><ul><li>window:包括全局属性、方法，控制浏览器窗口相关的属性、方法;</li><li>location:浏览器连接到的对象的位置(URL);</li><li>history:操作浏览器的历史;</li><li>navigator:用户代理(浏览器)的状态和标识(很少用到)</li><li>screen:屏幕窗口信息(很少用到);</li></ul><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><ul><li>setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。</li><li>setlnterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li><li>clearTimeout:取消 setTimeout 的定时器;</li><li>clearInterval:取消 setInterval 的定时器;</li></ul><p>:::info<br>如果提前定义好的定时器 let timer&#x3D;null,在后面去接收 timer&#x3D;setlnterval(fun,time),在清除定时器的时候一定要将 timer 重新赋为 null,clearInterval(timer);timer&#x3D;null</p><p>:::</p><h5 id="全局对象-window"><a href="#全局对象-window" class="headerlink" title="全局对象 window"></a>全局对象 window</h5><p>window 对象在浏览器中可以从两个视角来看待:</p><p><strong>视角一:全局对象。</strong></p><ul><li>我们知道 ECMAScript 其实是有一个全局对象的</li><li>这个全局对象在 Node 中是 global</li><li>在浏览器中就是 window 对象;</li></ul><p><strong>视角二:浏览器窗口对象。</strong></p><ul><li>作为浏览器窗口时，提供了对浏览器操作的相关的 API;</li></ul><h6 id="window-对象的作用"><a href="#window-对象的作用" class="headerlink" title="window 对象的作用"></a>window 对象的作用</h6><ul><li>第一包含大量的属性:localStorage、console、location、history、screenX、scrolX…</li><li>第二包含大量的方法:alert、close、scrollTo、open…</li><li>第三:包含大量的事件:focus、blur、load、hashchange…</li><li>第四:包含从 EventTarget 继承的方法，addEventListener、removeEventlistener、dispatchEvent 方法</li></ul><p>MDN 文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">https://developer.mozilla.org/zh-CN/docs/Web/API/Window</a></p><h5 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h5><p><strong>location 对象用于表示 window 上当前链接到的 URL 信息。</strong></p><p>**常见的属性: **</p><ul><li>href: 当前 window 对应的超链接 URL, 整个 URL;</li><li>protocol: 当前的协议;</li><li>host: 主机地址;</li><li>hostname: 主机地址(不带端口);</li><li>port: 端囗;</li><li>pathname: 路径;</li><li>search: 查询字符串;</li><li>hash: 哈希值;</li><li>username:URL 中的 username(很多浏览器已经禁用)</li><li>password:URL 中的 password(很多浏览器已经禁用)</li></ul><p><strong>location 有如下常用的方法:</strong></p><ul><li>assign:赋值一个新的 URL，并且跳转到该 URL 中;</li><li>replace:打开一个新的 URL，并且跳转到该 URL 中(不同的是不会在浏览记录中留下之前的记录);</li><li>reload:重新加载页面，可以传入一个 Boolean 类型;</li></ul><h6 id="URLSearchParams"><a href="#URLSearchParams" class="headerlink" title="URLSearchParams"></a>URLSearchParams</h6><p>URLSearchParams 定义了一些实用的方法来处理 URL 的查询字符串。</p><ul><li>可以将一个字符串转化成 URLSearchParams 类型:</li><li>也可以将一个 URLSearchParams 类型转成字符串;</li></ul><p><strong>URLSearchParams 常见的方法有如下:</strong></p><ul><li>get:获取搜索参数的值;</li><li>set:设置一个搜索参数和值;</li><li>append:追加一个搜索参数和值;</li><li>has:判断是否有某个搜索参数;</li></ul><p>MDN:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;script&gt;<br>        var urlSearchString = &#x27;?name=MirZ&amp;age=18&amp;height=188&#x27;<br>        //字符串转为URLSearchParams<br>        var searchParams=new URLSearchParams(urlSearchString)<br>        //获取搜索参数<br>        console.log(searchParams.get(&#x27;name&#x27;));<br>        //URLSearchParams转为String<br>        console.log(searchParams.toString());<br>        //添加搜索参数<br>        searchParams.append(&#x27;adresss&#x27;,&#x27;河南&#x27;)<br><br><br><br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h5><p><strong>history 对象允许我们访问浏览器曾经的会话历史记录。</strong></p><p>属性:</p><ul><li>length:会话中的记录条数;</li><li>state:当前保留的状态值;</li></ul><p>方法:</p><ul><li>back():返回上一页，等价于 history.go(-1);</li><li>forward():前进下一页，等价于 history.go(1);</li><li>go():加载历史中的某一页;</li><li>pushState():打开一个指定的地址:</li><li>replaceState():打开一个新的地址，并且使用 replace;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>修改history<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> btns = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><br><span class="language-javascript">      btns[<span class="hljs-number">0</span>].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        history.<span class="hljs-title function_">pushState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mir&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;18&quot;</span> &#125;, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;/Mir&quot;</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">      btns[<span class="hljs-number">1</span>].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//后退</span></span><br><span class="language-javascript">        <span class="hljs-comment">// history.back()</span></span><br><span class="language-javascript">        <span class="hljs-comment">//前进</span></span><br><span class="language-javascript">        <span class="hljs-comment">// history.forward()</span></span><br><span class="language-javascript">        <span class="hljs-comment">//加载某一页</span></span><br><span class="language-javascript">        <span class="hljs-comment">// history.go(2)</span></span><br><span class="language-javascript">        history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="navigator-和-screen"><a href="#navigator-和-screen" class="headerlink" title="navigator 和 screen"></a>navigator 和 screen</h5><p><strong>navigator 对象表示用户代理的状态和标识等信息。</strong></p><p><img src="1737990304029-3c4752ad-5cc5-41ed-b635-86faba095035.png"></p><p><strong>screen 主要记录的是浏览器窗口外面的客户端显示器的信息:</strong></p><p><img src="1737990500532-78c0914e-9cd9-4f68-93a0-a90584407979.png"></p><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>JSON 是一种重要的数据格式，它并不是编程语言，而是一种在服务器和客户端之间传输的数据格式,JSON 的全称是 JavaScript Object Notation(JavaScript 对象符号)</p><p><strong>JSON 被使用的场景</strong></p><ul><li>网络数据的传输 JSON 数据</li><li>项目的某些配置文件:</li><li>非关系型数据库(NoSQL)将 json 作为存储格式</li></ul><p><strong>JSON 的顶层支持三种类型的值:</strong></p><ul><li>简单值:数字(Number)、字符串(String，不支持单引号)、布尔类型(Boolean)、null 类型;</li><li>对象值:由 key、value 组成，key 是字符串类型，并且必须添加双引号，值可以是简单值、对象值、数组值;</li><li>数组值:数组的值可以是简单值、对象值、数组值;</li></ul><p><strong>序列化和反序列化</strong></p><p>某些情况下我们希望将 JavaScript 中的复杂类型转化成 JSON 格式的字符串，这样方便对其进行处理:</p><ul><li>比如我们希望将一个对象保存到 localStorage 中;但是如果我们直接存放一个对象，这个对象会被转化成[object Object]格式的字符串，并不是我们想要的结果</li><li>stringify 方法:将 JavaScript 类型转成对应的 JSON 字符串;</li><li>parse 方法:解析 JSON 字符串，转回对应的 JavaScript 类型;</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>    &lt;script&gt;<br>        const obj=&#123;<br>            name:&#x27;MirZ&#x27;,<br>            age:&#x27;18&#x27;<br>        &#125;<br>        //进行序列化在存储,否则存储的为[Object,Object]<br>        var objJsonStr=JSON.stringify(obj)<br>        //存储到localStorage<br>        localStorage.setItem(&#x27;info&#x27;,objJsonStr)<br>        //获取存储到localStorage的info<br>        const item=localStorage.getItem(&#x27;info&#x27;)<br>        //获取到的时序列化后的字符串<br>        console.log(item);<br>        //反序列化,获取对象<br>        const newObj=JSON.parse(item)<br>        console.log(newObj);<br><br><br>    &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部分知识记录</title>
    <link href="/2024/12/26/%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/26/%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h5 id="i3uQg">文档声明</h5><p>HTML 最上方的一段文本称之位文档类型声明,用于声明文档类型</p><p><code>&lt;!DOCTYPE html&gt;</code></p><p>1 HTML 文档声明，告诉浏览器当前页面是 HTML5 页面</p><p>2 让浏览器用 HTML5 的标准去解析识别 内容:</p><p>3 必须放在 HTML 文档的 最前面，不能省略 ，省略了会出现 兼容性 问题</p><h5 id="XBwWO">html元素</h5><html>元素 表示一个 HTML 文档的根元素(顶级元素)。所有其他元素必须是此元素的后代<p><code>&lt;html lang=&quot;zh-CN&quot;&gt;&lt;/html&gt;</code></p><p>W3C 标准建议为 html 元素增加一个 lang 属性，作用是</p><p>1 帮助语音合成工具确定要使用的发音;</p><p>2 帮助翻译工具确定要使用的翻译规则;</p><p>比如常用的规则:</p><p>lang&#x3D;“en”表示这个 HTML 文档的语言是英文</p><p>lang&#x3D;“zh-CN”表示这个 HTML 文档的语言是中文</p><h5 id="PTmF9">head元素</h5><p>HTML head 元素 规定文档相关的 配置信息 (也称之为 元数据 )，包括文档的 标题，引用的文档样式和脚本 等。</p><p>1 什么是元数据(metadaka)，是描述数据的数据;</p><p>2 这里我们可以理解成对整个页面的配置:</p><p>常见的设置有哪些呢?一般会至少包含如下 2 个设置。</p><p>网页的标题:<strong>title 元素</strong></p><p><code>&lt;title&gt;标题&lt;/title&gt;</code></p><p>网页的编码:<strong>meta 元素</strong></p><p><code>&lt;meta charset=&quot;UTF-8&quot;&gt; </code></p><p>可以用于设置网页的 字符编码 ，让浏览器更精准地显示每一个文字， 不设置或者设置错误会导致乱码 </p><p>一般都使用 utf-8 编码，涵盖了世界上几乎所有的文字;</p><p><strong>meta 元素用于定义元数据:</strong></p><p><strong>meta 用于定义那些不能使用其他定元相关(meta-related)元素定义的任何元数据信息;</strong></p><p>meta 元素定义的元数据的类型包括以下几种:</p><ul><li>如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。</li><li>如果设置 http-equiv 属性，meta 元素则是编译指令</li><li>如果设置了 name 属性，meta 元素提供的是文档级别(document-level)的元数据，应用于整个页面。</li></ul><h5 id="l96Bj">a标签</h5><p>在网页中我们经常需要<strong>跳转到另外一个链接</strong>，这个时候我们使用 a 元素:</p><p>a 元素有两个常见的属性:</p><p>href:Hypertext Reference 的简称 指定要打开的 URL 地址;</p><p>target:该属性指定在何处显示链接的资源，self:默认值，在当前窗口打开 URL; blank:在一个新的窗口中打开 URL;</p><p>parent top 其他不常用</p><p>锚点链接可以实现:<strong>跳转到网页中的具体位置</strong></p><p>锚点链接有两个重要步骤:</p><p>在要跳到的元素上定义一个 id 属性</p><p>定义 a 元素，并且 a 元素的 href 指向对应的 id，</p><p><code> &lt;a href=&quot;#id&quot;&gt;&lt;/a&gt;</code></p><h5 id="RMX4t">iframe标签</h5><p>利用 iframe 元素可以实现:在一个 HTML 文档中嵌入其他 HTML 文档</p><p><code>    &lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code></p><p>frameborder 属性 用于规定是否显示边框 1:显示 0:不显示</p><p>a 元素 target 的其他值:</p><p>_parent:在父窗口中打开 URL</p><p>_top:在顶层窗口中打开 URL</p><h5 id="NQWt2">字符实体</h5><p>思考:我们编写的 HTML 代码会被浏览器解析。如下代码是如何被解析的呢?</p><p>口如果你使用小于号(&lt;)，浏览器会将其后的文本解析为一个 tag 标签。但是某些情况下，我们确实需要编写一个小于号(&lt;);这个时候我们就可以使用字符实体;</p><p>HTML 实体是一段以连字号(&amp;)开头、以分号(;)结尾的文本(字符串):实体常常用于显示 保留字符 (这些字符会被解析为 HTML 代码)和 不可见的字符 (如“不换行空格”);你也可以用实体来 代替其他难以用标准键盘键入的字符 </p><p>常见字符实体:</p><p><code>&amp;nbsp;  //空格    </code></p><p><code>&amp;lt;    //小于号  </code></p><p><code>&amp;gt;    //大于号  </code></p><h5 id="xEwuh">URL和URl</h5><p>URl&#x3D;Uniform Resource ldentifier 统一资源<strong>标志符</strong>, 用于标识  Web 技术使用的逻辑或物理资源 。</p><p>URL&#x3D;Uniform Resource Locator 统一资源<strong>定位符</strong>，俗称 网络地址 ，相当于网络中的门牌号;</p><p><code>[协议类型]://[服务器地址]:[端口号]/[文件路径][文件名]?[查询]#[片段ID]</code></p><ul><li>URL 是 URI 的子集，即 URL 一定是 URI，但 URI 不一定是 URL </li><li>前端可以通过访问并得到资源，这是 URL </li><li>服务器内部，可以得到某一图片等资源，即图片等资源会有一个标识交给服务器，服务器可以通过该标识访问到该资源，甚至是物理设备，这期间不一定有 WEB 的参与，这是 URI</li></ul><h5 id="ufcYy">元素语义化</h5><p>元素的语义化:用正确的元素做正确的事情。</p><p>标签语义化的好处:</p><ul><li>方便代码维护</li><li>减少让开发者之间的沟通成本</li><li>能让语音合成工具正确识别网页元素的用途，以便作出正确的反应</li><li>有利于 SEO</li><li>…</li></ul><h5 id="v6xo4">DNS解析</h5><p>浏览器通过域名获取资源时, 会先访问域名服务器（DNS）, DNS 服务器会解析域名, 找到对应的 IP 地址, 再通过 IP 地址访问对应服务器。</p><p>域名的解析这一过程也是需要时间的, 我们可以尝试提前解析资源所在域名, 以提高获取资源时的访问速度</p><p>可以通过对 link 标签设置 dns-prefetch 来进行优化, 如下:</p><p><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//static.360buyimg.com&quot;&gt;</code></p><h5 id="Vam9e">text-align理解</h5><p>W3C 中的解释:</p><p>This shorthand propertly sets the “text-align-all’and “text-align-last’properties and describes how</p><p>the  inline-level content  of a block is aligned along the inline axis if the content does not completely fill</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-comment">/* text-align只作用于行内级元素(inline); */</span></span><br><span class="language-css">        <span class="hljs-comment">/* display: inline-block; */</span></span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: bisque;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="QrKNk">选择器权重</h5><p>按照经验，为了方便比较 CSS 属性的优先级，可以给 CSS 属性所处的环境定义一个权值(权重)</p><ul><li>!important: 10000</li><li>内联样式:1000</li><li>id 选择器:100</li><li>类选择器、属性选择器、伪类:10</li><li>元素选择器、伪元素:1</li><li>通配符:0</li></ul><h5 id="pbS3z">display:block-inline</h5><p>block 元素:</p><ul><li>独占父元素的一行</li><li>可以随意设置宽高</li><li>高度默认由内容决定</li></ul><p>inline-block 元素</p><ul><li>跟其他行内级元素在同一行显示</li><li>可以随意设置宽高</li></ul><p>:::tips<br>可以这样理解</p><p>对外来说，它是一个行内级元素</p><p>对内来说，它是一个块级元素</p><p>:::</p><p>:::tips<br>使用 display : inline-block 使两个元素同行排布时,元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal，合并多余空白），原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，间距为 8px。</p><p>:::</p><p>inline:</p><ul><li>跟其他行内级元素在同一行显示</li><li>不可以随意设置宽高</li><li>宽高都由内容决定</li></ul><h5 id="VQ48G">margin上下传递和折叠</h5><h6 id="QRiPD">margin的上下传递</h6><p>margin-top 传递</p><p>如果块级元素的顶部线和父元素的顶部线重叠，那么这个块级元素的 margin-top 值会传递给父元素</p><p>margin-bottom 传递</p><p>如果块级元案的底部线和父元案的底部线重写，并且父元案的高度是 auto，那么这个块级元案的 margin-bottom 值会传递给父元案</p><p><strong>如何防止出现传递问题?</strong></p><ul><li>给父元素设置 padding-topipadding-bottom</li><li>给父元素设置 border</li><li>触发 BFC: 设置 overflow 为 auto</li></ul><h6 id="MPS2x">margin的上下折叠</h6><ul><li>垂直方向上相邻的 2 个 margin(margin-top、margin-bottom)有可能会合并为 1 个 margin，这种现象叫做 collapse(折叠)</li><li>水平方向上的 margin(margin-left、margin-right)不会 collapse</li><li>折叠后最终值的计算规则:两个值进行比较，取较大的值</li><li>如何防止 margin collapse? 只设置其中一个元素的 margin</li></ul><h5 id="C0yz9">行内非替换元素的特殊性</h5><p>对于行内非替换元素(span,a,strong,i)等,某些属性具有特殊性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><br><span class="language-css">        <span class="hljs-comment">/* width,height不生效 */</span></span><br><span class="language-css">        <span class="hljs-comment">/* width: 100px;</span></span><br><span class="hljs-comment"><span class="language-css">            height: 100px; */</span></span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/*上下会撑开,但不占据空间  */</span></span><br><span class="language-css">        <span class="hljs-comment">/* padding: 30px; */</span></span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/*上下会撑开,但不占据空间  */</span></span><br><span class="language-css">        <span class="hljs-comment">/* border: 30px solid green; */</span></span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* margin上下不生效 */</span></span><br><span class="language-css">        <span class="hljs-comment">/* margin:30px */</span></span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span> 123 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Rh2BO">position</h5><h6 id="AbcxI">标准流</h6><p>默认情况下，元素都是按照 normal flow(标准流、常规流、正常流、文档流【documentflow】)进行排布</p><ul><li>从左到右、从上到下按顺序摆放好</li><li>默认情况下，互相之间不存在层叠现象</li></ul><p>在标准流中，可以使用 margin、padding 对元素进行定位</p><ul><li>其中 margin 还可以设置负数</li></ul><p>比较明显的缺点是</p><ul><li>设置一个元素的 margin 或者 padding,通常会影响到标准流中其他元素的定位效果</li><li>不便于实现元素层叠的效果</li></ul><p>如果我们希望一个元素可以跳出标准量,单独的对某个元素进行定位呢?我们可以通过 position 属性来进行设置:</p><p>利用 position 可以对元素进行定位，常用取值有 5 个:</p><p>默认值:</p><ul><li>static:默认值,静态定位</li></ul><p>使用下面的值，可以让元素变成定位元素(positionedelement)</p><ul><li>relative:相对定位</li><li>absolute:绝对定位</li><li>fixed:固定定位</li><li>sticky:粘性定位</li></ul><h6 id="rMWWW">relative-相对定位</h6><p>元素不会完全脱离标准流,元素按照 normal flow 布局</p><p>可以通过 left、right、top、bottom 进行定位</p><p>定位参照对象是元素自己原来的位置</p><ul><li>left、right、top、bottom 用来设置元素的具体位置</li></ul><p>相对定位的应用场景</p><ul><li>在不影响其他元素位置的前提下，对当前元素位置进行微调</li></ul><h6 id="fF5jk">fixed-固定定位</h6><p>元素脱离 normal flow(脱离标准流、脱标)</p><ul><li>可以通过 left、right、top、bottom 进行定位</li><li>定位参照对象是 视口(viewport) </li><li>当画布滚动时，固定不动</li></ul><h6 id="upwkb">absolute-绝对定位</h6><p>元素脱离 normalflow(脱离标准流、脱标)</p><ul><li>可以通过 left、right、top、bottom 进行定位</li><li>定位参照对象是 最邻近的定位祖先元素  , 如果找不到这样的祖先元素，参照对象是视口</li></ul><p>定位元素(positioned element)</p><ul><li>position 值不为 static 的元素,也就是 position 值为 relative、absolute、fixed 的元素</li></ul><h6 id="YURvn">positon:absolute/fixed的元素特征</h6><p>将 position 设为 absolute&#x2F;fixed 的元素有如下特征</p><ul><li>可以随意设置宽高,宽高默认由内容决定</li><li>不再受标准流的约束 , 不再严格按照从上到下、从左到右排布</li><li>不再严格区分块级(block)、行内级(inline)，行内块级(inline·block)的很多特性都会消失</li><li>不再给父元素汇报宽高数据</li><li>定位参照对象的宽度 &#x3D; left + right + margin-left + margin-right + 绝对定位元素的实际占用宽度</li><li>定位参照对象的高度&#x3D;top+bottom+ margin-top+ margin-bottom +绝对定位元素的实际占用高度</li></ul><p>如果希望<strong>绝对定位元素的宽高和定位参照对象</strong>一样，可以给绝对定位元素设置** **left: 0、right: 0 top:0、bottom:0、margin:0</p><p>如果希望<strong>绝对定位元素在定位参照对象中居中显示</strong>，可以给绝对定位元素设置 left: 0、right: 0、top: 0、bottom: 0、 margin: auto</p><p>另外，还得设置<strong>具体的宽高值</strong>(宽高小于定位参照对象的宽高)</p><h6 id="wfftC">sticky-粘性定位</h6><ul><li>可以看做是相对定位和固定(绝对)定位的结合体</li><li>它允许被定位的元素表现得像相对定位一样，直到它滚动到某个值点</li><li>当达到这个阈值点时,就会变成固定(绝对)定位</li><li>sticky 是相对于最近的滚动祖先包含视口的(the nearest ancestor  scroll  container’s scrollport)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">html</span>,</span><br><span class="language-css">      <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.nav</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: sticky;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aliceblue;</span><br><span class="language-css">        <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e8e8e8</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>我是导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> boxEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.box&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">genItem</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> itemList = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt;= <span class="hljs-number">50</span>; index++) &#123;</span><br><span class="language-javascript">          itemList += <span class="hljs-string">`&lt;div class=&#x27;item&#x27;&gt;`</span> + index + <span class="hljs-string">`&lt;/div&gt;`</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        boxEle.<span class="hljs-property">innerHTML</span> = itemList;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-title function_">genItem</span>();</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="M0ytX">z-index</h6><p>z-index 属性用来设置定位元素的层叠顺序(仅对定位元素有效)</p><ul><li>取值可以是正整数、负整数、0</li></ul><p><strong>比较原则</strong></p><p>如果是兄弟关系</p><ul><li>z-index 越大，层叠在越上面 </li><li>z-index 相等，写在后面的那个元素层叠在上面</li></ul><p>如果不是兄弟关系</p><ul><li>各自从元素自己以及祖先元素中，找出最邻近的 2 个定位元素(祖先元素为兄弟元素)进行比较 </li><li>而且这 2 个定位元素必须有设置 z-index 的具体数值</li></ul><h5 id="onhuI">浮动</h5><p>float 属性可以指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它(脱离标准流),有以下属性:left,right,none</p><h6 id="FbGGp">浮动规则</h6><p><strong>元素一旦浮动后，脱离标准流</strong></p><ul><li>朝着向左或向右方向移动，直到自己的边界紧贴着包含块(一般是父元素)或者其他浮动元素的边界为止 [不会超出包含块的边界(不超出 padding,只在内容中浮动)] </li><li>定位元素 会层叠在浮动元素上面</li></ul><p><strong>浮动元素之间不能层叠</strong></p><ul><li>如果一个元素浮动，另一个浮动元素已经在那个位置了，后浮动的元素将紧贴着前一个浮动元素(左浮找左浮，右浮找右浮)</li><li>如果水平方向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充足的空间为止</li></ul><p><strong>浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出</strong></p><ul><li>比如行内级元素、inline-block 元素、块级元素的文字内容</li></ul><p><strong>行内级元素、inline-block 元素浮动后，其顶部将与所在行的顶部对齐</strong></p><p>:::info<br>将多个行内级元素中间的空格(间隙)去除的方法</p><ol><li>删除换行符(不推荐)</li><li>将父级元素的 font-size 设置为 0，但是需要子元素设置回来</li><li>子元素设置浮动</li></ol><p>:::</p><h6 id="Cn7is">浮动引起高度塌陷-清除浮动</h6><p>由于浮动元素脱离了标准流，变成了脱标元素，所以不再向父元素汇报高度</p><ul><li>父元素计算总高度时，就不会计算浮动子元素的高度,导致了高度坍塌的问题</li></ul><p><strong>clear 属性可以指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面</strong></p><p>clear 的常用取值:</p><ul><li>left:要求元素的顶部低于之前生成的所有左浮动元素的底部</li><li>right:要求元素的顶部低于之前生成的所有右浮动元素的底部</li><li>both:要求元素的顶部低于之前生成的所有浮动元素的底部</li><li>none:默认值，无特殊要求</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">.clear-fix::after&#123; content: &#x27;&#x27;; display: block; clear: both; /*浏览器兼容性*/<br>visibility: hidden; height: 0; &#125; .clear-fix&#123; /* IE6/7兼容性 */ zoom: 1; &#125;<br></code></pre></td></tr></table></figure><h5 id="xtwyc">vertical-align(/*line boxes*/)</h5><p>This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.</p><p><strong>官方文档的翻译:vertical-align 会影响 **</strong> 行内块级元素  *<strong>*在一个**</strong>  行盒 *<strong>* 中垂直方向的位置</strong></p><h6 id="gNmBh">思考</h6><p><strong>一个 div 没有设置高度的时候，会不会有高度?</strong></p><ul><li>没有内容，没有高度</li><li>有内容，内容撑起来高度</li></ul><p><strong>但是内容撑起来高度的本质是什么呢?</strong></p><ul><li>内容有行高(line-height)，撑起来了 div 的高度</li></ul><p><strong>行高为什么可以撑起 div 的高度?</strong></p><ul><li>这是因为 line boxes 的存在，并且 line-boxes 有一个特性，包裹每行的 inline level</li><li>而其中的文字是有行高的，必须将整个行高包惠进去，才算包惠这个 line-level</li></ul><p><strong>那么，进一步思考:</strong></p><ul><li>如果这个 div 中有图片，文字，inline-block，甚至他们设置了 margin 这些属性呢?</li><li>line boxes 进一步变大,包裹内容</li></ul><p><strong>有图片、文字、inline-block(比图片要大)而且设置了 margin-bottom 并且有文字，如何包裹内容?</strong></p><ul><li>由于存在文本,文本默认按照 baseline 基线对齐,<strong>inline-block</strong>会下移,line boxes 变大</li></ul><h6 id="qY2Cx">vertical-align</h6><p><strong>结论:line-boxes 一定会想办法包裹住当前行中所有的内容</strong></p><ul><li>但是，但是为什么对齐方式千奇百怪呢?因为 baseline 对齐</li></ul><p>我们来看官方 vertical-align 的默认值:没错，就是 baseline</p><p>但是 baseline 都是谁呢?</p><ul><li>文本的 baseline 是字母 x 的下方</li><li>Inline-block 默认的 baseline 是 margin-bottom 的底部(没有，就是盒子的底部)</li><li>Inline-block 有文本时，baseline 是最后一行文本的 x 的下方</li></ul><p><strong>现在，对于不同的取值就非常容易理解了</strong></p><ul><li>baseline(默认值):基线对齐</li><li>top:把行内级盒子的顶部跟 line boxes 顶部对齐</li><li>middle:行内级盒子的中心点与父盒基线加上 x-height 一半的线对齐</li><li>bottom:把行内级盒子的底部跟 line box 底部对齐</li><li><percentage>:把行内级盒子提升或者下降一段距离(距离相对于 line-height 计算\元素高度)，0%意味着同 baseline-样</percentage></li><li><length>:把行内级盒子提升或者下降一段距离，0cm 意味着同 baseline-样</length></li></ul><h5 id="Fim4V">H5新增元素</h5><p><strong>HTML5 新增了语义化的元素:</strong></p><ul><li><header>:头部元素</header></li><li><nav>:导航元素</nav></li><li><section>:定义文档某个区域的元素</section></li><li><article>:内容元素</article></li><li><aside>:侧边栏元素</aside></li><li><footer>:尾部元素</footer></li></ul><h6 id="WEzFT">video</h6><p><strong>HTML <video>元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。</video></strong></p><table><thead><tr><th>常见属性</th><th>值的方式</th><th>属性作用</th></tr></thead><tbody><tr><td>src</td><td>url 地址</td><td>视频播放的 url 地址</td></tr><tr><td>width</td><td>pixels(像素)</td><td>video 宽度</td></tr><tr><td>height</td><td>pixels(像素)</td><td>vide 高度</td></tr><tr><td>controls</td><td>Boolean</td><td>是否显示控制栏</td></tr><tr><td>autoplay</td><td>Boolean</td><td>是否自动播放(某些浏览器需要添加 muted 比如 Chrome)</td></tr><tr><td>muted</td><td>Boolean</td><td>是否静音播放</td></tr><tr><td>preload</td><td>none&#x2F;metadata&#x2F;auto</td><td>是否预加载视频,metadata 表示预加载元数据</td></tr><tr><td>poster</td><td>url 地址</td><td>一海报帧的 url</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 兼容性写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.ogg&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前浏览器不支持,请更换<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="BakTc">audio</h6><p><strong>HTML<audio>元素用于在文档中嵌入音频内容，和 video 的用法非常类似</audio></strong></p><table><thead><tr><th><strong>常见属性</strong></th><th><strong>值的方式</strong></th><th><strong>属性作用</strong></th></tr></thead><tbody><tr><td>src</td><td>url 地址</td><td>视频播放的 url 地址</td></tr><tr><td>controls</td><td>Boolean</td><td>是否显示控制栏</td></tr><tr><td>autoplay</td><td>Boolean</td><td>是否自动播放(某些浏览器需要添加 muted 比如 Chrome)</td></tr><tr><td>muted</td><td>Boolean</td><td>是否静音播放</td></tr><tr><td>preload</td><td>none&#x2F;metadata&#x2F;auto</td><td>是否预加载视频,metadata 表示预加载元数据</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.mp3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/t.ogg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="ljXK1">全局属性data-*</h5><p><strong>在 HTML5 中,新增一种全局属性的格式 data-*,用于自定义数据属性:</strong></p><ul><li>data 设置的属性可以在 JavaScript 的 DOM 操作中通过 dataset 轻松获取到;</li><li>通常用于 HTML 和 JavaScript 数据之间的传递</li><li>在小程序中，就是通过 data-*来传递数据的</li></ul><h5 id="cXFLV">white-space</h5><p><strong>white-space 用于设置空白处理和换行规则</strong></p><ul><li>normal:合并所有连续的空白，允许单词超屏时自动换行</li><li>nowrap:合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre:阻止合并所有连续的空白，不允许单词超屏时自动换行</li><li>pre-wrap:阻止合并所有连续的空白，允许单词超屏时自动换行</li><li>pre-line:合并所有连续的空白(但保留换行)，允许单词超屏时自动换行</li></ul><h5 id="I7yWO">CSS函数补充</h5><h6 id="Hklff">var函数</h6><p>CSS 中可以自定义属性</p><ul><li>属性名需要以两个减号(–)开始;</li><li>属性值则可以是任何有效的 CSS 值</li><li>属性值须在父元素(根元素)定义</li><li></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">:root &#123; --v_color: #00CC4C &#125; .box &#123; width: 320px; height: 155px;<br>background-color: var(--v_color); &#125;<br></code></pre></td></tr></table></figure><h6 id="xCStG">calc函数</h6><p>calc()函数允许在声明 CSS 属性值时执行一些计算。</p><p>计算支持加减乘除的运算;</p><ul><li>+和-运算符的两边必须要有空白字符</li><li>通常用来设置一些元素的尺寸或者位置</li></ul><h6 id="H3HUt">bulr函数</h6><p><strong>blur()函数将**</strong> 高斯模糊 *<strong>*应用于输出图片或者元素;</strong></p><ul><li>blur(radius)</li><li>radius, 模糊的半径,用于定义高斯函数的偏差值,偏差值越大, 图片越模糊;</li></ul><p>通常会和两个属性一起使用:</p><ul><li>filter: 将模糊或颜色偏移等图形效果应用于元素;</li><li>backdrop-filter: 为元素后面的区域添加模糊或者其他效果;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">155px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-comment">/*父元素设置也可以,继承*/</span></span><br><span class="language-css">        <span class="hljs-comment">/* filter: blur(3px); */</span></span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">3px</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://sy-1254960240.image.myqcloud.com/box/ingame/images/202412/20241222122826-675357.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">155px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">img</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/*透明遮罩层+模糊  */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.cover</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);</span><br><span class="language-css">        backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">3px</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://sy-1254960240.image.myqcloud.com/box/ingame/images/202412/20241222122826-675357.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cover&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="SxCUp">gradient函数-颜色渐变</h6><p><strong><gradient>是一种<image>CSS 数据类型的子类型，用于表现两种或多种颜色的过渡转变，</image></gradient></strong></p><p><strong><gradient>常见的函数实现有下面几种:</gradient></strong></p><ul><li>linear-gradient():创建一个表示两种或多种颜色线性渐变的图片;</li><li>radial-gradient():创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成,</li><li>repeating-linear-gradient():创建一个由重复线性渐变组成的<image>;</image></li><li>repeating-radial-gradient0):创建一个重复的原点触发渐变组成的<image>;</image></li><li>…</li></ul><p><strong>linear-gradient:创建一个表示两种或多种颜色线性渐变的图片;</strong></p><p><code>background-image: linear-gradient(to right,red,blue);</code></p><p><code>background-image: linear-gradient(to right,red,blue 40px,orange 60%,purple 100%);</code></p><p><strong>radial-gradient:创建了一个图像，该图像是由从原点发出的两种或者多种颜色之间的逐步过渡组成;</strong></p><p><code>background-image:radial-gradient(50% 50%,red,blue)</code></p><h5 id="uTQ0u">BFC(块级格式化上下文)</h5><p><strong>FC 的全称是 Formatting Context(格式化上下文)，元索在标准流里面都是属于一个 FC 的;</strong></p><blockquote><p>Boxes in the normal flow belong to a formatting context, which may be block or inline, but not bothsimultaneously. <strong>Block-level boxes</strong> participate in a <strong>block formatting context.</strong> <strong>inline-level</strong> boxes participate in an** inline formatting context.**</p></blockquote><p><strong>MDN 上有整理出在哪些具体的情况下会创建 BFC:</strong></p><ul><li>根元素(<html>)</html></li><li>浮动元素(元系的 float 不是 none)</li><li>绝对定位元素(元素的 position 为 absolute 或 fixed)</li><li>行内块元素(元素的 display 为 inline-block)</li><li>表格单元格(元案的 display 为 table-cell，HTML 表格单元格默认为该值)，表格标题(元案的 display 为 table-caption，HTML 表格标题默认为该作值)</li><li>匿名表格单元格元案(元案的 display 为 table、table-row、table-row-group、table-header-group、table-footer-group(分别是 HTML tablerow、tbody、thead、tfoot 的默认属性)或 inline-table)</li><li>overflow 计算值(Computed)不为 visible 的块元家</li><li>弹性元素(display 为 flex 或 inline-flex 元系的直接子元素)</li><li>网格元素(display 为 grid 或 inline-grid 元系的直接子元素)</li><li>display 值为 flow-root 的元素</li><li>…</li></ul><p><strong>BFC 概述:</strong></p><ul><li>在 BFC 中，box 会在垂直方向上一个挨着一个的排布</li><li>垂直方向的间距由 margin 属性决定</li><li>在同一个 BFC 中，相邻两个 box 之间的 margin 会折叠(collapse)</li><li>在 BFC 中，每个元素的左边缘是紧挨着包含块的左边缘的;</li></ul><p><strong>网上有很多说法，BFC 可以解决浮动高度塌陷，可以实现清除浮动的效果。</strong></p><p>BFC 解决高度塌陷需要满足两个条件:</p><ul><li>浮动元素的父元素触发 BFC，形成独立的块级格式化上下文(BlockFormattingContext)</li><li>浮动元素的父元素的高度是 auto 的:</li></ul><p><strong>BFC 的高度是 auto 的情况下，是如下方法计算高度的</strong></p><ul><li>1.如果只有 inline-level，是行高的顶部和底部的距离;口</li><li>2.如果有 block-level，是由最底层的块上边缘和最底层块盒子的下边缘之间的距离</li><li>3.如果有绝对定位元素，将被忽略;</li><li>4.如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘</li></ul><h5 id="UH0SB">媒体查询</h5><p>媒体查询是一种提供给开发者针对不同设备需求进行定制化开发的一个接口。</p><p>你可以根据设备的类型(比如屏幕设备、打印机设备)或者特定的特性(比如屏幕的宽度)来修改你的页面。</p><p><strong>媒体查询的使用方式主要有三种:</strong></p><p>方式一:通过@media 和@import 使用不同的 CSS 规则(常用):</p><p><code> &lt;style&gt;    @import url() (max-width:800px);   &lt;/style&gt;</code></p><p>方式二:使用 media 属性为 style,link,source 和其他 HTML 元素指定特定的媒体类型;</p><p><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width:800px)&quot; href=&quot;&quot;&gt;</code></p><p><code>@media (max-width:800px) &#123;  &#125;</code></p><p>方式三:使用 Window.matchMedia()和 MediaQueryList.addListener()方法来测试和监控媒体状态</p><p><strong>常见的媒体类型值如下:</strong></p><ul><li>all:适用于所有设备</li><li>print:适用于在打印预览模式下在屏幕上查看的分页材料和文档。</li><li>screen(掌握):主要用于屏幕。</li><li>speech:主要用于语音合成器。</li></ul><p><strong>媒体查询的表达式最终会获得一个 Boolean 值，也就是真(true)或者假(false)</strong></p><p><strong>如果有多个条件，我们可以通过逻辑操作符联合复杂的媒体查询:</strong></p><ul><li>and :and 操作符用于将多个媒体查询规则组合成单条媒体查询</li><li>not:not 运算符用于否定媒体查询，如果不满足这个条件则返回 true，否则返回 false.</li><li>only:only 运算符仅在整个查询匹配时才用于应用样式。</li><li>，(逗号):逗号用于将多个媒体查询合并为一个规则。</li></ul><h5 id="kN0uZ">Less</h5><h6 id="jVbLV">Less的引入或使用</h6><ul><li>Node 环境下，通过 npm 包管理下载 less 编译器，对代码进行编译</li><li>通过 VSCode 插件来编译成 CSS 或者在线编译</li><li>引入 CDN 的 less 编译代码，对 less 进行实时的处理;</li></ul><h6 id="xyuzL">Less特性</h6><ol><li>使用 Less 语法支持嵌套</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-selector-class">.left</span>&#123;<br>        <span class="hljs-attribute">display</span>: block;<br>      <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>        <span class="hljs-attribute">color</span>:red<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义变量</li></ol><p><code>@TestColor: #f3c258 ;</code></p><ol start="3"><li>支持运算(数字,颜色,变量)</li><li>Mixins 混入</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.pray</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-selector-class">.pray</span>();<br>&#125;<br><span class="hljs-comment">/*混入可以传入参数  */</span><br><span class="hljs-selector-class">.pray</span>(<span class="hljs-variable">@color</span>:red) &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-selector-class">.pray</span>(black);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>Mixins 和 Map 混合使用(也可以当作简单自定义函数使用)</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.pray</span>(<span class="hljs-variable">@color</span>: red) &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: .<span class="hljs-built_in">pray</span>() [font-size];<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>继承</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.pry</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-selector-tag">&amp;</span>:<span class="hljs-selector-tag">extend</span>(.pry);<br>&#125;<br><span class="hljs-comment">/*相当于  */</span><br><span class="hljs-selector-class">.pry</span> <span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>内置函数</li></ol><p><a href="https://less.bootcss.com/functions/">Less 函数 | Less.js 中文文档 - Less 中文网</a></p><h5 id="Xy6lo">移动端适配</h5><ul><li>方案一:百分比设置:</li></ul><p>因为不同属性的百分比值，相对的可能是不同参照物，所以百分比很难统一所以百分比在移动端适配中基本不使用</p><ul><li>方案二:rem 单位+动态 html 的 font-size; </li><li>方案三:vw 单位; </li><li>方案四:flex 的弹性布局</li></ul><h6 id="RS7Aw">rem适配移动端</h6><ol><li>媒体查询 </li><li>JS 动态改变 fontSize</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs less">&lt;!<span class="hljs-selector-tag">DOCTYPE</span> <span class="hljs-selector-tag">html</span>&gt;<br>&lt;<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">lang</span>=&quot;<span class="hljs-selector-tag">en</span>&quot;&gt;<br><br>&lt;<span class="hljs-selector-tag">head</span>&gt;<br>  &lt;<span class="hljs-selector-tag">meta</span> <span class="hljs-selector-tag">charset</span>=&quot;<span class="hljs-selector-tag">UTF-8</span>&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">meta</span> <span class="hljs-selector-tag">name</span>=&quot;<span class="hljs-selector-tag">viewport</span>&quot; <span class="hljs-selector-tag">content</span>=&quot;<span class="hljs-selector-tag">width</span>=<span class="hljs-selector-tag">device-width</span>, <span class="hljs-selector-tag">initial-scale</span>=<span class="hljs-number">1.0</span>&quot;&gt;<br>  &lt;<span class="hljs-selector-tag">title</span>&gt;<span class="hljs-selector-tag">Document</span>&lt;/<span class="hljs-selector-tag">title</span>&gt;<br><br>&lt;/<span class="hljs-selector-tag">head</span>&gt;<br><br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">class</span>=&quot;<span class="hljs-selector-tag">box</span>&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>  &lt;<span class="hljs-selector-tag">script</span>&gt;<br>    <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlEl</span> = <span class="hljs-selector-tag">document</span><span class="hljs-selector-class">.documentElement</span><br>    <span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">setFontSize</span>() &#123;<br>      <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlWidth</span> = <span class="hljs-selector-tag">htmlEl</span><span class="hljs-selector-class">.clientWidth</span><br>      <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlFontSize</span> = <span class="hljs-selector-tag">htmlWidth</span> / <span class="hljs-number">10</span><br>      <span class="hljs-selector-tag">htmlEl</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-class">.fontSize</span> = <span class="hljs-selector-tag">htmlFontSize</span> + &#x27;<span class="hljs-selector-tag">px</span>&#x27;<br>    &#125;<br>    <span class="hljs-selector-tag">setFontSize</span>()<br>    <span class="hljs-selector-tag">window</span><span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, setFontSize)<br>  &lt;/<span class="hljs-selector-tag">script</span>&gt;<br>  &lt;<span class="hljs-selector-tag">style</span>&gt;<br>    <span class="hljs-selector-class">.box</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">2rem</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">2rem</span>;<br>      <span class="hljs-attribute">background-color</span>: antiquewhite;<br>    &#125;<br>  &lt;/<span class="hljs-selector-tag">style</span>,&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br><br>&lt;/<span class="hljs-selector-tag">html</span>&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用第三方库 lib-flexible</li></ol><p><strong>px&#x3D;&gt;rem 方案</strong></p><ul><li><strong>手动计算</strong></li><li><strong>less&#x2F;scss 函数</strong></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/*@remUnit:37.5由设计得 */</span><br><span class="hljs-variable">@remUnit:</span> <span class="hljs-number">37.5</span>;<br><span class="hljs-selector-class">.pxToRem</span>(<span class="hljs-variable">@px</span>) &#123;<br>  result: (@px / @remUnit) * 1rem;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: .<span class="hljs-built_in">pxToRem</span>(<span class="hljs-number">100</span>) [result];<br>  <span class="hljs-attribute">height</span>: .<span class="hljs-built_in">pxToRem</span>(<span class="hljs-number">100</span>) [result];<br>  <span class="hljs-attribute">background-color</span>: antiquewhite;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>postcss-pxtorem  webpack 插件自动转化</li><li>vscode 插件 px to rem</li></ul><h6 id="UsEFp">vw适配移动端</h6><p><strong>rem 事实上是作为一种过渡的方案</strong>，它利用的也是 vw 的思想。前面不管是我们自己编写的 js，还是 flexible 的源码;</p><p>都是将 1rem 等同于设计稿的 1&#x2F;10，在利用 1rem 计算相对于整个屏幕的尺寸大小，那么我们来思考，1vw 不是刚好等于屏幕的 1&#x2F;100 吗?且相对于 rem 还更加有优势:</p><p><strong>vw 相比于 rem 的优势:</strong></p><ul><li>优势一:不需要去计算 html 的 font-size 大小，也不需要给 html 设置这样一 font-size;</li><li>优势二:不会因为设置 html 的 font-size 大小，而必须给 body 再设置一个 font-size，防止继承;</li><li>优势三:因为不依赖 font-size 的尺寸，所以不用担心某些原因 html 的 font-size 尺寸被篡改，页面尺寸混乱;</li><li>优势四:vw 相比于 rem 更加语义化，1vw 刚才是 1&#x2F;100 的 viewport 的大小;:</li><li>优势五:可以具备 rem 之前所有的优点;</li></ul><p><strong>px&#x3D;&gt;vw 方案:</strong></p><ul><li><strong>手动计算</strong></li><li><strong>less&#x2F;scss 函数</strong></li><li>**postcss-px-to-viewport-8-plugin **   webpack 插件自动转化</li><li>px to vw 的插件，在编写时自动转化</li></ul></html>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2024/12/23/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2024/12/23/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>:::info<br> Node.js 有两个模块系统：CommonJS 模块和  <a href="https://nodejs.cn/api/esm.html">ECMAScript 模块</a> 。 </p><p> 官方文档解释: <a href="https://nodejs.cn/api/modules.html#%E8%AE%BF%E9%97%AE%E4%B8%BB%E6%A8%A1%E5%9D%97">CommonJS 模块 | Node.js v22 文档</a></p><p>:::</p><h3 id="EE1YO">1.模块化概述</h3><h4 id="uTPmG">1.1.什么是模块化?</h4><p>·将程序文件依据一定规则拆分成多个文件，这种编码方式就是模块化的编码方式。</p><p>·拆分出来每个文件就是一个模块，模块中的数据都是私有的，模块之间互相隔离。</p><p>·同时也能通过一些手段，可以把模块内的指定数据“交出去”，供其他模块使用。</p><h4 id="HzSas">1.2.为什么需要模块化?</h4><p>随着应用的复杂度越来越高，其代码量和文件数量都会急剧增加，会逐渐引发以下问题:</p><p>1.全局污染问题(命名冲突)</p><p>2.依赖混乱问题</p><p>3.数据安全问题</p><h3 id="GgblI">2.有哪些模块化规范</h3><p>随着时间的批移，针对 JavaScript 的不同运行环境，相出现了多种模块化规范，按时间排序，分别为:</p><p>:::info<br><strong>1.CommonJs– 服务端应用广泛</strong></p><p>2.AMD</p><p>3.CMD</p><p><strong>4.ES6 模块化 – 浏览器端应用广泛</strong></p><p>:::</p><h3 id="uppk4">3.导入和导出的概念</h3><p>模块化的核心思想就是:模块之间是隔离的，通过导入和导出进行数据和功能的共享</p><p>:::info<br><strong>导出</strong>:模块公开其内部的一部分(如变量、函数等)，使这些内容可以被其他模块使用。</p><p><strong>导入</strong>:模块引用和使用其他模块导出的内容，以重用代码和功能。</p><p>:::</p><h3 id="R6Lgy">4.CommonJs规范</h3><h4 id="YXqNW">导出数据</h4><p>在 CommonJs 标准中，导出数据有两种方式</p><p>:::info<br>第一种方式:module.exports &#x3D;value</p><p>第二种方式:exports.name &#x3D;value</p><p><img src="1732441087666-54ed39f5-ac50-4e4d-9131-cc0364d8f20d.png"></p><p>:::</p><p>:::success<br>1.每个模块内部的:this、exports、modules.exports 在初始时，都指向同一个空对象，该</p><p>空对象就是当前模块导出的数据，如下图</p><p><img src="1732441386700-3e730de2-0fba-4dc2-869d-1955d601a1c2.png"></p><p>2.无论如何修改导出对象，最终导出的都是 module.exports的值</p><p>3.exports 是对 module.exports 的初始引用，仅为了方便给导出象添加属性，所以不能使用exports &#x3D; value 的形式导出数据，但是可以使用 module.exports &#x3D; xxxx 导出数据</p><p>:::</p><h4 id="ydDTs">导入数据</h4><p><img src="1732441612377-01f04a62-0267-4e1f-a941-7e7c70dddf1a.png"></p><h4 id="pbR63">拓展理解</h4><p>一个 JS 模块在执行时，是被包裹在一个内置函数中执行的，所以每个模块都有自己的作用域，我们可以通</p><p>过如下方式验证这一说法:</p><p><img src="1732441825498-393438c3-6bfe-4df0-9c20-2435b70ea902.png"></p><p><img src="1732441843282-43a9d501-736c-42b1-b707-5a95d576b747.png"></p><h4 id="VTjje">浏览器端使用CommonJS</h4><p>Node.js 默认是支持 CommonJS 规范的，但浏览器端不支持，所以需要经过编译，步骤如下:</p><p><strong>第一步:全局安装 browserify</strong></p><p>:::tips<br><strong>pm i browserify -g</strong></p><p>:::</p><p><strong>第二步:编译</strong></p><p>:::tips<br><strong>browserify index.js -o build.js</strong></p><p>:::</p><p>:::color1<br><strong>备注:  index.js 是源文件   build.js 是输出的目标文件</strong></p><p>:::</p><p><strong>第三步:页面中引入使用</strong></p><p>:::tips<br><strong><script type="text/javascript" src="./build.js"></script></strong></p><p>:::</p><h3 id="LccGf">5.ES6 模块化规范</h3><p>ES6 模块化规范是一个 官方标准 的规范，它是在语言标准的层面上实现了模块化功能，是目前最流行的模</p><p>块化规范，且 浏览器与服务端 均支持该规范。</p><p>1.ESM 自动采用严格模式，忽路use strict’</p><p>2.每个 ES Module 都是运行在单独的<strong>私有作用域</strong>中</p><p>3.ESM 是通过 CORS 的方式请求外部JS 模块的</p><p>4.ESM 的 script 标签会延迟执行脚本</p><p><strong>ESM 对外暴露的是引用关系,且只读</strong></p><h4 id="whNbE">浏览器端和Node中运行ES6模块化</h4><p>:::tips<br><strong>浏览器端引入时,type应为”mouule”</strong></p><p><img src="1732442709794-bf57fc0c-3c29-48ad-abe2-2c549ad8d18b.png"></p><p>:::</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>   <span class="hljs-comment">//加载模块,不引用</span><br><span class="hljs-comment">//动态加载模块</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">moduie</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;https://unpkg.com/promise-polyfill@8.3.0/dist/polyfill.min.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>:::tips</p><h4 id="GnEcg">Node中运行ES6模块化两种方式.</h4><p><strong>方法一:</strong> 将js后缀更改为mjs</p><p>**方法二:**在package.json中配置</p><p><img src="1732442845102-91cfab20-27e3-411d-a691-0bc29ec24f4a.png"></p><p>:::</p><h4 id="HWqgM">导出数据</h4><p>ES6 模块化提供 3 种导出方式:①分别导出、②统一导出、③默认导出</p><blockquote><p>1.分别导出</p><p><img src="1732442993864-4554b76e-d71c-417d-8fea-8d4694ca46e8.png"></p></blockquote><blockquote><p>2.统一导出</p><p><img src="1732443152991-776590d0-1832-43ba-a4ce-78d6a18dfbee.png"></p><p>:::info<br>export { }   中{ }并非对象,而是一种类对象的形式</p><p>:::</p></blockquote><blockquote><p>3.默认导出</p><p><img src="1732443420385-81559b38-200e-4e4e-971f-2f0deb490c60.png"></p><p>:::info<br>export default { }   中导出的 { }是一个对象</p><p>:::</p></blockquote><p>:::info<br> tip:3 种导出方式可以混用</p><p>:::</p><h4 id="vHT1G">导入数据</h4><blockquote><p>1.导入全部(通用)</p></blockquote><p>可以将模块中的所有导出内容整合到一个对象中，</p><p><img src="1732443640826-434b4d2c-4cb3-46ce-a07a-8251131dc957.png"></p><blockquote><p>2.命名导入(对应导出方式:分别导出,统一导出)</p><p><img src="1732443933115-a97d93ec-3e8a-489e-af6a-718e6d3fb276.png"></p></blockquote><blockquote><p>3.默认导入(对应导出方式:默认导出)</p><p><img src="1732443989604-02785e06-71ff-44cb-be35-a981feeafd4f.png"></p></blockquote><blockquote><p>4.命名导入 与 默认导入可以混合使用</p><p><img src="1732444086381-b1df32dd-f894-45ca-8eff-abab0d414f46.png"></p></blockquote><blockquote><p>5.「动态导入」(通用)</p><p><img src="1732444201803-f0f85408-4af4-49b2-94f1-113e071985a7.png"></p></blockquote><blockquote><p>6.import 可以不接收任何数据</p><p><img src="1732444277761-42890bd8-79e6-4958-bf00-40fa94c983e3.png"></p></blockquote><h3 id="BR8jO">6.ESM和CommonJs的交互</h3><p>:::tips<br><img src="1732932495501-3ed374b2-a1ee-40bb-a5e7-35d36fb3697f.png"></p><p>:::</p><h3 id="7-ESM和CommonJs的区别"><a href="#7-ESM和CommonJs的区别" class="headerlink" title="7.ESM和CommonJs的区别"></a>7.ESM和CommonJs的区别</h3><p><strong>标准来源</strong></p><ul><li><font style="color:rgb(64, 64, 64);">CommonJS是Node.js早期为解决模块化问题而采用的规范，由</font><strong><font style="color:rgb(64, 64, 64);">社区</font></strong><font style="color:rgb(64, 64, 64);">提出并实现</font><ul><li><strong><font style="color:rgb(64, 64, 64);">社区标准(API层面)</font></strong></li></ul></li><li><font style="color:rgb(64, 64, 64);">ESM是ECMAScript语言规范（ES6&#x2F;ES2015）的一部分，由JavaScript</font><strong><font style="color:rgb(64, 64, 64);">官方标准化</font></strong><ul><li><strong><font style="color:rgb(64, 64, 64);">官方标准(语法层面)</font></strong></li></ul></li></ul><p><strong>时态</strong></p><ul><li><font style="color:rgb(64, 64, 64);">CommonJS是运行时态</font><ul><li><font style="color:rgb(64, 64, 64);">CommonJS本质上一个环境(Node) , 函数 . 它将模块化放在一个函数中</font></li><li><font style="color:rgb(64, 64, 64);">依赖关系确定在运行时( 可能导出未初始化的值 )</font></li><li><font style="color:rgb(64, 64, 64);">同步、动态加载（运行时解析）</font></li></ul></li><li><font style="color:rgb(64, 64, 64);">ESM 运行时态( import() )  +   编译时态( 静态 )</font><ul><li><font style="color:rgb(64, 64, 64);">预解析后执行（静态分析依赖关系）</font></li><li><font style="color:rgb(64, 64, 64);">在运行之前确定依赖关系</font></li><li><font style="color:rgb(64, 64, 64);">异步、静态加载（编译时解析）</font><ul><li><font style="color:rgb(64, 64, 64);">tree shaking依赖于ESM( 静态语法 ) , tree shaking在工程化环境中是在运行之前执行的( 打包 ),静态语法确定依赖关系</font></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模块化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS的形变,过渡,动画</title>
    <link href="/2024/12/20/CSS%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%98%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7/"/>
    <url>/2024/12/20/CSS%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%8F%98%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="VqwHr">形变-transform</h4>CSS transform属性允许对某一个元素进行某些形变,包括旋转，缩放，倾斜或平移等<p>注意事项，并非所有的盒子都可以进行transform的转换(通常行内级元素不能进行形变)</p><p>:::info<br>** Warning: **  Only elements that are positioned by the box model, i.e., all elements whose layout is managed by the CSS box model, except:  <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Inline-level_content"> non-replacing in-row boxes </a> ,  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/col"> table columns </a> , and  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/colgroup"> table column groups </a> . <code>transform</code></p><p>** 警告： **  只能 由盒模型定位的元素，也就是所有布局由 CSS 盒模型管理的元素，除了： <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Inline-level_content"> 非替换的行内盒子 </a> 、 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/col"> 表格列 </a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/colgroup"> 表格列组 </a> 。 <code>transform</code></p><p>:::</p><p>所以，transform对于行内级非替换元素是无效的  比如对span、a元素等:</p><p> 常见的函数transform function有 :</p><ul><li>平移:translate(x, y)</li><li>缩放:scale(x,y) </li><li>旋转:rotate(deg)</li><li>倾斜:skew(deg, deg)</li></ul><p>** transform可以设置多个值 **</p><p><code>transform:translate(188px) scale(0.5) rotate(45deg);</code></p><h6 id="BmQiH">translate</h6>**平移:translate(x,y)**<ul><li>translate是translateX和translateY函数的简写</li><li>这个CSS 函数用于移动元素在平面上的位置，</li><li>translate本身可以表示翻译的意思，在物理上也可以表示平移</li></ul><p><strong>值个数</strong></p><ul><li>一个值时，设置x轴上的位移</li><li>二个值时，设置x轴和y轴上的位移</li></ul><p><strong>值类型:</strong></p><ul><li>数字:100px</li><li>百分比:参照元素本身(referto the size of bounding box)</li></ul><h6 id="oytPc">scale</h6>**缩放:scale(x,y)**<p><strong>scale()可改变元系的大小</strong></p><p>值个数</p><ul><li>一个值时，设置x轴上的缩放</li><li>二个值时，设置x轴和y  轴上的缩放</li></ul><p>**值类型:**数字:</p><ul><li>1:保持不变</li><li>2:放大一倍</li><li>0.5:缩小一半</li><li>百分比:百分比不常用</li></ul><p>scale函数是scaleX和scaleY的缩写</p><h6 id="tl3BT">rotate</h6>**旋转:rotate(<angle>)**<p>值类型:</p><ul><li>常用单位deg:旋转的角度(degrees)</li><li>正数为顺时针</li><li>负数为逆时针</li></ul><p><strong>补充一:rotate函数是rotateZ函数的简写写法。</strong></p><p><strong>补充二:rotate的其他单位</strong></p><ul><li>事实上rotate支持的单位是很多的;度(degrees)、百分度(gradians)弧度(radians)或圈数(turns)</li></ul><h6 id="KrVSR">transform-origin</h6>**transform-origin:形变的原点**<p>比如在进行scale缩放或者rotate旋转时，都会有一个原点。</p><ul><li>一个值:设置x轴的原点</li><li>两个值:设置x轴和y轴的原点</li></ul><p>必须是<length>，<percentage>，或left,center, right, top, bottom关键字中的一个</percentage></length></p><ul><li>left, center, right, top, bottom关键字</li><li>length:从左上角开始计算</li><li>百分比:参考元素本身大小</li></ul><h6 id="dwaNH">skew</h6>倾斜:skew(x，y)<p>** 函数定义了一个元素在二维平面上的倾斜转换。**</p><ul><li>一个值时，表示x轴上的倾斜</li><li>二个值时，表示x轴和y轴上的倾斜</li></ul><p>值类型:</p><ul><li>deg:旋转的角度</li><li>正数为顺时针</li><li>负数为逆时针</li></ul><h4 id="muMft">过渡-transition</h4>什么是transition动画呢?<ul><li>CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法,</li><li>可以让CSS属性变化成为一个持续一段时间的过程，而不是立即生效的;</li><li>比如将一个元素从一个位置移动到另外一个位置，默认在修改完CSS属性后会立即生效:</li><li>但是我们可以通过CSS transition，让这个过程加上一定的动画效果，包括一定的曲线速率变化;</li></ul><p>通常将两个状态之间的过渡称为隐式过渡(implicit transitions)，因为开始与结束之间的状态由浏览器决定。</p><p><strong>Css transitions可以决定</strong></p><ul><li>哪些属性发生动画效果(明确地列出这些属性)</li><li>何时开始(设置 delay)</li><li>持续多久(设置 duration)</li><li>效何动画(定义timing function，比如匀速地或先快后慢)。</li></ul><p> transition CSS属性是  ** transition-property, transition-duration, transition-timing-function 和transition-delay **  的一个简写属性。 </p><p><code>transition-property:all  //动画生效的属性</code></p><p><code>transition-duration:1s  //动画持续的时间</code></p><p><code>transition-timing-function:ease //动画执行曲线</code></p><p><code>transition-delay:1s  //延迟动画</code></p><p><strong>transition-property:指定应用过渡属性的名称</strong></p><ul><li>all:所有属性都执行动画;</li><li>none:所有属性都不执行动画:</li><li>CSS属性名称:要执行动画的CSS属性名称，比如width、left、transform等;</li></ul><p><strong>transition-duration:指定过渡动画所需的时间</strong></p><ul><li>单位可以是秒(s)或毫秒(ms)</li></ul><p><strong>transition-timing-function:指定动画的变化曲线</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function">transition-timing-function - CSS：层叠样式表 | MDN</a></li></ul><p><strong>transition-delay:指定过渡动画执行之前的等待时间</strong></p><p><strong>transition的缺点:</strong></p><ul><li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态;</li><li>transition不能重复执行，除非一再触发动画;</li><li>transition需要在特定状态下会触发才能执行，比如某个属性被修改了。</li></ul><hr><h4 id="sGDf4">动画-animation</h4>**CSS Animation的使用分成两个步骤:**<ul><li>步骤一 :使用keyframes定义动画序列(每一帧动画如何执行)</li><li>步骤二 :配置动画执行的名称、持续时间、动画曲线、延迟、执行次数、方向等等</li></ul><p>可以使用@keyframes来定义多个变化状态，并且使用animation-name来声明匹配</p><ul><li>关键帧使用percentage来指定动画发生的时间点;</li><li>0%表示动画的第一时刻，100%表示动画的最终时刻;</li><li>因为这两个时间点十分重要，所以还有特殊的别名:from和to</li></ul><p><code>animation-iteration-count:2; //动画执行次数</code></p><p><code>animation-direction:normal;  //动画执行方向</code></p><p><code>animation-fill-mode: forwards; //动画停留位置</code></p><p><code>animation-play-state:paused;  //js动态修改</code></p><p><strong>CSS animation 属性是 animation-name, animation-duration, animation-timing-function, animation-delay,animation-iteration-count,animation-direction,animation-fill-mode属性的一个简写属性</strong></p><p> animation-name :指定执行哪一个关键帧动画</p><p> animation-duration :指定动画的持续时间</p><p> animation-timing-function :指定动画的变化曲线</p><p> animation-delay :指定延迟执行的时间</p><p> animation-iteration-count :指定动画执行的次数，执行infinite表示无限动画</p><p> animation-direction :指定方向，常用值normal和reverse</p><p> animation-fill-mode :执行动画最后保留哪一个值</p><ul><li>none:回到没有执行动画的位置</li><li>forwards:动画最后一帧的位置</li><li>backwards:动画第一帧的位置</li></ul></angle>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个不占据空间的滚动条</title>
    <link href="/2024/12/19/scrollBar/"/>
    <url>/2024/12/19/scrollBar/</url>
    
    <content type="html"><![CDATA[<p>GitHub地址:<a href="https://github.com/KingSora/OverlayScrollbars?tab=readme-ov-file">https://github.com/KingSora/OverlayScrollbars?tab=readme-ov-file</a></p><p>中文文档:<a href="https://www.koudingke.cn/docs/zh-Hans/overlay-scrollbars-docs/latest/Index">https://www.koudingke.cn/docs/zh-Hans/overlay-scrollbars-docs/latest/Index</a></p><p> 一个  <code>JavaScript</code>  滚动条插件，它能隐藏原生滚动条，提供可自定义样式的覆盖滚动条，并保留原生的功能和手感。创建这个插件是因为讨厌既难看又占用空间的原生滚动条。类似的插件在功能、质量、简洁性、许可协议或浏览器兼容性方面没有达到要求。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/overlayscrollbars/2.10.0/styles/overlayscrollbars.css&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/overlayscrollbars/2.10.0/browser/overlayscrollbars.browser.es6.js&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">html</span>,</span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.wrapper</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">72px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">72px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e8e8e8</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//OverlayScrollbars初始化</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-title class_">OverlayScrollbars</span>,</span><br><span class="language-javascript">        <span class="hljs-comment">// ScrollbarsHidingPlugin,</span></span><br><span class="language-javascript">        <span class="hljs-comment">// SizeObserverPlugin,</span></span><br><span class="language-javascript">        <span class="hljs-comment">// ClickScrollPlugin</span></span><br><span class="language-javascript">    &#125; = <span class="hljs-title class_">OverlayScrollbarsGlobal</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> osInstance = <span class="hljs-title class_">OverlayScrollbars</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;body&#x27;</span>), &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">scrollbars</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//scrollbars.autoHide属性有效值为：&#x27;never&#x27;, &#x27;scroll&#x27;, &#x27;leave&#x27;, 和 &#x27;move&#x27;。自动隐藏可见滚动条的可见性，在用户执行特定操作后。</span></span><br><span class="language-javascript">            <span class="hljs-attr">autoHide</span>: <span class="hljs-string">&#x27;leave&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-comment">//自动隐藏滚动条之前的时间延迟（以毫秒为单位）。</span></span><br><span class="language-javascript">            <span class="hljs-attr">autoHideDelay</span>: <span class="hljs-number">3000</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-comment">//插件配置,见文档</span></span><br><span class="language-javascript">    <span class="hljs-comment">// OverlayScrollbarsGlobal.OverlayScrollbars.plugin([</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     OverlayScrollbarsGlobal.SizeObserverPlugin,</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     OverlayScrollbarsGlobal.ClickScrollPlugin,</span></span><br><span class="language-javascript">    <span class="hljs-comment">//     OverlayScrollbarsGlobal.ScrollbarsHidingPlugin,</span></span><br><span class="language-javascript">    <span class="hljs-comment">// ])</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">genDiv</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> wrapperEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;wrapper&#x27;</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> divList = <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt;= <span class="hljs-number">50</span>; index++) &#123;</span><br><span class="language-javascript">            divList += <span class="hljs-string">&#x27;&lt;div class=&quot;item&quot;&gt;&#x27;</span> + index + <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        wrapperEle.<span class="hljs-property">innerHTML</span> = divList</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">genDiv</span>()</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>拓展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>拓展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="/2024/12/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <url>/2024/12/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2024/12/12/Git/"/>
    <url>/2024/12/12/Git/</url>
    
    <content type="html"><![CDATA[<p><strong>Git 是一个免费的开源分布式版本控制系统，旨在处理从小型到 快速高效的超大型项目。</strong></p><h4 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h4><p>git官网:<a href="https://git-scm.com/">Git</a></p><p>:::tips<br>&#x2F;&#x2F; 查看git版本</p><p>git -v</p><p>初次使用git需要配置用户名和邮箱</p><p>git config –global user.name “Jasper Yang’</p><p>git config –global user.email <a href="mailto:&#103;&#x65;&#x65;&#x6b;&#x68;&#97;&#x6c;&#x6c;&#x2e;&#99;&#x6e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;">&#103;&#x65;&#x65;&#x6b;&#x68;&#97;&#x6c;&#x6c;&#x2e;&#99;&#x6e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a></p><p><img src="1732771915677-78ecf971-8142-462c-b6b9-5a373d49bf58-1733989032467-1.png"></p><p>查看配置的信息</p><p>git config –global –list</p><p>:::</p><h4 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h4><h5 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h5><p>:::tips<br>方式一 : git init     &#x2F;&#x2F;本地初始化仓库</p><p>方式二 : git clone  &#x2F;&#x2F;远程克隆仓库</p><p>:::</p><h5 id="工作区域和文件状态"><a href="#工作区域和文件状态" class="headerlink" title="工作区域和文件状态"></a>工作区域和文件状态</h5><blockquote><p>工作区域</p><p><img src="1732772549334-abaf791a-542c-4983-a1d2-867486e8e86d.png"></p></blockquote><blockquote><p>文件状态</p><p>:::tips<br>未跟踪:新创建的,未被git管理的文件</p><p>未修改:已被git管理,文件内容未被修改的文件</p><p>已修改:已修改,未被添加到暂存区的文件</p><p>已暂存::已被添加到暂存区的文件</p><p>:::</p></blockquote><blockquote><p><img src="1732772735047-29d7e85d-498d-40fb-b91e-46b3c66075ed.png"></p><p><img src="1732783489100-cdccaa59-036a-4abf-b29d-f532460549be.png"></p></blockquote><h5 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h5><p>:::tips<br>git init       创建仓库</p><p>git status   查看仓库</p><p>git add       添加到暂存区</p><p>git commit 提交</p><p>git log        查看历史提交记录</p><p>git log –pretty&#x3D;oneline 单行显示提交记录</p><p>:::</p><h5 id="git-reset-回退版本"><a href="#git-reset-回退版本" class="headerlink" title="git reset 回退版本"></a>git reset 回退版本</h5><p>:::info<br>git reset</p><p><img src="1732773470015-e79cce61-fadd-4408-9f81-6ab750c4fb60.png"></p><p>:::</p><p>:::tips<br>ls 查看工作区所有文件</p><p>ls -a 查看工作区所有文件(包括隐藏文件)</p><p>git ls-liles 查看暂存区所有文件</p><p>:::</p><p>:::tips<br>  HEAD 指向分支的最新提交节点  HEAD^上一个版本 HEAD^^上两个版本 or HEAD~2</p><p>谨慎使用 –hard 会删除两个版本之间的工作区和暂存区</p><p>若误操作删除,可以使用git reflog 查看操作的历史记录,然后使用git reset 回退到误操作前的版本</p><p>:::</p><h5 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h5><blockquote><p>git diff</p><p><img src="1732774168228-3499e932-da8b-495f-9298-8c4ff7992573.png"></p></blockquote><p>:::tips<br>&#x2F;&#x2F;  HEAD 指向分支的最新提交节点</p><p>git diff    默认查看工作区和暂存区的差异</p><p>git diff HEAD  查看工作区和版本库的差异</p><p>git diff –cached 查看暂存区和版本库的差异</p><p>git diff <ID> <ID> 查看两次版本库的差异</ID></ID></p><p>git diff <ID> <ID> <flie> 查看两次版本库中某个文件的差异</flie></ID></ID></p><p>:::</p><h5 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h5><blockquote><p>git rm</p><p><img src="1732775143522-e8eb1bcf-e989-49cb-9d6f-3705c6524b45.png"></p></blockquote><h5 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h5><blockquote><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。我们可以创建一个和.gitignore文件进行配置</p><p><img src="1732775241241-3856ded3-d183-455f-bdbc-3862bfc32acd.png"></p></blockquote><p>Git官网匹配规则:<a href="https://git-scm.com/docs/gitignore">Git - gitignore Documentation</a></p><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><details class="lake-collapse"><summary id="u77f25584"><span class="ne-text">不存在本地仓库</span></summary><p id="u809ffe96" class="ne-p"><span class="ne-text">echo&quot;# remote-repo&quot;&gt;&gt; README.md</span></p><p id="u20eb9812" class="ne-p"><span class="ne-text">git init</span></p><p id="uc6343321" class="ne-p"><span class="ne-text">git add README.md</span></p><p id="uaba48681" class="ne-p"><span class="ne-text">git commit -m&quot;first commit&quot;</span></p><p id="ueb47bd2e" class="ne-p"><span class="ne-text">git branch - main</span></p><p id="u98a0e619" class="ne-p"><span class="ne-text">git remote add origin git@github.com:geekhall-laoyang/remote-repo.git</span></p><p id="u4a691752" class="ne-p"><span class="ne-text">git push -u origin main</span></p></details><details class="lake-collapse"><summary id="ub1ce2e9e"><span class="ne-text">存在本地仓库</span></summary><p id="u50cfc4d2" class="ne-p"><span class="ne-text">git remote add origin git@github.com:geekhall-laoyang/remote-repo.git</span></p><p id="u52d33af1" class="ne-p"><span class="ne-text">git branch - main</span></p><p id="uf0b08533" class="ne-p"><span class="ne-text">git push -u origin main</span></p></details><blockquote><p>配置SSH密钥</p><p>如果第一次使用ssh方式,需要配置SSH密钥,详见<a href="https://blog.csdn.net/lqlqlq007/article/details/78983879">git ssh key配置_git配置ssh key-CSDN博客</a></p><p><img src="1732782348793-e29eae91-71c5-4d70-8eae-5435aa735915.png"></p></blockquote><p>:::tips</p><p>git remote -v      查看本地仓库关联远程仓库</p><p>git push -u origin main:main 将本地分支和远程分支关联并推送(如果本地和远程分支相同,则可省略:main)</p><p>git pull&lt;远程仓库名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;  如果省略的话默认就是拉取仓库别名为origin的主分支</p><p>git branch –set-upstream-to&#x3D;origin&#x2F;master   为当前分支设置远程仓库分支为上游分支</p><p>git pull 本质上等于 git fetch 和git merge结合</p><p>:::</p><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>:::tips<br>git branch    查看分支</p><p>git branch <name>     创建新的分支</name></p><p>git checkout <name>   切换分支(git checkout 也有恢复文件的功能,如果分支名和文件名重复,可能冲突)</name></p><p>git checkout  -b <name> 创建分支并切换</name></p><p>git switch <name>  切换分支</name></p><p>git switch -c <name>  创建分支并切换</name></p><p>git merge dev   合并分支   (首先切换到要接受合并的分支,例如:main)</p><p>git branch -d dev 删除已被合并的分支  ( 未被合并不能被-d删除,需要-D强制删除分支  )</p><p>git merge –abort  终止合并</p><p>:::</p><h5 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h5><p>如果两个分支修改了同一处代码,合并时会产生合并冲突,需要解决冲突</p><p>:::tips<br>当发生冲突可以使用git status 查看冲突文件列表,也可使用git diff 查看具体冲突内容</p><p>需要手动修改冲突文件,在重新提交</p><p>:::</p><h5 id="git-rebase变基"><a href="#git-rebase变基" class="headerlink" title="git  rebase变基"></a>git  rebase变基</h5><p><img src="1732784949965-9d77b1e1-d0e4-4a19-9a44-38aef9ea7520-1733989032468-11.png"></p><p>rebase后需要git merge dev,否则main主分支在main5,没有在线性结构最后一次提交</p><p>注意: 不要在主分支使用rebase(第二次),会造成大量提交历史在main分支不同</p><p><img src="1732785147042-fd8304df-3a89-4293-bdfd-af7d272816a4-1733989032468-13.png"><img src="1732785156279-aa64bcd2-9e0e-4a5c-8ce2-be406e3f104a-1733989032468-15.png"></p><h5 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h5><p>:::tips<br><code>git cherry-pick</code> 命令的作用，就是将指定的提交（ <a href="https://so.csdn.net/so/search?q=commit">commit</a> ）应用于其他分支。 </p><p> git cherry-pick <commitHash> </commitHash></p><p>:::</p><p><img src="1732785882221-49592d40-dda3-4867-97dd-7a8564cacd06-1733989032468-17.png"></p><p>:::tips<br> $ git cherry-pick <HashA> <HashB>   合并两次的提交</HashB></HashA></p><p>&#x2F;&#x2F; 不包含A，包含B</p><p>$ git cherry-pick A..B </p><p>&#x2F;&#x2F; 如果想搞成[]区间，使用 git cherry-pick A^..B 相当于[A B]包含A</p><p>$ git cherry-pick A^..B </p><p>:::</p><p><img src="1732786053734-4ea518c3-27d9-4a60-b874-e3c8c5834298-1733989032468-19.png"></p><h4 id="lQvvX">补充</h4><h5 id="nXMmY">tag</h5><p>对于重大的版本我们常常会打上一个标签，以表示它的重要性:</p><p>Git 可以给仓库历史中的某一个提交打上标签;比较有代表性的是人们会使用这个功能来标记发布结点(v1.0、v2.0 等等) <code>git tag v1.1.0</code></p><p>创建标签:</p><ul><li>Git 支持两种标签:轻量标签(lightweight)与附注标签(annotated);</li><li>附注标签:通过-a选项，并且通过-m添加额外信息; <code>git tag -a v1.2.0 -m&quot;一个重要版本&quot;</code></li></ul><p><code>git show v1.1.1</code>查看tag的详情</p><hr><p>在创建完标签后你必须显式地推送标签到共享服务器上，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签</p><ul><li>git push origin v1.0 推送某一tag到远程</li><li>git push origin–tags  推送本地所有tag到远程</li><li>git tag -d v1.1.1 删除本地tag</li><li>git push origin -d v1.1.1 删除远程某一tag</li></ul><hr><p>如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令回到对应tag 版本,但是不推荐在之前的tag版本进行直接修改,一般新建一个对应的分支,进行修改</p><ul><li>git checkout v1.0</li><li>git switch to ‘v1.0’</li></ul><h5 id="Fw3Wa">git提交对象</h5><p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p><p>在进行提交操作时，Git会保存一个提交对象(commitobject):</p><ul><li>该提交对象会包含一个指向暂存内容快照的指针;</li><li>该提交对象还包含了作者的姓名和邮箱、 提交时输入的信息以及指向它的父对象的指针;<ul><li>首次提交产生的提交对象没有父对象普通提交操作产生的提交对象有一个父对象</li><li>而由多个分支合并产生的提交对象有多个父对象;</li></ul></li></ul><h5 id="pJ6ks">git分支相关</h5><p>GIt 是怎么创建新分支的呢?很简单，它只是为你创建了一个可以移动的新的指针:比如，创建一个 testing 分支，你需要使用 git branch 命令 , 那么，Git 又是怎么知道当前在哪一个分支上呢?也很简单，它也是通过一个名为 <strong>HEAD</strong> 的特殊指针:</p><p><img src="1741250443786-04caa98d-93b1-4775-9ed6-6aa6e8205c58.png"></p><h5 id="wcla9">git工作流( git flow )</h5><p><img src="1741253206760-bb598adc-5e77-4d83-9f1d-c17d7179cc36.png"></p><ul><li>master作为主分支;</li><li>develop作为开发分支，并且有稳定版本时，合并到master分支中;</li><li>topic作为某一个主题或者功能或者特性的分支进行开发，开发完成后合并到develop分支中;</li></ul><p><img src="1741253277955-338046d6-5c07-4bc2-9e18-0725be35264b.png"></p><ul><li>master作为主分支;</li><li>hotfix作为bug修复分支,修复完成合并至master和develop分支中 ,在删除hotfix分支</li><li>develop作为开发分支，并且有稳定版本时，合并到master分支中;</li><li>feature作为某一个主题或者功能或者特性的分支进行开发，开发完成后合并到develop分支中;</li><li>release作为发布分支,由测试完成后,进行发布最后合并至develop和master分支</li></ul><h5 id="TUYeK">git命令汇总</h5><p><img src="1741259352705-22c1fbb6-fb6c-4d4d-adda-58e4fde5dc7f.png"></p><h5 id="fLKEP">问题</h5><p><strong>问题一:当前分支没有track的分支</strong></p><p><img src="1741094705136-97b70276-2890-456f-a1d4-45e65e0978eb.png"></p><p>原因:当前分支没有和远程的分支进行跟踪</p><ul><li>在没有跟踪的情况下，我们直接执行pull操作的时候必须指定从哪一个远程仓库中的哪一个分支中获取内容 <strong>git pull origin master</strong></li><li>如果我们想要直接执行git fetch是有一个前提的:必须给当前分支设置一个跟踪分支:<ul><li>git branch –set-upstream-to&#x3D;origin&#x2F;master </li><li>git pull</li></ul></li></ul><hr><p><strong>问题二:合并远程分支时,拒绝合并不相干历史</strong></p><p><img src="1741094290297-fef495ab-3bb3-483f-9160-947f1e2dc96b.png"></p><p><img src="1741094335371-d731b824-6b72-45e4-a5d5-7994c9871c7b.png"></p><p><img src="1741094395875-94afefb9-5425-4d7c-b893-107cc0efc027.png"></p><p>简单来说就是:过去git merge允许将两个没有共同基础的分支进行合并，这导致了一个后果:新创建的项目可能被一个毫不怀疑的维护者合并了很多没有必要的历史，到一个已经存在的项目中，目前这个命令已经被纠正，但是我们依然可以通过<strong>allow-unrelated-histories</strong>选项来逃逸这个限制，来合并两个独立的项目</p><hr><p><strong>问题三:git push默认行为为simple而不是upstream</strong></p><p><img src="1741158597211-8a9a9059-216f-4607-8f1e-9299a5443b33.png"></p><p>git push默认行为为simple而不是upstream,默认找不到对应的same name on the remote,可以更改git push 的默认行为使用 **git config push.default upstream **更改git push的默认行为</p><p><img src="1741158918754-899f58c1-ca93-489c-bcd8-57783ab530e1.png"></p><p>push.default为simple时会寻找same的远程分支,如果无则报错,如果push.default为current时,会寻找same的远程分支,如果无则创建对应的远程分支</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FlexBox</title>
    <link href="/2024/12/10/FlexBox/"/>
    <url>/2024/12/10/FlexBox/</url>
    
    <content type="html"><![CDATA[<p><strong>Flexbox 翻译为弹性盒子</strong></p><p> 弹性盒子 是一种用于按行或按列布同元素的一维布局方法</p><ul><li>元素可以膨胀以填充额外的空间，收缩以适应更小的空间,</li><li>通常我们使用 Flexbox 来进行布局的方案称之为 flex 布局(flexlayout);</li></ul><p>两个重要的概念:</p><ul><li>开启了 flex 布局的元素叫 flex container</li><li>flex container 里面的直接子元素叫做 flex item</li></ul><p>当 felx container 中的子元素变成了 flex item 时,具备以下特点:</p><ul><li>flex item 的布局将受 flex container 属性的设置来进行控制和布局</li><li>flex item 不再严格区分块级元素和行内级元素</li><li>flex item 默认情况下是包裹内容的,但是可以设置宽度和高度</li></ul><h5 id="display-flex-inline-flex"><a href="#display-flex-inline-flex" class="headerlink" title="display:flex&#x2F;inline-flex"></a>display:flex&#x2F;inline-flex</h5><p>设置 display 属性为 flex 或者 inline-flex 可以成为 flex container</p><ul><li>flex:flex container 以 block-level 形式存在</li><li>inline-flex: flex container 以 inline-level 形式存在</li></ul><h5 id="flex-container-上的-css-属性"><a href="#flex-container-上的-css-属性" class="headerlink" title="flex container 上的 css 属性"></a>flex container 上的 css 属性</h5><h6 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h6><p>flex items 默认都是沿着 main axis( 主轴 )从 main start 开始往 main end 方向排布</p><p> flex-direction  决定了 main axis 的方向，有 4 个取值</p><p> row (默认值)、row-reverse、 column 、column-reverse</p><h6 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h6><p>flex-wrap 决定了 flex container 是单行还是多行</p><ul><li>nowrap(默认):单行</li><li>wrap:多行</li><li>wrap-reverse:多行(对比 wrap，cross start 与 cross end 相反)</li></ul><h6 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h6><p>flex-flow 属性是 flex-direction 和 flex-wrap 的简写。</p><ul><li>顺序任何,并且都可以省略;</li></ul><h6 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h6><p><strong>justify-content 决定了 flex items 在 main axis 上的**</strong> 对齐方式 **</p><p> flex-start (默认值):与 main start 对齐</p><p> flex-end :与 main end 对齐</p><p> center :居中对齐</p><p> space-between </p><ul><li>flex items 之间的距离相等</li><li>与 main start、main end 两端对齐</li></ul><p> space-around </p><ul><li>flex items 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离是 flex items 之间距离的一半</li></ul><p> space-evenly </p><ul><li>flexitems 之间的距离相等</li><li>flex items 与 main start、main end 之间的距离 等于 fex items 之间的距离</li></ul><h6 id="align-item"><a href="#align-item" class="headerlink" title="align-item"></a>align-item</h6><p><strong>align-items 决定了**</strong> flex items *<strong>*在**</strong>  cross axis(交叉轴) *<strong>* 上的对齐方式</strong></p><p> normal :在弹性布局中，效果和 stretch 一样</p><p> stretch :当 flexitems 在 cross axis 方向的 size 为 auto 时，会自动拉伸至填充 flex container</p><p> flex-start :与 cross start 对齐</p><p> flex-end: 与 cross end 对齐</p><p> center :居中对齐</p><p> baseline :与基准线对齐</p><h6 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h6><p><strong>align-content 决定了**</strong> 多行 fexitems *<strong>*在 **</strong> cross axis *<strong>* 上的对齐方式，用法与 justify-content 相似</strong></p><p>stretch(默认值):与 align-items 的 stretch 类似</p><p> flex-start :与 cross start 对齐</p><p> flex-end :与 cross end 对齐</p><p> center :居中对齐</p><p> space-between :</p><ul><li>flexitems 之间的距离相等</li><li>与 cross start、cross end 两端对齐</li></ul><p> space-around </p><ul><li>√flex items 之间的距离相等</li><li>√flexitems 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li></ul><p> space-evenly: </p><ul><li>flex items 之间的距离相等</li><li>flexitems 与 cross start、cross end 之间的距离 等于 flex items 之间的距离</li></ul><h6 id><a href="#" class="headerlink" title></a></h6><h5 id="flex-item-上的-css-属性"><a href="#flex-item-上的-css-属性" class="headerlink" title="flex item 上的 css 属性"></a>flex item 上的 css 属性</h5><h6 id="order"><a href="#order" class="headerlink" title="order"></a>order</h6><p>order 决定了 flex items 的排布顺序</p><ul><li>可以设置任意整数(正整数、负整数、0)，值越小就越排在前面</li><li>默认值是 0</li></ul><h6 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h6><p>flex items 可以通过 align-self 覆盖 flex container 设置的 align-items</p><ul><li>auto(默认值):遵从 flex container 的 align-items 设置</li><li>stretch、flex-start、flex-end、center、baseline,效果跟 align-items -致</li></ul><h6 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h6><p><strong>fex-grow 决定了 flex items 如何扩展(拉伸&#x2F;成长)</strong></p><ul><li>可以设置任意非负数字(正小数、正整数、0)，默认值是 0</li><li>当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 属性才会有效</li><li>如果所有 flex items 的 flex-grow 总和 sum 超过 1，每个 flex item 扩展的 size 为 flex container 的剩余 size*(flex-grow&#x2F;sum)</li><li>flex items 扩展后的最终 size 不能超过 max-width\max-height</li></ul><h6 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h6><p><strong>flex-shrink 决定了 fexitems 如何收缩(缩小)</strong></p><ul><li>可以设置任意非负数字(正小数、正整数、0)，默认值是 1</li><li>当 flex items 在 main axis 方向上超过了 fex container 的 size，flex-shrink 属性才会有效</li><li>如果所有 flex items 的 fex-shrink 总和超过 1，每个 fexitem 收缩的 size 为 flex items 超出 flex container 的 size*收缩比例&#x2F;所有 flex items 的收缩比例之和</li></ul><h6 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h6><p><strong>flex-basis 用来设置 fexitems 在 main axis 方向上的 base size</strong></p><ul><li>auto(默认值)、具体的宽度数值(100px)</li></ul><p><strong>决定 flexitems 最终 base size 的因素，从优先级高到低</strong></p><ul><li>max-width\max-height\min-width\min-height</li><li>flex-basis</li><li>width\height</li><li>内容本身的 size</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">700px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">120px</span>;</span><br><span class="language-css">        <span class="hljs-comment">/* width: 120px; */</span></span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>cccccccccccccccccccccccc<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h6><p><strong>flex 是 flex-grow| flex-shrink| flex-basis 的简写,flex 属性可以指定 1 个，2 个或 3 个值</strong></p><p><strong>单值语法:值必须为以下其中之一:</strong></p><ul><li>一个无单位数(<number>): 它会被当作<flex-grow>的值。</flex-grow></number></li><li>一个有效的宽度(width)值: 它会被当作 <flex-basis>的值。</flex-basis></li><li>关键字 none，auto 或 initial.</li></ul><p><strong>双值语法: 第一个值必须为一个无单位数，并且它会被当作<flex-grow>的值，</flex-grow></strong></p><p><strong>第二个值必须为以下之一:</strong></p><ul><li>一个无单位数:它会被当作<flex-shrink>的值，</flex-shrink></li><li>一个有效的宽度值: 它会被当作<flex-basis>的值,</flex-basis></li></ul><p><strong>三值语法:</strong></p><ul><li>第一个值必须为一个无单位数，并且它会被当作<flex-grow>的值,</flex-grow></li><li>第二个值必须为一个无单位数，并且它会被当作<flex-shrink>的值,</flex-shrink></li><li>第三个值必须为一个有效的宽度值，并且它会被当作<flex-basis>的值.</flex-basis></li></ul><p>:::info<br>initial</p><p>元素会根据自身宽高设置尺寸。它会缩短自身以适应 fiex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器。相当于将属性设置为”flex:0 1 auto”</p><p>auto</p><p>元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 fex 容器。这相当于将属性设置为”flex:1 1 auto”</p><p>none</p><p>元素会根据自身宽高来设置尺寸。它是完全非弹性的:既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为”flex:0 0 auto”。</p><p>:::</p><h5 id="flex-布局下的-justify-content-下最后一行元素排布"><a href="#flex-布局下的-justify-content-下最后一行元素排布" class="headerlink" title="flex 布局下的 justify-content 下最后一行元素排布"></a>flex 布局下的 justify-content 下最后一行元素排布</h5><p><strong>当使用 justify-content:space-between 时,最后一行元素可能不够填充一行,导致排布混乱,有两种解决方案</strong></p><ul><li>不使用**justify-content,**计算使用 margin</li><li>使用(列数-2)个宽度与排布元素宽度相同,无高度的元素放到末尾进行填充</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: space-between;</span><br><span class="language-css">        <span class="hljs-attribute">flex-wrap</span>: wrap;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aquamarine;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &gt; <span class="hljs-selector-tag">i</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>布局</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2024/12/08/webpack/"/>
    <url>/2024/12/08/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="ztgII">前言</h1><p> 从Webpack开始的前端工程化探索 </p><h1 id="dCQEd">模块化</h1><p> 随着前端应用的日益复杂，程序员需要更高效的代码组织形式，以便提高可维护性并提升开发效率。 </p><p> 模块化将复杂的代码按功能的不同，分为不同的模块，单独维护，提高开发效率。 </p><p>** 模块： **</p><ol><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。 </li><li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</li></ol><h2 id="ZNsRX">演变</h2><p>** 1、文件划分 **<br>  将不同的功能及其状态数据存放在单独的JS文件中。约定一个文件就是一个模块，以单独的script标签引入至HTML。 </p><p> 虽然实现了功能的划分，但缺点也十分明显： </p><ol><li>污染全局作用域 </li><li>命名冲突 </li><li>无法管理模块的依赖关系</li></ol><p>** 2、命名空间 **<br>  在文件划分的基础上，约定每个模块只暴露一个全局的对象，对象包裹着模块的方法和状态。 </p><p> 虽然避免了命名冲突，但仍然没有私有空间， </p><p>** 3、IIFE **<br>  通过立即执行函数实现私有空间，使用window暴露模块的成员，通过参数声明依赖。 </p><p><strong>js</strong></p><p> 在没有工具和相关规范的早期，以约定的形式，实践模块化思想的方式。 </p><p> 仍然存在问题： </p><ol><li>依赖管理混乱 </li><li>不同开发者、不同项目，模块化的实现有差异 </li><li>模块的导入不受代码控制</li></ol><h3 id="FjzOd">现代化</h3><ol><li>** 模块化规范： ** 对模块代码书写格式和交互规则的详细描述 </li><li>** 模块加载器： ** 使用代码的方式，自动控制模块的导入，管理模块的依赖。</li></ol><p> 在ES6模块化出现之前，为了解决模块化的需求，出现了众多的模块化机制，CommonJS(NodeJS内置)、AMD(require.js)、CMD(Sea.js) </p><p> ES6模块化出现后的 ** 最佳实践 ** ： </p><ol><li>浏览器环境：ES Module </li><li>Node环境：CommonJS</li></ol><h2 id="gt4Tx">ES Module</h2><p> ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJS 和 AMD 模块，都是运行时的 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;script type=&#x27;module&#x27;&gt;<br>  import &#123; name &#125; from &#x27;./modules/index.js&#x27;;<br>  export name;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p> 特性： </p><ol><li>自动采用严格模式，忽略’use strict’ </li><li>每个ESM模块都是单独的私有作用域 </li><li>ESM通过CORS请求外部JS模块 </li><li>ESM的script标签会延迟执行脚本(相当于defer)</li></ol><p> 详见 <a href="https://www.qcqx.cn/article/383b041f.html#Module%E6%A8%A1%E5%9D%97%E5%8C%96"> ES6查缺补漏 #Module模块化 </a> 、 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules"> MDN-JavaScript模块 </a></p><h3 id="aTsbD">兼容性问题</h3><p> ES6仍然有兼容性问题，早期的浏览器，特别是国产和手机上的浏览器 </p><p><strong>shell</strong></p><p>使用 caniuse-cmd 检查兼容性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g caniuse-cmd<br>caniuse import<br></code></pre></td></tr></table></figure><p> 可以引入    <a href="https://polyfill.io/"> Polyfill </a>    兼容 </p><p> 使用 webpack、vite 后，有更多的兼容插件可以安装使用，如    <code>@vitejs/plugin-legacy</code></p><p> script添加nomodule属性，仅在不支持ESM的浏览器上执行该脚本 </p><h3 id="tWXEu">ESM in Node</h3><p> ESM在Node.js的v8.5.0中作为实验性功能被引入，v12.17.0为所有Node.js应用程序提供了ESM支持 </p><p> 使用    <code>.mjs</code> 、 <code>.cjs</code>    文件后缀区分 ESM 和 CommonJS 模块 </p><p> 原生Node环境中的ESM与CommonJS： </p><ol><li>ES Module中可以导入CommonJS模块 </li><li>CommonJS中不能导入ES Module模块 </li><li>CommonJS始终只会导出一个默认成员</li></ol><p> ESM得到CommonJS全局成员的值： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">// console.log(__dirname)<br>// ReferenceError: __dirname is not defined in ES module scope<br>import &#123; fileURLToPath &#125; from &#x27;url&#x27;<br>import &#123; dirname &#125; from &#x27;path&#x27;<br>const __filename = fileURLToPath(import.meta.url)<br>const __dirname = dirname(__filename)<br>console.log(__filename)<br>console.log(__dirname)<br>// c:\***\esm-in-node\index.mjs<br>// c:\***\esm-in-node<br></code></pre></td></tr></table></figure><h2 id="y8o51">前端打包工具</h2><p> ESM仍然存在一些问题： </p><ol><li>存在兼容性问题 </li><li>模块文件过多，网络请求频繁 </li><li>不仅是JS，前端所有的资源，包括CSS、HTML都需要模块化</li></ol><p> 前端需要更好的工具和规范，让开发者继续享受模块化带来的便利，而不需要担心对 ** 生产环境 ** 产生的影响。 </p><p>** 需求推动技术的进步 ** ，打包工具顺势出现了。打包工具解决的是前端整体的模块化，不只是局限于JS的模块化。 </p><p> 如今前端项目的代码组织，已经走上了 ** 编辑代码 ** 和 ** 最终运行文件 ** 完全两样的形式，一系列 ** 工具链 ** 和自动化的思想也融入进了打包工具中，打包也逐渐从一个技术问题，转变为了生态和管理问题。打包工具现在也可称为 ** 构建工具 ** ，支撑着前端工程化。 </p><p> 常见的打包工具： <a href="https://webpack.docschina.org/"> Webpack </a> 、 <a href="https://vitejs.dev/"> Vite </a> 、 <a href="https://rollupjs.org/"> Rollup </a> 、 <a href="https://esbuild.github.io/"> esbuild </a></p><h1 id="uHXZM">Webpack</h1><p><a href="https://webpack.docschina.org/"> Webpack </a> 是一个用于现代 JavaScript 应用程序的静态模块打包工具。 </p><p> 学习webpack大体上就是学习webpack.config.js的配置、各种loaders和plugins的使用，所以，多看文档，广泛了解，取所需使用 <a href="https://webpack.docschina.org/concepts/"> 文档 </a> 、 <a href="https://webpack.docschina.org/configuration/"> 配置 </a> 、 <a href="https://webpack.docschina.org/guides/"> 指南 </a> 、 <a href="https://webpack.docschina.org/loaders/"> loaders </a> 、 <a href="https://webpack.docschina.org/plugins/"> plugins </a></p><h2 id="yrYsD">快速上手</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm init -y<br>npm install webpack webpack-cli --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;private&quot;: true, // 防止意外发布<br>  &quot;scripts&quot;: &#123;<br>    &quot;build&quot;: &quot;webpack&quot; // 打包命令<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建index.html和src目录，并写两个模块化文件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;Document&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;script type=&quot;module&quot; src=&quot;src/index.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; createTitle &#125; from &quot;./module.js&quot;;<br>document.body.append(createTitle(&#x27;Hello World&#x27;));<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">export const createTitle = (title) =&gt; &#123;<br>  const element = document.createElement(&#x27;h2&#x27;)<br>  element.textContent = title<br>  element.addEventListener(&#x27;click&#x27;, () =&gt; &#123;<br>    alert(title)<br>  &#125;)<br>  return element<br>&#125;<br></code></pre></td></tr></table></figure><p> 直接打开 index.html 可以看到页面上的 Hello World </p><p> 接着使用webpack进行打包 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">npx webpack<br># 或<br>npm run build<br></code></pre></td></tr></table></figure><p> webpack自动创建了 dist 目录，存放了打包好的 main.js </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!-- &lt;script type=&quot;module&quot; src=&quot;src/index.js&quot;&gt;&lt;/script&gt; --&gt;<br>&lt;!-- 打包好的main.js已经是ES5语法，可以去掉type=&quot;module&quot; --&gt;<br>&lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p> 打开 index.html 仍然可以看到 Hello World </p><p> Webpack4以后，支持这样0配置的方式，快速打包项目，src是默认打包入口，dist是输出，index.js -&gt; main.js </p><h1 id="E4MOi">配置</h1><p> 根目录的    <code>webpack.config.js</code>    是webpack默认的配置文件 </p><p> 可以手动创建配置文件，或在 VSCode 中下载 <a href="https://marketplace.visualstudio.com/items?itemName=jeremyrajan.webpack"> webpack插件 </a> ，通过    <code>Webpack Create</code>    命令，初始化 webpack </p><p><strong>默认创建的wbpack.config.js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs plain">const path = require(&#x27;path&#x27;);<br>module.exports = &#123;<br>  // 设置模式为开发模式<br>  mode: &#x27;development&#x27;,<br>  // 应用程序的入口点<br>  entry: path.join(__dirname, &#x27;src&#x27;, &#x27;index&#x27;),<br>  // 启用监视模式，以在文件更改时进行自动重新编译<br>  watch: true,<br>  // 输出配置<br>  output: &#123;<br>    // 存储输出文件的目录<br>    path: path.join(__dirname, &#x27;dist&#x27;),<br>    // 打包文件的公共路径（由浏览器用于加载资源）<br>    publicPath: &#x27;/dist/&#x27;,<br>    // 主要包的输出文件名<br>    filename: &quot;bundle.js&quot;,<br>    // 动态加载的代码的输出文件名（代码分割）<br>    chunkFilename: &#x27;[name].js&#x27;<br>  &#125;,<br>  // 用于处理不同文件类型的模块配置<br>  module: &#123;<br>    // 使用Babel处理JavaScript和JSX文件的规则<br>    rules: [&#123;<br>      // 用于匹配以.jsx或.js结尾的文件<br>      test: /.jsx?$/,<br>      // 只处理src目录下的文件<br>      include: [<br>        path.resolve(__dirname, &#x27;src&#x27;)<br>      ],<br>      // 排除node_modules目录下的文件<br>      exclude: [<br>        path.resolve(__dirname, &#x27;node_modules&#x27;)<br>      ],<br>      // 使用babel-loader进行转译<br>      loader: &#x27;babel-loader&#x27;,<br>      options: &#123;<br>        // 使用指定的Babel预设<br>        presets: [<br>          [&quot;@babel/env&quot;, &#123;<br>            // 指定目标浏览器版本为最近的两个Chrome版本<br>            &quot;targets&quot;: &#123;<br>              &quot;browsers&quot;: &quot;last 2 chrome versions&quot;<br>            &#125;<br>          &#125;]<br>        ]<br>      &#125;<br>    &#125;]<br>  &#125;,<br>  // 配置模块解析的文件扩展名<br>  resolve: &#123;<br>    extensions: [&#x27;.json&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;]<br>  &#125;,<br>  // 生成源映射以方便调试<br>  devtool: &#x27;source-map&#x27;,<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 提供内容的基本目录<br>    contentBase: path.join(__dirname, &#x27;/dist/&#x27;),<br>    // 启用内联模式，自动注入脚本以处理实时更新<br>    inline: true,<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p> JS配置文件运行在node环境中，所以需要使用CommonJS写法 </p><p> 插件还会自动安装这些插件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;devDependencies&quot;: &#123;<br>  &quot;webpack&quot;: &quot;^5.74.0&quot;,<br>  &quot;webpack-cli&quot;: &quot;^4.10.0&quot;,<br>  &quot;@babel/core&quot;: &quot;^7.18.13&quot;,<br>  &quot;@babel/preset-env&quot;: &quot;^7.18.10&quot;,<br>  &quot;babel-loader&quot;: &quot;^8.2.5&quot;,<br>  &quot;webpack-dev-server&quot;: &quot;^4.10.0&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="GATLr">基本概念</h2><ol><li><code>entry</code> : webpack打包的入口起点，从这里开始根据各个文件之间的依赖来对文件进行打包。单页面应用只有一个入口起点，多页面应用则存在多个入口起点 </li><li><code>output</code> : 打包文件输出定义的地方，定义打包后输出文件的名字以及输出路径等 </li><li><code>mode</code> : 模式，webpack打包的模式，分为三种 development、production、none </li><li><code>loader</code> : 对javascript等文件进行预处理的，可以通过loader来构建包含javascript在内的任何静态资源 </li><li><code>plugin</code> : 插件是用来解决loader解决不了的问题，它可以在webpack构建过程中任何一个节点来调用</li></ol><p><a href="https://createapp.dev/webpack/"> createapp.dev </a>    是一个创建自定义 webpack 配置的在线工具 </p><p> 使用不同的配置文件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;scripts&quot;: &#123;<br>  &quot;build&quot;: &quot;webpack --config prod.config.js&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="oPcrk">入口和上下文</h1><p> 入口对象是用于 webpack 查找开始构建 bundle 的地方。上下文是入口文件所处的目录的绝对路径的字符串。 <a href="https://webpack.docschina.org/configuration/entry-context/"> 文档 </a></p><h2 id="Gw0xq">基础目录context</h2><p><code>context</code>  基础目录， ** 绝对路径 ** ，解析入口点(entry point)和加载器(loader) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">context: path.resolve(__dirname, &#x27;src&#x27;),<br></code></pre></td></tr></table></figure><p> 配置了context后，entry路径相对于context </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#x27;./src/index.js&#x27;,<br>// 配置context后<br>context: path.resolve(__dirname, &#x27;src&#x27;),<br>entry: &#x27;./index.js&#x27;,<br></code></pre></td></tr></table></figure><h2 id="G263V">入口entry</h2><p> entry指示webpack使用一个或多个模块，来作为构建应用的入口，webpack会找出哪些模块和是入口起点的直接或者间接的依赖，并将其打包到一起。默认值    <code>./src/index.js</code></p><p>** value类型： ** string、array、object </p><p> 入口分为 ** 单入口 ** (单页应用SPA)和 ** 多入口 ** (多页面应用) </p><p>** 1、单入口 **<br>  单入口主要使用string、array为值，应用于单页应用SPA </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#x27;./index.js&#x27;,<br>// 将这两个文件以及其中所依赖的代码打包到同一个文件中<br>entry: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br></code></pre></td></tr></table></figure><p> 这种写法默认的chunkname是main，是object的简略写法 </p><p>object完整写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#123;<br>  main: &#x27;./index.js&#x27;,<br>&#125;,<br>entry: &#123;<br>  main: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>&#125;,<br></code></pre></td></tr></table></figure><p>** 2、多入口 **<br>  多入口即有多个html，分别需要不同的打包好的js </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  entry: &#123;<br>    main: &#x27;./src/main.js&#x27;,<br>    bundle: &#x27;./src/index.js&#x27;<br>  &#125;,<br>  // 这里的[name]相当于是个占位符，值就是上面入口的key值，单入口时可以写死，不过不建议<br>  output: &#123;<br>    // 多入口需要对应多出口，通常用[name]占位，不然打包会报错<br>    filename: &#x27;[name].js&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 可以看到dist目录下打包好了 main.js 和 index.js 两个文件 </p><p>** 3、更多配置 **<br>  打包入口不仅仅是写一个入口文件地址就可以，它还有额外的配置： </p><ol><li><code>dependOn</code> : 指当前入口文件所依赖的模块，这些模块必须在入口文件被加载前加载 </li><li><code>filename</code> : 指定要输出的文件名称(优先级高于output中的filename和path) </li><li><code>import</code> : 启动时要加载的模块(入口文件地址)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  entry: &#123;<br>    index: &#x27;./index.js&#x27;,<br>    main: &#x27;./main.js&#x27;,<br>    catalog: &#123;<br>      import: &#x27;./catalog.js&#x27;,<br>      filename: &#x27;pages/log.js&#x27;,<br>      dependOn: &#x27;main&#x27;,<br>    &#125;,<br>  &#125;,<br>  output: &#123;<br>    filename: &#x27;[name].js&#x27;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LjQ58">出口output</h2><p> output配置的作用是告知webpack如何向硬盘写入打包好的文件。 </p><p>** 注意： ** entry可以存在多个入口，但output只有一个出口配置 </p><p>** 配置项： **</p><ol><li>filename 打包文件名，默认main.js </li><li>path 打包文件输出路径，默认dist </li><li>clean 输出包前清空输出目录，默认false</li></ol><p>** 1、filename **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">// [name]对应entry的key<br>output: &#123;<br>  filename: &#x27;[name].js&#x27;,<br>&#125;<br>// 使用内部chunk id占位<br>output: &#123;<br>  filename: &#x27;[id].bundle.js&#x27;,<br>  // main-0.js<br>&#125;,<br>// 使用由生成的内容产生的 hash，通常和[name]组合使用<br>output: &#123;<br>  filename: &#x27;[name]-[contenthash].js&#x27;,<br>  // main-8bc05850732530fe321c.js<br>&#125;,<br></code></pre></td></tr></table></figure><p>** 2、path 和 clean **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">output: &#123;<br>  path: path.resolve(__dirname, &#x27;dist&#x27;),<br>  filename: &#x27;[name]-[contenthash].js&#x27;,<br>  clean: true,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="pVq9O">工作模式mode</h1><p><code>mode</code>  用于设置webpack的工作模式，告知 webpack 使用相应模式的内置优化 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  mode: &#x27;development&#x27;,<br>&#125;;<br></code></pre></td></tr></table></figure><p> 三种工作模式： </p><ol><li>** production **    默认，生产模式，启用自动压缩代码、去除业务无关代码等 </li><li>** development **    开发模式 </li><li>** none **    不使用任何默认优化选项</li></ol><h1 id="yAZpM">打包结果分析</h1><p> 将 mode 设为 none，查看输出文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plain">/******/ (() =&gt; &#123; // webpackBootstrap<br>/******/ &quot;use strict&quot;;<br>/******/ var __webpack_modules__ = ([<br>/******/ ]);<br>/************************************************************************/<br>/******/ // The module cache<br>/******/ var __webpack_module_cache__ = &#123;&#125;;<br>/******/ <br>/******/ // The require function<br>/******/ function __webpack_require__(moduleId) &#123;<br>/******/ &#125;<br>/******/ <br>/************************************************************************/<br>/******/ /* webpack/runtime/define property getters */<br>/******/ (() =&gt; &#123;<br>/******/ &#125;)();<br>/******/ <br>/******/ /* webpack/runtime/hasOwnProperty shorthand */<br>/******/ (() =&gt; &#123;<br>/******/ &#125;)();<br>/******/ <br>/******/ /* webpack/runtime/make namespace object */<br>/******/ (() =&gt; &#123;<br>/******/ &#125;)();<br>/******/ <br>/************************************************************************/<br>var __webpack_exports__ = &#123;&#125;;<br>// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.<br>(() =&gt; &#123;<br>&#125;)();<br><br>// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.<br>(() =&gt; &#123;<br>&#125;)();<br><br>/******/ &#125;)()<br>;<br></code></pre></td></tr></table></figure><p> 先看最末尾的两个IIFE，两个入口文件 index.js 和 main.js，分别被打包为了立即执行函数，以此实现私有作用域 </p><h1 id="WlqMk">loader</h1><p><a href="https://webpack.docschina.org/concepts/loaders/"> loader </a> 是webpack实现前端模块化的核心，用于将指定格式的资源文件按一定格式进行转换输出 </p><p> 例如，可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。 </p><p> 官方: <a href="https://webpack.docschina.org/loaders/"> Loaders | webpack 中文文档 </a></p><p>** 特点： **</p><ol><li>单一职责：一个Loader只做一件事情，正因为职责越单一，所以Loaders的组合性强，可配置性好 </li><li>loader支持链式调用，上一个loader的处理结果可以传给下一个loader接着处理，上一个Loader的参数options可以传递给下一个loader，直到最后一个loader，返回Webpack所期望的JavaScript</li></ol><p> webpack内部的default loader只能处理JavaScript，想要处理如css、ts等其它类型文件，就要安装对应的loader </p><p> loader可以分为三类： </p><ol><li>编译转换型：如css-loader </li><li>文件操作型：如file-loader </li><li>代码检查型：如eslint-loader</li></ol><p>** 案例： **</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 用于处理不同文件类型的模块配置</span><br><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-comment">// 使用Babel处理JavaScript和JSX文件的规则</span><br>  <span class="hljs-attr">rules</span>: [&#123;<br>    <span class="hljs-comment">// 用于匹配以.jsx或.js结尾的文件</span><br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.jsx?$/</span>,<br>    <span class="hljs-comment">// 只处理src目录下的文件</span><br>    <span class="hljs-attr">include</span>: [<br>      path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>    ],<br>    <span class="hljs-comment">// 排除node_modules目录下的文件</span><br>    <span class="hljs-attr">exclude</span>: [<br>      path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;node_modules&#x27;</span>)<br>    ],<br>    <span class="hljs-comment">// 使用babel-loader进行转译</span><br>    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>    <span class="hljs-attr">options</span>: &#123;<br>      <span class="hljs-comment">// 使用指定的Babel预设</span><br>      <span class="hljs-attr">presets</span>: [<br>        [<span class="hljs-string">&quot;@babel/env&quot;</span>, &#123;<br>          <span class="hljs-comment">// 指定目标浏览器版本为最近的两个Chrome版本</span><br>          <span class="hljs-string">&quot;targets&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;browsers&quot;</span>: <span class="hljs-string">&quot;last 2 chrome versions&quot;</span><br>          &#125;<br>        &#125;]<br>      ]<br>    &#125;<br>  &#125;]<br>&#125;,<br></code></pre></td></tr></table></figure><p> Module的文档： <a href="https://webpack.docschina.org/configuration/module/"> Module | webpack 中文文档 </a></p><h2 id="ijkvD">加载css</h2><p> 查看官方文档 <a href="https://webpack.docschina.org/guides/asset-management/#loading-css"> 指南-管理资源-加载CSS </a></p><p> 安装所需的loader </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install --save-dev style-loader css-loader<br></code></pre></td></tr></table></figure><p> 添加配置， <a href="https://webpack.docschina.org/loaders/css-loader/"> css-loader </a> 将css文件打包为js模块， <a href="https://webpack.docschina.org/loaders/style-loader/"> style-loader </a> 把 CSS 插入到 DOM 中（css-loader将css push到一个数组中，style-loader将数组中的css通过style标签追加到html-head中） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        // 正则匹配loader要处理的资源<br>        test: /\.css$/i,<br>        // 逆序执行，从右往左<br>        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p> src目录下创建index.css,打包入口中使用该css </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#x27;./index.css&#x27;<br></code></pre></td></tr></table></figure><p> 现在样式已经生效 </p><p> webpack推荐我们使用import根据JS代码的需要 ** 动态 ** 导入资源，就像刚刚import css一样，这样的代码与资源的关系，更符合模块化的依赖思想 </p><h2 id="ampB3">加载其它资源</h2><p> webpack5使用 <a href="https://webpack.docschina.org/guides/asset-modules/"> 资源模块Asset Modules </a> 来加载图片、字体等资源，webpack4则使用 <a href="https://v4.webpack.docschina.org/loaders/file-loader/"> file-loader </a> 和 <a href="https://v4.webpack.docschina.org/loaders/url-loader/"> url-loader </a> 等 </p><h3 id="OBn90">file-loader</h3><p> 安装 <a href="https://v4.webpack.docschina.org/loaders/file-loader/"> file-loader </a> ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i file-loader -D<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import avatar from &#x27;./avatar.png&#x27; // 导入打包后资源的路径<br>const img = new Image();<br>img.src = avatar;<br>document.body.append(img);<br></code></pre></td></tr></table></figure><p> 配置规则 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">module: &#123;<br>  rules: [<br>    /******/<br>    &#123;<br>      test: /\.png$/,<br>      use: &#x27;file-loader&#x27;,<br>    &#125;<br>  ],<br>&#125;,<br></code></pre></td></tr></table></figure><p> 打包后，在dist目录下生成了871132b331c17257fcba75273b57f9fe.png，这是将文件的hash值作为了打包后的文件名，当然，这也是可以自定义的。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.png$/,<br>  use: &#123;<br>    loader: &#x27;file-loader&#x27;,<br>    options: &#123;<br>      // 默认[hash].[ext]<br>      name: &#x27;[path][name].[ext]&#x27;,<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p> 这样就能保留图片的原始相对路径和名称。 </p><h3 id="vK2Dh">url-loader</h3><p> file-loader拷贝文件到输出目录，而 <a href="https://v4.webpack.docschina.org/loaders/url-loader/"> url-loader </a> 通过 ** durl ** 的形式表示文件 </p><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i url-loader -D<br></code></pre></td></tr></table></figure><p> durl即Data URLs，可以通过url直接去表示文件的内容，不会产生任何请求 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 一个html类型的文件内容，编码是utf-8<br>data:text/html;charset=UTF-8,&lt;h1&gt;html content&lt;/h1&gt;<br>// 如果是图片这种无法直接通过文本表示的文件，则可以将文件内容进行base64编码<br>data:image/png;base64,iDAHAidhbaIADHA...AHiDAd<br></code></pre></td></tr></table></figure><p>** 最佳实践： ** 配置小文件使用url-loader，大文件则使用file-loader </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.(png|ico)$/,<br>  use: &#123;<br>    loader: &quot;url-loader&quot;,<br>    options: &#123;<br>      name: &quot;[path][name]_[hash:6].[ext]&quot;,<br>      limit: 50 * 1024, //小于50kb的进行编码<br>      // 超过这个大小，url-loader会自动调用file-loader<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; createImage &#125; from &quot;./module.js&quot;;<br>import avatar from &#x27;./avatar.png&#x27;<br>import icon from &#x27;./icon.ico&#x27;<br>document.body.append(createImage(avatar));<br>document.body.append(createImage(icon));<br></code></pre></td></tr></table></figure><h3 id="mggbT">Asset Modules</h3><p> webpack5使用 <a href="https://webpack.docschina.org/guides/asset-modules/"> 资源模块Asset Modules </a> 来加载图片、字体等资源。 </p><p> 在webpack5之前，通常使用：raw-loader将文件导入为字符串，url-loader将文件作为durl内联到bundle中，file-loader将文件发送到输出目录 </p><p> 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader： </p><ol><li><code>asset/resource</code>    发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。 </li><li><code>asset/inline</code>    导出一个资源的 data URI。之前通过使用 url-loader 实现。 </li><li><code>asset/source</code>    导出资源的源代码。之前通过使用 raw-loader 实现。 </li><li><code>asset</code>    在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。</li></ol><p>** 案例： **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.(png|jpg|svg|gif|ico)$/,<br>  // type选择类型<br>  type: &quot;asset/resource&quot;,<br>  // 通过generator属性进行配置<br>  generator: &#123;<br>    filename: &quot;img/[name]_[hash:6][ext]&quot;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">asset/inline&#123;<br>  test: /\.(png|jpg|svg|gif|ico)$/,<br>  type: &quot;asset/inline&quot;,<br>&#125;,<br></code></pre></td></tr></table></figure><p> 最佳实践：type设为asset，添加一个parser属性，并且制定dataUrl的条件，添加maxSize属性； </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.(png|jpg|svg|gif|ico)$/,<br>  type: &quot;asset&quot;,<br>  generator: &#123;<br>    filename: &quot;img/[name]_[hash:6][ext]&quot;,<br>  &#125;,<br>  parser: &#123;<br>    dataUrlCondition: &#123;<br>      maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>    &#125;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="jcGSI">babel-loader</h2><p> webpack由于打包需要，会去处理import和export，但对于其它ES6新特性，则不会去做兼容处理 </p><p> 如果需要将代码中的ES6进行转换，则需要 <a href="https://webpack.docschina.org/loaders/babel-loader/"> babel-loader </a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 安装babel-loader及其依赖的核心库和特性转换集合<br>npm install -D babel-loader @babel/core @babel/preset-env<br></code></pre></td></tr></table></figure><p>** 注意： ** babel只是转换JS代码的一个平台，还需要用其它的插件，如@babel&#x2F;preset-env，通过该平台来转换ES6特性 </p><p> 进行配置： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">module: &#123;<br>  rules: [<br>    &#123;<br>      test: /\.js$/i,<br>      include: [<br>        path.resolve(__dirname, &#x27;src&#x27;)<br>      ],<br>      exclude: [<br>        path.resolve(__dirname, &#x27;node_modules&#x27;)<br>      ],<br>      loader: &#x27;babel-loader&#x27;,<br>      options: &#123;<br>        presets: [&quot;@babel/preset-env&quot;]<br>      &#125;<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p> 开启ESM转CommonJS(会导致Tree Shaking失效，不推荐开启) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">presets: [<br>  [&quot;@babel/preset-env&quot;, &#123;<br>    modules: &quot;commonjs&quot;, // 开启ESM转CommonJS，默认：&quot;auto&quot;<br>  &#125;]<br>]<br></code></pre></td></tr></table></figure><p> 这样就完成了简单的ES6转换，更完善的使用core-js@3兼容，后面再说吧。 </p><h2 id="Pmsfh">资源加载方式</h2><p> 除了在js文件中使用import加载资源，webpack还会自动处理其它加载资源的方式，如css文件中的url()、@import </p><p> 例如：当css-loader在处理css文件时遇到url()时，会找到符合的规则对所需的资源进行处理，如使用asset&#x2F;resource对图片资源处理 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">/* main.css */<br>body&#123;<br>  background-image: url(avatar.png);<br>  background-size: auto;<br>&#125;<br><br>/* index.css */<br>@import &#x27;./main.css&#x27;;<br>body&#123;<br>  background-color: #ccc;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zM3TD">开发loader</h2><p> 尝试开发一个markdown-loader，深入了解loader的工作过程 </p><p>** 文档： **<a href="https://www.webpackjs.com/contribute/writing-a-loader/"> 编写loader </a></p><p>** 功能： ** 将模块中所需的markdown资源转为html内容导入 </p><p> 在根目录新建 <code>markdown-loader.js</code> ，一个最简单的loader是一个函数，接收传入的资源内容，若该loader是最后一个执行的，返回结果必须是JS代码 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = source =&gt; &#123;<br>  console.log(source)<br>  return &#x27;console.log(source)&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p> 使用该loader </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.md$/i,<br>  use: path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>&#125;<br></code></pre></td></tr></table></figure><p> 在模块中导入markdown，webpack只会处理模块所依赖的资源 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">import md from &#x27;./01.md&#x27;<br>console.log(md)<br></code></pre></td></tr></table></figure><p> 打包时控制台输出了markdown的内容。查看打包结果，loader返回的js也在其中，被一个IIFE包裹。 </p><p> 下面继续完成功能： </p><p> 安装解析markdown内容的模块，使用 <a href="https://www.npmjs.com/package/marked"> marked </a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i marked -D<br></code></pre></td></tr></table></figure><p> 修改  <code>markdown-loader.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">const marked = require(&#x27;marked&#x27;);<br><br>module.exports = source =&gt; &#123;<br>  console.log(source)<br>  const html = marked.parse(source)<br>  console.log(html)<br>  return &#x27;console.log(source)&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p> 输出如下，现在loader已经能解析markdown文件了 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 简介<br>这是一个**markdown**<br>&lt;h1&gt;简介&lt;/h1&gt;<br>&lt;p&gt;这是一个&lt;strong&gt;markdown&lt;/strong&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p> 完善loader，将html暴露给模块使用，会作为模块中import markdown文件的default值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const marked = require(&#x27;marked&#x27;);<br><br>module.exports = source =&gt; &#123;<br>  const html = marked.parse(source)<br>  // html中存在一些字符，使用JSON.stringify进行转译<br>  return `export default $&#123;JSON.stringify(html)&#125;`<br>&#125;<br></code></pre></td></tr></table></figure><p> 现在，markdown-loader就完成了，模块导入的就是解析好的html内容 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import md from &#x27;./01.md&#x27;<br>console.log(md)<br>// &lt;h1&gt;简介&lt;/h1&gt;<br>// &lt;p&gt;这是一个&lt;strong&gt;markdown&lt;/strong&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p> 当然，markdown-loader也可以直接返回解析好的html内容，再交给loader管道中下一个loader进行处理，webpack只要求最后一个loader返回的需要是JS代码 </p><p> 处理html就需要安装html-loader， <code>npm i html-loader -D</code></p><p> 修改代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  test: /\.md$/i,<br>  use: [<br>    &#x27;html-loader&#x27;,<br>    path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">const marked = require(&#x27;marked&#x27;);<br><br>module.exports = source =&gt; &#123;<br>  const html = marked.parse(source)<br>  return html<br>&#125;<br></code></pre></td></tr></table></figure><p> 实现的功能也是一样的 </p><h1 id="BCeWv">plugin</h1><p> loader用于处理资源的加载，而插件 <a href="https://webpack.docschina.org/concepts/plugins/"> plugin </a> 用于实现各种 ** 自动化 ** 操作，如压缩代码、替换内容、处理资源 </p><p> 官方 <a href="https://webpack.docschina.org/plugins/"> plugins </a></p><h2 id="RQuMG">打包分析插件</h2><p><a href="https://www.npmjs.com/package/webpack-bundle-analyzer"> webpack-bundle-analyzer </a> 是一个打包分析插件，使用交互式可缩放树形地图可视化，并输出文件的大小。可以方便开发人员检查打包后的文件拆分、分析文件大小。 </p><p> 每次打包时，会自动打开浏览器，访问 <code>127.0.0.1:8888</code> 查看项目结构 </p><p> 安装： <code>npm i webpack-bundle-analyzer -D</code></p><p> webpack中，插件都需要导入后使用，且通常插件导出的都是一个class，需要new实例。配置项plugins是一个数组，保存插件的实例。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;);<br>/*****/<br>plugins: [<br>  new BundleAnalyzerPlugin(),<br>],<br></code></pre></td></tr></table></figure><h2 id="RKMW1">自动生成HTML</h2><p> 手动在根目录创建index.html，并配置打包好的JS等资源的路径，这样硬编码过于麻烦且易出错 </p><p> 可以使用 <a href="https://webpack.docschina.org/plugins/html-webpack-plugin/"> html-webpack-plugin </a> 简化HTML文件的创建，自动引入打包好的JS模块，这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。 </p><p> 安装： <code>npm i html-webpack-plugin --D</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)<br>plugins: [<br>  new HtmlWebpackPlugin(&#123;<br>    template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>    inject: &#x27;body&#x27;, // 插入到body<br>    filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>    title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>    minify: true, // 压缩<br>  &#125;),<br>]<br></code></pre></td></tr></table></figure><p> 修改根目录下的index.html，使其作为一个模板 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;!-- 去掉js文件的引入，插件会自动引入 --&gt;<br>  &lt;!-- &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt; --&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p> 查看打包后的index.html </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;title&gt;webpack测试&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;script defer src=&quot;main_0cc0be.js&quot;&gt;&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p> html-webpack-plugin还有其它的配置项，查看官方仓库文档： <a href="https://github.com/jantimon/html-webpack-plugin#options"> 配置项 </a></p><p> 若是多页面、多个html文件，则创建多个插件实例加入到plugins数组中 </p><h2 id="JC5om">拷贝文件</h2><p> 通常项目中还有一些无需打包的静态文件存放于public目录，这些资源同样需要输出到dist </p><p><a href="https://webpack.docschina.org/plugins/copy-webpack-plugin/"> copy-webpack-plugin </a></p><p> 安装： <code>npm i copy-webpack-plugin -D</code></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);<br>plugins: [<br>  new CopyPlugin(&#123;<br>    patterns: [<br>      // 复制public文件夹内的文件到&#123;output&#125;中<br>      &#123; from: path.resolve(__dirname, &#x27;public&#x27;), to: &quot;&quot; &#125;,<br>    ],<br>  &#125;),<br>]<br></code></pre></td></tr></table></figure><h2 id="KjyCM">开发plugin</h2><p> 相较于loader只作用于模块加载，plugin的作用范围更广。plugin通过常见的 ** 钩子机制 ** 实现，就像Vue生命周期提供的钩子一样。 </p><p> webpack提供了很多打包过程中的 ** 钩子 ** ，plugin向这些钩子上 ** 挂载 ** 任务，并获取 ** 上下文 ** ，来实现对资源的操作等功能。 </p><p> 钩子相关文档： <a href="https://webpack.docschina.org/api/compiler-hooks/"> compiler-hooks </a></p><p> webpack要求plugin必须是一个函数，或一个 ** 包含apply方法 ** 的对象，通常是定义一个包含apply方法的类 </p><p> 新建 <code>myPlugin.js</code></p><p><strong>js</strong></p><p> 现在开发一个用于清除webpack生成的 <code>/******/</code> 注释，以方便阅读打包后的JS代码 </p><p> 明确了功能，考虑需要用到哪些钩子，显然，清除注释要在输出文件前执行，对要输出的内容进行处理。 <a href="https://webpack.docschina.org/api/compiler-hooks/#emit"> emit </a> 钩子符合需求，这个钩子在输出 asset 到 output 目录之前执行。 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default class &#123;<br>  // apply接收一个compiler对象参数<br>  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数<br>  apply(compiler) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">export default class &#123;<br>  // apply接收一个compiler对象参数<br>  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数<br>  apply(compiler) &#123;<br>    // 通过hooks属性访问钩子，tap方法注册钩子函数<br>    // tap方法第一个参数为plugin名，第二个参数是接收了compilation对象的钩子函数<br>    compiler.hooks.emit.tap(&#x27;MyPlugin&#x27;, compilation =&gt; &#123;<br>      // compilation是此次打包过程中的上下文，存放了打包过程的信息和结果<br>      // compilation.assets获取即将输出的资源文件信息<br>      for (const name in compilation.assets) &#123;<br>        console.log(name); // 输出文件名<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 使用插件 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">const MyPlugin = require(&#x27;./myPlugin.js&#x27;);<br>plugins: [<br>  new MyPlugin(),<br>]<br></code></pre></td></tr></table></figure><p> 输出： </p><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">main_28990539038fea465479.js<br>img/avatar_871132b331c17257fcba.png<br>img/icon_36fa45932bf38a34e9af.ico<br>favicon.ico<br>index.html<br></code></pre></td></tr></table></figure><p> 插件已经能读取到打包后的文件名，接下来通过正则替换来处理JS文件 </p><p><strong>js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> &#123;<br>  #<span class="hljs-title function_">isJSFile</span>(<span class="hljs-params">filename</span>) &#123;<br>    <span class="hljs-comment">// 使用正则表达式检查文件名是否以 .js 结尾</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\.js$/i</span>.<span class="hljs-title function_">test</span>(filename);<br>  &#125;<br><br>  <span class="hljs-comment">// apply接收一个compiler对象参数</span><br>  <span class="hljs-comment">// 这个对象包含了打包过程中所有信息以及用于注册钩子函数</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// 通过hooks属性访问钩子，tap方法注册钩子函数</span><br>    <span class="hljs-comment">// tap方法第一个参数为plugin名，第二个参数是接收了compilation对象的钩子函数</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function"><span class="hljs-params">compilation</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// compilation是此次打包过程中的上下文，存放了打包过程的信息和结果</span><br>      <span class="hljs-comment">// compilation.assets获取即将输出的资源文件信息</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">in</span> compilation.<span class="hljs-property">assets</span>) &#123;<br>        <span class="hljs-comment">// console.log(name);</span><br>        <span class="hljs-comment">// 使用source方法获取文件内容</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">isJSFile</span>(name))&#123;<br>          <span class="hljs-keyword">let</span> content = compilation.<span class="hljs-property">assets</span>[name].<span class="hljs-title function_">source</span>();<br>          <span class="hljs-comment">// 使用正则去除webpack生成的/******/</span><br>          content = content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/\*&#123;3,&#125;\//g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>          <span class="hljs-comment">// 覆盖文件信息</span><br>          compilation.<span class="hljs-property">assets</span>[name] = &#123;<br>            <span class="hljs-comment">// 覆盖内容</span><br>            <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> content,<br>            <span class="hljs-comment">// webpack要求指定大小</span><br>            <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> content.<span class="hljs-property">length</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 现在，打包的JS文件内容已经去除了 <code>/******/</code></p><p> 但控制台有警告信息： </p><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">(node:76292) [DEP_WEBPACK_COMPILATION_ASSETS] DeprecationWarning: Compilation.assets will be frozen in future, all modifications are deprecated.<br>BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.<br>        Do changes to assets earlier, e. g. in Compilation.hooks.processAssets.<br>        Make sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.<br>(Use `node --trace-deprecation ...` to show where the warning was created)<br></code></pre></td></tr></table></figure><p> 这是因为Webpack5将在未来版本冻结 <code>compilation.assets</code> ，需在 <code>compiler.hooks.thisCompilation</code> 钩子中使用 Compilation 中的 processAssets hook 来对资源进行再处理 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = class &#123;<br>  #isJSFile(filename) &#123;<br>    // 使用正则表达式检查文件名是否以 .js 结尾<br>    return /\.js$/i.test(filename);<br>  &#125;<br><br>  // apply接收一个compiler对象参数<br>  // 这个对象包含了打包过程中所有信息以及用于注册钩子函数<br>  apply(compiler) &#123;<br>    // 使用thisCompilation钩子，在 compilation 对象创建时执行一些自定义逻辑<br>    compiler.hooks.thisCompilation.tap(&#x27;MyPlugin&#x27;, compilation =&gt; &#123;<br>      // processAssets钩子用于在 webpack 编译完成后，但在最终资源输出之前，处理资源文件的阶段执行插件代码<br>      compilation.hooks.processAssets.tap(<br>        &#123;<br>          name: &#x27;MyPlugin&#x27;,<br>          // https://webpack.docschina.org/api/compilation-hooks/#list-of-asset-processing-stages<br>          stage: compilation.PROCESS_ASSETS_STAGE_OPTIMIZE, // 以通用的方式优化已有asset<br>        &#125;,<br>        (assets) =&gt; &#123;<br>          for (const name in assets) &#123;<br>            if (this.#isJSFile(name)) &#123;<br>              // 使用正则表达式去除块注释<br>              const content = assets[name].source().replace(/\/\*&#123;3,&#125;\//g, &#x27;&#x27;);<br>              // 覆盖文件信息<br>              assets[name] = &#123;<br>                source: () =&gt; content,<br>                size: () =&gt; content.length,<br>              &#125;;<br>            &#125;<br>          &#125;<br>        &#125;<br>      );<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="hyJBV">优化开发过程</h1><p> 项目打包过程已经自动化了，但开发过程仍然在手动操作 </p><p> 编写代码-&gt;命令打包-&gt;运行应用-&gt;刷新浏览器，这个繁琐的过程也需要自动化，以提高开发效率 </p><p> 提出下面的需求： </p><ol><li>以 HTTP Server 运行，而不是打开文件浏览 </li><li>自动编译 + 自动刷新 </li><li>提供 Source Map 支持，方便调试</li></ol><h2 id="SwxYz">watch工作模式</h2><p> 处于watch工作模式时，webpack会监听文件变化，自动重新打包 </p><p> 添加watch配置： </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  watch: true,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MMMYw">DevServer</h2><p><a href="https://webpack.docschina.org/configuration/dev-server"> webpack dev server </a> 提供了HTTP Server，集成了自动编译和自动刷新浏览器的功能。 </p><p> 该插件会将将打包结果暂时存放于内存，而不输出于硬盘，以提高性能。 </p><p> 安装： <code>npm i webpack-dev-server -D</code></p><p><strong>js</strong></p><p>添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>    // 启用Gzip<br>    compress: true,<br>    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>     // 使用static配置从目录提供静态文件的选项，默认public<br>    static: &#123;<br>      // 告诉服务器从哪里提供内容<br>      directory: path.join(__dirname, &#x27;public&#x27;),<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 添加命令脚本 </p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;scripts&quot;: &#123;<br>    &quot;serve&quot;: &quot;webpack serve&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 使用命令运行 <code>npm run serve</code></p><h2 id="d1fjn">代理API服务</h2><p> 前后端同源部署时，本地开发在请求api时可能有cors问题，可以使用开发服务器代理api请求，服务器间通信就不存在cors了 </p><p> DevServer就支持 <code>proxy</code> 配置api代理， <a href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy"> 文档 </a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">devServer: &#123;<br>  proxy: &#123;<br>    // 代理api路径<br>    &#x27;/api&#x27;: &#123;<br>      // localhost:8080/api/user -&gt; api.github.com/api/user<br>      target: &#x27;https://api.github.com&#x27;,<br>      // 请求路径重写 /api/user -&gt; /user<br>      pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>      // 将 host 请求头修改为 target 的 URL<br>      changeOrigin: true,<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="nI3ag">Source Map</h2><p> 前端工程化后，源代码和运行代码几乎完全不同，调试和报错都是基于运行代码，调试源代码就成了问题 </p><p> Source Map用于映射源代码和运行代码之间的关系 </p><p> 一个Source Map的组成： </p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;version&quot;: 3, // 当前Map使用的Source Map标准版本<br>  &quot;sources&quot;: [&quot;main.js&quot;], // 记录源文件的名称，可以是多个文件<br>  &quot;names&quot;: [&quot;global&quot;,/****/], // 源代码使用的成员名称，如变量的原名<br>  &quot;mappings&quot;: &quot;;/****/&quot; // 核心，记录源码和运行代码一些字符的映射关系<br>&#125;<br></code></pre></td></tr></table></figure><p> 通过一行特定格式的注释引入Source Map </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">//# sourceMappingURL=main.map<br></code></pre></td></tr></table></figure><p> 如果Source Map不起作用，需在浏览器控制台-设置-偏好设置中启用JavaScript源代映射 </p><p> 使用 <a href="https://webpack.docschina.org/configuration/devtool/"> Devtool </a> 在webpack中配置Source Map： </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  devtool: &#x27;source-map&#x27;, // 值为Source Map工作模式<br>&#125;<br></code></pre></td></tr></table></figure><p> 相关文章： <a href="https://juejin.cn/post/6960941899616092167"> 一文搞懂SourceMap以及webpack devtool </a></p><p> Source Map工作模式： </p><p><strong>text</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map<br></code></pre></td></tr></table></figure><ol><li><code>inline-</code>  将SourceMap内联到原始文件中，而不是创建一个单独的文件。 </li><li><code>hidden-</code>    仍然会生成.map文件，但是打包后的代码中没有sourceMappingURL，即浏览器不会加载.map文件，控制台中看不到源代码。Map生成后只供服务端分析使用，前端将出错的行列传给服务端。 </li><li><code>eval-</code>    通过eval包裹每个模块打包后代码以及对应生成的SourceMap（不实际生成），因为eval中为字符串形式，进行字符串处理会提升rebuild的速度。 </li><li><code>nosources-</code>    不包含 sourcesContent 内容，调试时只能看到文件信息和行信息，无法看到源码。 </li><li><code>cheap-[module-]</code>    只定位到源码所在的行，不定位至具体的列，构建速度有所提升。如果只用 cheap ，显示的是 loader 编译之后的源代码，加上 module 后会显示编译之前的源代码。</li></ol><p> 如何选择devtool： </p><ol><li>** production： ** none，source-map，hidden-source-map，nosources-source-map </li><li>** development： ** eval，eval-source-map，eval-cheap-source-map，eval-cheap-module-source-map</li></ol><p> 开发环境下，需要频繁的修改代码，更多地考虑的开发效率和调试效率，所以更多关注 performance 中 rebuild 的性能。生产环境下，不必过多关注打包性能，主要考虑 quality 代码的保护性、出错的定位速度已经安全性 </p><h2 id="Zfh6G">热替换HMR</h2><p> 监视模块变动后重新打包、自动刷新会导致页面的一些状态丢失（输入的文本内容），如果能让页面不刷新，模块也能更新，这样的开发体验会好很多 </p><p> 模块热替换 <a href="https://webpack.docschina.org/configuration/dev-server/#devserverhot"> HMR </a> (Hot Module Replacement)可以实现无刷更新模块， <a href="https://juejin.cn/post/6870258201384714253"> 「webpack 核心特性」模块热替换(HMR) </a></p><p> HMR作用： </p><ol><li>保留在完全重新加载页面期间丢失的应用程序状态。 </li><li>只更新变更内容，以节省宝贵的开发时间。 </li><li>在源代码中 CSS&#x2F;JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li></ol><p><strong>js</strong></p><p>使用HMR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">devServer: &#123;<br>  hot: true, // 开启HMR<br>  // 在构建失败时不刷新页面作为回退<br>  // hot: &#x27;only&#x27;,<br>&#125;<br></code></pre></td></tr></table></figure><p> 从webpack-dev-server v4开始，HMR已默认启用。会自动应用HotModuleReplacementPlugin插件 </p><p>** 注意： ** HMR并不是开箱即用，还需要使用 <a href="https://webpack.docschina.org/api/hot-module-replacement/"> HMR-API </a> 手动处理模块的热替换逻辑，否则还会自动刷新，部分loader和插件如style-loader已经处理好了css的热更新逻辑，在Vue等框架下开发，框架本身也处理好了HMR </p><p> 使用 <a href="https://webpack.docschina.org/api/hot-module-replacement/"> HMR-API </a> 手动处理JS模块热替换： </p><p><strong>js</strong></p><p>通常在入口模块统一做处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (module.hot) &#123;<br>  module.hot.accept(&#x27;./library.js&#x27;, function() &#123;<br>    // 对更新过的 library 模块做些事情...<br>  &#125;);<br>&#125;<br>// or<br>if (import.meta.webpackHot) &#123;<br>  import.meta.webpackHot.accept(&#x27;./library.js&#x27;, function () &#123;<br>    // Do something with the updated library module…<br>  &#125;);<br>&#125;<br><br>// accept方法<br>module.hot.accept(<br>  dependencies, // 可以是一个字符串或字符串数组<br>  callback // 用于在模块更新后触发的函数<br>  errorHandler // (err, &#123;moduleId, dependencyId&#125;) =&gt; &#123;&#125;<br>);<br></code></pre></td></tr></table></figure><p> 案例： </p><p><strong>js</strong></p><p>src&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; appendMarkdown &#125; from &quot;./module.js&quot;;<br>import md from &#x27;./01.md&#x27;<br>let mde = appendMarkdown(md);<br><br>if (module.hot) &#123;<br>  // 处理01.md的更新<br>  module.hot.accept(&#x27;./01.md&#x27;, () =&gt; &#123;<br>    // 热重载，先移除原来的<br>    document.body.removeChild(mde);<br>    // 再创建新的<br>    mde = appendMarkdown(md);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p> 热重载的需要根据自己的业务逻辑去实现，没有通用的方法，这也是webpack没有提供JS模块HMR的原因。 </p><p> 打包后，HMR相关代码会被自动去除 </p><h1 id="HfM4W">不同环境的配置</h1><p> 不同的环境需要不同的webpack配置，主要是区分生产和开发环境， <a href="https://webpack.docschina.org/configuration/"> 文档 </a></p><p> 区分环境有两种方式 </p><ol><li>配置函数中判断env，返回不同的配置信息 </li><li>创建多个配置文件对应不同的环境（推荐）</li></ol><h2 id="c4N7I">判断env</h2><p> webpack配置导出一个函数而非对象， <a href="https://webpack.docschina.org/configuration/configuration-types/#exporting-a-function"> 导出函数 </a> ， <a href="https://webpack.docschina.org/guides/environment-variables/"> 环境变量 </a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs plain">/**<br> * <br> * @param &#123;string&#125; env 环境名参数<br> * @param &#123;array&#125; argv cli传递的所有参数<br> * @returns &#123;object&#125; webpack配置<br> */<br>module.exports = (env, argv) =&gt; &#123;<br>  console.log(env);<br>  // 默认的通用配置<br>  const config = &#123;<br>    mode: &#x27;none&#x27;,<br>    // 生成源映射以方便调试<br>    devtool: &#x27;eval-source-map&#x27;,<br>    // watch: true,<br>    context: path.resolve(__dirname, &#x27;src&#x27;),<br>    entry: &#123;<br>      main: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>    &#125;,<br>    output: &#123;<br>      path: path.resolve(__dirname, &#x27;dist&#x27;),<br>      filename: &#x27;[name]_[contenthash].js&#x27;,<br>      clean: true,<br>    &#125;,<br>    module: &#123;<br>      rules: [<br>        &#123;<br>          // 正则匹配loader要处理的资源<br>          test: /\.css$/i,<br>          // 逆序执行，从右往左<br>          use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],<br>        &#125;,<br>        &#123;<br>          test: /\.(png|jpg|svg|gif|ico)$/,<br>          type: &quot;asset&quot;,<br>          generator: &#123;<br>            filename: &quot;img/[name]_[contenthash][ext]&quot;,<br>          &#125;,<br>          parser: &#123;<br>            dataUrlCondition: &#123;<br>              maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>            &#125;,<br>          &#125;,<br>        &#125;,<br>        &#123;<br>          test: /\.js$/i,<br>          include: [<br>            path.resolve(__dirname, &#x27;src&#x27;)<br>          ],<br>          exclude: [<br>            path.resolve(__dirname, &#x27;node_modules&#x27;)<br>          ],<br>          loader: &#x27;babel-loader&#x27;,<br>          options: &#123;<br>            presets: [&quot;@babel/preset-env&quot;]<br>          &#125;<br>        &#125;,<br>        &#123;<br>          test: /\.md$/i,<br>          use: path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>        &#125;<br>      ],<br>    &#125;,<br>    plugins: [<br>      new HtmlWebpackPlugin(&#123;<br>        template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>        inject: &#x27;body&#x27;, // 插入到body<br>        filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>        title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>        minify: true, // 压缩<br>      &#125;),<br>    ],<br>    // 配置开发服务器<br>    devServer: &#123;<br>      // 服务器主机<br>      host: &#x27;localhost&#x27;,<br>      // 服务器端口<br>      port: 8080,<br>      // 使用HMR<br>      hot: true,<br>      // 启用Gzip<br>      compress: true,<br>      // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>      // 使用static配置从目录提供静态文件的选项，默认public<br>      static: &#123;<br>        // 告诉服务器从哪里提供内容<br>        directory: path.join(__dirname, &#x27;public&#x27;),<br>      &#125;,<br>      proxy: &#123;<br>        // 代理api路径<br>        &#x27;/api&#x27;: &#123;<br>          // localhost:8080/api/user -&gt; api.github.com/api/user<br>          target: &#x27;https://api.github.com&#x27;,<br>          // 请求路径重写 /api/user -&gt; /user<br>          pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>          // 将 host 请求头修改为 target 的 URL<br>          changeOrigin: true,<br>        &#125;,<br>      &#125;,<br>    &#125;<br>  &#125;<br>  // 判断环境，修改配置<br>  if (env.production) &#123; // 生产环境<br>    config.mode = &#x27;production&#x27;;<br>    config.devtool = false;<br>    config.plugins = [<br>      ...config.plugins,<br>      new CopyPlugin(&#123;<br>        patterns: [<br>          // 复制public文件夹内的文件到&#123;output&#125;中<br>          &#123; from: path.resolve(__dirname, &#x27;public&#x27;), to: &quot;&quot; &#125;,<br>        ],<br>      &#125;),<br>    ];<br>  &#125; else if (env.development) &#123; // 开发环境<br>    config.mode = &#x27;development&#x27;;<br>  &#125;<br><br>  return config<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>shell</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npx webpack --env production<br>npx webpack --env development<br></code></pre></td></tr></table></figure><h2 id="M29q7">多配置文件</h2><p> 若项目较大配置复杂，就不适合用判断env的方式，写多个配置文件更清晰明了， <a href="https://webpack.docschina.org/guides/production/"> 文档 </a></p><p> 通常有三个配置文件： </p><ol><li><code>webpack.common.js</code>    通用配置文件，写一些项目的通用基础配置 </li><li><code>webpack.dev.js</code>    开发配置文件 </li><li><code>webpack.prod.js</code>    生产配置文件</li></ol><p> 安装 <a href="https://www.npmjs.com/package/webpack-merge"> webpack-merge </a> 合并配置对象： <code>npm i webpack-merge -D</code></p><p><strong>js</strong></p><p>webpack.common.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs plain">const path = require(&#x27;path&#x27;);<br>const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);<br><br>module.exports = &#123;<br>  mode: &#x27;none&#x27;,<br>  // 生成源映射以方便调试<br>  devtool: &#x27;source-map&#x27;,<br>  // watch: true,<br>  context: path.resolve(__dirname, &#x27;src&#x27;),<br>  entry: &#123;<br>    main: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>  &#125;,<br>  output: &#123;<br>    path: path.resolve(__dirname, &#x27;dist&#x27;),<br>    filename: &#x27;[name]_[contenthash].js&#x27;,<br>    clean: true,<br>  &#125;,<br>  //警告 webpack 的性能提示<br>  performance: &#123;<br>    hints: &#x27;warning&#x27;,<br>    //入口起点的最大体积<br>    maxEntrypointSize: 1024 * 1024 * 10,<br>    //生成文件的最大体积<br>    maxAssetSize: 1024 * 1024,<br>    //只给出 js 文件的性能提示<br>    assetFilter: function (assetFilename) &#123;<br>      return /\.js$/.test(assetFilename);<br>    &#125;<br>  &#125;,<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        // 正则匹配loader要处理的资源<br>        test: /\.css$/i,<br>        // 逆序执行，从右往左<br>        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;],<br>      &#125;,<br>      &#123;<br>        test: /\.(png|jpg|svg|gif|ico)$/,<br>        type: &quot;asset&quot;,<br>        generator: &#123;<br>          filename: &quot;img/[name]_[contenthash][ext]&quot;,<br>        &#125;,<br>        parser: &#123;<br>          dataUrlCondition: &#123;<br>            maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        test: /\.js$/i,<br>        include: [<br>          path.resolve(__dirname, &#x27;src&#x27;)<br>        ],<br>        exclude: [<br>          path.resolve(__dirname, &#x27;node_modules&#x27;)<br>        ],<br>        loader: &#x27;babel-loader&#x27;,<br>        options: &#123;<br>          presets: [&quot;@babel/preset-env&quot;]<br>        &#125;<br>      &#125;,<br>      &#123;<br>        test: /\.md$/i,<br>        use: path.resolve(__dirname, &#x27;markdown-loader.js&#x27;),<br>      &#125;<br>    ],<br>  &#125;,<br>  plugins: [<br>    new HtmlWebpackPlugin(&#123;<br>      template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>      inject: &#x27;body&#x27;, // 插入到body<br>      filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>      title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>      minify: true, // 压缩<br>    &#125;),<br>  ],<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>    // 使用HMR<br>    hot: true,<br>    // 启用Gzip<br>    compress: true,<br>    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>    // 使用static配置从目录提供静态文件的选项，默认public<br>    static: &#123;<br>      // 告诉服务器从哪里提供内容<br>      directory: path.join(__dirname, &#x27;public&#x27;),<br>    &#125;,<br>    proxy: &#123;<br>      // 代理api路径<br>      &#x27;/api&#x27;: &#123;<br>        // localhost:8080/api/user -&gt; api.github.com/api/user<br>        target: &#x27;https://api.github.com&#x27;,<br>        // 请求路径重写 /api/user -&gt; /user<br>        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>        // 将 host 请求头修改为 target 的 URL<br>        changeOrigin: true,<br>      &#125;,<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>webpack.dev.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">const common = require(&quot;./webpack.common&quot;);<br>const &#123; merge &#125; = require(&quot;webpack-merge&quot;);<br><br>module.exports = merge(common, &#123;<br>  mode: &#x27;development&#x27;,<br>  devtool: &#x27;eval-source-map&#x27;,<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>webpack.prod.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">const common = require(&quot;./webpack.common&quot;);<br>const path = require(&#x27;path&#x27;);<br>const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);<br>const &#123; merge &#125; = require(&quot;webpack-merge&quot;);<br><br>module.exports = merge(common, &#123;<br>  mode: &#x27;production&#x27;,<br>  devtool: false,<br>  plugins: [<br>    new CopyPlugin(&#123;<br>      patterns: [<br>        // 复制public文件夹内的文件到&#123;output&#125;中<br>        &#123; from: path.resolve(__dirname, &#x27;public&#x27;), to: &quot;&quot; &#125;,<br>      ],<br>    &#125;),<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure><p> 通过 —config 标志使用不同的配置文件 </p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;scripts&quot;: &#123;<br>  &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,<br>  &quot;build-dev&quot;: &quot;webpack --config webpack.dev.js&quot;,<br>  &quot;prod&quot;: &quot;webpack serve --config webpack.prod.js&quot;,<br>  &quot;dev&quot;: &quot;webpack serve --config webpack.dev.js&quot;<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="Fhu5a">内置插件</h1><p> webpack本身内置了很多插件对bundle进行优化，且一些插件在 <code>mode: production</code> 时会自动开启，进行一些通用的优化操作， <a href="https://webpack.docschina.org/configuration/optimization/"> 优化(Optimization) </a></p><h2 id="iuMQm">DefinePlugin</h2><p><a href="https://webpack.docschina.org/plugins/define-plugin/"> DefinePlugin </a> 用来注入全局成员，在 ** 编译时 ** 将代码中的变量替换为其他值或表达式 </p><p> 在 <code>mode: production</code> 时，DefinePlugin默认启用，并注入了 <code>process.env.NODE_ENV</code> ，许多第三方的模块使用这个常量来判断当前环境 </p><p> DefinePlugin接收一个对象，对象中的值若为字符串，将被作为代码片段使用， </p><p><strong>js</strong></p><p>使用API_BASE_URL区分生产和开发环境API接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const webpack = require(&#x27;webpack&#x27;);<br><br>plugins: [<br>  new webpack.DefinePlugin(&#123;<br>    // 使用JSON.stringify作为表示字符串的代码片段<br>    API_BASE_URL: JSON.stringify(&#x27;http://api.github.com&#x27;),<br>  &#125;),<br>],<br><br>console.log(API_BASE_URL)<br></code></pre></td></tr></table></figure><h2 id="zHa1p">Tree Shaking</h2><p><a href="https://webpack.docschina.org/guides/tree-shaking/"> Tree Shaking </a> 用于移除JS上下文中的 ** 未引用 ** 代码(dead-code)， ** 基于ESM **</p><p> 在 <code>mode: production</code> 时Tree Shaking功能自动开启，也可通过配置开启 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  optimization: &#123;<br>    // 只导出使用了的成员<br>    usedExports: true,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p> 测试代码： </p><p><strong>js</strong></p><p>src&#x2F;utils.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">const info = &#123;<br>  name: &#x27;chuckle&#x27;,<br>  age: &#x27;20&#x27;,<br>&#125;<br>export function getName()&#123;<br>  return info.name<br>&#125;<br>export function getAge()&#123;<br>  return info.age<br>&#125;<br>export function logName()&#123;<br>  console.log(info.name);<br>&#125;<br>export function logAge()&#123;<br>  console.log(info.age);<br>&#125;<br></code></pre></td></tr></table></figure><p> 打包结果，仍然存在未使用的代码片段，这是因为usedExports只是标记了未引用代码，而 <code>optimization.minimize</code> 才是用于压缩bundle，并去除未引用代码，两者搭配才实现了Tree Shaking </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;<br>/* harmony export */   logName: () =&gt; (/* binding */ logName)<br>/* harmony export */ &#125;);<br>/* unused harmony exports getName, getAge, logAge */<br>var info = &#123;<br>  name: &#x27;chuckle&#x27;,<br>  age: &#x27;20&#x27;<br>&#125;;<br>function getName() &#123;<br>  return info.name;<br>&#125;<br>function getAge() &#123;<br>  return info.age;<br>&#125;<br>function logName() &#123;<br>  var _console;<br>  /* eslint-disable */(_console = console).log.apply(_console, _toConsumableArray(oo_oo(&quot;3634127370_12_2_12_24_4&quot;, info.name)));<br>&#125;<br>function logAge() &#123;<br>  var _console2;<br>  /* eslint-disable */(_console2 = console).log.apply(_console2, _toConsumableArray(oo_oo(&quot;3634127370_15_2_15_23_4&quot;, info.age)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="rFB9Q">压缩代码去除未引用</h3><p><code>optimization.minimize</code> 压缩bundle并去除未引用代码， <code>mode: production</code> 默认开启 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">module.exports = &#123;<br>  //...<br>  optimization: &#123;<br>    minimize: true,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p> 打包后，未使用过的代码已经去除 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">e.d(_,&#123;logName:()=&gt;d&#125;);var t=&#123;name:&quot;chuckle&quot;,age:&quot;20&quot;&#125;;<br></code></pre></td></tr></table></figure><h3 id="Lnxqo">副作用</h3><p> 将文件标记为 <a href="https://webpack.docschina.org/guides/tree-shaking/#mark-the-file-as-side-effect-free"> side-effect-free </a> (无副作用)安全地删除未用到的export，目的是为了给Tree Shaking更大的优化空间 </p><p> 副作用：模块执行时，除了导出成员之外所作的事情 </p><p><a href="https://webpack.docschina.org/configuration/optimization/#optimizationsideeffects"> optimization.sideEffects </a> 告知webpack去辨识package.json中的副作用标记或规则，以跳过那些当导出不被使用且被标记不包含副作用的模块。 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">optimization: &#123;<br>  sideEffects: true, // 开启<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;sideEffects&quot;: false, // 项目所有模块都无副作用<br>// or<br>&quot;sideEffects&quot;: [&quot;*.css&quot;], // 使用css-loader且在css文件中使用import时很有必要<br></code></pre></td></tr></table></figure><p> 常见副作用代码： </p><p><strong>js</strong></p><p>src&#x2F;pad.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 数字前补全0<br>Number.prototype.pad = function (size) &#123;<br>  let result = String(this);<br>  while (result.length &lt; size) &#123;<br>    result += &#x27;0&#x27;;<br>  &#125;<br>  return result;<br>&#125;<br><br>// 导入使用<br>import &#x27;./pad&#x27;<br></code></pre></td></tr></table></figure><p> 若没有标记副作用，打包会排除该代码片段 </p><p><strong>text</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Uncaught TypeError: 8.pad is not a function<br>  at ./main.js (main.js:17:72)<br>  at __webpack_require__ (bootstrap:24:1)<br>  at startup:7:1<br>  at startup:7:1<br></code></pre></td></tr></table></figure><p> 标记副作用 </p><p><strong>json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;./src/pad.js&quot;],<br></code></pre></td></tr></table></figure><h2 id="R9T71">模块分包</h2><p> webpack会将所有小颗粒度的模块，从入口模块开始打包到一个JS模块，若项目较大，bundle也会很大，一些模块可以分包出来，减小bundle的体积， <a href="https://webpack.docschina.org/guides/code-splitting/"> 文档 </a></p><p> 模块分包办法： </p><ol><li>多入口打包 </li><li>动态导入</li></ol><h3 id="q8PNg">多入口打包</h3><p> 多入口打包通常用于多页面应用，但也可以一个页面应用多个bundle，实现分包 </p><p> 同事可以使用 <code>dependOn</code> 指定依赖的公共模块，并在html中引入公共模块 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plain">entry: &#123;<br>  main: &#123;<br>    import: [&#x27;./index.js&#x27;, &#x27;./main.js&#x27;],<br>    dependOn: &#x27;shared&#x27;,<br>  &#125;,<br>  about: &#123;<br>    import: [&#x27;./about.js&#x27;],<br>    dependOn: &#x27;shared&#x27;,<br>  &#125;,<br>  shared: &#x27;./module.js&#x27;,<br>&#125;,<br>output: &#123;<br>  path: path.resolve(__dirname, &#x27;dist&#x27;),<br>  filename: &#x27;[name]_[contenthash].js&#x27;,<br>  clean: true,<br>&#125;,<br>plugins: [<br>  new HtmlWebpackPlugin(&#123;<br>    template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>    inject: &#x27;body&#x27;, // 插入到body<br>    filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>    title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>    minify: true, // 压缩<br>    chunks: [&#x27;main&#x27;, &#x27;shared&#x27;], // 公共模块也要引入<br>  &#125;),<br>  new HtmlWebpackPlugin(&#123;<br>    template: path.resolve(__dirname, &#x27;./about.html&#x27;),<br>    inject: &#x27;body&#x27;,<br>    filename: &#x27;about.html&#x27;,<br>    title: &#x27;关于页&#x27;,<br>    minify: true, // 压缩<br>    chunks: [&#x27;about&#x27;, &#x27;shared&#x27;],<br>  &#125;),<br>],<br></code></pre></td></tr></table></figure><p> 如果想要在一个 HTML 页面上使用多个入口，还需设置    <a href="https://webpack.docschina.org/configuration/optimization/#optimizationruntimechunk"> runtimeChunk </a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">optimization: &#123;<br>  // 用于指定运行时(runtime)代码的拆分策略<br>  runtimeChunk: &#x27;single&#x27;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="IFW6L">自动提取</h3><p> 当多个模块引入了同一个模块，可以使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/"> splitChunks </a> 将其自动提取为独立的chunk </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">splitChunks: &#123;<br>  chunks: &#x27;all&#x27;,<br>  minSize: 20 * 1024, // 设置最小分包大小,默认20000<br>  minSizeReduction: 50 * 1024, // 需要分包的bundle最小大小<br>&#125;,<br></code></pre></td></tr></table></figure><p><code>minSizeReduction</code> ：设置需要分包的bundle最小大小，这意味着如果分割成一个 chunk 并没有减少主 chunk（bundle）的给定字节数，它将不会被分割，即使它满足 splitChunks.minSize </p><p> 这样就不用使用 <code>dependOn</code> 指定依赖的公共模块了 </p><h3 id="zBmI2">动态导入</h3><p><a href="https://webpack.docschina.org/guides/code-splitting/#dynamic-imports"> 动态导入 </a> 实现按需加载，需要某个模块再加载该模块，所有动态导入的模块都会被自动分包 </p><p> 使用ESM的 <code>import()</code> 实现动态导入 </p><p> 下面是一个hash路由的小demo </p><p><strong>html</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;body&gt;<br>  &lt;header&gt;<br>    &lt;a href=&quot;#Home&quot;&gt;首页&lt;/a&gt;<br>    &lt;a href=&quot;#List&quot;&gt;列表&lt;/a&gt;<br>  &lt;/header&gt;<br>  &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>src&#x2F;blog.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">import home from &#x27;./home&#x27;;<br>import list from &#x27;./list&#x27;;<br><br>const render = ()=&gt;&#123;<br>  const hash = window.location.hash || &quot;#Home&quot;;<br>  const mainEle = document.querySelector(&#x27;#main&#x27;);<br>  mainEle.innerHTML = &quot;&quot;;<br>  if(hash === &quot;#List&quot;)&#123;<br>    mainEle.appendChild(list());<br>  &#125;else if(hash === &quot;#Home&quot;)&#123;<br>    mainEle.appendChild(home());<br>  &#125;<br>&#125;<br>render();<br><br>window.addEventListener(&quot;hashchange&quot;, render)<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>src&#x2F;home&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; renderMarkdown &#125; from &quot;../module&quot;;<br>import &#x27;./index.css&#x27;<br>import md from &#x27;./index.md&#x27;<br>export default () =&gt; renderMarkdown(md, &quot;home&quot;);<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><p>src&#x2F;list&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; renderMarkdown &#125; from &quot;../module&quot;;<br>import &#x27;./index.css&#x27;<br>import md from &#x27;./index.md&#x27;<br>export default () =&gt; renderMarkdown(md, &#x27;list&#x27;);<br></code></pre></td></tr></table></figure><p> 若不使用动态导入，不同路由页引入的css都同时影响样式，导致样式冲突，下面使用 <code>import()</code> 改造 </p><p><strong>js</strong></p><p>src&#x2F;blog.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">const render = () =&gt; &#123;<br>  const hash = window.location.hash || &quot;#Home&quot;;<br>  const mainEle = document.querySelector(&#x27;#main&#x27;);<br>  mainEle.innerHTML = &quot;&quot;;<br>  if (hash === &quot;#List&quot;) &#123;<br>    import(&#x27;./list&#x27;).then((&#123; default: list &#125;) =&gt; &#123;<br>      mainEle.appendChild(list());<br>    &#125;)<br>  &#125; else if (hash === &quot;#Home&quot;) &#123;<br>    import(&#x27;./home&#x27;).then((&#123; default: home &#125;) =&gt; &#123;<br>      mainEle.appendChild(home());<br>    &#125;)<br>  &#125;<br>&#125;<br>render();<br><br>window.addEventListener(&quot;hashchange&quot;, render)<br></code></pre></td></tr></table></figure><h3 id="Y3ON1">魔法注释</h3><p> 在动态导入过程中可以加入魔法注释，控制分包命名、合并、开启 <a href="https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules"> 预加载 </a></p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 使用chunkName设置分包命名<br>import(/* webpackChunkName: &quot;home&quot; */&#x27;./home&#x27;)<br>import(/* webpackChunkName: &quot;list&quot; */&#x27;./list&#x27;)<br>// 相同chunkName会被打包到一起<br>import(/* webpackChunkName: &quot;components&quot; */&#x27;./home&#x27;)<br>import(/* webpackChunkName: &quot;components&quot; */&#x27;./list&#x27;)<br>// 开启预加载<br>import(/* webpackPrefetch: true */&#x27;./list&#x27;);<br></code></pre></td></tr></table></figure><h1 id="XjBRY">css处理进阶</h1><p> css这东西吧，还得琢磨琢磨 </p><h2 id="ijIJ0">css-loader模块化</h2><p> 开启 <code>options.modules</code> ，css-loader会将样式中的类名进行转换，根据模块路径和类名生成转换为一个唯一的hash值。 <a href="https://webpack.docschina.org/loaders/css-loader/#modules"> 文档 </a></p><p>** 作用： ** CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">rules: [<br>  &#123;<br>    test: /\.css$/i,<br>    loader: &quot;css-loader&quot;,<br>    options: &#123;<br>      modules: true,<br>    &#125;,<br>  &#125;,<br>],<br></code></pre></td></tr></table></figure><p> 通过导出对象访问类名来应用样式 </p><p><strong>css</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">.list&#123;<br>  background-color: #2f59b4<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">import &#123; renderMarkdown &#125; from &quot;../module&quot;;<br>import css from &#x27;./index.css&#x27;<br>import md from &#x27;./index.md&#x27;<br>export default () =&gt; renderMarkdown(md, css.list);<br></code></pre></td></tr></table></figure><h2 id="ROK4P">提取css</h2><p> 之前css通过style-loader直接应用到style标签内，而css则保存在js模块中，若css体积较大，还是提取css为一个单独的文件好 </p><p><a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/"> MiniCssExtractPlugin </a> 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载 </p><p> 安装： <code>npm i mini-css-extract-plugin -D</code></p><p><strong>js</strong></p><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);<br><br>module.exports = &#123;<br>  plugins: [new MiniCssExtractPlugin()],<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        test: /\.css$/i,<br>        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="mlkJ3">压缩css</h2><p> webpack本身只能压缩JS模块,需要压缩CSS等其它类型文件需要安装对应的插件 </p><p> 使用 <a href="https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/"> CssMinimizerWebpackPlugin </a> 优化和压缩独立的CSS模块 </p><p> 安装： <code>npm i css-minimizer-webpack-plugin -D</code></p><p><strong>js</strong></p><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);<br><br>optimization: &#123;<br>  minimize: true,<br>  // 压缩类的插件应配置在minimizer，受minimize控制<br>  minimizer: [<br>    // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`）<br>    `...`,<br>    new CssMinimizerPlugin(),<br>  ],<br>&#125;,<br></code></pre></td></tr></table></figure><h1 id="jiFAz">文件hash</h1><p> 开启静态资源的客户端缓存后，为了能及时更新资源，资源文件就需要带上hash， <a href="https://webpack.docschina.org/guides/caching/"> 文档 </a></p><p> 绝大多数插件都支持使用 <code>filename</code> 配置输出的文件名 </p><p> 三种hash： </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">// [hash]项目级hash，项目中一个模块有变化，该hash就变化<br>filename: &#x27;[name]_[hash].js&#x27;,<br>// [chunkhash]chunk级hash，同一路的打包相同hash<br>filename: &#x27;[name]_[chunkhash].js&#x27;,<br>// [contenthash]文件级hash，根据输出文件内容的hash<br>filename: &#x27;[name]_[contenthash].js&#x27;,<br></code></pre></td></tr></table></figure><p> 指定hash长度 </p><p><strong>js</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">filename: &#x27;[name]_[contenthash:8].js&#x27;,<br></code></pre></td></tr></table></figure><p> 控制缓存最佳实践：8位contenthash </p><h1 id="hC4TN">总结</h1><p><strong>json</strong></p><p>package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;name&quot;: &quot;webpack01&quot;,<br>  &quot;version&quot;: &quot;1.0.0&quot;,<br>  &quot;description&quot;: &quot;&quot;,<br>  &quot;private&quot;: true,<br>  &quot;scripts&quot;: &#123;<br>    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,<br>    &quot;build-dev&quot;: &quot;webpack --config webpack.dev.js&quot;,<br>    &quot;prod&quot;: &quot;webpack serve --config webpack.prod.js&quot;,<br>    &quot;dev&quot;: &quot;webpack serve --config webpack.dev.js&quot;<br>  &#125;,<br>  &quot;sideEffects&quot;: [<br>    &quot;*.css&quot;,<br>    &quot;./src/pad.js&quot;<br>  ],<br>  &quot;keywords&quot;: [],<br>  &quot;author&quot;: &quot;&quot;,<br>  &quot;license&quot;: &quot;ISC&quot;,<br>  &quot;devDependencies&quot;: &#123;<br>    &quot;@babel/core&quot;: &quot;^7.23.3&quot;,<br>    &quot;@babel/preset-env&quot;: &quot;^7.23.3&quot;,<br>    &quot;babel-loader&quot;: &quot;^8.3.0&quot;,<br>    &quot;copy-webpack-plugin&quot;: &quot;^11.0.0&quot;,<br>    &quot;css-loader&quot;: &quot;^6.8.1&quot;,<br>    &quot;css-minimizer-webpack-plugin&quot;: &quot;^5.0.1&quot;,<br>    &quot;file-loader&quot;: &quot;^6.2.0&quot;,<br>    &quot;html-loader&quot;: &quot;^4.2.0&quot;,<br>    &quot;html-webpack-plugin&quot;: &quot;^5.5.3&quot;,<br>    &quot;marked&quot;: &quot;^9.1.6&quot;,<br>    &quot;mini-css-extract-plugin&quot;: &quot;^2.7.6&quot;,<br>    &quot;style-loader&quot;: &quot;^3.3.3&quot;,<br>    &quot;url-loader&quot;: &quot;^4.1.1&quot;,<br>    &quot;webpack&quot;: &quot;^5.74.0&quot;,<br>    &quot;webpack-bundle-analyzer&quot;: &quot;^4.9.1&quot;,<br>    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;,<br>    &quot;webpack-dev-server&quot;: &quot;^4.15.1&quot;,<br>    &quot;webpack-merge&quot;: &quot;^5.10.0&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="VmFlU">配置TS环境</h1><p> 安装TS相关依赖： </p><ol><li>编译TS    <code>npm install ts-loader -D</code></li><li>TS环境    <code>npm install typescript -D</code></li></ol><p><strong>js</strong></p><p>配置webpack.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs plain">const path = require(&#x27;path&#x27;);<br>const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);<br>const webpack = require(&#x27;webpack&#x27;);<br>const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);<br>const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);<br><br>module.exports = &#123;<br>  mode: &#x27;none&#x27;,<br>  // 生成源映射以方便调试<br>  devtool: &#x27;source-map&#x27;,<br>  // watch: true,<br>  context: path.resolve(__dirname, &#x27;src&#x27;),<br>  entry: &#123;<br>    main: &#123;<br>      import: [&#x27;./index.ts&#x27;],<br>    &#125;<br>  &#125;,<br>  output: &#123;<br>    path: path.resolve(__dirname, &#x27;dist&#x27;),<br>    filename: &#x27;[name]_[contenthash].js&#x27;,<br>    clean: true,<br>  &#125;,<br>  optimization: &#123;<br>    usedExports: true,<br>    // minimize: true,<br>    // 用于指定运行时(runtime)代码的拆分策略<br>    // runtimeChunk: &#x27;single&#x27;,<br>    // splitChunks: &#123;<br>    //   chunks: &#x27;all&#x27;,<br>    //   minSize: 10 * 1024, // 设置最小分包大小<br>    //   // minSizeReduction: 50 * 1024, // 需要分包的bundle最小大小<br>    // &#125;,<br>    minimizer: [<br>      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`）<br>      `...`,<br>      new CssMinimizerPlugin(),<br>    ],<br>  &#125;,<br>  //警告 webpack 的性能提示<br>  performance: &#123;<br>    hints: &#x27;warning&#x27;,<br>    //入口起点的最大体积<br>    maxEntrypointSize: 1024 * 1024 * 10,<br>    //生成文件的最大体积<br>    maxAssetSize: 1024 * 1024,<br>    //只给出 js 文件的性能提示<br>    assetFilter: function (assetFilename) &#123;<br>      return /\.ts$/.test(assetFilename);<br>    &#125;<br>  &#125;,<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        // 正则匹配loader要处理的资源<br>        test: /\.css$/i,<br>        // 逆序执行，从右往左<br>        use: [<br>          // &#123;<br>          //   loader: &#x27;style-loader&#x27;,<br>          // &#125;,<br>          &#123;<br>            loader: MiniCssExtractPlugin.loader<br>          &#125;,<br>          &#123;<br>            loader: &#x27;css-loader&#x27;,<br>            // options: &#123;<br>            //   modules: true // css-loader会将样式中的类名进行转换，根据模块路径和类名生成转换为一个唯一的hash值。<br>            // &#125;,<br>          &#125;,<br>        ],<br>      &#125;,<br>      &#123;<br>        test: /\.(png|jpg|svg|gif|ico)$/,<br>        type: &quot;asset&quot;,<br>        generator: &#123;<br>          filename: &quot;img/[name]_[contenthash][ext]&quot;,<br>        &#125;,<br>        parser: &#123;<br>          dataUrlCondition: &#123;<br>            maxSize: 50 * 1024,//小于50kb进行编码，转为base64<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        test: /\.js$/i,<br>        include: [<br>          path.resolve(__dirname, &#x27;src&#x27;)<br>        ],<br>        exclude: [<br>          path.resolve(__dirname, &#x27;node_modules&#x27;)<br>        ],<br>        loader: &#x27;babel-loader&#x27;,<br>        options: &#123;<br>          presets: [&quot;@babel/preset-env&quot;]<br>          // presets: [<br>          //   [&quot;@babel/preset-env&quot;, &#123;<br>          //     modules: &quot;commonjs&quot;, // 开启ESM转CommonJS<br>          //   &#125;]<br>          // ]<br>        &#125;<br>      &#125;,<br>      &#123;<br>        test: /\.ts$/i,<br>        loader: &quot;ts-loader&quot;,<br>        include: [<br>          path.resolve(__dirname, &#x27;src&#x27;)<br>        ],<br>        exclude: [<br>          path.resolve(__dirname, &#x27;node_modules&#x27;)<br>        ],<br>      &#125;<br>    ],<br>  &#125;,<br>  plugins: [<br>    new HtmlWebpackPlugin(&#123;<br>      template: path.resolve(__dirname, &#x27;./index.html&#x27;), // 自定义模板<br>      inject: &#x27;body&#x27;, // 插入到body<br>      filename: &#x27;index.html&#x27;, // 输出文件名，默认index.html<br>      title: &#x27;webpack测试&#x27;, // 自定义title，通过&lt;%= htmlWebpackPlugin.options.title %&gt;在html中使用<br>      minify: true, // 压缩<br>      chunks: [&#x27;main&#x27;],<br>    &#125;),<br>    new webpack.DefinePlugin(&#123;<br>      API_BASE_URL: JSON.stringify(&#x27;http://api.github.com&#x27;),<br>    &#125;),<br>    new MiniCssExtractPlugin(),<br>  ],<br>  resolve: &#123;<br>    extensions: [&#x27;.ts&#x27;, &#x27;.js&#x27;],<br>    alias: &#123;<br>      &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;)<br>    &#125;<br>  &#125;,<br>  // 配置开发服务器<br>  devServer: &#123;<br>    // 服务器主机<br>    host: &#x27;localhost&#x27;,<br>    // 服务器端口<br>    port: 8080,<br>    // 使用HMR<br>    hot: true,<br>    // 启用Gzip<br>    compress: true,<br>    // CopyPlugin通常只在项目上线时去使用，开发时通常将静态资源目录配置给devServer，以提高性能<br>    // 使用static配置从目录提供静态文件的选项，默认public<br>    static: &#123;<br>      // 告诉服务器从哪里提供内容<br>      directory: path.join(__dirname, &#x27;public&#x27;),<br>    &#125;,<br>    proxy: &#123;<br>      // 代理api路径<br>      &#x27;/api&#x27;: &#123;<br>        // localhost:8080/api/user -&gt; api.github.com/api/user<br>        target: &#x27;https://api.github.com&#x27;,<br>        // 请求路径重写 /api/user -&gt; /user<br>        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,<br>        // 将 host 请求头修改为 target 的 URL<br>        changeOrigin: true,<br>      &#125;,<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>json</strong></p><p>tsconfig.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;<br>  &quot;compilerOptions&quot;: &#123;<br>    &quot;incremental&quot;: false, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度<br>    // &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置<br>    &quot;diagnostics&quot;: true, // 打印诊断信息 <br>    &quot;target&quot;: &quot;esnext&quot;, /* 指定 ECMAScript 目标版本：&#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;,&#x27;ES2018&#x27; or &#x27;ESNEXT&#x27;. */<br>    &quot;module&quot;: &quot;esnext&quot;, /* 输出的代码使用什么方式进行模块化： &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */<br>    &quot;lib&quot;: [ /* 指定引用的标准库 */<br>      &quot;esnext&quot;,<br>      &quot;dom&quot;,<br>      &quot;dom.iterable&quot;,<br>    ], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,<br>    &quot;allowJs&quot;: true, // 允许编译器编译JS，JSX文件<br>    &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用<br>    &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录<br>    &quot;rootDir&quot;: &quot;./src&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构<br>    &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件<br>    &quot;declarationDir&quot;: &quot;./dist/typings&quot;, // 指定生成声明文件存放目录<br>    // &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件<br>    &quot;sourceMap&quot;: false, // 生成目标文件的sourceMap文件<br>    // &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中<br>    &quot;declarationMap&quot;: false, // 为声明文件生成sourceMap<br>    // &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types<br>    &quot;types&quot;: [], // 加载的声明文件包<br>    &quot;removeComments&quot;: true, // 删除注释 <br>    &quot;noEmit&quot;: false, // 不输出文件,即编译后不会生成任何js文件<br>    &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件<br>    &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用<br>    &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块<br>    &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现<br>    &quot;strict&quot;: true, // 开启所有严格的类型检查<br>    &quot;alwaysStrict&quot;: true, // 在代码中注入&#x27;use strict&#x27;<br>    &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型<br>    &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量<br>    &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变<br>    &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化<br>    &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查<br>    &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型<br>    &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错)<br>    &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错)<br>    &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)<br>    &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值<br>    &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入<br>    &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块<br>    &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入<br>    &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录<br>    &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl<br>      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置<br>      // &quot;jquery&quot;: [<br>      //   &quot;node_modules/jquery/dist/jquery.min.js&quot;<br>      // ],<br>      &quot;@/*&quot;: [<br>        &quot;src/*&quot;<br>      ]<br>    &#125;,<br>    &quot;rootDirs&quot;: [<br>      &quot;src&quot;<br>    ], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错<br>    &quot;listEmittedFiles&quot;: true, // 打印输出文件<br>    &quot;listFiles&quot;: true, // 打印编译的文件(包括引用的声明文件)<br>    &quot;experimentalDecorators&quot;: true,<br>    &quot;emitDecoratorMetadata&quot;: true,<br>    &quot;resolveJsonModule&quot;: true,<br>    &quot;allowImportingTsExtensions&quot;: true,<br>  &#125;,<br>  // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）<br>  &quot;include&quot;: [<br>    &quot;src/**/*&quot;,<br>  ],<br>  // 指定一个排除列表（include的反向操作）<br>  // &quot;exclude&quot;: [<br>  //   &quot;demo.ts&quot;<br>  // ],<br>  // 指定哪些文件使用该配置（属于手动一个个指定文件）<br>  // &quot;files&quot;: [<br>  //   &quot;demo.ts&quot;<br>  // ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模块化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo图片加载问题</title>
    <link href="/2024/12/08/foreworld/"/>
    <url>/2024/12/08/foreworld/</url>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>文档 : <a href="https://hexo.io/zh-cn/docs/">hexo|文档</a></p><h5 id="Ddzce">hexo常用命令</h5><p>:::info<br>hexo c &#x2F;&#x2F;清除缓存</p><p>hexo g &#x2F;&#x2F;生成静态资源</p><p>hexo s &#x2F;&#x2F;本地部署预览</p><p>hexo d &#x2F;&#x2F;云端部署</p><p>hexo new title &#x2F;&#x2F;生成文章</p><p>:::</p><h5 id="CCkF4"> 解决方法 </h5><p> 可以通过修改配置并安装插件的方法完成图片的插入。你需要 ** 修改站点配置 **<code>_config.yml</code> ，将  <code>post_asset_folder</code>  设置为  <code>true</code></p><p> 这样在 hexo new xxx 会生成一个同名文件夹存放图片资源 </p><p> 然后安装插件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install hexo-asset-image -- save<br></code></pre></td></tr></table></figure><p> 在 typora 中修改图片设置 </p><p><img src="1733662577985-c91c13a3-1ee6-4ea4-8775-91a6933e9fca.png"></p><p>  如果你使用的是插件，当生成预览的时候，可能依旧无法正常查看图片。通过直接查看 HTML 文件，我们可以看到是因为多了 &#x2F;.com&#x2F;，所以在加载图片的时候无法获得正确的路径。 </p><p> 具体的修改也很简单，我们只需要到  <code>node_modules</code>  中找到  <code>hexo-asset-image</code> ，并将 58、89 行的 </p><p><img src="1733662764449-d1f26996-9963-4abd-8e91-a9c542dc6a03.png"></p><p> 修改为 </p><p><img src="1733662782894-6cefafe5-30d4-4d20-9108-6a4f795c6cf4.png"></p><p> 不出意外的话，就可以看到正常显示的图片了 </p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ts</title>
    <link href="/2024/12/08/Ts/"/>
    <url>/2024/12/08/Ts/</url>
    
    <content type="html"><![CDATA[<h3 id="Ts-介绍"><a href="#Ts-介绍" class="headerlink" title="Ts 介绍"></a>Ts 介绍</h3><p><strong>TypeScript 是由微软开发的，基于 JavaScript（JS）的一个扩展语言，包含 JS 所有内容，并增加了静态类型检查、接口、泛型等特性.</strong></p><p><strong>Ts 支持静态类型检查,在代码运行前进行检查,减少运行异常的概率.同样的功能,Ts 的代码量大于 Js,但是代码结构更加清晰,更加便于维护.</strong></p><p><strong>Ts 编译:Ts 不能直接被浏览器运行,需要先编译为 Js,再交由浏览器解析执行.(vue,react 基于 webpack,vite 等配置进行 Ts 编译)</strong></p><details class="lake-collapse"><summary id="uf812c35c"><span class="ne-text">1.命令行编译</span></summary><p id="u4edc343b" class="ne-p" style="text-indent: 2em"><span class="ne-text">安装ts,命令npm i typescript -g(全局安装) ,编译命令tsc &lt;ts文件&gt;解析编译出ts文件对应的js文件</span></p></details><details class="lake-collapse"><summary id="uf7a681eb"><span class="ne-text">2.自动化编译</span></summary><p id="u27e3738b" class="ne-p" style="text-indent: 2em"><span class="ne-text">同样先全局安装ts,输入命令tsc --init,生成tsconfig.json配置文件.</span></p><p id="u692d87af" class="ne-p" style="text-indent: 2em"><span class="ne-text">ts --watch监视全部ts文件,也可监视单个ts文件</span></p><p id="ufea8de56" class="ne-p"><span class="ne-text">技巧:当出现错误时,不进行编译 tsc --noEmitOnError --watch(也可直接修改tsconfig.json的noEmitOnError 属性)</span></p></details><p>对于变量,函数进行基本的类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">boolean</span>;<br>a = <span class="hljs-string">&quot;hello&quot;</span>;<br>b = <span class="hljs-number">1</span>;<br>c = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>Ts 类型推断,Ts 会根据代码进行类型推断,面对复杂类型可能出错,尽量明确编写的类型声明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> d= <span class="hljs-number">99</span><br>d=<span class="hljs-string">&#x27;123</span><br></code></pre></td></tr></table></figure><h3 id="基础类型总览"><a href="#基础类型总览" class="headerlink" title="基础类型总览"></a>基础类型总览</h3><details class="lake-collapse"><summary id="uaabb7dd7"><span class="ne-text">js中的数据类型</span></summary><p id="ua5bf1f19" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">① string </span></p><p id="ub8258016" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">② </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">number </span></p><p id="u306b5347" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">③ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">boolean </span></p><p id="ud79c25c0" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">④ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">null </span></p><p id="u17e78bca" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑤ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">undefined </span></p><p id="u0d936672" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑥ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">bigint </span></p><p id="ud4c5383f" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑦ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">symbol </span></p><p id="u6ecacdea" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑧ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">object </span></p><p id="u1b4cd798" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">备注：其中 object 包含： Array 、 Function 、 Date 、 Error 等.....</span></p></details><details class="lake-collapse"><summary id="u32dbb78f"><span class="ne-text">ts中的数据类型</span></summary><p id="u2ff6582f" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">1. 上述所有 JavaScript 类型 </span></p><p id="u590a9d1e" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">2. </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">六个新类型： </span></p><p id="u01c33d3a" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">① </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">any </span></p><p id="u76ff1110" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">② </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">unknown </span></p><p id="u56d902db" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">③ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">never </span></p><p id="u4585c27d" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">④ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">void </span></p><p id="u57ba264a" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑤ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">tuple </span></p><p id="ue42ab522" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">⑥ </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">enum </span></p><p id="ud2723297" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">3. </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">两个⽤于⾃定义类型的⽅式： </span></p><p id="u0254fc1f" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">① </span><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">type </span></p><p id="u2451c65d" class="ne-p"><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">② interface</span></p></details><p>:::info<br>注意: 在 JavaScript 中的这些内置构造函数： Number 、 String 、 Boolean ，⽤于  </p><p> 创建对应的包装对象， 在⽇常开发时  很少使⽤  ，在   TypeScript   中也是同理，所以  </p><p> 在   TypeScript   中进⾏类型声明时，通常都是⽤⼩写的   number   、   string   、   bo  </p><p> olean </p><ol><li>原始类型 VS 包装对象<br> 原始类型：如 number 、 string 、 boolean ，在 JavaScript 中是简单数据<br> 类型，它们在内存中占⽤空间少，处理速度快。<br> 包装对象：如 Number 对象、 String 对象、 Boolean 对象，是复杂类型，在<br> 内存中占⽤更多空间，在⽇常开发时很少由开发⼈员⾃⼰创建包装对象。 </li><li>⾃动装箱：JavaScript 在必要时会⾃动将原始类型包装成对象，以便调⽤⽅法或访<br> 问属性</li></ol><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 原始类型字符串</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">// 当访问str.length时，JavaScript引擎做了以下⼯作：</span><br><span class="hljs-keyword">let</span> size = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. ⾃动装箱：创建⼀个临时的String对象包装原始字符串</span><br>  <span class="hljs-keyword">let</span> tempStringObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str);<br>  <span class="hljs-comment">// 2. 访问String对象的length属性</span><br>  <span class="hljs-keyword">let</span> lengthValue = tempStringObject.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 3. 销毁临时对象，返回⻓度值</span><br>  <span class="hljs-comment">// （JavaScript引擎⾃动处理对象销毁，开发者⽆感知）</span><br>  <span class="hljs-keyword">return</span> lengthValue;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(size); <span class="hljs-comment">// 输出: 5</span><br></code></pre></td></tr></table></figure><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><p>**any:**任意类型, 可以赋值给任意类型的变量(容易造成类型错误,比如将一个 any 类型的数据赋值给一个 string 类型的数据),不进行声明时 Ts 会判断为隐式 any. </p><p>** unknow: ** 可以理解为一个类型安全的 any,适⽤于：起初不确定数据的具体类型，要后期才能确定.使用时强制开发者进行类型判断,从而保证类型安全.(可以使用断言进行强制推断) </p><p>:::info<br>** tip(断言): **</p><p> 第 1 种⽅式<br>  x &#x3D; a as string<br>  第 2 种⽅式<br>  x &#x3D; <string>a </string></p><p>:::</p><p><strong>never</strong>:不是任何值,一般不主动使用(无意义),一般由 ts 进行类型推断,推断为”never”.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 指定a的类型为string</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 给a设置⼀个值</span><br>a = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toUpperCase</span>());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// TypeScript会推断出此处的a是never，因为没有任何⼀个值符合此处的</span><br>  逻辑;<br>&#125;<br></code></pre></td></tr></table></figure><p>** void  ** ：函数不返回任何值，调⽤者也不应依赖其返回值进⾏  任何操作  ！ </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"><span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;<br><span class="hljs-title function_">logMessage</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br></code></pre></td></tr></table></figure><p>:::info<br> 注意：编码者没有编写 return 指定函数返回值，所以 logMessage 函数是没有  显式  </p><p> 返回值  的，但会有⼀个  隐式返回值   ，是   undefined   ，虽然函数返回类型为   void   ，但  </p><p> 也是可以接受 undefined 的，简单记：  ** undefined  ** 是  ** void  ** 可以接受的⼀种“空”。 </p><p>:::</p><details class="lake-collapse"><summary id="u3118a979"><strong><span class="ne-text" style="color: rgb(38,38,38); font-size: 16px">理解 void 与 undefined </span></strong></summary><p id="u5c954ab3" class="ne-p" style="text-indent: 2em"><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">void </span><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">是⼀个⼴泛的概念，⽤来表达“空”，⽽ </span><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">undefined </span><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">则是这种“空”的具体 </span></p><p id="ucba7d1dd" class="ne-p"><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">实现。 </span></p><p id="uff48e4eb" class="ne-p" style="text-indent: 2em"><span class="ne-text" style="color: rgb(88,90,90); font-size: 16px">因此可以说 undefined 是 void 能接受的⼀种“空”的状态。也可以理解为： void 包含 undefined ，但 void 所表达的语义超越了 undefined ， void 是⼀种意图上的约定，⽽不仅仅是特定值的限制。 </span></p></details><p>** object  ** （⼩写) ： 所有⾮原始类型，可存储：对象、函数、数组等，由于限制的范围⽐较宽泛，在实际开发中使⽤的相对较少。</p><p> Object（⼤写）:   所有可以调⽤  ** Object  ** ⽅法的类型。(除了 undefined 和 null 的任何值.) </p><h4 id="声明对象类型"><a href="#声明对象类型" class="headerlink" title="声明对象类型"></a>声明对象类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 限制person1对象必须有name属性，age为可选属性</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person1</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age?: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-comment">// 含义同上，也能⽤分号做分隔</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person2</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; age?: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-comment">// 含义同上，也能⽤换⾏做分隔</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">person3</span>: &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>索引签名</strong>： 允许定义对象可以具有任意数量的属性，这些属性的键和类型是可变的,常⽤于：描述类型不确定的属性，（具有动态属性的对象）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 限制person对象必须有name属性，可选age属性但值必须是数字，同时可以有任意数</span><br>量、任意类型的其他属性<br><span class="hljs-keyword">let</span> <span class="hljs-attr">person</span>: &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br> age?: <span class="hljs-built_in">number</span><br> [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明函数类型"><a href="#声明函数类型" class="headerlink" title="声明函数类型"></a>声明函数类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br>count = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>:::info<br> 备注：TypeScript 中的 &#x3D;&gt; 在函数类型声明时表示函数类型，描述其参数类型和返回类 型。  </p><p> JavaScript 中的 &#x3D;&gt; 是⼀种定义函数的语法，是具体的函数实现。函数类型声明还可以使⽤：接⼝、⾃定义类型等⽅式 </p><p>:::</p><p>:::info<br>tip: 在函数定义时，限制函数返回值为 void ，那么函数的返回值就必须是空。使⽤类型声明限制函数返回值为 void 时， ** TypeScript  ** 并不会严格要求函数返回空。 </p><p> 是为了确保如下代码成⽴，我们知道 Array.prototype.push 的返回值是⼀个数字 Array.prototype.forEach ⽅法期望其回调的返回类型是 void 。 </p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> src = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> dst = [<span class="hljs-number">0</span>];<br><span class="hljs-comment">//若是src.forEach((el) =&gt; &#123;dst.push(el)&#125;)返回值为void;若是简写形式则返回为number</span><br>src.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> dst.<span class="hljs-title function_">push</span>(el));<br></code></pre></td></tr></table></figure><h4 id="声明数组类型"><a href="#声明数组类型" class="headerlink" title="声明数组类型"></a>声明数组类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-built_in">string</span>[];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">//泛型</span><br>arr1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>];<br>arr2 = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];<br></code></pre></td></tr></table></figure><p><strong>元组(tuple):</strong> tuple 是⼀种特殊的数组类型，可以存储固定数量的元素，并且每个元素的类型是已  </p><p> 知的且可以不同。元组⽤于精确描述⼀组值的类型，? 表示可选元素。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 第⼀个元素必须是 string 类型，第⼆个元素必须是 number 类型。</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-comment">// 第⼀个元素必须是 number 类型，第⼆个元素是可选的，如果存在，必须是 boolean 类型。</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>?];<br><span class="hljs-comment">// 第⼀个元素必须是 number 类型，后⾯的元素可以是任意数量的 string 类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr3</span>: [<span class="hljs-built_in">number</span>, ...<span class="hljs-built_in">string</span>[]];<br></code></pre></td></tr></table></figure><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p>** 枚举（ enum ） ** :可以定义  ⼀组命名常量  ，它能增强代码的可读性，也让代码更好维护 </p><p>** 数字枚举: ** 数字枚举⼀种最常⻅的枚举类型，其成员的值会  ⾃动递增  ，且数字枚举还具备  反向映射  的  </p><p> 特点,  也可以指定枚举成员的初始值，其后的成员值会⾃动递增  。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span>,<br>  <span class="hljs-title class_">Down</span>,<br>  <span class="hljs-title class_">Left</span>,<br>  <span class="hljs-title class_">Right</span>,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>); <span class="hljs-comment">// 打印Direction会看到如下内容</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> &#123;</span><br><span class="hljs-comment"> 0:&#x27;Up&#x27;, </span><br><span class="hljs-comment"> 1:&#x27;Down&#x27;, </span><br><span class="hljs-comment"> 2:&#x27;Left&#x27;, </span><br><span class="hljs-comment"> 3:&#x27;Right&#x27;, </span><br><span class="hljs-comment"> Up:0, </span><br><span class="hljs-comment"> Down:1, </span><br><span class="hljs-comment"> Left:2,</span><br><span class="hljs-comment"> Right:3</span><br><span class="hljs-comment"> &#125; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 反向映射</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 此⾏代码报错，枚举中的属性是只读的</span><br><span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span> = <span class="hljs-string">&quot;shang&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>字符串枚举:</strong> 枚举成员的值是字符串 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span> = <span class="hljs-string">&quot;up&quot;</span>,<br>  <span class="hljs-title class_">Down</span> = <span class="hljs-string">&quot;down&quot;</span>,<br>  <span class="hljs-title class_">Left</span> = <span class="hljs-string">&quot;left&quot;</span>,<br>  <span class="hljs-title class_">Right</span> = <span class="hljs-string">&quot;right&quot;</span>,<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">dir</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dir); <span class="hljs-comment">// 输出: &quot;up&quot;</span><br></code></pre></td></tr></table></figure><p><strong>常量枚举:</strong> 官⽅描述：常量枚举是⼀种特殊枚举类型，它使⽤   const   关键字定义，在编译时会被  </p><p> 内联  ，  避免  ⽣成⼀些  额外  的代码。 </p><p>:::info<br> 何为  编译时内联  ？  </p><p> 所谓“内联”其实就是 TypeScript 在编译时，会将枚举成员引⽤替换为它们的实际值,⽽不是⽣成额外的枚举对象。这可以减少⽣成的 JavaScript 代码量，并提⾼运⾏时性能 </p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Directions</span> &#123;<br>  <span class="hljs-title class_">Up</span>,<br>  <span class="hljs-title class_">Down</span>,<br>  <span class="hljs-title class_">Left</span>,<br>  <span class="hljs-title class_">Right</span>,<br>&#125;<br><span class="hljs-keyword">let</span> x = <span class="hljs-title class_">Directions</span>.<span class="hljs-property">Up</span>;<br></code></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>** type **  :可以为任意类型创建别名，让代码更简洁、可读性更强，同时能更⽅便地进⾏类型复⽤和扩展 </p><p>** 基本用法: ** 类型别名使⽤ type 关键字定义， type 后跟类型名称 </p><p>** 联合类型: ** 联合类型是⼀种⾼级类型，它表示⼀个值可以是⼏种不同类型之⼀。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Status</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Gender</span> = <span class="hljs-string">&quot;男&quot;</span> | <span class="hljs-string">&quot;⼥&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>交叉类型</strong>: 交叉类型（Intersection Types）允许将多个类型合并为⼀个类型。合并后的类型将拥  </p><p> 有所有被合并类型的成员。交叉类型通常⽤于对象类型。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//⾯积</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Area</span> = &#123;<br>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//⾼</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//宽</span><br>&#125;;<br><span class="hljs-comment">//地址</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Address</span> = &#123;<br>  <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//楼号</span><br>  <span class="hljs-attr">cell</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//单元号</span><br>  <span class="hljs-attr">room</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//房间号</span><br>&#125;;<br><span class="hljs-comment">// 定义类型House，且House是Area和Address组成的交叉类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">House</span> = <span class="hljs-title class_">Area</span> &amp; <span class="hljs-title class_">Address</span>;<br></code></pre></td></tr></table></figure><p>:::info<br>tip: 在函数定义时，限制函数返回值为 void ，那么函数的返回值就必须是空。使⽤类型声明限制函数返回值为 void 时， ** TypeScript  ** 并不会严格要求函数返回空。 </p><p> 是为了确保如下代码成⽴，我们知道 Array.prototype.push 的返回值是⼀个数字 Array.prototype.forEach ⽅法期望其回调的返回类型是 void 。 </p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> src = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> dst = [<span class="hljs-number">0</span>];<br><span class="hljs-comment">//若是src.forEach((el) =&gt; &#123;dst.push(el)&#125;)返回值为void;若是简写形式则返回为number</span><br>src.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> dst.<span class="hljs-title function_">push</span>(el));<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// 属性声明</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-comment">// ⽅法</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Person实例</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>  &#125;<br>  <span class="hljs-comment">// 备注本例中若Student类不需要额外的属性，Student的构造器可以省略</span><br>  <span class="hljs-comment">// 重写从⽗类继承的⽅法</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我是学⽣，我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁，在读<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.grade&#125;</span></span><br><span class="hljs-string">年级`</span>);<br>  &#125;<br>  <span class="hljs-comment">// ⼦类⾃⼰的⽅法</span><br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努⼒学习中......`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h4><table><thead><tr><th>** 修饰符 **</th><th>** 含义 **</th><th>**  是否可以被访问 **</th></tr></thead><tbody><tr><td>public</td><td>公开的</td><td>可以被  类内部,子类,类外部  访问</td></tr><tr><td>protected</td><td>受保护的</td><td>可以被  类内部,子类  访问</td></tr><tr><td>private</td><td>私有的</td><td>可以被  类内部  访问</td></tr><tr><td>readonly</td><td>只读</td><td>属性无法被修改, 只读</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// name写了public修饰符，age没写修饰符，最终都是public修饰符</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类的【内部】可以访问public修饰的name和age</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 类的【外部】可以访问public修饰的属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>);<br><span class="hljs-comment">//子类也可访问到</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>  &#125;<br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 【⼦类中】可以访问⽗类中public修饰的：name属性、age属性</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁的<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努⼒学习`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//完整写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//简写形式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-comment">// name和age是受保护属性，不能在类外部访问，但可以在【类】与【⼦类】中访问</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">protected</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// getDetails是受保护⽅法，不能在类外部访问，但可以在【类】与【⼦类】中访问</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">getDetails</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-comment">// 类中能访问受保护的name和age属性</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，年龄是：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-comment">// introduce是公开⽅法，类、⼦类、类外部都能使⽤</span><br>  <span class="hljs-title function_">introduce</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类中能访问受保护的getDetails⽅法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getDetails</span>());<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;杨超越&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 可以在类外部访问introduce</span><br>p1.<span class="hljs-title function_">introduce</span>();<br><span class="hljs-comment">// 以下代码均报错</span><br><span class="hljs-comment">// p1.getDetails()</span><br><span class="hljs-comment">// p1.name</span><br><span class="hljs-comment">// p1.age</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>  &#125;<br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ⼦类中可以访问introduce</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">introduce</span>();<br>    <span class="hljs-comment">// ⼦类中可以访问name</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>正在努⼒学习`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">17</span>);<br>s1.<span class="hljs-title function_">introduce</span>();<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">    <span class="hljs-comment">// IDCard属性为私有的(private)属性，只能在【类内部】使⽤</span></span><br><span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-title class_">IDCard</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  </span>) &#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">getPrivateInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类内部可以访问私有的(private)属性 —— IDCard</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`身份证号码为：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.IDCard&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-title function_">getInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类内部可以访问受保护的(protected)属性 —— name和age</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`我叫: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, 今年刚满<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁`</span>;<br>  &#125;<br>  <span class="hljs-title function_">getFullInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 类内部可以访问公开的getInfo⽅法，也可以访问私有的getPrivateInfo⽅法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getInfo</span>() + <span class="hljs-string">&quot;，&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPrivateInfo</span>();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;110114198702034432&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getFullInfo</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getInfo</span>());<br><span class="hljs-comment">// 以下代码均报错</span><br><span class="hljs-comment">// p1.IDCard</span><br><span class="hljs-comment">// p1.getPrivateInfo()</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">vin</span>: <span class="hljs-built_in">string</span>, <span class="hljs-comment">//⻋辆识别码，为只读属性</span></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">year</span>: <span class="hljs-built_in">number</span>, <span class="hljs-comment">//出⼚年份，为只读属性</span></span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">sound</span>: <span class="hljs-built_in">string</span></span><br><span class="hljs-params">  </span>) &#123;&#125;<br>  <span class="hljs-comment">// 打印⻋辆信息</span><br>  <span class="hljs-title function_">displayInfo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`</span><br><span class="hljs-string"> 识别码：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vin&#125;</span>,</span><br><span class="hljs-string"> 出⼚年份：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.year&#125;</span>,</span><br><span class="hljs-string"> 颜⾊：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.color&#125;</span>,</span><br><span class="hljs-string"> ⾳响：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.sound&#125;</span></span><br><span class="hljs-string"> `</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;1HGCM82633A123456&quot;</span>, <span class="hljs-number">2018</span>, <span class="hljs-string">&quot;⿊⾊&quot;</span>, <span class="hljs-string">&quot;Bose⾳响&quot;</span>);<br>car.<span class="hljs-title function_">displayInfo</span>();<br></code></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><strong>抽象类:</strong> 抽象类是⼀种  ⽆法被实例化  的类，专⻔⽤来定义类的  结构和⾏为  ，类中可以写  抽象⽅法  ，也可以写  具体实现  。抽象类主要⽤来为其派⽣类提供⼀个  基础结构  ，要求其派⽣类  必须实现  其中的抽象法。 简记：抽象类  不能实例化  ，其意义是  可以被继承  ，抽象类⾥可以有  普通⽅法  、也可以有  抽象⽅法  。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Package</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">weight</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// 抽象⽅法：⽤来计算运费，不同类型包裹有不同的计算⽅式</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">calculate</span>(): <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 通⽤⽅法：打印包裹详情</span><br>  <span class="hljs-title function_">printPackage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`包裹重量为: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.weight&#125;</span>kg，运费为: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.calculate()&#125;</span>元`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 标准包裹</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardPackage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Package</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">weight</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">    <span class="hljs-keyword">public</span> <span class="hljs-attr">unitPrice</span>: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 每公⽄的固定费率</span></span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-variable language_">super</span>(weight);<br>  &#125;<br>  <span class="hljs-comment">// 实现抽象⽅法：计算运费</span><br>  <span class="hljs-title function_">calculate</span>(): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">unitPrice</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建标准包裹实例</span><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardPackage</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>s1.<span class="hljs-title function_">printPackage</span>();<br></code></pre></td></tr></table></figure><p>:::info<br> 总结：何时使⽤  抽象类  ？  </p><ol><li><p>定义 通用接口：为⼀组相关的类定义通⽤的⾏为（⽅法或属性）时。  </p></li><li><p>提供 基础实现：在抽象类中提供某些⽅法或为其提供基础实现，这样派⽣类就可以继承这</p></li></ol><p> 些实现。  </p><ol start="3"><li><p>确保关键实现：强制派⽣类实现⼀些关键⾏为。  </p></li><li><p>共享代码和逻辑：当多个类需要共享部分代码时，抽象类可以避免代码重复。</p></li></ol><p>:::</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>接口</strong>: interface 是⼀种  定义结构  的⽅式，主要作⽤是为：类、对象、函数等规定  ⼀种契约  ，这样可以确保代码的⼀致性和类型安全，但要注意 interface   只能  定义  格式  ，  不能  包含  任何实现. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// PersonInterface接⼝，⽤与限制Person类的格式</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-comment">// 定义⼀个类 Person，实现 PersonInterface 接⼝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// 实现接⼝中的 speak ⽅法</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-comment">// 打印出包含名字和年龄的问候语句</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建⼀个 Person 类的实例 p1，传⼊名字 &#x27;tom&#x27; 和年龄 18</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">18</span>);<br>p1.<span class="hljs-title function_">speak</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 只读属性</span><br>  age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可选属性</span><br>  <span class="hljs-attr">run</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">UserInterface</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-title function_">run</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`奔跑了<span class="hljs-subst">$&#123;n&#125;</span>⽶`</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CountInterface</span> &#123;<br>  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">count</span>: <span class="hljs-title class_">CountInterface</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>接口的继承:</strong> ⼀个 interface 继承另⼀个 interface ，从⽽实现代码的复⽤ </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 姓名</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 年龄</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 年级</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">stu</span>: <span class="hljs-title class_">StudentInterface</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">grade</span>: <span class="hljs-string">&quot;⾼三&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>tip:当接口重复定义时,会自动合并</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// PersonInterface接⼝</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-comment">// 属性声明</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// 给PersonInterface接⼝添加新属性</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-comment">// ⽅法声明</span><br>  <span class="hljs-title function_">speak</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-comment">// Person类实现PersonInterface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersonInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-comment">// ⽅法</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好！我是⽼师:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>:::info<br>总结：何时使⽤接⼝？</p><ol><li>定义对象的格式： 描述数据模型、API 响应格式、配置对象……..等等，是开发中⽤的最多<br>的场景。</li><li>类的契约：规定⼀个类需要实现哪些属性和⽅法。</li><li>扩展已有接⼝：⼀般⽤于扩展第三⽅库的类型， 这种特性在⼤型项⽬中可能会⽤到。</li></ol><p>:::</p><h4 id="interface-和-type"><a href="#interface-和-type" class="headerlink" title="interface 和 type"></a>interface 和 type</h4><p>:::info<br> 相同点： interface 和 type 都可以⽤于定义  对象结构  ，在定义对象结构时两者可以互换。  </p><p> 不同点：  </p><p> 1️⃣     interface   ：更专注于定义  对象  和  类  的结构，⽀持  继承  、  合并  。  </p><p> 2️⃣   type ：可以定义  类型别名、联合类型  、  交叉类型  ，但不⽀持继承和⾃动合并。  </p><p>:::</p><h4 id="interface-和抽象类"><a href="#interface-和抽象类" class="headerlink" title="interface 和抽象类"></a>interface 和抽象类</h4><p>:::info<br> 相同点：都能定义⼀个  类的格式  （定义类应遵循的契约）  </p><p> 不相同：  </p><p> 1️⃣   接⼝：  只能  描述  结构  ，  不能  有任何  实现代码  ，⼀个类可以实现  多个  接⼝。  </p><p> 2️⃣   抽象类：既可以包含  抽象⽅法  ，也可以包含  具体⽅法  ， ⼀个类只能继承  ⼀个  抽象类。 </p><p>:::</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>泛型:</strong> 泛型允许我们在定义函数、类或接⼝时，使⽤类型参数来表示  未指定的类型  ，这些参数在具体  使⽤时  ，才被指定  具体的类型  ，泛型能让同⼀段代码适⽤于多种类型，同时仍然保持类型的安全性。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> logData&lt;T&gt;(<span class="hljs-attr">data</span>: T): T &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br>logData&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">100</span>);<br>logData&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//也可以多个泛型</span><br><span class="hljs-keyword">function</span> logData&lt;T, U&gt;(<span class="hljs-attr">data1</span>: T, <span class="hljs-attr">data2</span>: U): T | U &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1, data2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() % <span class="hljs-number">2</span> ? data1 : data2;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">extraInfo</span>: T;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">PersonInterface</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">p2</span>: <span class="hljs-title class_">PersonInterface</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br>p1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">extraInfo</span>: <span class="hljs-string">&quot;⼀个好⼈&quot;</span> &#125;;<br>p2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">extraInfo</span>: <span class="hljs-number">250</span> &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LengthInterface</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// 约束规则是：传⼊的类型T必须具有 length 属性</span><br><span class="hljs-keyword">function</span> logPerson&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LengthInterface</span>&gt;(<span class="hljs-attr">data</span>: T): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;<br>logPerson&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 报错：因为number不具备length属性</span><br><span class="hljs-comment">// logPerson&lt;number&gt;(100)</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;T&gt; &#123;<br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params"> <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params"> <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params"> <span class="hljs-keyword">public</span> <span class="hljs-attr">extraInfo</span>: T</span><br><span class="hljs-params"> </span>) &#123; &#125;<br> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁了`</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">extraInfo</span>)<br> &#125;<br>&#125;<br><span class="hljs-comment">// 测试代码1</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">250</span>);<br><span class="hljs-comment">// 测试代码2</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">JobInfo</span> = &#123;<br> <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br> <span class="hljs-attr">company</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;<span class="hljs-title class_">JobInfo</span>&gt;(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">30</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;研发总监&#x27;</span>, <span class="hljs-attr">company</span>: <span class="hljs-string">&#x27;发发发</span><br><span class="hljs-string">科技公司&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a>类型声明文件</h3><p>:::info<br> 类型声明⽂件是 TypeScript 中的⼀种特殊⽂件，通常以 .d.ts 作为扩展名。它的主要作⽤  </p><p> 是为现有的   JavaScript 代码  提供  类型信息  ，使得 TypeScript 能够在使⽤这些 JavaScript 库  </p><p> 或模块时进⾏  类型检查和提示  。 </p><p>:::</p><h3 id="Ts-装饰器"><a href="#Ts-装饰器" class="headerlink" title="Ts 装饰器"></a>Ts 装饰器</h3><h4 id="Ts-装饰器-简介"><a href="#Ts-装饰器-简介" class="headerlink" title="Ts 装饰器 简介"></a>Ts 装饰器 简介</h4><ol><li>装饰器本质是一种特殊的<strong>函数</strong>，它可以对：类、属性、方法、参数进行扩展，同时能让代码更简洁。</li><li>装饰器自<code>2015</code>年在<code>ECMAScript-6</code>中被提出到现在，已将近 10 年。</li><li>截止目前，装饰器依然是实验性特性 ，需要开发者手动调整配置，来开启装饰器支持。</li><li>装饰器有 5 种：</li></ol><p>1⃣ 类装饰器<br>2⃣ 属性装饰器<br>3⃣ 方法装饰器<br>4⃣ 访问器装饰器<br>5⃣ 参数装饰器</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  Demo函数会在Person类定义时执行</span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">     target参数是被装饰的类，即：Person</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>&#125;<br><br><span class="hljs-comment">// 使用装饰器</span><br><span class="hljs-meta">@Demo</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 使用装饰器重写toString方法 + 封闭其原型对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomString</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-comment">// 向被装饰类的原型上添加自定义的 toString 方法</span><br>  target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;;<br>  <span class="hljs-comment">// 封闭其原型对象，禁止随意操作其原型对象</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>&#125;<br><br><span class="hljs-comment">// 使用 CustomString 装饰器</span><br><span class="hljs-meta">@CustomString</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好呀！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 测试代码如下 */</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// 输出：&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">toString</span>());<br><span class="hljs-comment">// 禁止随意操作其原型对象</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-comment">// Person.prototype.a = 100 // 此行会报错：Cannot add property a, object is not extensible</span><br><span class="hljs-comment">// console.log(p1.a)</span><br></code></pre></td></tr></table></figure><p><strong>类装饰器的返回值</strong></p><p>:::info<br> 类装饰器有返回值：若类装饰器返回一个新的类，那这个新类将 ** 替换 ** 掉被装饰的类。 </p><p> 类装饰器无返回值：若类装饰器无返回值或返回 <code>undefined</code> ，那被装饰的类 ** 不会 ** 被替换。 </p><p>:::</p><p>** 关于构造类型 **</p><p> 在 TypeScript 中， <code>Function</code>  类型所表示的范围十分广泛，包括：普通函数、箭头函数、方法等等。但并非 <code>Function</code>  类型的函数都可以被  <code>new</code>  关键字实例化，例如箭头函数是不能被实例化的，那么 TypeScript 中概如何声明一个构造类型呢？有以下两种方式： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  ○ new     表示：该类型是可以用new操作符调用。</span><br><span class="hljs-comment">  ○ ...args 表示：构造器可以接受【任意数量】的参数。</span><br><span class="hljs-comment">  ○ any[]   表示：构造器可以接受【任意类型】的参数。</span><br><span class="hljs-comment">  ○ &#123;&#125;      表示：返回类型是对象(非null、非undefined的对象)。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 定义Constructor类型，其含义是构造类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; &#123;&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-attr">fn</span>: <span class="hljs-title class_">Constructor</span></span>) &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-title class_">Person</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个构造类型，且包含一个静态属性 wife</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = &#123;<br>  <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): &#123;&#125;; <span class="hljs-comment">// 构造签名</span><br>  <span class="hljs-attr">wife</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// wife属性</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-attr">fn</span>: <span class="hljs-title class_">Constructor</span></span>) &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">static</span> wife = <span class="hljs-string">&quot;asd&quot;</span>;<br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-title class_">Person</span>);<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// User接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">getTime</span>(): <span class="hljs-title class_">Date</span>;<br>  <span class="hljs-title function_">log</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// 自定义类型Class</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; &#123;&#125;;<br><br><span class="hljs-comment">// 创建一个装饰器，为类添加日志功能和创建时间</span><br><span class="hljs-keyword">function</span> <span class="hljs-title class_">LogTime</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Constructor</span>&gt;(<span class="hljs-attr">target</span>: T) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> target &#123;<br>    <span class="hljs-attr">createdTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(...args);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 记录对象创建时间</span><br>    &#125;<br>    <span class="hljs-title function_">getTime</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`该对象创建时间为：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.createdTime&#125;</span>`</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@LogTime</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>说：你好啊！`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">13</span>);<br>user1.<span class="hljs-title function_">speak</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-title function_">getTime</span>());<br></code></pre></td></tr></table></figure><h4 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h4><p>** 装饰器工厂是一个返回装饰器函数的函数，可以为装饰器添加参数，可以更灵活地控制装饰器的行为。 **</p><p>** 需求： ** 定义一个 <code>LogInfo</code> 类装饰器工厂，实现 <code>Person</code> 实例可以调用到 <code>introduce</code> 方法，且 <code>introduce</code> 中输出内容的次数，由 <code>LogInfo</code> 接收的参数决定。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">introduce</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个装饰器工厂 LogInfo，它接受一个参数 n，返回一个类装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LogInfo</span>(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-comment">// 装饰器函数，target 是被装饰的类</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">introduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我的名字：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@LogInfo</span>(<span class="hljs-number">5</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好呀！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-comment">// console.log(p1) // 打印的p1是：_classThis，转换的JS版本比较旧时，会出现，不必纠结</span><br>p1.<span class="hljs-title function_">speak</span>();<br>p1.<span class="hljs-title function_">introduce</span>();<br></code></pre></td></tr></table></figure><p>:::info<br> 装饰器可以组合使用，执行顺序为：先【由上到下】的执行所有的装饰器工厂，依次获取到装饰器，然后再【由下到上】执行所有的装饰器。 </p><p>:::</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test1&quot;</span>);<br>&#125;<br><span class="hljs-comment">//装饰器工厂</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test2工厂&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test2&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">//装饰器工厂</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test3工厂&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test3&quot;</span>);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">//装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test4</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;test4&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@test1</span><br><span class="hljs-meta">@test2</span>()<br><span class="hljs-meta">@test3</span>()<br><span class="hljs-meta">@test4</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  控制台打印：</span><br><span class="hljs-comment">    test2工厂</span><br><span class="hljs-comment">    test3工厂</span><br><span class="hljs-comment">    test4</span><br><span class="hljs-comment">    test3</span><br><span class="hljs-comment">    test2</span><br><span class="hljs-comment">    test1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target: 对于静态属性来说值是类，对于实例属性来说值是类的原型对象。</span><br><span class="hljs-comment">    ○ propertyKey: 属性名。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, propertyKey);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Demo</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-meta">@Demo</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-meta">@Demo</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">school</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p> 如下代码中：当构造器中的 <code>this.age = age</code> 试图在实例上赋值时，实际上是调用了原型上 <code>age</code> 属性的 <code>set</code> 方法。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> value = <span class="hljs-number">99</span>;<br><span class="hljs-comment">// 使用defineProperty给Person原型添加age属性，并配置对应的get与set</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;age&quot;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;<br>    value = val;<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">//与js同理,实例对象上无age属性,沿原型链逐级查找,在原型对象查找到age,进行修改,则不会在实例对象上创建age属性</span><br><span class="hljs-comment">//若先创建示例对象,在调用Object.defineProperty方法去添加属性,则示例对象的age为给定的值,原型上的age为原拟定的value</span><br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>); <span class="hljs-comment">//18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span>); <span class="hljs-comment">//18</span><br></code></pre></td></tr></table></figure><p> 需求：定义一个 <code>State</code> 属性装饰器，来监视属性的修改。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 声明一个装饰器函数 State，用于捕获数据的修改</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">State</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 存储属性的内部值</span><br>  <span class="hljs-keyword">let</span> key = <span class="hljs-string">`__<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>;<br><br>  <span class="hljs-comment">// 使用 Object.defineProperty 替换类的原始属性</span><br>  <span class="hljs-comment">// 重新定义属性，使其使用自定义的 getter 和 setter</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[key];<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params"><span class="hljs-attr">newVal</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>的最新值为：<span class="hljs-subst">$&#123;newVal&#125;</span>`</span>);<br>      <span class="hljs-comment">//将变化的值存在实例本身,以免发生多个实例对象捕获无法区分的错误</span><br>      <span class="hljs-variable language_">this</span>[key] = newVal;<br>    &#125;,<br>    <span class="hljs-comment">//可枚举性</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">//可配置性</span><br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">//使用State装饰器</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>  school = <span class="hljs-string">&quot;atguigu&quot;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">30</span>);<br><br>p1.<span class="hljs-property">age</span> = <span class="hljs-number">80</span>;<br>p2.<span class="hljs-property">age</span> = <span class="hljs-number">90</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;------------------&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>); <span class="hljs-comment">//80</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">age</span>); <span class="hljs-comment">//90</span><br></code></pre></td></tr></table></figure><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target: 对于静态方法来说值是类，对于实例方法来说值是原型对象。</span><br><span class="hljs-comment">    ○ propertyKey:方法的名称。</span><br><span class="hljs-comment">    ○ descriptor: 方法的描述对象，其中value属性是被装饰的方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propertyKey);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-comment">// Demo装饰实例方法</span><br>  <span class="hljs-meta">@Demo</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>  <span class="hljs-comment">// Demo装饰静态方法</span><br>  <span class="hljs-meta">@Demo</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">isAdult</span>(<span class="hljs-params"><span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>p1.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>需求：</p><ol><li>定义一个<code>Logger</code>方法装饰器，用于在方法执行前和执行后，均追加一些额外逻辑。</li><li>定义一个<code>Validate</code>方法装饰器，用于验证数据。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Logger</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 保存原始方法</span><br>  <span class="hljs-keyword">const</span> original = descriptor.<span class="hljs-property">value</span>;<br>  <span class="hljs-comment">// 替换原始方法</span><br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>开始执行......`</span>);<br>    <span class="hljs-comment">//不能直接调用original,否则会丢失this,使用call函数,修改this指向</span><br>    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>执行完毕......`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Validate</span>(<span class="hljs-params"><span class="hljs-attr">maxValue</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 保存原始方法</span><br>    <span class="hljs-keyword">const</span> original = descriptor.<span class="hljs-property">value</span>;<br>    <span class="hljs-comment">// 替换原始方法</span><br>    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>      <span class="hljs-comment">// 自定义的验证逻辑</span><br>      <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] &gt; maxValue) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;年龄非法！&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 如果所有参数都符合要求，则调用原始方法</span><br>      <span class="hljs-comment">//call和apply都能修改this,call需要一个一个传参数,apply一次性传入数组</span><br>      <span class="hljs-keyword">return</span> original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>  <span class="hljs-meta">@Logger</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>，我的年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>  <span class="hljs-meta">@Validate</span>(<span class="hljs-number">120</span>)<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isAdult</span>(<span class="hljs-params"><span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> age &gt;= <span class="hljs-number">18</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>p1.<span class="hljs-title function_">speak</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">isAdult</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><h4 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target: </span><br><span class="hljs-comment">        1. 对于实例访问器来说值是【所属类的原型对象】。</span><br><span class="hljs-comment">        2. 对于静态访问器来说值是【所属类】。</span><br><span class="hljs-comment">    ○ propertyKey:访问器的名称。</span><br><span class="hljs-comment">    ○ descriptor: 描述对象。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propertyKey);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Demo</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">address</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;北京宏福科技园&quot;</span>;<br>  &#125;<br>  <span class="hljs-meta">@Demo</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">country</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;中国&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 需求：对 <code>Weather</code> 类的 <code>temp</code> 属性的 <code>set</code> 访问器进行限制，设置的最低温度 <code>-50</code> ，最高温度 <code>50</code>  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">RangeValidate</span>(<span class="hljs-params"><span class="hljs-attr">min</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">max</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 保存原始的 setter 方法，以便在后续调用中使用</span><br>    <span class="hljs-keyword">const</span> originalSetter = descriptor.<span class="hljs-property">set</span>;<br><br>    <span class="hljs-comment">// 重写 setter 方法，加入范围验证逻辑</span><br>    descriptor.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>      <span class="hljs-comment">// 检查设置的值是否在指定的最小值和最大值之间</span><br>      <span class="hljs-keyword">if</span> (value &lt; min || value &gt; max) &#123;<br>        <span class="hljs-comment">// 如果值不在范围内，抛出错误</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyKey&#125;</span>的值应该在 <span class="hljs-subst">$&#123;min&#125;</span> 到 <span class="hljs-subst">$&#123;max&#125;</span>之间！`</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 如果值在范围内，且原始 setter 方法存在，则调用原始 setter 方法</span><br>      <span class="hljs-keyword">if</span> (originalSetter) &#123;<br>        originalSetter.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, value);<br>      &#125;<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_temp</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">_temp</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_temp</span> = _temp;<br>  &#125;<br>  <span class="hljs-comment">// 设置温度范围在 -50 到 50 之间</span><br>  <span class="hljs-meta">@RangeValidate</span>(-<span class="hljs-number">50</span>, <span class="hljs-number">50</span>)<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">temp</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_temp</span> = value;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">temp</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_temp</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> w1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weather</span>(<span class="hljs-number">25</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(w1);<br>w1.<span class="hljs-property">temp</span> = <span class="hljs-number">67</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(w1);<br></code></pre></td></tr></table></figure><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  参数说明：</span><br><span class="hljs-comment">    ○ target:</span><br><span class="hljs-comment">      1.如果修饰的是【实例方法】的参数，target 是类的【原型对象】。</span><br><span class="hljs-comment">      2.如果修饰的是【静态方法】的参数，target 是【类】。</span><br><span class="hljs-comment">    ○ propertyKey：参数所在的方法的名称。</span><br><span class="hljs-comment">    ○ parameterIndex: 参数在函数参数列表中的索引，从 0 开始。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">parameterIndex</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propertyKey);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parameterIndex);<br>&#125;<br><br><span class="hljs-comment">// 类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"><span class="hljs-meta">@Demo</span> <span class="hljs-attr">message1</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">message2</span>: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>想对说：<span class="hljs-subst">$&#123;message1&#125;</span>，<span class="hljs-subst">$&#123;message2&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 需求：定义方法装饰器 <code>Validate</code> ，同时搭配参数装饰器 <code>NotNumber</code> ，来对 <code>speak</code> 方法的参数类型进行限制。 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NotNumber</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">parameterIndex</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-comment">// 初始化或获取当前方法的参数索引列表</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">notNumberArr</span>: <span class="hljs-built_in">number</span>[] = target[<span class="hljs-string">`__notNumber_<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>] || [];<br>  <span class="hljs-comment">// 将当前参数索引添加到列表中</span><br>  notNumberArr.<span class="hljs-title function_">push</span>(parameterIndex);<br>  <span class="hljs-comment">// 将列表存储回目标对象</span><br>  target[<span class="hljs-string">`__notNumber_<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>] = notNumberArr;<br>&#125;<br><br><span class="hljs-comment">// 方法装饰器定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Validate</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> method = descriptor.<span class="hljs-property">value</span>;<br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-comment">// 获取被标记为不能为空的参数索引列表</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">notNumberArr</span>: <span class="hljs-built_in">number</span>[] = target[<span class="hljs-string">`__notNumber_<span class="hljs-subst">$&#123;propertyKey&#125;</span>`</span>] || [];<br>    <span class="hljs-comment">// 检查参数是否为 null 或 undefined</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> index <span class="hljs-keyword">of</span> notNumberArr) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[index] === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>          <span class="hljs-string">`方法 <span class="hljs-subst">$&#123;propertyKey&#125;</span> 中索引为 <span class="hljs-subst">$&#123;index&#125;</span> 的参数不能是数字！`</span><br>        );<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 调用原始方法</span><br>    <span class="hljs-keyword">return</span> method.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-comment">// 类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-meta">@Validate</span><br>  <span class="hljs-title function_">speak</span>(<span class="hljs-params"><span class="hljs-meta">@NotNumber</span> <span class="hljs-attr">message1</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">mesage2</span>: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>想对说：<span class="hljs-subst">$&#123;message1&#125;</span>，<span class="hljs-subst">$&#123;mesage2&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>s1.<span class="hljs-title function_">speak</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ts</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
